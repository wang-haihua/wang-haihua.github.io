<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>08二叉搜索树BST | 王清欢Randy</title>
    <meta name="generator" content="VuePress 1.9.2">
    <link rel="icon" href="/img/favicon.ico">
    <meta name="description" content="解决问题，担当责任，优雅生活。">
    <meta name="keywords" content="vuepress,it,blog">
    <meta name="theme-color" content="#cf2825">
    
    <link rel="preload" href="/assets/css/0.styles.ded236f3.css" as="style"><link rel="preload" href="/assets/js/app.3c964c09.js" as="script"><link rel="preload" href="/assets/js/2.7cb4c100.js" as="script"><link rel="preload" href="/assets/js/93.c070a2da.js" as="script"><link rel="prefetch" href="/assets/js/10.63f63ae7.js"><link rel="prefetch" href="/assets/js/100.95a6c99c.js"><link rel="prefetch" href="/assets/js/101.b4a49f0b.js"><link rel="prefetch" href="/assets/js/102.2de85a2d.js"><link rel="prefetch" href="/assets/js/103.45e2e113.js"><link rel="prefetch" href="/assets/js/104.56158bd6.js"><link rel="prefetch" href="/assets/js/105.1f16775f.js"><link rel="prefetch" href="/assets/js/106.84151016.js"><link rel="prefetch" href="/assets/js/107.7b9fd16b.js"><link rel="prefetch" href="/assets/js/108.9a669853.js"><link rel="prefetch" href="/assets/js/109.607b8ba0.js"><link rel="prefetch" href="/assets/js/11.9a5b96b4.js"><link rel="prefetch" href="/assets/js/110.035ebd82.js"><link rel="prefetch" href="/assets/js/111.2189344f.js"><link rel="prefetch" href="/assets/js/112.acc94015.js"><link rel="prefetch" href="/assets/js/113.732292c6.js"><link rel="prefetch" href="/assets/js/114.69d6fa65.js"><link rel="prefetch" href="/assets/js/115.b01a3599.js"><link rel="prefetch" href="/assets/js/116.6724705b.js"><link rel="prefetch" href="/assets/js/117.ce49efe5.js"><link rel="prefetch" href="/assets/js/118.28357f19.js"><link rel="prefetch" href="/assets/js/119.183d08ed.js"><link rel="prefetch" href="/assets/js/12.44fb0008.js"><link rel="prefetch" href="/assets/js/120.474cdfad.js"><link rel="prefetch" href="/assets/js/121.e3ecdcc4.js"><link rel="prefetch" href="/assets/js/122.0a0bc0aa.js"><link rel="prefetch" href="/assets/js/123.0c6ab3ab.js"><link rel="prefetch" href="/assets/js/124.0d0ffb49.js"><link rel="prefetch" href="/assets/js/125.0e81a183.js"><link rel="prefetch" href="/assets/js/126.aad938f8.js"><link rel="prefetch" href="/assets/js/127.a0f92902.js"><link rel="prefetch" href="/assets/js/128.1d6192b0.js"><link rel="prefetch" href="/assets/js/129.b953e757.js"><link rel="prefetch" href="/assets/js/13.a330722e.js"><link rel="prefetch" href="/assets/js/130.7bb5e38e.js"><link rel="prefetch" href="/assets/js/131.7462b2ba.js"><link rel="prefetch" href="/assets/js/132.c0928987.js"><link rel="prefetch" href="/assets/js/133.198cb7db.js"><link rel="prefetch" href="/assets/js/134.297283a1.js"><link rel="prefetch" href="/assets/js/135.7f82baca.js"><link rel="prefetch" href="/assets/js/136.0c6b96f4.js"><link rel="prefetch" href="/assets/js/137.dae22f59.js"><link rel="prefetch" href="/assets/js/138.30641cf0.js"><link rel="prefetch" href="/assets/js/139.4153d23d.js"><link rel="prefetch" href="/assets/js/14.6847a39f.js"><link rel="prefetch" href="/assets/js/140.c25d78fc.js"><link rel="prefetch" href="/assets/js/141.496ceb78.js"><link rel="prefetch" href="/assets/js/142.0de8f200.js"><link rel="prefetch" href="/assets/js/143.28d82825.js"><link rel="prefetch" href="/assets/js/144.acce788f.js"><link rel="prefetch" href="/assets/js/145.9cfb27d2.js"><link rel="prefetch" href="/assets/js/146.6230832c.js"><link rel="prefetch" href="/assets/js/147.121e1344.js"><link rel="prefetch" href="/assets/js/148.f0e26f06.js"><link rel="prefetch" href="/assets/js/149.dea71d53.js"><link rel="prefetch" href="/assets/js/15.0e030877.js"><link rel="prefetch" href="/assets/js/150.9ba2012f.js"><link rel="prefetch" href="/assets/js/151.59a8ddd9.js"><link rel="prefetch" href="/assets/js/152.1d937849.js"><link rel="prefetch" href="/assets/js/153.d9366ef7.js"><link rel="prefetch" href="/assets/js/154.9d104827.js"><link rel="prefetch" href="/assets/js/155.96d646cc.js"><link rel="prefetch" href="/assets/js/156.f87e7868.js"><link rel="prefetch" href="/assets/js/157.9fd3efa6.js"><link rel="prefetch" href="/assets/js/158.75948c6a.js"><link rel="prefetch" href="/assets/js/159.9b842781.js"><link rel="prefetch" href="/assets/js/16.74612e69.js"><link rel="prefetch" href="/assets/js/160.56221aa8.js"><link rel="prefetch" href="/assets/js/161.17b059f2.js"><link rel="prefetch" href="/assets/js/162.668f0874.js"><link rel="prefetch" href="/assets/js/163.b6b0e348.js"><link rel="prefetch" href="/assets/js/164.341c344d.js"><link rel="prefetch" href="/assets/js/165.c8c5e318.js"><link rel="prefetch" href="/assets/js/166.15c69481.js"><link rel="prefetch" href="/assets/js/167.0d5a35a6.js"><link rel="prefetch" href="/assets/js/168.169a4503.js"><link rel="prefetch" href="/assets/js/169.0918ad60.js"><link rel="prefetch" href="/assets/js/17.aff28c92.js"><link rel="prefetch" href="/assets/js/170.1f41cdee.js"><link rel="prefetch" href="/assets/js/171.32de0dd3.js"><link rel="prefetch" href="/assets/js/172.8d0977fa.js"><link rel="prefetch" href="/assets/js/173.7f833ed2.js"><link rel="prefetch" href="/assets/js/174.e3cf5acf.js"><link rel="prefetch" href="/assets/js/175.c5e1249f.js"><link rel="prefetch" href="/assets/js/176.36d2aed6.js"><link rel="prefetch" href="/assets/js/177.2b946f65.js"><link rel="prefetch" href="/assets/js/178.6471a14e.js"><link rel="prefetch" href="/assets/js/18.6c553fe2.js"><link rel="prefetch" href="/assets/js/19.25a79e40.js"><link rel="prefetch" href="/assets/js/20.2912c5fd.js"><link rel="prefetch" href="/assets/js/21.cc8f7cb4.js"><link rel="prefetch" href="/assets/js/22.73f5d0fb.js"><link rel="prefetch" href="/assets/js/23.082f826b.js"><link rel="prefetch" href="/assets/js/24.62a7a3fb.js"><link rel="prefetch" href="/assets/js/25.3f1ff6cb.js"><link rel="prefetch" href="/assets/js/26.02eb8e1c.js"><link rel="prefetch" href="/assets/js/27.c669fe7b.js"><link rel="prefetch" href="/assets/js/28.5c92c35c.js"><link rel="prefetch" href="/assets/js/29.5b037672.js"><link rel="prefetch" href="/assets/js/3.5e9c9aeb.js"><link rel="prefetch" href="/assets/js/30.503d0120.js"><link rel="prefetch" href="/assets/js/31.24297fec.js"><link rel="prefetch" href="/assets/js/32.96252ef0.js"><link rel="prefetch" href="/assets/js/33.c89e1ff8.js"><link rel="prefetch" href="/assets/js/34.d3ccb114.js"><link rel="prefetch" href="/assets/js/35.16c1381a.js"><link rel="prefetch" href="/assets/js/36.bf337c21.js"><link rel="prefetch" href="/assets/js/37.946363a7.js"><link rel="prefetch" href="/assets/js/38.97180054.js"><link rel="prefetch" href="/assets/js/39.db68880e.js"><link rel="prefetch" href="/assets/js/4.4290cd63.js"><link rel="prefetch" href="/assets/js/40.fdfa3edb.js"><link rel="prefetch" href="/assets/js/41.1364b864.js"><link rel="prefetch" href="/assets/js/42.b5fe6688.js"><link rel="prefetch" href="/assets/js/43.a657a0ea.js"><link rel="prefetch" href="/assets/js/44.c60c202e.js"><link rel="prefetch" href="/assets/js/45.f0ca7707.js"><link rel="prefetch" href="/assets/js/46.a2cfa915.js"><link rel="prefetch" href="/assets/js/47.00eaf68b.js"><link rel="prefetch" href="/assets/js/48.0697506a.js"><link rel="prefetch" href="/assets/js/49.d975a8c1.js"><link rel="prefetch" href="/assets/js/5.c8d737d0.js"><link rel="prefetch" href="/assets/js/50.d71495f8.js"><link rel="prefetch" href="/assets/js/51.45b983df.js"><link rel="prefetch" href="/assets/js/52.86cfff51.js"><link rel="prefetch" href="/assets/js/53.7aab1ca2.js"><link rel="prefetch" href="/assets/js/54.4d1b9288.js"><link rel="prefetch" href="/assets/js/55.5b50da92.js"><link rel="prefetch" href="/assets/js/56.2c9ea1c5.js"><link rel="prefetch" href="/assets/js/57.ed975abb.js"><link rel="prefetch" href="/assets/js/58.c103cc9b.js"><link rel="prefetch" href="/assets/js/59.aa73a8af.js"><link rel="prefetch" href="/assets/js/6.a41c5e20.js"><link rel="prefetch" href="/assets/js/60.12f2b692.js"><link rel="prefetch" href="/assets/js/61.83fae5c1.js"><link rel="prefetch" href="/assets/js/62.e31f6715.js"><link rel="prefetch" href="/assets/js/63.295992f4.js"><link rel="prefetch" href="/assets/js/64.2fc8a996.js"><link rel="prefetch" href="/assets/js/65.3d399173.js"><link rel="prefetch" href="/assets/js/66.aa557906.js"><link rel="prefetch" href="/assets/js/67.254bd65a.js"><link rel="prefetch" href="/assets/js/68.ad2097e4.js"><link rel="prefetch" href="/assets/js/69.b9231851.js"><link rel="prefetch" href="/assets/js/7.77d76dfa.js"><link rel="prefetch" href="/assets/js/70.49947637.js"><link rel="prefetch" href="/assets/js/71.d2610084.js"><link rel="prefetch" href="/assets/js/72.bff01f1e.js"><link rel="prefetch" href="/assets/js/73.3d9b6c19.js"><link rel="prefetch" href="/assets/js/74.a4201e96.js"><link rel="prefetch" href="/assets/js/75.8489c790.js"><link rel="prefetch" href="/assets/js/76.2f9bc769.js"><link rel="prefetch" href="/assets/js/77.ff492b54.js"><link rel="prefetch" href="/assets/js/78.31c6d8b2.js"><link rel="prefetch" href="/assets/js/79.21d03938.js"><link rel="prefetch" href="/assets/js/8.45e21c4e.js"><link rel="prefetch" href="/assets/js/80.0e9d328b.js"><link rel="prefetch" href="/assets/js/81.871bf4a7.js"><link rel="prefetch" href="/assets/js/82.e75460b6.js"><link rel="prefetch" href="/assets/js/83.e13d0013.js"><link rel="prefetch" href="/assets/js/84.8c34a475.js"><link rel="prefetch" href="/assets/js/85.e108fbd1.js"><link rel="prefetch" href="/assets/js/86.7d4ff604.js"><link rel="prefetch" href="/assets/js/87.53bc3752.js"><link rel="prefetch" href="/assets/js/88.a45401e3.js"><link rel="prefetch" href="/assets/js/89.b419f73b.js"><link rel="prefetch" href="/assets/js/9.c216597d.js"><link rel="prefetch" href="/assets/js/90.c7fe862e.js"><link rel="prefetch" href="/assets/js/91.ef3cfddd.js"><link rel="prefetch" href="/assets/js/92.721483d9.js"><link rel="prefetch" href="/assets/js/94.0295dc34.js"><link rel="prefetch" href="/assets/js/95.f327f220.js"><link rel="prefetch" href="/assets/js/96.922233b5.js"><link rel="prefetch" href="/assets/js/97.1c062e72.js"><link rel="prefetch" href="/assets/js/98.bc678e0d.js"><link rel="prefetch" href="/assets/js/99.40c68a6a.js">
    <link rel="stylesheet" href="/assets/css/0.styles.ded236f3.css">
  </head>
  <body class="theme-mode-light">
    <div id="app" data-server-rendered="true"><div class="theme-container sidebar-open have-rightmenu"><header class="navbar blur"><div title="目录" class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/img/logo.png" alt="王清欢Randy" class="logo"> <span class="site-name can-hide">王清欢Randy</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="编程基础" class="dropdown-title"><a href="/pages/fa0f35/" class="link-title">编程基础</a> <span class="title" style="display:none;">编程基础</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>编程语言</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/pages/bb810c/" class="nav-link">C/C++ 学习笔记</a></li><li class="dropdown-subitem"><a href="/pages/4b9df2/" class="nav-link">Golang 学习笔记</a></li></ul></li><li class="dropdown-item"><h4>算法分析</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/pages/0f3851/" class="nav-link">LeetCode 刷题笔记</a></li></ul></li><li class="dropdown-item"><h4>操作系统</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/pages/bcf4de/" class="nav-link">Linux 基础</a></li><li class="dropdown-subitem"><a href="/pages/875f14/" class="nav-link">Vim 实用技巧</a></li><li class="dropdown-subitem"><a href="/pages/028d7e/" class="nav-link">Shell 脚本编程</a></li><li class="dropdown-subitem"><a href="/pages/f4281d/" class="nav-link">GDB 学习笔记</a></li></ul></li><li class="dropdown-item"><h4>开发工具</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/pages/8292d8/" class="nav-link">Git 学习笔记</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="理论知识" class="dropdown-title"><a href="/pages/240fd4/" class="link-title">理论知识</a> <span class="title" style="display:none;">理论知识</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>分布式理论</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/pages/01f1e6/404" class="nav-link">共识算法</a></li><li class="dropdown-subitem"><a href="/pages/01f1e6/404" class="nav-link">分布式事务</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="开源实践" class="dropdown-title"><a href="/pages/93824d/" class="link-title">开源实践</a> <span class="title" style="display:none;">开源实践</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>数据库内核</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/pages/01f1e6/404" class="nav-link">PostgreSQL</a></li><li class="dropdown-subitem"><a href="/pages/01f1e6/404" class="nav-link">Postgres-XL</a></li></ul></li><li class="dropdown-item"><!----> <a href="/pages/01f1e6/404" class="nav-link">hidb</a></li><li class="dropdown-item"><!----> <a href="/pages/01f1e6/404" class="nav-link">pgproxy</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="胡思乱想" class="dropdown-title"><a href="/pages/0232db/" class="link-title">胡思乱想</a> <span class="title" style="display:none;">胡思乱想</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/baaa02/" class="nav-link">实用技巧</a></li><li class="dropdown-item"><!----> <a href="/pages/f2a556/" class="nav-link">学习方法</a></li><li class="dropdown-item"><!----> <a href="/pages/35750f/" class="nav-link">资源分享</a></li></ul></div></div> <a href="https://github.com/wang-haihua/TechStack" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar-hover-trigger"></div> <aside class="sidebar" style="display:none;"><!----> <nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="编程基础" class="dropdown-title"><a href="/pages/fa0f35/" class="link-title">编程基础</a> <span class="title" style="display:none;">编程基础</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>编程语言</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/pages/bb810c/" class="nav-link">C/C++ 学习笔记</a></li><li class="dropdown-subitem"><a href="/pages/4b9df2/" class="nav-link">Golang 学习笔记</a></li></ul></li><li class="dropdown-item"><h4>算法分析</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/pages/0f3851/" class="nav-link">LeetCode 刷题笔记</a></li></ul></li><li class="dropdown-item"><h4>操作系统</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/pages/bcf4de/" class="nav-link">Linux 基础</a></li><li class="dropdown-subitem"><a href="/pages/875f14/" class="nav-link">Vim 实用技巧</a></li><li class="dropdown-subitem"><a href="/pages/028d7e/" class="nav-link">Shell 脚本编程</a></li><li class="dropdown-subitem"><a href="/pages/f4281d/" class="nav-link">GDB 学习笔记</a></li></ul></li><li class="dropdown-item"><h4>开发工具</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/pages/8292d8/" class="nav-link">Git 学习笔记</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="理论知识" class="dropdown-title"><a href="/pages/240fd4/" class="link-title">理论知识</a> <span class="title" style="display:none;">理论知识</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>分布式理论</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/pages/01f1e6/404" class="nav-link">共识算法</a></li><li class="dropdown-subitem"><a href="/pages/01f1e6/404" class="nav-link">分布式事务</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="开源实践" class="dropdown-title"><a href="/pages/93824d/" class="link-title">开源实践</a> <span class="title" style="display:none;">开源实践</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>数据库内核</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/pages/01f1e6/404" class="nav-link">PostgreSQL</a></li><li class="dropdown-subitem"><a href="/pages/01f1e6/404" class="nav-link">Postgres-XL</a></li></ul></li><li class="dropdown-item"><!----> <a href="/pages/01f1e6/404" class="nav-link">hidb</a></li><li class="dropdown-item"><!----> <a href="/pages/01f1e6/404" class="nav-link">pgproxy</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="胡思乱想" class="dropdown-title"><a href="/pages/0232db/" class="link-title">胡思乱想</a> <span class="title" style="display:none;">胡思乱想</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/baaa02/" class="nav-link">实用技巧</a></li><li class="dropdown-item"><!----> <a href="/pages/f2a556/" class="nav-link">学习方法</a></li><li class="dropdown-item"><!----> <a href="/pages/35750f/" class="nav-link">资源分享</a></li></ul></div></div> <a href="https://github.com/wang-haihua/TechStack" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>基础算法</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading open"><span>双指针</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/0f3851/" class="sidebar-link">双指针基础</a></li><li><a href="/pages/700e2e/" class="sidebar-link">碰撞指针</a></li><li><a href="/pages/85ec9f/" class="sidebar-link">快慢指针</a></li><li><a href="/pages/90a84d/" class="sidebar-link">滑动窗口</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>二分查找</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/3b46c0/" class="sidebar-link">基础应用</a></li><li><a href="/pages/0a4983/" class="sidebar-link">边界收缩</a></li><li><a href="/pages/d09927/" class="sidebar-link">局部有序</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>排序算法</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/3aa832/" class="sidebar-link">01八大排序</a></li><li><a href="/pages/8c54f6/" class="sidebar-link">02快速排序</a></li><li><a href="/pages/832c90/" class="sidebar-link">03归并排序</a></li><li><a href="/pages/a40ad8/" class="sidebar-link">04桶排序</a></li><li><a href="/pages/c2b2d7/" class="sidebar-link">05堆排序</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>优先搜索</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/9c6520/" class="sidebar-link">01递归</a></li><li><a href="/pages/88ecc3/" class="sidebar-link">02网格结构深度优先搜索</a></li><li><a href="/pages/35b7a7/" class="sidebar-link">03树结构深度优先搜索</a></li><li><a href="/pages/13d287/" class="sidebar-link">04图结构深度优先搜索</a></li><li><a href="/pages/3cb71c/" class="sidebar-link">05网格结构广度优先搜索</a></li><li><a href="/pages/5134a9/" class="sidebar-link">06树结构广度优先搜索</a></li><li><a href="/pages/4da67f/" class="sidebar-link">07图结构广度优先搜索</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>回溯算法</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/9c7a53/" class="sidebar-link">01递归</a></li><li><a href="/pages/cbe7a5/" class="sidebar-link">02 子集问题</a></li><li><a href="/pages/71f066/" class="sidebar-link">03 全排列问题</a></li><li><a href="/pages/21e47b/" class="sidebar-link">04 组合问题</a></li><li><a href="/pages/e9a845/" class="sidebar-link">05 回溯搜索问题</a></li></ul></section></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>基础数据结构</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>线性表与哈希表</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/e3b123/" class="sidebar-link">01数组</a></li><li><a href="/pages/c3fc14/" class="sidebar-link">02栈和队列</a></li><li><a href="/pages/45a757/" class="sidebar-link">03单调栈</a></li><li><a href="/pages/366d13/" class="sidebar-link">04优先队列</a></li><li><a href="/pages/dfe85c/" class="sidebar-link">05双端队列</a></li><li><a href="/pages/d9969b/" class="sidebar-link">06哈希表</a></li><li><a href="/pages/52cdea/" class="sidebar-link">07多重集合</a></li><li><a href="/pages/45a8d1/" class="sidebar-link">08前缀和</a></li><li><a href="/pages/7a84c5/" class="sidebar-link">09数据结构设计</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>字符串</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/5f258c/" class="sidebar-link">01字符串比较</a></li><li><a href="/pages/8a4607/" class="sidebar-link">02回文字符串</a></li><li><a href="/pages/d0219a/" class="sidebar-link">03字符串匹配</a></li><li><a href="/pages/9ad0e3/" class="sidebar-link">04字符串算术表达式</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>单链表</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/1b79f3/" class="sidebar-link">01链表基础操作</a></li><li><a href="/pages/3871a6/" class="sidebar-link">02链表遍历</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading open"><span>二叉树</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/334633/" class="sidebar-link">01二叉树的属性</a></li><li><a href="/pages/f97107/" class="sidebar-link">02二叉树的操作</a></li><li><a href="/pages/22355f/" class="sidebar-link">03层次遍历</a></li><li><a href="/pages/0480d5/" class="sidebar-link">04前中后序遍历</a></li><li><a href="/pages/b9029c/" class="sidebar-link">05二叉搜索树的属性</a></li><li><a href="/pages/8995b9/" class="sidebar-link">06二叉搜索树的操作</a></li><li><a href="/pages/5c0017/" class="sidebar-link">07字典树</a></li><li><a href="/pages/01f1e6/" aria-current="page" class="active sidebar-link">08二叉搜索树BST</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level2"><a href="/pages/01f1e6/#二叉搜索树-bst" class="sidebar-link">二叉搜索树 BST</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/01f1e6/#什么是二叉搜索树" class="sidebar-link">什么是二叉搜索树</a></li><li class="sidebar-sub-header level3"><a href="/pages/01f1e6/#bst-的节点属性" class="sidebar-link">BST 的节点属性</a></li><li class="sidebar-sub-header level3"><a href="/pages/01f1e6/#bst-的中序遍历" class="sidebar-link">BST 的中序遍历</a></li><li class="sidebar-sub-header level3"><a href="/pages/01f1e6/#bst-搜索" class="sidebar-link">BST 搜索</a></li><li class="sidebar-sub-header level3"><a href="/pages/01f1e6/#bst-插入" class="sidebar-link">BST 插入</a></li><li class="sidebar-sub-header level3"><a href="/pages/01f1e6/#bst-删除的三种情况" class="sidebar-link">BST 删除的三种情况</a></li><li class="sidebar-sub-header level4"><a href="/pages/01f1e6/#_1-目标节点是叶子节点" class="sidebar-link">1 目标节点是叶子节点</a></li><li class="sidebar-sub-header level4"><a href="/pages/01f1e6/#_2-目标节点有一个子节点" class="sidebar-link">2 目标节点有一个子节点</a></li><li class="sidebar-sub-header level4"><a href="/pages/01f1e6/#_3-目标节点有两个子节点" class="sidebar-link">3 目标节点有两个子节点</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/01f1e6/#平衡二叉搜索树" class="sidebar-link">平衡二叉搜索树</a></li><li class="sidebar-sub-header level2"><a href="/pages/01f1e6/#自平衡二叉搜索树-avl" class="sidebar-link">自平衡二叉搜索树 AVL</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/01f1e6/#什么是-avl" class="sidebar-link">什么是 AVL</a></li><li class="sidebar-sub-header level3"><a href="/pages/01f1e6/#树的旋转" class="sidebar-link">树的旋转</a></li><li class="sidebar-sub-header level4"><a href="/pages/01f1e6/#_1-ll-单旋转" class="sidebar-link">1 LL 单旋转</a></li><li class="sidebar-sub-header level4"><a href="/pages/01f1e6/#_2-rr-单旋转" class="sidebar-link">2 RR 单旋转</a></li><li class="sidebar-sub-header level4"><a href="/pages/01f1e6/#_3-lr-双旋转" class="sidebar-link">3 LR 双旋转</a></li><li class="sidebar-sub-header level4"><a href="/pages/01f1e6/#_4-rl-双旋转" class="sidebar-link">4 RL 双旋转</a></li><li class="sidebar-sub-header level3"><a href="/pages/01f1e6/#avl-插入与删除" class="sidebar-link">AVL 插入与删除</a></li><li class="sidebar-sub-header level4"><a href="/pages/01f1e6/#_1-avl-插入" class="sidebar-link">1 AVL 插入</a></li><li class="sidebar-sub-header level4"><a href="/pages/01f1e6/#_2-avl-删除" class="sidebar-link">2 AVL 删除</a></li></ul></li></ul></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>图</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/208d53/" class="sidebar-link">01二分图</a></li><li><a href="/pages/f51192/" class="sidebar-link">02拓扑排序</a></li><li><a href="/pages/e70bde/" class="sidebar-link">03并查集</a></li><li><a href="/pages/599b16/" class="sidebar-link">04最小生成树</a></li><li><a href="/pages/cc367b/" class="sidebar-link">05最短路径</a></li></ul></section></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>进阶算法</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading open"><span>贪心算法</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/fbf15c/" class="sidebar-link">01跳跃游戏</a></li><li><a href="/pages/82a324/" class="sidebar-link">02分配问题</a></li><li><a href="/pages/df21f6/" class="sidebar-link">03区间问题</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>分治策略</span> <!----></p> <!----></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>动态规划</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/be1ad8/" class="sidebar-link">01一维动态规划</a></li><li><a href="/pages/5b4acb/" class="sidebar-link">02二维动态规划</a></li><li><a href="/pages/4015bd/" class="sidebar-link">03分割型动态规划</a></li><li><a href="/pages/221930/" class="sidebar-link">04子序列问题</a></li><li><a href="/pages/6417f0/" class="sidebar-link">05背包问题</a></li><li><a href="/pages/ef03e8/" class="sidebar-link">06字符串编辑问题</a></li><li><a href="/pages/c50903/" class="sidebar-link">07股票交易问题</a></li></ul></section></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>其他内容</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading open"><span>数学问题</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/1a23eb/" class="sidebar-link">01公倍数与公因数</a></li><li><a href="/pages/8d884e/" class="sidebar-link">02质数问题</a></li><li><a href="/pages/aef702/" class="sidebar-link">03进制转换问题</a></li><li><a href="/pages/65cf94/" class="sidebar-link">04数字字符串求和问题</a></li><li><a href="/pages/be2fa2/" class="sidebar-link">05众数问题</a></li><li><a href="/pages/a8b0f0/" class="sidebar-link">06中位数问题</a></li><li><a href="/pages/261fe5/" class="sidebar-link">07数字处理问题</a></li><li><a href="/pages/708f52/" class="sidebar-link">08随机数问题</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>位运算</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/296a65/" class="sidebar-link">01位运算基础</a></li><li><a href="/pages/bec6ef/" class="sidebar-link">02妙用异或运算</a></li><li><a href="/pages/d88bb5/" class="sidebar-link">03二进制特性</a></li></ul></section></li></ul></section></li></ul> </aside> <div><main class="page"><div class="theme-vdoing-wrapper "><div class="articleInfo-wrap" data-v-06225672><div class="articleInfo" data-v-06225672><ul class="breadcrumbs" data-v-06225672><li data-v-06225672><a href="/" title="首页" class="iconfont icon-home router-link-active" data-v-06225672></a></li> <li data-v-06225672><span data-v-06225672>LeetCode刷题笔记</span></li><li data-v-06225672><span data-v-06225672>基础数据结构</span></li><li data-v-06225672><span data-v-06225672>二叉树</span></li></ul> <div class="info" data-v-06225672><div title="作者" class="author iconfont icon-touxiang" data-v-06225672><a href="https://github.com/wang-haihua" target="_blank" title="作者" class="beLink" data-v-06225672>王清欢</a></div> <div title="创建时间" class="date iconfont icon-riqi" data-v-06225672><a href="javascript:;" data-v-06225672>2023-03-24</a></div> <!----></div></div></div> <!----> <div class="content-wrapper"><div class="right-menu-wrapper"><div class="right-menu-margin"><div class="right-menu-title">目录</div> <div class="right-menu-content"></div></div></div> <h1><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAAXNSR0IArs4c6QAABKFJREFUSA3tVl1oFVcQnrMbrak3QUgkya1akpJYcrUtIqW1JvFBE9LiQ5v6JmJpolbMg32rVrhgoYK0QiMY6i9Y6EMaW5D+xFJaTYItIuK2Kr3+BJNwkxBj05sQY3b3nM6cs2dv9t7NT/vQJw/sndk5M/PNzJkzewGerP+pAmy+ON8lLzUJgA8ZYxYIYZmGYRnctDaWvJJAmTtfP1pvXsBCCPP8QFcCaRkZYACgDZFO4stNIcBCajEOlmmC9XpJ9bAGCaPaPmzPl32dvLSVu3BWCTQs0XQQ6g0DYgwLIoAZbBCdW/i+781o1VVlm/410mw4h06Y7bIPHNyWDyL4FHkX03Q8SrzNhZTZriieckWt7cL6MM85YcLpsi/7O9/iXFT6MswI0DmmpkSaJ0qLxFIm3+i1THHB3zmBH3PYx9CcykcLOeQVVa7QtdxTgQgEleX2AjHYfwA+2ddV77ruGoJUbhGDI09YSNXyMpUt5ylOzxgbUmtOp7NmbNt8v3arjTBfYELmLUV+M+nSawNNAUqpT3ClJWg5I3BLT+cGW/DXNGCa6tx1aakCGEigArTn4TDIPdrXXYKCZNrHLMCOEPvHBlLQ99s9eHB7EB6NTki73CVPQ2F5MSx/uRQixfmq7rK0wYD8w8E905bnPDfwoWs/rfv93NWN/ZfvwsLIU7A09gxECyISeGJkHAau98L97tuw7NXnoPyNF8FcYGLGKsOs0mN3OEyec9esGW/ZEl945dTP34wlR2FZVQWU1q0Cw8Tr7p+hgLLNL0FPxx/Q35mA8aEUrH6nCgwEl0tn7wUiZYJnNRh6DK4UH/k0lfyrsBKdPVv/AriGIQcEDQZ65LBAGe2Rzui9Ybjz7XUppz1/uKBbyVPGkN3ZAeC6hr0x7Nr38N5+EqkoOm17xpoqR9ohQF55ERSvr4Dkr3chNfC3DMzGJlNBElW8w9nsGQvhNGIzDkXzCg8cLK951xHsFBlTJspJNi3ZFIMF2AeDV3q8DNOB+YHi6QTrChDIWDBRi5U5f+ZMfJLu3ccrqxtdxk4SKH336LFxSmkqefwU5T8fhdSdQf9IVKD6aNiwI/hnmcAZ91isYMJIaCUCx9W098+LgruikeTqzqqxKPUwqJyCPJiyemVVZBOijDGjD38Os0jOiSPL1z3SPjXNANbiNPXAdzTfukjjuknNBbyz3nwgTd3AVFqUJ5hpHlq9MveLnWwttUfoygBmvVjuikxND3znrhsELnZk7k+OjIGxeNEkomyLVta0xxn+HZhjBc4YZ/AFjHjz9u3xRZl2BN4aq9nFwWh16IrQ1aHHEd3j1+4/dB9OtH4e29A2H1DyHQRmOSfQZ1Fy7MHBTGB6J/Djq6p3OxyO2cB+4Car7v/o3GXgfAkj23+x9ID1Teoamo/SXcbvSf2PX7Vc8DdCmE1vN9di+32P9/5YR3vLnhCVGUWBjEkr3yh4H8v9CzmsbdhzOKzsJKM90iFdaTMjRPhGVsakRvOaRidljo6H6G7j+ctrJpsP+4COhDIl0La2+FS4+5mlocBaXY5QnGZysIBYoeSsl5qQzrSj/cgNrfuEzlWBfwA+EjrZyWUvpAAAAABJRU5ErkJggg==">08二叉搜索树BST<!----></h1> <!----> <div class="theme-vdoing-content content__default"><h2 id="二叉搜索树-bst"><a href="#二叉搜索树-bst" class="header-anchor">#</a> 二叉搜索树 BST</h2> <h3 id="什么是二叉搜索树"><a href="#什么是二叉搜索树" class="header-anchor">#</a> 什么是二叉搜索树</h3> <p>​	二叉搜索树（又称：二叉查找树，二叉排序树，Binary Search Tree, BST）是一种特殊的二叉树：对于每个父节点，其左子节点的值小于等于父结点的值，其右子节点的值大于等于父结点的值。</p> <p>​	因此对于一个二叉搜索树，我们可以在 O(nlogn) 的时间内查找一个值是否存在：从根节点开始，若当前节点的值大于查找值则向左下走，若当前节点的值小于查找值则向右下走。</p> <p>​	同时因为二叉查找树是有序的，对其中序遍历的结果即为排好序的数组。</p> <p>​	一个二叉搜索树实例<code>[15,6,23,4,7,null,71,null,5,null,null,null,null,50,null]</code>如下图所示：</p> <p><img src="/home/wang/Desktop/TechStack/ALGLearning/LeetCode_Cpp/LeetCodeNote/Tree/img/BST/BST.png" alt="BST"></p> <p>​	二叉搜索树除了创建二叉树之外的基本操作有三种：（1）搜索（2）插入 （3）删除</p> <h3 id="bst-的节点属性"><a href="#bst-的节点属性" class="header-anchor">#</a> BST 的节点属性</h3> <p>​	和普通二叉树一样，二叉搜索树的每个节点<strong>至少</strong>有 3 个属性：左孩子，右孩子和数据值，它然节点还可以包含其他潜在的属性。 二叉搜索树节点的结构体声明可以如下：</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">struct</span> <span class="token class-name">Node</span> <span class="token punctuation">{</span>
	T data<span class="token punctuation">;</span> <span class="token comment">// T 代表模板类</span>
	Node<span class="token operator">*</span> left<span class="token punctuation">;</span>
	Node<span class="token operator">*</span> right<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>​	二叉搜索树的节点放置规则是：任何节点的数据值一定大于其左子树中的每个节点的数据值，并小于其右子树中的每个节点的数据值。所以，在遍历二叉搜索树时，一直往左走可以得到最小元素，一直往右走可以得到最大元素。</p> <h3 id="bst-的中序遍历"><a href="#bst-的中序遍历" class="header-anchor">#</a> BST 的中序遍历</h3> <p>​	我们再来复习一遍二叉搜索树的特性：左子树上所有结点的值均小于它的根结点的值，右子树上所有结点的值均大于它的根结点的值。</p> <p>​	依据这一特性我们可以推出二叉搜索树的另一个重要特性：<strong>二叉搜索树的中序遍历序列是一个递增序列</strong>。</p> <p>​	二叉搜索树的中序遍历实现和普通二叉树一样，也有递归和非递归的实现方式。但是无论 BST 的高度如何，中序遍历的时间复杂度都是<code>O(N)</code>。</p> <p>​	**（1）递归实现方式：**先遍历左节点，再遍历父结点，最后遍历右节点</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">void</span> <span class="token function">inorder</span><span class="token punctuation">(</span>Node<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">inorder</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">visit</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">inorder</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>​	（2）<strong>非递归实现方式：</strong></p> <p>​	二叉树中序遍历是从左子树的最左边的叶子节点开始处理，是<strong>自下而上的递归</strong>。</p> <p>​	节点访问过程：由于是自下而上的访问，使用迭代实现中序遍历需要一个额外的指针来访问节点，从根节点一层层向左访问到左子树的最左边的叶子节点并逐个入栈，再开始向上迭代处理节点值。完成访问之后，栈中保存的是从根节点到最左边的叶子节点路径上的所有节点，他们都是左节点。</p> <p>​	节点处理过程：直接取栈顶元素将其值加入结果集，然后查看它是否具有右节点。如果有右节点则使用指针从该节点开始进行和根节点一样的访问过程，将从该节点开始到以该节点为根节点的子树的最左叶子节点路径上的所有节点入栈。完成访问之后再重复处理过程，最终完成所有节点的访问和处理。</p> <p>​	实现代码如下：</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">inorderTraversal</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> ans<span class="token punctuation">;</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span><span class="token punctuation">{</span>
	    <span class="token keyword">return</span> ans<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	stack<span class="token operator">&lt;</span>TreeNode<span class="token operator">*</span><span class="token operator">&gt;</span> s<span class="token punctuation">;</span>
	TreeNode<span class="token operator">*</span> cur <span class="token operator">=</span> root<span class="token punctuation">;</span>
	<span class="token keyword">while</span><span class="token punctuation">(</span>cur <span class="token operator">||</span> <span class="token operator">!</span>s<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>cur<span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token comment">// 从根节点到最左叶子节点的访问过程</span>
            s<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>cur<span class="token punctuation">)</span><span class="token punctuation">;</span>
            cur <span class="token operator">=</span> cur<span class="token operator">-&gt;</span>left<span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>
            <span class="token comment">// 自下而上 左中右的节点处理过程</span>
            cur <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            s<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            ans<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>cur<span class="token operator">-&gt;</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
            cur <span class="token operator">=</span> cur<span class="token operator">-&gt;</span>right<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> ans<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="bst-搜索"><a href="#bst-搜索" class="header-anchor">#</a> BST 搜索</h3> <p>​	二叉搜索树，最为基础的操作当然就是<strong>搜索</strong>了。</p> <p>​	二叉树搜索过程中使用根结点 root 和目标值 target 进行比较，不同情况处理如下：</p> <ul><li>若 target 小于根结点键值，只需在左子树中继续搜索</li> <li>如果 target 大于根结点的键值，在右子树中进行继续搜索</li> <li>若两者比较结果是相等，搜索完成，返回指向此结点的指针。</li></ul> <p><img src="/home/wang/Desktop/TechStack/ALGLearning/LeetCode_Cpp/LeetCodeNote/Tree/img/BST/%E6%90%9C%E7%B4%A2.gif" alt="搜索"></p> <p>​	搜索过程的代码实现如下：</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>Node<span class="token operator">*</span> <span class="token function">find</span><span class="token punctuation">(</span>Node<span class="token operator">*</span> t<span class="token punctuation">,</span> T target<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>target <span class="token operator">&lt;</span> t<span class="token operator">-&gt;</span>data<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token function">find</span><span class="token punctuation">(</span>t<span class="token operator">-&gt;</span>left<span class="token punctuation">,</span> target<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>target <span class="token operator">&gt;</span> t<span class="token operator">-&gt;</span>data<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token function">find</span><span class="token punctuation">(</span>t<span class="token operator">-&gt;</span>right<span class="token punctuation">,</span> target<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> t<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>​	除了快速搜索目标值，二叉搜索树中还可以快速查找最大值和最小值。</p> <p><strong>查找最大值和最小值</strong></p> <p>​	二叉搜索树的节点放置规则是：任何节点的数据值一定大于其左子树中的每个节点的数据值，并小于其右子树中的每个节点的数据值。所以，在遍历二叉搜索树时，一直往左走就可以得到最小元素，一直往右走就可以得到最大元素。</p> <p>​	查找最大值和最小值的代码实现如下：</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token comment">// 查找最小值</span>
Node<span class="token operator">*</span> <span class="token function">findMin</span><span class="token punctuation">(</span>Node<span class="token operator">*</span> t<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">==</span> <span class="token constant">NULL</span> <span class="token operator">||</span> t<span class="token operator">-&gt;</span>left <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token keyword">return</span> t<span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token function">findMin</span><span class="token punctuation">(</span>t<span class="token operator">-&gt;</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 查找最大值</span>
Node<span class="token operator">*</span> <span class="token function">findMax</span><span class="token punctuation">(</span>Node<span class="token operator">*</span> t<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">==</span> <span class="token constant">NULL</span> <span class="token operator">||</span> t<span class="token operator">-&gt;</span>right <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token keyword">return</span> t<span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token function">findMax</span><span class="token punctuation">(</span>t<span class="token operator">-&gt;</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>​	二叉搜索树的搜索时间复杂度与其自身高度 <strong>h</strong> 相关，通常为<code>O(h)</code>。但值得注意的是：在普通的 BST 中其自身高度 <strong>h</strong> 可能和元素 O(<strong>N</strong>) 一样高，即向右倾斜或向左倾斜的情况。</p> <h3 id="bst-插入"><a href="#bst-插入" class="header-anchor">#</a> BST 插入</h3> <p>​	二叉搜索树中插入新元素时，从根节点开始寻找插入位置，遇到数据值较大的节点就向左，遇到数据值较小的节点就向右。重复上述步骤一直到尾端，最终完成插入位置的寻找，然后插入新节点。</p> <p>​	我们还是使用递归实现二叉搜索树的插入操作：</p> <ul><li>遇到数据值较大的节点就向左递归</li> <li>遇到数据值较小的节点就向右递归</li> <li>到达尾端，新建节点并插入</li></ul> <p>​    向上述二叉搜索树插入<code>9, 60</code>两个值的过程如下图：</p> <p><img src="/home/wang/Desktop/TechStack/ALGLearning/LeetCode_Cpp/LeetCodeNote/Tree/img/BST/%E6%8F%92%E5%85%A5.gif" alt="插入"></p> <p>​	代码实现如下：</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>Node<span class="token operator">*</span> <span class="token function">insert</span><span class="token punctuation">(</span>Node<span class="token operator">*</span> t<span class="token punctuation">,</span> T x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        t <span class="token operator">=</span> <span class="token keyword">new</span> Node<span class="token punctuation">;</span>
        t<span class="token operator">-&gt;</span>data <span class="token operator">=</span> x<span class="token punctuation">;</span>
        t<span class="token operator">-&gt;</span>left <span class="token operator">=</span> t<span class="token operator">-&gt;</span>right <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">&lt;</span> t<span class="token operator">-&gt;</span>data<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        t<span class="token operator">-&gt;</span>left <span class="token operator">=</span> <span class="token function">insert</span><span class="token punctuation">(</span>t<span class="token operator">-&gt;</span>left<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">&gt;</span> t<span class="token operator">-&gt;</span>data<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        t<span class="token operator">-&gt;</span>right <span class="token operator">=</span> <span class="token function">insert</span><span class="token punctuation">(</span>t<span class="token operator">-&gt;</span>right<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> t<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>​	二叉搜索树插入的时间复杂度也是 <code>O(h)</code> ，其中 h 是 BST 的高度。同样的这个 <strong>h</strong> 在普通 BST 中可以和 O(<strong>N</strong>) 一样高，即向右倾斜或向左倾斜的情况。</p> <h3 id="bst-删除的三种情况"><a href="#bst-删除的三种情况" class="header-anchor">#</a> BST 删除的三种情况</h3> <p>​	二叉搜索树的删除操作还是通过与搜索操作相似先找到要删除的节点：</p> <ul><li>如果找不到目标节点，什么都不做。</li> <li>如果找到了目标节点，这时需要考虑三个可能的删除情况：
<ul><li>目标节点是叶子节点</li> <li>目标节点有一个子节点</li> <li>目标节点有两个子节点</li></ul></li></ul> <h4 id="_1-目标节点是叶子节点"><a href="#_1-目标节点是叶子节点" class="header-anchor">#</a> 1 目标节点是叶子节点</h4> <p>​	第一种情况是最简单的，目标节点是当前二叉搜索树的叶子节点之一。</p> <p>​	要删除叶子顶点很容易，我们只需要找到这个节点并将其删除就可以了，下图展示了删除上述二叉搜索树叶子节点<code>5</code>的过程。</p> <p><img src="/home/wang/Desktop/TechStack/ALGLearning/LeetCode_Cpp/LeetCodeNote/Tree/img/BST/%E5%88%A0%E9%99%A41.gif" alt="删除1"></p> <h4 id="_2-目标节点有一个子节点"><a href="#_2-目标节点有一个子节点" class="header-anchor">#</a> 2 目标节点有一个子节点</h4> <p>​	第二种情况也不是那么难：目标节点是当前二叉搜索树的非叶子节点，但是它只有一个子节点。</p> <p>​	删除这个节点时我们只需要将该节点的唯一的子节点与该节点的父节点连接即可，下图展示了删除上述二叉搜索树中只有一个子节点<code>71</code>的过程。</p> <p><img src="/home/wang/Desktop/TechStack/ALGLearning/LeetCode_Cpp/LeetCodeNote/Tree/img/BST/%E5%88%A0%E9%99%A42.gif" alt="删除2"></p> <h4 id="_3-目标节点有两个子节点"><a href="#_3-目标节点有两个子节点" class="header-anchor">#</a> 3 目标节点有两个子节点</h4> <p>​	第三种情况是三者中最复杂的：目标节点是当前二叉搜索树中具有两个叶子节点的非叶子节点。</p> <p>​	删除该节点需要进行如下步骤：</p> <ul><li>搜索二叉搜索树找到该节点</li> <li>找到以该节点为根节点的右子树中的最小结点<code>findMin()</code></li> <li>使用右子树中的最小节点替代该节点</li> <li>然后依据上述三种删除情况，<strong>递归调整</strong>其右子树的放置情况</li></ul> <p>​    下图展示了删除上述二叉搜索树具有两个叶子节点<code>6</code>的过程。
<img src="/home/wang/Desktop/TechStack/ALGLearning/LeetCode_Cpp/LeetCodeNote/Tree/img/BST/%E5%88%A0%E9%99%A43.gif" alt="删除3"></p> <p>​	二叉搜索树删除操作的代码实现如下：</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>Node<span class="token operator">*</span> <span class="token function">remove</span><span class="token punctuation">(</span>Node<span class="token operator">*</span> t<span class="token punctuation">,</span> T x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	Node<span class="token operator">*</span> temp<span class="token punctuation">;</span>
    <span class="token comment">// 搜索目标节点</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
	<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">&lt;</span> t<span class="token operator">-&gt;</span>data<span class="token punctuation">)</span> t<span class="token operator">-&gt;</span>left <span class="token operator">=</span> <span class="token function">remove</span><span class="token punctuation">(</span>t<span class="token operator">-&gt;</span>left<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">&gt;</span> t<span class="token operator">-&gt;</span>data<span class="token punctuation">)</span> t<span class="token operator">-&gt;</span>right <span class="token operator">=</span> <span class="token function">remove</span><span class="token punctuation">(</span>t<span class="token operator">-&gt;</span>right<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 情况 3</span>
	<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>t<span class="token operator">-&gt;</span>left <span class="token operator">&amp;&amp;</span> t<span class="token operator">-&gt;</span>right<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		temp <span class="token operator">=</span> <span class="token function">findMin</span><span class="token punctuation">(</span>t<span class="token operator">-&gt;</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
        t<span class="token operator">-&gt;</span>data <span class="token operator">=</span> temp<span class="token operator">-&gt;</span>data<span class="token punctuation">;</span>
        t<span class="token operator">-&gt;</span>right <span class="token operator">=</span> <span class="token function">remove</span><span class="token punctuation">(</span>t<span class="token operator">-&gt;</span>right<span class="token punctuation">,</span> t<span class="token operator">-&gt;</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        temp <span class="token operator">=</span> t<span class="token punctuation">;</span>
        <span class="token comment">// 情况 2</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>t<span class="token operator">-&gt;</span>left <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> t <span class="token operator">=</span> t<span class="token operator">-&gt;</span>right<span class="token punctuation">;</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>t<span class="token operator">-&gt;</span>right <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> t <span class="token operator">=</span> t<span class="token operator">-&gt;</span>left<span class="token punctuation">;</span>
        <span class="token comment">// 情况 1</span>
        <span class="token keyword">delete</span> temp<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
	<span class="token keyword">return</span> t<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>​	二叉搜索树删除操作的时间复杂度也是 <code>O(h)</code> ，其中 h 是 BST 的高度，即使是第三种最复杂的情况时间复杂度也不会超过 <code>O(h)</code> 。同样的这个 <strong>h</strong> 在普通 BST 中可以和 O(<strong>N</strong>) 一样高，即向右倾斜或向左倾斜的情况。</p> <h2 id="平衡二叉搜索树"><a href="#平衡二叉搜索树" class="header-anchor">#</a> 平衡二叉搜索树</h2> <p>​	在二叉搜索树 BST 的介绍过程中，我们不断提到了操作的时间复杂度，其中除了中序遍历之外，大部分操作的时间复杂度都是 O(<strong>h</strong>) ，即与 BST 自身的高度相关。</p> <p>​	而普通二叉搜索树可能会出现向右倾斜或向左倾斜的情况，即导致其高度为 <code>N-1</code>，从而使得二叉搜索树操作出现最坏情况时间复杂度为 O(<strong>N</strong>) 。</p> <p>​	为了降低二叉搜索树操作的时间复杂度，我们将讨论<strong>平衡二叉搜索树</strong>的概念，以使得 <code>h = O(logN)</code>。</p> <div class="language- extra-class"><pre><code>二叉树的极度平衡和极度不平衡状态如下图所示：
</code></pre></div><img src="/home/wang/Desktop/TechStack/ALGLearning/LeetCode_Cpp/LeetCodeNote/Tree/img/BST/平衡BST.png" alt="平衡BST" style="zoom:80%;"> <p>​	树形结构是否平衡并没有绝对的衡量标准，它指的是没有任何一个节点深度过大。不同的平衡条件，可以实现不同的树形操作效率，也会带来不同的实现复杂度。</p> <p>​	用的最多的平衡标准是：<strong>其左子树和右子树均为平衡二叉树，且左子树和右子树的高度差的绝对值不超过 1</strong>。这使得含有 N 个结点的平衡二叉树的最大深度为 <code>O(logN)</code>。</p> <p>​	基于平衡二叉树的概念，已经有多种实现平衡二叉搜索树的数据结构，例如 <code>AVL-Tree, RB-Tree, B/B+ Tree</code>等，他们比一般的二叉搜索树复杂，但是能够保证高效的查找、插入和删除等操作。</p> <h2 id="自平衡二叉搜索树-avl"><a href="#自平衡二叉搜索树-avl" class="header-anchor">#</a> 自平衡二叉搜索树 AVL</h2> <h3 id="什么是-avl"><a href="#什么是-avl" class="header-anchor">#</a> 什么是 AVL</h3> <p>​	AVL-Tree，是由两位俄罗斯（苏联）发明家 <em>Georgy Adelson-Velskii</em> 和 <em>Evgenii Landis</em> 在 1962 年提出的。</p> <p>​	AVL-Tree 使用的平衡标准就是：<strong>二叉搜索树所有非叶子节点的左子树和右子树均为平衡二叉树，且左子树和右子树的高度差的绝对值不超过 1</strong>。该平衡条件就是为了确保整颗二叉搜索树的深度为<code>O(logN)</code>。</p> <p>​	自平衡二叉搜索树 AVL 是带了自平衡功能的二叉搜索树。当对其进行插入或删除操作后破坏了平衡条件时，它能够进行调整，使整颗树的高度平衡为 <code>O(logN)</code>。</p> <p><img src="/home/wang/Desktop/TechStack/ALGLearning/LeetCode_Cpp/LeetCodeNote/Tree/img/BST/AVL.png" alt="AVL"></p> <h3 id="树的旋转"><a href="#树的旋转" class="header-anchor">#</a> 树的旋转</h3> <p>​	由于 AVL-Tree 的平衡条件，对其进行插入和删除操作后可能破坏整颗树的平衡，平衡被破坏后 AVL 能够自行进行调整恢复平衡。首先，找到平衡被破坏中的各个非叶子节点中深度最深的那一个。</p> <p>​	由于二叉树最多有两个子节点，而平衡被破坏即为该节点的左右子树的高度相差 2。因此，以插入操作为例可以将平衡被破坏分为如下四种情况：</p> <ol><li>插入左子节点的左子树  <strong>LL</strong></li> <li>插入右子节点的右子树  <strong>RR</strong></li> <li>插入左子节点的右子树  <strong>LR</strong></li> <li>插入右子节点的左子树  <strong>RL</strong></li></ol> <p>​    情况 1 和 2 又可以称为<strong>外侧插入</strong>，使用单旋转操作调整恢复平衡；情况 3 和 4 称为<strong>内侧插入</strong>，使用双旋转操作调整恢复平衡。</p> <h4 id="_1-ll-单旋转"><a href="#_1-ll-单旋转" class="header-anchor">#</a> 1 LL 单旋转</h4> <p>​	上述 AVL-Tree 中的节点<code>20</code>，我们进行外侧插入，在其左子节点<code>11</code>的左子树插入新的节点<code>5</code>。这就破坏了整颗树的平衡，处于不平衡状态的节点有<code>41, 20</code>，而<code>20</code>的深度更大。</p> <p>​	为了调整平衡状态，需要将以<code>6</code>为根节点的子树提高一层，将以<code>29</code>为根节点的子树下降一层，进行如下单向右旋步骤：</p> <ul><li>深度最大的不平衡状态的节点 node，即<code>20</code></li> <li>node 的左孩子代替 node，即用<code>11</code>代替<code>20</code>，<code>41-&gt;left = 11</code></li> <li>node 左孩子的右子树变为 node 的左子树，即将<code>20-&gt;left = 15</code></li> <li>将 node 作为其原始左孩子的右子树，即将<code>11-&gt;right = 20</code></li></ul> <p><img src="/home/wang/Desktop/TechStack/ALGLearning/LeetCode_Cpp/LeetCodeNote/Tree/img/BST/AVL-LL.gif" alt="AVL-LL"></p> <p>​	AVL-Tree LL型调整操作的代码实现如下：（<a href="https://zhuanlan.zhihu.com/p/56066942" target="_blank" rel="noopener noreferrer">代码来源<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>，如有侵权请告知）</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token comment">//LL型调整函数</span>
<span class="token comment">//返回:新父节点</span>
Node <span class="token function">LL_rotate</span><span class="token punctuation">(</span>Node node<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment">//node为离操作结点最近的失衡的结点</span>
    Node parent<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">,</span>son<span class="token punctuation">;</span>
    <span class="token comment">//获取失衡结点的父节点</span>
    parent<span class="token operator">=</span>node<span class="token operator">-&gt;</span>parent<span class="token punctuation">;</span>
    <span class="token comment">//获取失衡结点的左孩子</span>
    son<span class="token operator">=</span>node<span class="token operator">-&gt;</span>lchild<span class="token punctuation">;</span>
    <span class="token comment">//设置son结点右孩子的父指针</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>son<span class="token operator">-&gt;</span>rchild<span class="token operator">!=</span><span class="token constant">NULL</span><span class="token punctuation">)</span>  son<span class="token operator">-&gt;</span>rchild<span class="token operator">-&gt;</span>parent<span class="token operator">=</span>node<span class="token punctuation">;</span>
    <span class="token comment">//失衡结点的左孩子变更为son的右孩子</span>
    node<span class="token operator">-&gt;</span>lchild<span class="token operator">=</span>son<span class="token operator">-&gt;</span>rchild<span class="token punctuation">;</span>
    <span class="token comment">//更新失衡结点的高度信息</span>
    <span class="token function">update_depth</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//失衡结点变成son的右孩子</span>
    son<span class="token operator">-&gt;</span>rchild<span class="token operator">=</span>node<span class="token punctuation">;</span>
    <span class="token comment">//设置son的父结点为原失衡结点的父结点</span>
    son<span class="token operator">-&gt;</span>parent<span class="token operator">=</span>parent<span class="token punctuation">;</span>
    <span class="token comment">//如果失衡结点不是根结点，则开始更新父节点</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>parent<span class="token operator">!=</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token comment">//如果父节点的左孩子是失衡结点，指向现在更新后的新孩子son</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>parent<span class="token operator">-&gt;</span>lchild<span class="token operator">==</span>node<span class="token punctuation">)</span><span class="token punctuation">{</span>
            parent<span class="token operator">-&gt;</span>lchild<span class="token operator">=</span>son<span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>
             <span class="token comment">//父节点的右孩子是失衡结点</span>
              parent<span class="token operator">-&gt;</span>rchild<span class="token operator">=</span>son<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
     <span class="token punctuation">}</span>
    <span class="token comment">//设置失衡结点的父亲</span>
    node<span class="token operator">-&gt;</span>parent<span class="token operator">=</span>son<span class="token punctuation">;</span>
    <span class="token comment">//更新son结点的高度信息</span>
    <span class="token function">update_depth</span><span class="token punctuation">(</span>son<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> son<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="_2-rr-单旋转"><a href="#_2-rr-单旋转" class="header-anchor">#</a> 2 RR 单旋转</h4> <p>​	上述 AVL-Tree 中的节点<code>65</code>，我们进行外侧插入，在其左子节点<code>91</code>的右子树插入新的节点<code>100</code>。这就破坏了整颗树的平衡，处于不平衡状态的节点有<code>41, 65</code>，而<code>65</code>的深度更大。</p> <p>​	为了调整平衡状态，需要将以<code>99</code>为根节点的子树提高一层，将以<code>50</code>为根节点的子树下降一层，进行如下单向左旋步骤：</p> <ul><li>深度最大的不平衡状态的节点 node，即<code>65</code></li> <li>node 的右孩子代替 node，即用<code>91</code>代替<code>65</code>，<code>41-&gt;right = 91</code></li> <li>node 右孩子的左子树变为 node 的右子树，即将<code>65-&gt;right = 72</code></li> <li>将 node 作为其原始右孩子的左子树，即将<code>91-&gt;left = 65</code></li></ul> <p><img src="/home/wang/Desktop/TechStack/ALGLearning/LeetCode_Cpp/LeetCodeNote/Tree/img/BST/AVL-RR.gif" alt="AVL-RR"></p> <p>​	AVL-Tree RR型调整操作的代码实现如下：（<a href="https://zhuanlan.zhihu.com/p/56066942" target="_blank" rel="noopener noreferrer">代码来源<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>，如有侵权请告知）</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token operator">/</span>RR型调整函数
<span class="token comment">//返回新父节点</span>
Node <span class="token function">RR_rotate</span><span class="token punctuation">(</span>Node node<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment">//node为离操作结点最近的失衡的结点</span>
    Node parent<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">,</span>son<span class="token punctuation">;</span>
    <span class="token comment">//获取失衡结点的父节点</span>
    parent<span class="token operator">=</span>node<span class="token operator">-&gt;</span>parent<span class="token punctuation">;</span>
    <span class="token comment">//获取失衡结点的右孩子</span>
    son<span class="token operator">=</span>node<span class="token operator">-&gt;</span>rchild<span class="token punctuation">;</span>
    <span class="token comment">//设置son结点左孩子的父指针</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>son<span class="token operator">-&gt;</span>lchild<span class="token operator">!=</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
          son<span class="token operator">-&gt;</span>lchild<span class="token operator">-&gt;</span>parent<span class="token operator">=</span>node<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">//失衡结点的右孩子变更为son的左孩子</span>
    node<span class="token operator">-&gt;</span>rchild<span class="token operator">=</span>son<span class="token operator">-&gt;</span>lchild<span class="token punctuation">;</span>
    <span class="token comment">//更新失衡结点的高度信息</span>
    <span class="token function">update_depth</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//失衡结点变成son的左孩子</span>
    son<span class="token operator">-&gt;</span>lchild<span class="token operator">=</span>node<span class="token punctuation">;</span>
    <span class="token comment">//设置son的父结点为原失衡结点的父结点</span>
    son<span class="token operator">-&gt;</span>parent<span class="token operator">=</span>parent<span class="token punctuation">;</span>
    <span class="token comment">//如果失衡结点不是根结点，则开始更新父节点</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>parent<span class="token operator">!=</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token comment">//如果父节点的左孩子是失衡结点，指向现在更新后的新孩子son</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>parent<span class="token operator">-&gt;</span>lchild<span class="token operator">==</span>node<span class="token punctuation">)</span><span class="token punctuation">{</span>
            parent<span class="token operator">-&gt;</span>lchild<span class="token operator">=</span>son<span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>
            <span class="token comment">//父节点的右孩子是失衡结点</span>
            parent<span class="token operator">-&gt;</span>rchild<span class="token operator">=</span>son<span class="token punctuation">;</span>
        <span class="token punctuation">}</span> 
    <span class="token punctuation">}</span>
    <span class="token comment">//设置失衡结点的父亲</span>
    node<span class="token operator">-&gt;</span>parent<span class="token operator">=</span>son<span class="token punctuation">;</span>
    <span class="token comment">//更新son结点的高度信息</span>
    <span class="token function">update_depth</span><span class="token punctuation">(</span>son<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> son<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="_3-lr-双旋转"><a href="#_3-lr-双旋转" class="header-anchor">#</a> 3 LR 双旋转</h4> <p>​	上述 AVL-Tree 中的节点<code>20</code>，我们进行内侧插入，在其左子节点<code>11</code>的<strong>右子树</strong>插入新的节点<code>14</code>。这就破坏了整颗树的平衡，处于不平衡状态的节点有<code>41, 20</code>，而<code>20</code>的深度更大。</p> <p>​	这种情况我们无法直接使用 LL 或者 RR 的单旋转完整调整，因为旋转之后仍然是不平衡的。为了调整平衡状态，需要将以<code>15</code>作为跳转子树的新根节点，这使得<code>11</code>必将成为<code>15</code>的左子节点，而<code>20</code>则将称为<code>15</code>的右子节点，这样就恢复了平衡状态。</p> <p>​	这一过程需要进行两次单旋转，首先进行 RR 单向左旋转让<code>11</code>成为<code>15</code>的左孩子；然后进行 LL 单向右旋转让<code>20</code>成为<code>15</code>的右孩子。</p> <p><img src="/home/wang/Desktop/TechStack/ALGLearning/LeetCode_Cpp/LeetCodeNote/Tree/img/BST/AVL-LR.gif" alt="AVL-LR"></p> <p>​	AVL-Tree LR型调整操作的代码实现如下：（<a href="https://zhuanlan.zhihu.com/p/56066942" target="_blank" rel="noopener noreferrer">代码来源<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>，如有侵权请告知）</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token comment">//LR型，先左旋转，再右旋转</span>
<span class="token comment">//返回：新父节点</span>
Node <span class="token function">LR_rotate</span><span class="token punctuation">(</span>Node node<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token function">RR_rotate</span><span class="token punctuation">(</span>node<span class="token operator">-&gt;</span>lchild<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token function">LL_rotate</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="_4-rl-双旋转"><a href="#_4-rl-双旋转" class="header-anchor">#</a> 4 RL 双旋转</h4> <p>​	上述 AVL-Tree 中的节点<code>65</code>，我们进行内侧插入，在其右子节点<code>91</code>的<strong>左子树</strong>插入新的节点<code>73</code>。这就破坏了整颗树的平衡，处于不平衡状态的节点有<code>41, 65</code>，而<code>65</code>的深度更大。</p> <p>​	这种情况我们无法直接使用 LL 或者 RR 的单旋转完整调整，因为旋转之后仍然是不平衡的。为了调整平衡状态，需要将以<code>72</code>作为跳转子树的新根节点，这使得<code>91</code>必将成为<code>72</code>的右子节点，而<code>65</code>则将称为<code>72</code>的左子节点，这样就恢复了平衡状态。</p> <p>​	这一过程需要进行两次单旋转，首先进行 LL 单向右旋转让<code>91</code>成为<code>72</code>的右孩子；然后进行 RR 单向左旋转让<code>65</code>成为<code>72</code>的右孩子。</p> <p><img src="/home/wang/Desktop/TechStack/ALGLearning/LeetCode_Cpp/LeetCodeNote/Tree/img/BST/AVL-RL.gif" alt="AVL-RL"></p> <p>​	AVL-Tree RL型调整操作的代码实现如下：（<a href="https://zhuanlan.zhihu.com/p/56066942" target="_blank" rel="noopener noreferrer">代码来源<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>，如有侵权请告知）</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token comment">//RL型，先右旋转，再左旋转</span>
<span class="token comment">//返回:新父节点</span>
Node <span class="token function">RL_rotate</span><span class="token punctuation">(</span>Node node<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token function">LL_rotate</span><span class="token punctuation">(</span>node<span class="token operator">-&gt;</span>rchild<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token function">RR_rotate</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="avl-插入与删除"><a href="#avl-插入与删除" class="header-anchor">#</a> AVL 插入与删除</h3> <h4 id="_1-avl-插入"><a href="#_1-avl-插入" class="header-anchor">#</a> 1 AVL 插入</h4> <p>​	介绍完树的旋转，其实就已经介绍完了 AVL-Tree 的核心步骤。</p> <p>​	AVL-Tree 插入的总体步骤如下：</p> <ol><li>和普通二叉搜索树插入过程一样，BST 插入</li> <li>从插入点向上走遍历 AVL-Tree 直到回到根节点。每遍历一个节点，我们更新处于不平衡状态节点的高度和平衡因子：
<ul><li>如果存在不平衡状态的节点，停止在不平衡的第一个节点即深度最大的不平衡状态节点，其平衡因子为<code>+2 或 -2</code></li> <li>使用四个树旋转案例中的一个来跳转二叉树，使其重新达到平衡状态</li></ul></li></ol> <h4 id="_2-avl-删除"><a href="#_2-avl-删除" class="header-anchor">#</a> 2 AVL 删除</h4> <p>​	AVL 删除和 AVL 插入本质上是相似的方法，核心还是在于使用树旋转调整平衡状态。</p> <p>​	AVL-Tree 删除的总体步骤如下：</p> <ol><li>和普通二叉搜索树删除过程一样，使用三个删除案例中的一个进行 BST 删除</li> <li>在 AVL-Tree 中从删除点向上走直到回到根节点。每遍历一个节点，我们更新处于不平衡状态节点的高度和平衡因子：
<ul><li>如果存在不平衡状态的节点，停止在不平衡的第一个节点即深度最大的不平衡状态节点，其平衡因子为<code>+2 或 -2</code></li> <li>使用四个树旋转案例中的一个来跳转二叉树，使其重新达到平衡状态</li></ul></li></ol> <p><strong>总结</strong></p> <p>​	BST 插入和删除操作与AVL 的插入和删除操作相比的主要区别在于：可能会多次触发四种可能的需要重新平衡情况中的一种，但时间复杂度不会超过 <code>h = O(logN)</code>。</p></div></div> <!----> <div class="page-edit"><!----> <!----> <div class="last-updated"><span class="prefix">上次更新:</span> <span class="time">2023/11/19, 12:55:48</span></div></div> <div class="page-nav-wapper"><div class="page-nav-centre-wrap"><a href="/pages/5c0017/" class="page-nav-centre page-nav-centre-prev"><div class="tooltip">07字典树</div></a> <a href="/pages/208d53/" class="page-nav-centre page-nav-centre-next"><div class="tooltip">01二分图</div></a></div> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/pages/5c0017/" class="prev">07字典树</a></span> <span class="next"><a href="/pages/208d53/">01二分图</a>→
      </span></p></div></div></div> <!----></main></div> <div class="footer"><div class="icons"><a href="mailto:wanghaihua@hust.edu.cn" title="发邮件" target="_blank" class="iconfont icon-youjian"></a><a href="https://github.com/wang-haihua" title="GitHub" target="_blank" class="iconfont icon-github"></a><a href="https://randy.blog.csdn.net/" title="CSDN" target="_blank" class="iconfont icon-csdn"></a></div> 
  Theme by
  <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" title="本站主题">Vdoing</a> 
    | Copyright © 2023-2024
    <span>Wang Qinghuan | MIT License</span></div> <div class="buttons"><div title="返回顶部" class="button blur go-to-top iconfont icon-fanhuidingbu" style="display:none;"></div> <div title="去评论" class="button blur go-to-comment iconfont icon-pinglun" style="display:none;"></div> <div title="主题模式" class="button blur theme-mode-but iconfont icon-zhuti"><ul class="select-box" style="display:none;"><li class="iconfont icon-zidong">
          跟随系统
        </li><li class="iconfont icon-rijianmoshi">
          浅色模式
        </li><li class="iconfont icon-yejianmoshi">
          深色模式
        </li><li class="iconfont icon-yuedu">
          阅读模式
        </li></ul></div></div> <!----> <!----> <!----></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.3c964c09.js" defer></script><script src="/assets/js/2.7cb4c100.js" defer></script><script src="/assets/js/93.c070a2da.js" defer></script>
  </body>
</html>
