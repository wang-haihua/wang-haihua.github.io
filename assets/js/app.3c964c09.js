(window.webpackJsonp=window.webpackJsonp||[]).push([[0],[]]);!function(n){function e(e){for(var i,s,o=e[0],l=e[1],d=e[2],u=0,p=[];u<o.length;u++)s=o[u],Object.prototype.hasOwnProperty.call(r,s)&&r[s]&&p.push(r[s][0]),r[s]=0;for(i in l)Object.prototype.hasOwnProperty.call(l,i)&&(n[i]=l[i]);for(c&&c(e);p.length;)p.shift()();return a.push.apply(a,d||[]),t()}function t(){for(var n,e=0;e<a.length;e++){for(var t=a[e],i=!0,o=1;o<t.length;o++){var l=t[o];0!==r[l]&&(i=!1)}i&&(a.splice(e--,1),n=s(s.s=t[0]))}return n}var i={},r={1:0},a=[];function s(e){if(i[e])return i[e].exports;var t=i[e]={i:e,l:!1,exports:{}};return n[e].call(t.exports,t,t.exports,s),t.l=!0,t.exports}s.e=function(n){var e=[],t=r[n];if(0!==t)if(t)e.push(t[2]);else{var i=new Promise((function(e,i){t=r[n]=[e,i]}));e.push(t[2]=i);var a,o=document.createElement("script");o.charset="utf-8",o.timeout=120,s.nc&&o.setAttribute("nonce",s.nc),o.src=function(n){return s.p+"assets/js/"+({}[n]||n)+"."+{2:"7cb4c100",3:"5e9c9aeb",4:"4290cd63",5:"c8d737d0",6:"a41c5e20",7:"77d76dfa",8:"45e21c4e",9:"c216597d",10:"63f63ae7",11:"9a5b96b4",12:"44fb0008",13:"a330722e",14:"6847a39f",15:"0e030877",16:"74612e69",17:"aff28c92",18:"6c553fe2",19:"25a79e40",20:"2912c5fd",21:"cc8f7cb4",22:"73f5d0fb",23:"082f826b",24:"62a7a3fb",25:"3f1ff6cb",26:"02eb8e1c",27:"c669fe7b",28:"5c92c35c",29:"5b037672",30:"503d0120",31:"24297fec",32:"96252ef0",33:"c89e1ff8",34:"d3ccb114",35:"16c1381a",36:"bf337c21",37:"946363a7",38:"97180054",39:"db68880e",40:"fdfa3edb",41:"1364b864",42:"b5fe6688",43:"a657a0ea",44:"c60c202e",45:"f0ca7707",46:"a2cfa915",47:"00eaf68b",48:"0697506a",49:"d975a8c1",50:"d71495f8",51:"45b983df",52:"86cfff51",53:"7aab1ca2",54:"4d1b9288",55:"5b50da92",56:"2c9ea1c5",57:"ed975abb",58:"c103cc9b",59:"aa73a8af",60:"12f2b692",61:"83fae5c1",62:"e31f6715",63:"295992f4",64:"2fc8a996",65:"3d399173",66:"aa557906",67:"254bd65a",68:"ad2097e4",69:"b9231851",70:"49947637",71:"d2610084",72:"bff01f1e",73:"3d9b6c19",74:"a4201e96",75:"8489c790",76:"2f9bc769",77:"ff492b54",78:"31c6d8b2",79:"21d03938",80:"0e9d328b",81:"871bf4a7",82:"e75460b6",83:"e13d0013",84:"8c34a475",85:"e108fbd1",86:"7d4ff604",87:"53bc3752",88:"a45401e3",89:"b419f73b",90:"c7fe862e",91:"ef3cfddd",92:"721483d9",93:"c070a2da",94:"0295dc34",95:"f327f220",96:"922233b5",97:"1c062e72",98:"bc678e0d",99:"40c68a6a",100:"95a6c99c",101:"b4a49f0b",102:"2de85a2d",103:"45e2e113",104:"56158bd6",105:"1f16775f",106:"84151016",107:"7b9fd16b",108:"9a669853",109:"607b8ba0",110:"035ebd82",111:"2189344f",112:"acc94015",113:"732292c6",114:"69d6fa65",115:"b01a3599",116:"6724705b",117:"ce49efe5",118:"28357f19",119:"183d08ed",120:"474cdfad",121:"e3ecdcc4",122:"0a0bc0aa",123:"0c6ab3ab",124:"0d0ffb49",125:"0e81a183",126:"aad938f8",127:"a0f92902",128:"1d6192b0",129:"b953e757",130:"7bb5e38e",131:"7462b2ba",132:"c0928987",133:"198cb7db",134:"297283a1",135:"7f82baca",136:"0c6b96f4",137:"dae22f59",138:"30641cf0",139:"4153d23d",140:"c25d78fc",141:"496ceb78",142:"0de8f200",143:"28d82825",144:"acce788f",145:"9cfb27d2",146:"6230832c",147:"121e1344",148:"f0e26f06",149:"dea71d53",150:"9ba2012f",151:"59a8ddd9",152:"1d937849",153:"d9366ef7",154:"9d104827",155:"96d646cc",156:"f87e7868",157:"9fd3efa6",158:"75948c6a",159:"9b842781",160:"56221aa8",161:"17b059f2",162:"668f0874",163:"b6b0e348",164:"341c344d",165:"c8c5e318",166:"15c69481",167:"0d5a35a6",168:"169a4503",169:"0918ad60",170:"1f41cdee",171:"32de0dd3",172:"8d0977fa",173:"7f833ed2",174:"e3cf5acf",175:"c5e1249f",176:"36d2aed6",177:"2b946f65",178:"6471a14e"}[n]+".js"}(n);var l=new Error;a=function(e){o.onerror=o.onload=null,clearTimeout(d);var t=r[n];if(0!==t){if(t){var i=e&&("load"===e.type?"missing":e.type),a=e&&e.target&&e.target.src;l.message="Loading chunk "+n+" failed.\n("+i+": "+a+")",l.name="ChunkLoadError",l.type=i,l.request=a,t[1](l)}r[n]=void 0}};var d=setTimeout((function(){a({type:"timeout",target:o})}),12e4);o.onerror=o.onload=a,document.head.appendChild(o)}return Promise.all(e)},s.m=n,s.c=i,s.d=function(n,e,t){s.o(n,e)||Object.defineProperty(n,e,{enumerable:!0,get:t})},s.r=function(n){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},s.t=function(n,e){if(1&e&&(n=s(n)),8&e)return n;if(4&e&&"object"==typeof n&&n&&n.__esModule)return n;var t=Object.create(null);if(s.r(t),Object.defineProperty(t,"default",{enumerable:!0,value:n}),2&e&&"string"!=typeof n)for(var i in n)s.d(t,i,function(e){return n[e]}.bind(null,i));return t},s.n=function(n){var e=n&&n.__esModule?function(){return n.default}:function(){return n};return s.d(e,"a",e),e},s.o=function(n,e){return Object.prototype.hasOwnProperty.call(n,e)},s.p="/",s.oe=function(n){throw console.error(n),n};var o=window.webpackJsonp=window.webpackJsonp||[],l=o.push.bind(o);o.push=e,o=o.slice();for(var d=0;d<o.length;d++)e(o[d]);var c=l;a.push([104,0]),t()}([function(n,e,t){var i=t(55),r=i.all;n.exports=i.IS_HTMLDDA?function(n){return"function"==typeof n||n===r}:function(n){return"function"==typeof n}},function(n,e,t){var i=t(27),r=Function.prototype,a=r.call,s=i&&r.bind.bind(a,a);n.exports=i?s:function(n){return function(){return a.apply(n,arguments)}}},function(n,e){var t=function(n){return n&&n.Math==Math&&n};n.exports=t("object"==typeof globalThis&&globalThis)||t("object"==typeof window&&window)||t("object"==typeof self&&self)||t("object"==typeof global&&global)||function(){return this}()||this||Function("return this")()},function(n,e){n.exports=function(n){try{return!!n()}catch(n){return!0}}},function(n,e,t){var i=t(3);n.exports=!i((function(){return 7!=Object.defineProperty({},1,{get:function(){return 7}})[1]}))},function(n,e){var t=Array.isArray;n.exports=t},function(n,e,t){var i=t(69),r="object"==typeof self&&self&&self.Object===Object&&self,a=i||r||Function("return this")();n.exports=a},function(n,e,t){"use strict";function i(n,e,t,i,r,a,s,o){var l,d="function"==typeof n?n.options:n;if(e&&(d.render=e,d.staticRenderFns=t,d._compiled=!0),i&&(d.functional=!0),a&&(d._scopeId="data-v-"+a),s?(l=function(n){(n=n||this.$vnode&&this.$vnode.ssrContext||this.parent&&this.parent.$vnode&&this.parent.$vnode.ssrContext)||"undefined"==typeof __VUE_SSR_CONTEXT__||(n=__VUE_SSR_CONTEXT__),r&&r.call(this,n),n&&n._registeredComponents&&n._registeredComponents.add(s)},d._ssrRegister=l):r&&(l=o?function(){r.call(this,(d.functional?this.parent:this).$root.$options.shadowRoot)}:r),l)if(d.functional){d._injectStyles=l;var c=d.render;d.render=function(n,e){return l.call(e),c(n,e)}}else{var u=d.beforeCreate;d.beforeCreate=u?[].concat(u,l):[l]}return{exports:n,options:d}}t.d(e,"a",(function(){return i}))},function(n,e,t){var i=t(1),r=t(32),a=i({}.hasOwnProperty);n.exports=Object.hasOwn||function(n,e){return a(r(n),e)}},function(n,e,t){var i=t(0),r=t(55),a=r.all;n.exports=r.IS_HTMLDDA?function(n){return"object"==typeof n?null!==n:i(n)||n===a}:function(n){return"object"==typeof n?null!==n:i(n)}},function(n,e,t){var i=t(164),r=t(167);n.exports=function(n,e){var t=r(n,e);return i(t)?t:void 0}},function(n,e,t){"use strict";t.d(e,"e",(function(){return i})),t.d(e,"b",(function(){return a})),t.d(e,"j",(function(){return s})),t.d(e,"g",(function(){return l})),t.d(e,"h",(function(){return d})),t.d(e,"i",(function(){return c})),t.d(e,"c",(function(){return u})),t.d(e,"f",(function(){return p})),t.d(e,"l",(function(){return m})),t.d(e,"m",(function(){return h})),t.d(e,"d",(function(){return g})),t.d(e,"k",(function(){return b})),t.d(e,"n",(function(){return v})),t.d(e,"a",(function(){return y}));t(16);const i=/#.*$/,r=/\.(md|html)$/,a=/\/$/,s=/^[a-z]+:/i;function o(n){return decodeURI(n).replace(i,"").replace(r,"")}function l(n){return s.test(n)}function d(n){return/^mailto:/.test(n)}function c(n){return/^tel:/.test(n)}function u(n){if(l(n))return n;if(!n)return"404";const e=n.match(i),t=e?e[0]:"",r=o(n);return a.test(r)?n:r+".html"+t}function p(n,e){const t=n.hash,r=function(n){const e=n&&n.match(i);if(e)return e[0]}(e);if(r&&t!==r)return!1;return o(n.path)===o(e)}function m(n,e,t){if(l(e))return{type:"external",path:e};t&&(e=function(n,e,t){const i=n.charAt(0);if("/"===i)return n;if("?"===i||"#"===i)return e+n;const r=e.split("/");t&&r[r.length-1]||r.pop();const a=n.replace(/^\//,"").split("/");for(let n=0;n<a.length;n++){const e=a[n];".."===e?r.pop():"."!==e&&r.push(e)}""!==r[0]&&r.unshift("");return r.join("/")}(e,t));const i=o(e);for(let e=0;e<n.length;e++)if(o(n[e].regularPath)===i)return Object.assign({},n[e],{type:"page",path:u(n[e].path)});return console.error(`[vuepress] No matching page found for sidebar item "${e}"`),{}}function h(n,e,t,i){const{pages:r,themeConfig:a}=t,s=i&&a.locales&&a.locales[i]||a;if("auto"===(n.frontmatter.sidebar||s.sidebar||a.sidebar))return f(n);const o=s.sidebar||a.sidebar;if(o){const{base:t,config:i}=function(n,e){if(Array.isArray(e))return{base:"/",config:e};for(const i in e)if(0===(t=n,/(\.html|\/)$/.test(t)?t:t+"/").indexOf(encodeURI(i)))return{base:i,config:e[i]};var t;return{}}(e,o);return"auto"===i?f(n):i?i.map(n=>function n(e,t,i,r=1){if("string"==typeof e)return m(t,e,i);if(Array.isArray(e))return Object.assign(m(t,e[0],i),{title:e[1]});{r>3&&console.error("[vuepress] detected a too deep nested sidebar group.");const a=e.children||[];return 0===a.length&&e.path?Object.assign(m(t,e.path,i),{title:e.title}):{type:"group",path:e.path,title:e.title,sidebarDepth:e.sidebarDepth,initialOpenGroupIndex:e.initialOpenGroupIndex,children:a.map(e=>n(e,t,i,r+1)),collapsable:!1!==e.collapsable}}}(n,r,t)):[]}return[]}function f(n){const e=g(n.headers||[]);return[{type:"group",collapsable:!1,title:n.title,path:null,children:e.map(e=>({type:"auto",title:e.title,basePath:n.path,path:n.path+"#"+e.slug,children:e.children||[]}))}]}function g(n){let e;return(n=n.map(n=>Object.assign({},n))).forEach(n=>{2===n.level?e=n:e&&(e.children||(e.children=[])).push(n)}),n.filter(n=>2===n.level)}function b(n){return Object.assign(n,{type:n.items&&n.items.length?"links":"link"})}function v(n){return Object.prototype.toString.call(n).match(/\[object (.*?)\]/)[1].toLowerCase()}function x(n){let e=n.frontmatter.date||n.lastUpdated||new Date,t=new Date(e);return"Invalid Date"==t&&e&&(t=new Date(e.replace(/-/g,"/"))),t.getTime()}function y(n,e){return x(e)-x(n)}},function(n,e){n.exports=function(n){return null!=n&&"object"==typeof n}},function(n,e,t){var i=t(15),r=t(149),a=t(150),s=i?i.toStringTag:void 0;n.exports=function(n){return null==n?void 0===n?"[object Undefined]":"[object Null]":s&&s in Object(n)?r(n):a(n)}},function(n,e,t){var i=t(4),r=t(17),a=t(35);n.exports=i?function(n,e,t){return r.f(n,e,a(1,t))}:function(n,e,t){return n[e]=t,n}},function(n,e,t){var i=t(6).Symbol;n.exports=i},function(n,e,t){"use strict";var i=t(26),r=t(32),a=t(33),s=t(128),o=t(130);i({target:"Array",proto:!0,arity:1,forced:t(3)((function(){return 4294967297!==[].push.call({length:4294967296},1)}))||!function(){try{Object.defineProperty([],"length",{writable:!1}).push()}catch(n){return n instanceof TypeError}}()},{push:function(n){var e=r(this),t=a(e),i=arguments.length;o(t+i);for(var l=0;l<i;l++)e[t]=arguments[l],t++;return s(e,t),t}})},function(n,e,t){var i=t(4),r=t(64),a=t(99),s=t(25),o=t(54),l=TypeError,d=Object.defineProperty,c=Object.getOwnPropertyDescriptor;e.f=i?a?function(n,e,t){if(s(n),e=o(e),s(t),"function"==typeof n&&"prototype"===e&&"value"in t&&"writable"in t&&!t.writable){var i=c(n,e);i&&i.writable&&(n[e]=t.value,t={configurable:"configurable"in t?t.configurable:i.configurable,enumerable:"enumerable"in t?t.enumerable:i.enumerable,writable:!1})}return d(n,e,t)}:d:function(n,e,t){if(s(n),e=o(e),s(t),r)try{return d(n,e,t)}catch(n){}if("get"in t||"set"in t)throw l("Accessors not supported");return"value"in t&&(n[e]=t.value),n}},function(n,e,t){var i=t(1),r=i({}.toString),a=i("".slice);n.exports=function(n){return a(r(n),8,-1)}},function(n,e,t){var i=t(154),r=t(155),a=t(156),s=t(157),o=t(158);function l(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var i=n[e];this.set(i[0],i[1])}}l.prototype.clear=i,l.prototype.delete=r,l.prototype.get=a,l.prototype.has=s,l.prototype.set=o,n.exports=l},function(n,e,t){var i=t(71);n.exports=function(n,e){for(var t=n.length;t--;)if(i(n[t][0],e))return t;return-1}},function(n,e,t){var i=t(10)(Object,"create");n.exports=i},function(n,e,t){var i=t(176);n.exports=function(n,e){var t=n.__data__;return i(e)?t["string"==typeof e?"string":"hash"]:t.map}},function(n,e,t){var i=t(45);n.exports=function(n){if("string"==typeof n||i(n))return n;var e=n+"";return"0"==e&&1/n==-1/0?"-0":e}},function(n,e,t){var i,r;
/* NProgress, (c) 2013, 2014 Rico Sta. Cruz - http://ricostacruz.com/nprogress
 * @license MIT */void 0===(r="function"==typeof(i=function(){var n,e,t={version:"0.2.0"},i=t.settings={minimum:.08,easing:"ease",positionUsing:"",speed:200,trickle:!0,trickleRate:.02,trickleSpeed:800,showSpinner:!0,barSelector:'[role="bar"]',spinnerSelector:'[role="spinner"]',parent:"body",template:'<div class="bar" role="bar"><div class="peg"></div></div><div class="spinner" role="spinner"><div class="spinner-icon"></div></div>'};function r(n,e,t){return n<e?e:n>t?t:n}function a(n){return 100*(-1+n)}t.configure=function(n){var e,t;for(e in n)void 0!==(t=n[e])&&n.hasOwnProperty(e)&&(i[e]=t);return this},t.status=null,t.set=function(n){var e=t.isStarted();n=r(n,i.minimum,1),t.status=1===n?null:n;var l=t.render(!e),d=l.querySelector(i.barSelector),c=i.speed,u=i.easing;return l.offsetWidth,s((function(e){""===i.positionUsing&&(i.positionUsing=t.getPositioningCSS()),o(d,function(n,e,t){var r;return(r="translate3d"===i.positionUsing?{transform:"translate3d("+a(n)+"%,0,0)"}:"translate"===i.positionUsing?{transform:"translate("+a(n)+"%,0)"}:{"margin-left":a(n)+"%"}).transition="all "+e+"ms "+t,r}(n,c,u)),1===n?(o(l,{transition:"none",opacity:1}),l.offsetWidth,setTimeout((function(){o(l,{transition:"all "+c+"ms linear",opacity:0}),setTimeout((function(){t.remove(),e()}),c)}),c)):setTimeout(e,c)})),this},t.isStarted=function(){return"number"==typeof t.status},t.start=function(){t.status||t.set(0);var n=function(){setTimeout((function(){t.status&&(t.trickle(),n())}),i.trickleSpeed)};return i.trickle&&n(),this},t.done=function(n){return n||t.status?t.inc(.3+.5*Math.random()).set(1):this},t.inc=function(n){var e=t.status;return e?("number"!=typeof n&&(n=(1-e)*r(Math.random()*e,.1,.95)),e=r(e+n,0,.994),t.set(e)):t.start()},t.trickle=function(){return t.inc(Math.random()*i.trickleRate)},n=0,e=0,t.promise=function(i){return i&&"resolved"!==i.state()?(0===e&&t.start(),n++,e++,i.always((function(){0==--e?(n=0,t.done()):t.set((n-e)/n)})),this):this},t.render=function(n){if(t.isRendered())return document.getElementById("nprogress");d(document.documentElement,"nprogress-busy");var e=document.createElement("div");e.id="nprogress",e.innerHTML=i.template;var r,s=e.querySelector(i.barSelector),l=n?"-100":a(t.status||0),c=document.querySelector(i.parent);return o(s,{transition:"all 0 linear",transform:"translate3d("+l+"%,0,0)"}),i.showSpinner||(r=e.querySelector(i.spinnerSelector))&&p(r),c!=document.body&&d(c,"nprogress-custom-parent"),c.appendChild(e),e},t.remove=function(){c(document.documentElement,"nprogress-busy"),c(document.querySelector(i.parent),"nprogress-custom-parent");var n=document.getElementById("nprogress");n&&p(n)},t.isRendered=function(){return!!document.getElementById("nprogress")},t.getPositioningCSS=function(){var n=document.body.style,e="WebkitTransform"in n?"Webkit":"MozTransform"in n?"Moz":"msTransform"in n?"ms":"OTransform"in n?"O":"";return e+"Perspective"in n?"translate3d":e+"Transform"in n?"translate":"margin"};var s=function(){var n=[];function e(){var t=n.shift();t&&t(e)}return function(t){n.push(t),1==n.length&&e()}}(),o=function(){var n=["Webkit","O","Moz","ms"],e={};function t(t){return t=t.replace(/^-ms-/,"ms-").replace(/-([\da-z])/gi,(function(n,e){return e.toUpperCase()})),e[t]||(e[t]=function(e){var t=document.body.style;if(e in t)return e;for(var i,r=n.length,a=e.charAt(0).toUpperCase()+e.slice(1);r--;)if((i=n[r]+a)in t)return i;return e}(t))}function i(n,e,i){e=t(e),n.style[e]=i}return function(n,e){var t,r,a=arguments;if(2==a.length)for(t in e)void 0!==(r=e[t])&&e.hasOwnProperty(t)&&i(n,t,r);else i(n,a[1],a[2])}}();function l(n,e){return("string"==typeof n?n:u(n)).indexOf(" "+e+" ")>=0}function d(n,e){var t=u(n),i=t+e;l(t,e)||(n.className=i.substring(1))}function c(n,e){var t,i=u(n);l(n,e)&&(t=i.replace(" "+e+" "," "),n.className=t.substring(1,t.length-1))}function u(n){return(" "+(n.className||"")+" ").replace(/\s+/gi," ")}function p(n){n&&n.parentNode&&n.parentNode.removeChild(n)}return t})?i.call(e,t,e,n):i)||(n.exports=r)},function(n,e,t){var i=t(9),r=String,a=TypeError;n.exports=function(n){if(i(n))return n;throw a(r(n)+" is not an object")}},function(n,e,t){var i=t(2),r=t(51).f,a=t(14),s=t(112),o=t(37),l=t(65),d=t(124);n.exports=function(n,e){var t,c,u,p,m,h=n.target,f=n.global,g=n.stat;if(t=f?i:g?i[h]||o(h,{}):(i[h]||{}).prototype)for(c in e){if(p=e[c],u=n.dontCallGetSet?(m=r(t,c))&&m.value:t[c],!d(f?c:h+(g?".":"#")+c,n.forced)&&void 0!==u){if(typeof p==typeof u)continue;l(p,u)}(n.sham||u&&u.sham)&&a(p,"sham",!0),s(t,c,p,n)}}},function(n,e,t){var i=t(3);n.exports=!i((function(){var n=function(){}.bind();return"function"!=typeof n||n.hasOwnProperty("prototype")}))},function(n,e,t){var i=t(47),r=t(52);n.exports=function(n){return i(r(n))}},function(n,e,t){var i=t(2),r=t(0),a=function(n){return r(n)?n:void 0};n.exports=function(n,e){return arguments.length<2?a(i[n]):i[n]&&i[n][e]}},function(n,e,t){var i=t(0),r=t(110),a=TypeError;n.exports=function(n){if(i(n))return n;throw a(r(n)+" is not a function")}},function(n,e,t){var i=t(2),r=t(61),a=t(8),s=t(63),o=t(59),l=t(58),d=i.Symbol,c=r("wks"),u=l?d.for||d:d&&d.withoutSetter||s;n.exports=function(n){return a(c,n)||(c[n]=o&&a(d,n)?d[n]:u("Symbol."+n)),c[n]}},function(n,e,t){var i=t(52),r=Object;n.exports=function(n){return r(i(n))}},function(n,e,t){var i=t(122);n.exports=function(n){return i(n.length)}},function(n,e,t){var i=t(27),r=Function.prototype.call;n.exports=i?r.bind(r):function(){return r.apply(r,arguments)}},function(n,e){n.exports=function(n,e){return{enumerable:!(1&n),configurable:!(2&n),writable:!(4&n),value:e}}},function(n,e,t){var i=t(2),r=t(37),a=i["__core-js_shared__"]||r("__core-js_shared__",{});n.exports=a},function(n,e,t){var i=t(2),r=Object.defineProperty;n.exports=function(n,e){try{r(i,n,{value:e,configurable:!0,writable:!0})}catch(t){i[n]=e}return e}},function(n,e,t){var i=t(148),r=t(12),a=Object.prototype,s=a.hasOwnProperty,o=a.propertyIsEnumerable,l=i(function(){return arguments}())?i:function(n){return r(n)&&s.call(n,"callee")&&!o.call(n,"callee")};n.exports=l},function(n,e,t){var i=t(10)(t(6),"Map");n.exports=i},function(n,e){n.exports=function(n){var e=typeof n;return null!=n&&("object"==e||"function"==e)}},function(n,e,t){var i=t(168),r=t(175),a=t(177),s=t(178),o=t(179);function l(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var i=n[e];this.set(i[0],i[1])}}l.prototype.clear=i,l.prototype.delete=r,l.prototype.get=a,l.prototype.has=s,l.prototype.set=o,n.exports=l},function(n,e){n.exports=function(n){var e=-1,t=Array(n.size);return n.forEach((function(n){t[++e]=n})),t}},function(n,e){n.exports=function(n){return"number"==typeof n&&n>-1&&n%1==0&&n<=9007199254740991}},function(n,e,t){var i=t(5),r=t(45),a=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,s=/^\w*$/;n.exports=function(n,e){if(i(n))return!1;var t=typeof n;return!("number"!=t&&"symbol"!=t&&"boolean"!=t&&null!=n&&!r(n))||(s.test(n)||!a.test(n)||null!=e&&n in Object(e))}},function(n,e,t){var i=t(13),r=t(12);n.exports=function(n){return"symbol"==typeof n||r(n)&&"[object Symbol]"==i(n)}},function(n,e){n.exports=function(n){return n}},function(n,e,t){var i=t(1),r=t(3),a=t(18),s=Object,o=i("".split);n.exports=r((function(){return!s("z").propertyIsEnumerable(0)}))?function(n){return"String"==a(n)?o(n,""):s(n)}:s},function(n,e){n.exports={}},function(n,e){n.exports=function(n){return n.webpackPolyfill||(n.deprecate=function(){},n.paths=[],n.children||(n.children=[]),Object.defineProperty(n,"loaded",{enumerable:!0,get:function(){return n.l}}),Object.defineProperty(n,"id",{enumerable:!0,get:function(){return n.i}}),n.webpackPolyfill=1),n}},function(n,e){var t=/^\s+|\s+$/g,i=/^[-+]0x[0-9a-f]+$/i,r=/^0b[01]+$/i,a=/^0o[0-7]+$/i,s=parseInt,o="object"==typeof global&&global&&global.Object===Object&&global,l="object"==typeof self&&self&&self.Object===Object&&self,d=o||l||Function("return this")(),c=Object.prototype.toString,u=Math.max,p=Math.min,m=function(){return d.Date.now()};function h(n){var e=typeof n;return!!n&&("object"==e||"function"==e)}function f(n){if("number"==typeof n)return n;if(function(n){return"symbol"==typeof n||function(n){return!!n&&"object"==typeof n}(n)&&"[object Symbol]"==c.call(n)}(n))return NaN;if(h(n)){var e="function"==typeof n.valueOf?n.valueOf():n;n=h(e)?e+"":e}if("string"!=typeof n)return 0===n?n:+n;n=n.replace(t,"");var o=r.test(n);return o||a.test(n)?s(n.slice(2),o?2:8):i.test(n)?NaN:+n}n.exports=function(n,e,t){var i,r,a,s,o,l,d=0,c=!1,g=!1,b=!0;if("function"!=typeof n)throw new TypeError("Expected a function");function v(e){var t=i,a=r;return i=r=void 0,d=e,s=n.apply(a,t)}function x(n){return d=n,o=setTimeout(E,e),c?v(n):s}function y(n){var t=n-l;return void 0===l||t>=e||t<0||g&&n-d>=a}function E(){var n=m();if(y(n))return _(n);o=setTimeout(E,function(n){var t=e-(n-l);return g?p(t,a-(n-d)):t}(n))}function _(n){return o=void 0,b&&i?v(n):(i=r=void 0,s)}function k(){var n=m(),t=y(n);if(i=arguments,r=this,l=n,t){if(void 0===o)return x(l);if(g)return o=setTimeout(E,e),v(l)}return void 0===o&&(o=setTimeout(E,e)),s}return e=f(e)||0,h(t)&&(c=!!t.leading,a=(g="maxWait"in t)?u(f(t.maxWait)||0,e):a,b="trailing"in t?!!t.trailing:b),k.cancel=function(){void 0!==o&&clearTimeout(o),d=0,i=l=r=o=void 0},k.flush=function(){return void 0===o?s:_(m())},k}},function(n,e,t){var i=t(4),r=t(34),a=t(106),s=t(35),o=t(28),l=t(54),d=t(8),c=t(64),u=Object.getOwnPropertyDescriptor;e.f=i?u:function(n,e){if(n=o(n),e=l(e),c)try{return u(n,e)}catch(n){}if(d(n,e))return s(!r(a.f,n,e),n[e])}},function(n,e,t){var i=t(53),r=TypeError;n.exports=function(n){if(i(n))throw r("Can't call method on "+n);return n}},function(n,e){n.exports=function(n){return null==n}},function(n,e,t){var i=t(107),r=t(56);n.exports=function(n){var e=i(n,"string");return r(e)?e:e+""}},function(n,e){var t="object"==typeof document&&document.all,i=void 0===t&&void 0!==t;n.exports={all:t,IS_HTMLDDA:i}},function(n,e,t){var i=t(29),r=t(0),a=t(57),s=t(58),o=Object;n.exports=s?function(n){return"symbol"==typeof n}:function(n){var e=i("Symbol");return r(e)&&a(e.prototype,o(n))}},function(n,e,t){var i=t(1);n.exports=i({}.isPrototypeOf)},function(n,e,t){var i=t(59);n.exports=i&&!Symbol.sham&&"symbol"==typeof Symbol.iterator},function(n,e,t){var i=t(60),r=t(3),a=t(2).String;n.exports=!!Object.getOwnPropertySymbols&&!r((function(){var n=Symbol();return!a(n)||!(Object(n)instanceof Symbol)||!Symbol.sham&&i&&i<41}))},function(n,e,t){var i,r,a=t(2),s=t(108),o=a.process,l=a.Deno,d=o&&o.versions||l&&l.version,c=d&&d.v8;c&&(r=(i=c.split("."))[0]>0&&i[0]<4?1:+(i[0]+i[1])),!r&&s&&(!(i=s.match(/Edge\/(\d+)/))||i[1]>=74)&&(i=s.match(/Chrome\/(\d+)/))&&(r=+i[1]),n.exports=r},function(n,e,t){var i=t(62),r=t(36);(n.exports=function(n,e){return r[n]||(r[n]=void 0!==e?e:{})})("versions",[]).push({version:"3.31.0",mode:i?"pure":"global",copyright:"© 2014-2023 Denis Pushkarev (zloirock.ru)",license:"https://github.com/zloirock/core-js/blob/v3.31.0/LICENSE",source:"https://github.com/zloirock/core-js"})},function(n,e){n.exports=!1},function(n,e,t){var i=t(1),r=0,a=Math.random(),s=i(1..toString);n.exports=function(n){return"Symbol("+(void 0===n?"":n)+")_"+s(++r+a,36)}},function(n,e,t){var i=t(4),r=t(3),a=t(98);n.exports=!i&&!r((function(){return 7!=Object.defineProperty(a("div"),"a",{get:function(){return 7}}).a}))},function(n,e,t){var i=t(8),r=t(117),a=t(51),s=t(17);n.exports=function(n,e,t){for(var o=r(e),l=s.f,d=a.f,c=0;c<o.length;c++){var u=o[c];i(n,u)||t&&i(t,u)||l(n,u,d(e,u))}}},function(n,e,t){var i=t(121);n.exports=function(n){var e=+n;return e!=e||0===e?0:i(e)}},function(n,e,t){var i=t(134),r=t(25),a=t(135);n.exports=Object.setPrototypeOf||("__proto__"in{}?function(){var n,e=!1,t={};try{(n=i(Object.prototype,"__proto__","set"))(t,[]),e=t instanceof Array}catch(n){}return function(t,i){return r(t),a(i),e?n(t,i):t.__proto__=i,t}}():void 0)},function(n,e){n.exports=function(n,e){for(var t=-1,i=e.length,r=n.length;++t<i;)n[r+t]=e[t];return n}},function(n,e){var t="object"==typeof global&&global&&global.Object===Object&&global;n.exports=t},function(n,e,t){var i=t(19),r=t(159),a=t(160),s=t(161),o=t(162),l=t(163);function d(n){var e=this.__data__=new i(n);this.size=e.size}d.prototype.clear=r,d.prototype.delete=a,d.prototype.get=s,d.prototype.has=o,d.prototype.set=l,n.exports=d},function(n,e){n.exports=function(n,e){return n===e||n!=n&&e!=e}},function(n,e,t){var i=t(13),r=t(40);n.exports=function(n){if(!r(n))return!1;var e=i(n);return"[object Function]"==e||"[object GeneratorFunction]"==e||"[object AsyncFunction]"==e||"[object Proxy]"==e}},function(n,e){var t=Function.prototype.toString;n.exports=function(n){if(null!=n){try{return t.call(n)}catch(n){}try{return n+""}catch(n){}}return""}},function(n,e,t){var i=t(180),r=t(12);n.exports=function n(e,t,a,s,o){return e===t||(null==e||null==t||!r(e)&&!r(t)?e!=e&&t!=t:i(e,t,a,s,n,o))}},function(n,e,t){var i=t(76),r=t(183),a=t(77);n.exports=function(n,e,t,s,o,l){var d=1&t,c=n.length,u=e.length;if(c!=u&&!(d&&u>c))return!1;var p=l.get(n),m=l.get(e);if(p&&m)return p==e&&m==n;var h=-1,f=!0,g=2&t?new i:void 0;for(l.set(n,e),l.set(e,n);++h<c;){var b=n[h],v=e[h];if(s)var x=d?s(v,b,h,e,n,l):s(b,v,h,n,e,l);if(void 0!==x){if(x)continue;f=!1;break}if(g){if(!r(e,(function(n,e){if(!a(g,e)&&(b===n||o(b,n,t,s,l)))return g.push(e)}))){f=!1;break}}else if(b!==v&&!o(b,v,t,s,l)){f=!1;break}}return l.delete(n),l.delete(e),f}},function(n,e,t){var i=t(41),r=t(181),a=t(182);function s(n){var e=-1,t=null==n?0:n.length;for(this.__data__=new i;++e<t;)this.add(n[e])}s.prototype.add=s.prototype.push=r,s.prototype.has=a,n.exports=s},function(n,e){n.exports=function(n,e){return n.has(e)}},function(n,e,t){var i=t(193),r=t(199),a=t(82);n.exports=function(n){return a(n)?i(n):r(n)}},function(n,e,t){(function(n){var i=t(6),r=t(195),a=e&&!e.nodeType&&e,s=a&&"object"==typeof n&&n&&!n.nodeType&&n,o=s&&s.exports===a?i.Buffer:void 0,l=(o?o.isBuffer:void 0)||r;n.exports=l}).call(this,t(49)(n))},function(n,e){var t=/^(?:0|[1-9]\d*)$/;n.exports=function(n,e){var i=typeof n;return!!(e=null==e?9007199254740991:e)&&("number"==i||"symbol"!=i&&t.test(n))&&n>-1&&n%1==0&&n<e}},function(n,e,t){var i=t(196),r=t(197),a=t(198),s=a&&a.isTypedArray,o=s?r(s):i;n.exports=o},function(n,e,t){var i=t(72),r=t(43);n.exports=function(n){return null!=n&&r(n.length)&&!i(n)}},function(n,e,t){var i=t(10)(t(6),"Set");n.exports=i},function(n,e,t){var i=t(40);n.exports=function(n){return n==n&&!i(n)}},function(n,e){n.exports=function(n,e){return function(t){return null!=t&&(t[n]===e&&(void 0!==e||n in Object(t)))}}},function(n,e,t){var i=t(87),r=t(23);n.exports=function(n,e){for(var t=0,a=(e=i(e,n)).length;null!=n&&t<a;)n=n[r(e[t++])];return t&&t==a?n:void 0}},function(n,e,t){var i=t(5),r=t(44),a=t(210),s=t(213);n.exports=function(n,e){return i(n)?n:r(n,e)?[n]:a(s(n))}},function(n,e){},function(n,e,t){},function(n,e,t){},function(n,e,t){},function(n,e,t){},function(n,e,t){var i=t(146),r=t(151),a=t(222),s=t(230),o=t(239),l=t(103),d=a((function(n){var e=l(n);return o(e)&&(e=void 0),s(i(n,1,o,!0),r(e,2))}));n.exports=d},function(n,e,t){"use strict";
/*!
 * escape-html
 * Copyright(c) 2012-2013 TJ Holowaychuk
 * Copyright(c) 2015 Andreas Lubbe
 * Copyright(c) 2015 Tiancheng "Timothy" Gu
 * MIT Licensed
 */var i=/["'&<>]/;n.exports=function(n){var e,t=""+n,r=i.exec(t);if(!r)return t;var a="",s=0,o=0;for(s=r.index;s<t.length;s++){switch(t.charCodeAt(s)){case 34:e="&quot;";break;case 38:e="&amp;";break;case 39:e="&#39;";break;case 60:e="&lt;";break;case 62:e="&gt;";break;default:continue}o!==s&&(a+=t.substring(o,s)),o=s+1,a+=e}return o!==s?a+t.substring(o,s):a}},function(n,e,t){"use strict";t.r(e);var i={name:"CodeBlock",props:{title:{type:String,required:!0},active:{type:Boolean,default:!1}}},r=(t(242),t(7)),a=Object(r.a)(i,(function(){return(0,this._self._c)("div",{staticClass:"theme-code-block",class:{"theme-code-block__active":this.active}},[this._t("default")],2)}),[],!1,null,"4f1e9d0c",null);e.default=a.exports},function(n,e,t){"use strict";t.r(e);var i={name:"CodeGroup",data:()=>({codeTabs:[],activeCodeTabIndex:-1}),watch:{activeCodeTabIndex(n){this.codeTabs.forEach(n=>{n.elm.classList.remove("theme-code-block__active")}),this.codeTabs[n].elm.classList.add("theme-code-block__active")}},mounted(){this.codeTabs=(this.$slots.default||[]).filter(n=>Boolean(n.componentOptions)).map((n,e)=>(""===n.componentOptions.propsData.active&&(this.activeCodeTabIndex=e),{title:n.componentOptions.propsData.title,elm:n.elm})),-1===this.activeCodeTabIndex&&this.codeTabs.length>0&&(this.activeCodeTabIndex=0)},methods:{changeCodeTab(n){this.activeCodeTabIndex=n}}},r=(t(243),t(7)),a=Object(r.a)(i,(function(){var n=this,e=n._self._c;return e("div",{staticClass:"theme-code-group"},[e("div",{staticClass:"theme-code-group__nav"},[e("ul",{staticClass:"theme-code-group__ul"},n._l(n.codeTabs,(function(t,i){return e("li",{key:t.title,staticClass:"theme-code-group__li"},[e("button",{staticClass:"theme-code-group__nav-tab",class:{"theme-code-group__nav-tab-active":i===n.activeCodeTabIndex},on:{click:function(e){return n.changeCodeTab(i)}}},[n._v("\n            "+n._s(t.title)+"\n          ")])])})),0)]),n._v(" "),n._t("default"),n._v(" "),n.codeTabs.length<1?e("pre",{staticClass:"pre-blank"},[n._v("// Make sure to add code blocks to your code group")]):n._e()],2)}),[],!1,null,"2f5f1757",null);e.default=a.exports},function(n,e){n.exports=["constructor","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","toLocaleString","toString","valueOf"]},function(n,e,t){var i=t(2),r=t(9),a=i.document,s=r(a)&&r(a.createElement);n.exports=function(n){return s?a.createElement(n):{}}},function(n,e,t){var i=t(4),r=t(3);n.exports=i&&r((function(){return 42!=Object.defineProperty((function(){}),"prototype",{value:42,writable:!1}).prototype}))},function(n,e,t){var i=t(1),r=t(3),a=t(0),s=t(8),o=t(4),l=t(113).CONFIGURABLE,d=t(114),c=t(115),u=c.enforce,p=c.get,m=String,h=Object.defineProperty,f=i("".slice),g=i("".replace),b=i([].join),v=o&&!r((function(){return 8!==h((function(){}),"length",{value:8}).length})),x=String(String).split("String"),y=n.exports=function(n,e,t){"Symbol("===f(m(e),0,7)&&(e="["+g(m(e),/^Symbol\(([^)]*)\)/,"$1")+"]"),t&&t.getter&&(e="get "+e),t&&t.setter&&(e="set "+e),(!s(n,"name")||l&&n.name!==e)&&(o?h(n,"name",{value:e,configurable:!0}):n.name=e),v&&t&&s(t,"arity")&&n.length!==t.arity&&h(n,"length",{value:t.arity});try{t&&s(t,"constructor")&&t.constructor?o&&h(n,"prototype",{writable:!1}):n.prototype&&(n.prototype=void 0)}catch(n){}var i=u(n);return s(i,"source")||(i.source=b(x,"string"==typeof e?e:"")),n};Function.prototype.toString=y((function(){return a(this)&&p(this).source||d(this)}),"toString")},function(n,e,t){var i=t(61),r=t(63),a=i("keys");n.exports=function(n){return a[n]||(a[n]=r(n))}},function(n,e,t){var i=t(1),r=t(8),a=t(28),s=t(119).indexOf,o=t(48),l=i([].push);n.exports=function(n,e){var t,i=a(n),d=0,c=[];for(t in i)!r(o,t)&&r(i,t)&&l(c,t);for(;e.length>d;)r(i,t=e[d++])&&(~s(c,t)||l(c,t));return c}},function(n,e){n.exports=function(n){var e=null==n?0:n.length;return e?n[e-1]:void 0}},function(n,e,t){n.exports=t(248)},function(n,e,t){"use strict";var i=t(26),r=t(125).left,a=t(126),s=t(60);i({target:"Array",proto:!0,forced:!t(127)&&s>79&&s<83||!a("reduce")},{reduce:function(n){var e=arguments.length;return r(this,n,e,e>1?arguments[1]:void 0)}})},function(n,e,t){"use strict";var i={}.propertyIsEnumerable,r=Object.getOwnPropertyDescriptor,a=r&&!i.call({1:2},1);e.f=a?function(n){var e=r(this,n);return!!e&&e.enumerable}:i},function(n,e,t){var i=t(34),r=t(9),a=t(56),s=t(109),o=t(111),l=t(31),d=TypeError,c=l("toPrimitive");n.exports=function(n,e){if(!r(n)||a(n))return n;var t,l=s(n,c);if(l){if(void 0===e&&(e="default"),t=i(l,n,e),!r(t)||a(t))return t;throw d("Can't convert object to primitive value")}return void 0===e&&(e="number"),o(n,e)}},function(n,e){n.exports="undefined"!=typeof navigator&&String(navigator.userAgent)||""},function(n,e,t){var i=t(30),r=t(53);n.exports=function(n,e){var t=n[e];return r(t)?void 0:i(t)}},function(n,e){var t=String;n.exports=function(n){try{return t(n)}catch(n){return"Object"}}},function(n,e,t){var i=t(34),r=t(0),a=t(9),s=TypeError;n.exports=function(n,e){var t,o;if("string"===e&&r(t=n.toString)&&!a(o=i(t,n)))return o;if(r(t=n.valueOf)&&!a(o=i(t,n)))return o;if("string"!==e&&r(t=n.toString)&&!a(o=i(t,n)))return o;throw s("Can't convert object to primitive value")}},function(n,e,t){var i=t(0),r=t(17),a=t(100),s=t(37);n.exports=function(n,e,t,o){o||(o={});var l=o.enumerable,d=void 0!==o.name?o.name:e;if(i(t)&&a(t,d,o),o.global)l?n[e]=t:s(e,t);else{try{o.unsafe?n[e]&&(l=!0):delete n[e]}catch(n){}l?n[e]=t:r.f(n,e,{value:t,enumerable:!1,configurable:!o.nonConfigurable,writable:!o.nonWritable})}return n}},function(n,e,t){var i=t(4),r=t(8),a=Function.prototype,s=i&&Object.getOwnPropertyDescriptor,o=r(a,"name"),l=o&&"something"===function(){}.name,d=o&&(!i||i&&s(a,"name").configurable);n.exports={EXISTS:o,PROPER:l,CONFIGURABLE:d}},function(n,e,t){var i=t(1),r=t(0),a=t(36),s=i(Function.toString);r(a.inspectSource)||(a.inspectSource=function(n){return s(n)}),n.exports=a.inspectSource},function(n,e,t){var i,r,a,s=t(116),o=t(2),l=t(9),d=t(14),c=t(8),u=t(36),p=t(101),m=t(48),h=o.TypeError,f=o.WeakMap;if(s||u.state){var g=u.state||(u.state=new f);g.get=g.get,g.has=g.has,g.set=g.set,i=function(n,e){if(g.has(n))throw h("Object already initialized");return e.facade=n,g.set(n,e),e},r=function(n){return g.get(n)||{}},a=function(n){return g.has(n)}}else{var b=p("state");m[b]=!0,i=function(n,e){if(c(n,b))throw h("Object already initialized");return e.facade=n,d(n,b,e),e},r=function(n){return c(n,b)?n[b]:{}},a=function(n){return c(n,b)}}n.exports={set:i,get:r,has:a,enforce:function(n){return a(n)?r(n):i(n,{})},getterFor:function(n){return function(e){var t;if(!l(e)||(t=r(e)).type!==n)throw h("Incompatible receiver, "+n+" required");return t}}}},function(n,e,t){var i=t(2),r=t(0),a=i.WeakMap;n.exports=r(a)&&/native code/.test(String(a))},function(n,e,t){var i=t(29),r=t(1),a=t(118),s=t(123),o=t(25),l=r([].concat);n.exports=i("Reflect","ownKeys")||function(n){var e=a.f(o(n)),t=s.f;return t?l(e,t(n)):e}},function(n,e,t){var i=t(102),r=t(97).concat("length","prototype");e.f=Object.getOwnPropertyNames||function(n){return i(n,r)}},function(n,e,t){var i=t(28),r=t(120),a=t(33),s=function(n){return function(e,t,s){var o,l=i(e),d=a(l),c=r(s,d);if(n&&t!=t){for(;d>c;)if((o=l[c++])!=o)return!0}else for(;d>c;c++)if((n||c in l)&&l[c]===t)return n||c||0;return!n&&-1}};n.exports={includes:s(!0),indexOf:s(!1)}},function(n,e,t){var i=t(66),r=Math.max,a=Math.min;n.exports=function(n,e){var t=i(n);return t<0?r(t+e,0):a(t,e)}},function(n,e){var t=Math.ceil,i=Math.floor;n.exports=Math.trunc||function(n){var e=+n;return(e>0?i:t)(e)}},function(n,e,t){var i=t(66),r=Math.min;n.exports=function(n){return n>0?r(i(n),9007199254740991):0}},function(n,e){e.f=Object.getOwnPropertySymbols},function(n,e,t){var i=t(3),r=t(0),a=/#|\.prototype\./,s=function(n,e){var t=l[o(n)];return t==c||t!=d&&(r(e)?i(e):!!e)},o=s.normalize=function(n){return String(n).replace(a,".").toLowerCase()},l=s.data={},d=s.NATIVE="N",c=s.POLYFILL="P";n.exports=s},function(n,e,t){var i=t(30),r=t(32),a=t(47),s=t(33),o=TypeError,l=function(n){return function(e,t,l,d){i(t);var c=r(e),u=a(c),p=s(c),m=n?p-1:0,h=n?-1:1;if(l<2)for(;;){if(m in u){d=u[m],m+=h;break}if(m+=h,n?m<0:p<=m)throw o("Reduce of empty array with no initial value")}for(;n?m>=0:p>m;m+=h)m in u&&(d=t(d,u[m],m,c));return d}};n.exports={left:l(!1),right:l(!0)}},function(n,e,t){"use strict";var i=t(3);n.exports=function(n,e){var t=[][n];return!!t&&i((function(){t.call(null,e||function(){return 1},1)}))}},function(n,e,t){var i=t(18);n.exports="undefined"!=typeof process&&"process"==i(process)},function(n,e,t){"use strict";var i=t(4),r=t(129),a=TypeError,s=Object.getOwnPropertyDescriptor,o=i&&!function(){if(void 0!==this)return!0;try{Object.defineProperty([],"length",{writable:!1}).length=1}catch(n){return n instanceof TypeError}}();n.exports=o?function(n,e){if(r(n)&&!s(n,"length").writable)throw a("Cannot set read only .length");return n.length=e}:function(n,e){return n.length=e}},function(n,e,t){var i=t(18);n.exports=Array.isArray||function(n){return"Array"==i(n)}},function(n,e){var t=TypeError;n.exports=function(n){if(n>9007199254740991)throw t("Maximum allowed index exceeded");return n}},function(n,e,t){var i=t(26),r=t(2),a=t(132),s=t(133),o=r.WebAssembly,l=7!==Error("e",{cause:7}).cause,d=function(n,e){var t={};t[n]=s(n,e,l),i({global:!0,constructor:!0,arity:1,forced:l},t)},c=function(n,e){if(o&&o[n]){var t={};t[n]=s("WebAssembly."+n,e,l),i({target:"WebAssembly",stat:!0,constructor:!0,arity:1,forced:l},t)}};d("Error",(function(n){return function(e){return a(n,this,arguments)}})),d("EvalError",(function(n){return function(e){return a(n,this,arguments)}})),d("RangeError",(function(n){return function(e){return a(n,this,arguments)}})),d("ReferenceError",(function(n){return function(e){return a(n,this,arguments)}})),d("SyntaxError",(function(n){return function(e){return a(n,this,arguments)}})),d("TypeError",(function(n){return function(e){return a(n,this,arguments)}})),d("URIError",(function(n){return function(e){return a(n,this,arguments)}})),c("CompileError",(function(n){return function(e){return a(n,this,arguments)}})),c("LinkError",(function(n){return function(e){return a(n,this,arguments)}})),c("RuntimeError",(function(n){return function(e){return a(n,this,arguments)}}))},function(n,e,t){var i=t(27),r=Function.prototype,a=r.apply,s=r.call;n.exports="object"==typeof Reflect&&Reflect.apply||(i?s.bind(a):function(){return s.apply(a,arguments)})},function(n,e,t){"use strict";var i=t(29),r=t(8),a=t(14),s=t(57),o=t(67),l=t(65),d=t(136),c=t(137),u=t(138),p=t(142),m=t(143),h=t(4),f=t(62);n.exports=function(n,e,t,g){var b=g?2:1,v=n.split("."),x=v[v.length-1],y=i.apply(null,v);if(y){var E=y.prototype;if(!f&&r(E,"cause")&&delete E.cause,!t)return y;var _=i("Error"),k=e((function(n,e){var t=u(g?e:n,void 0),i=g?new y(n):new y;return void 0!==t&&a(i,"message",t),m(i,k,i.stack,2),this&&s(E,this)&&c(i,this,k),arguments.length>b&&p(i,arguments[b]),i}));if(k.prototype=E,"Error"!==x?o?o(k,_):l(k,_,{name:!0}):h&&"stackTraceLimit"in y&&(d(k,y,"stackTraceLimit"),d(k,y,"prepareStackTrace")),l(k,y),!f)try{E.name!==x&&a(E,"name",x),E.constructor=k}catch(n){}return k}}},function(n,e,t){var i=t(1),r=t(30);n.exports=function(n,e,t){try{return i(r(Object.getOwnPropertyDescriptor(n,e)[t]))}catch(n){}}},function(n,e,t){var i=t(0),r=String,a=TypeError;n.exports=function(n){if("object"==typeof n||i(n))return n;throw a("Can't set "+r(n)+" as a prototype")}},function(n,e,t){var i=t(17).f;n.exports=function(n,e,t){t in n||i(n,t,{configurable:!0,get:function(){return e[t]},set:function(n){e[t]=n}})}},function(n,e,t){var i=t(0),r=t(9),a=t(67);n.exports=function(n,e,t){var s,o;return a&&i(s=e.constructor)&&s!==t&&r(o=s.prototype)&&o!==t.prototype&&a(n,o),n}},function(n,e,t){var i=t(139);n.exports=function(n,e){return void 0===n?arguments.length<2?"":e:i(n)}},function(n,e,t){var i=t(140),r=String;n.exports=function(n){if("Symbol"===i(n))throw TypeError("Cannot convert a Symbol value to a string");return r(n)}},function(n,e,t){var i=t(141),r=t(0),a=t(18),s=t(31)("toStringTag"),o=Object,l="Arguments"==a(function(){return arguments}());n.exports=i?a:function(n){var e,t,i;return void 0===n?"Undefined":null===n?"Null":"string"==typeof(t=function(n,e){try{return n[e]}catch(n){}}(e=o(n),s))?t:l?a(e):"Object"==(i=a(e))&&r(e.callee)?"Arguments":i}},function(n,e,t){var i={};i[t(31)("toStringTag")]="z",n.exports="[object z]"===String(i)},function(n,e,t){var i=t(9),r=t(14);n.exports=function(n,e){i(e)&&"cause"in e&&r(n,"cause",e.cause)}},function(n,e,t){var i=t(14),r=t(144),a=t(145),s=Error.captureStackTrace;n.exports=function(n,e,t,o){a&&(s?s(n,e):i(n,"stack",r(t,o)))}},function(n,e,t){var i=t(1),r=Error,a=i("".replace),s=String(r("zxcasd").stack),o=/\n\s*at [^:]*:[^\n]*/,l=o.test(s);n.exports=function(n,e){if(l&&"string"==typeof n&&!r.prepareStackTrace)for(;e--;)n=a(n,o,"");return n}},function(n,e,t){var i=t(3),r=t(35);n.exports=!i((function(){var n=Error("a");return!("stack"in n)||(Object.defineProperty(n,"stack",r(1,7)),7!==n.stack)}))},function(n,e,t){var i=t(68),r=t(147);n.exports=function n(e,t,a,s,o){var l=-1,d=e.length;for(a||(a=r),o||(o=[]);++l<d;){var c=e[l];t>0&&a(c)?t>1?n(c,t-1,a,s,o):i(o,c):s||(o[o.length]=c)}return o}},function(n,e,t){var i=t(15),r=t(38),a=t(5),s=i?i.isConcatSpreadable:void 0;n.exports=function(n){return a(n)||r(n)||!!(s&&n&&n[s])}},function(n,e,t){var i=t(13),r=t(12);n.exports=function(n){return r(n)&&"[object Arguments]"==i(n)}},function(n,e,t){var i=t(15),r=Object.prototype,a=r.hasOwnProperty,s=r.toString,o=i?i.toStringTag:void 0;n.exports=function(n){var e=a.call(n,o),t=n[o];try{n[o]=void 0;var i=!0}catch(n){}var r=s.call(n);return i&&(e?n[o]=t:delete n[o]),r}},function(n,e){var t=Object.prototype.toString;n.exports=function(n){return t.call(n)}},function(n,e,t){var i=t(152),r=t(208),a=t(46),s=t(5),o=t(219);n.exports=function(n){return"function"==typeof n?n:null==n?a:"object"==typeof n?s(n)?r(n[0],n[1]):i(n):o(n)}},function(n,e,t){var i=t(153),r=t(207),a=t(85);n.exports=function(n){var e=r(n);return 1==e.length&&e[0][2]?a(e[0][0],e[0][1]):function(t){return t===n||i(t,n,e)}}},function(n,e,t){var i=t(70),r=t(74);n.exports=function(n,e,t,a){var s=t.length,o=s,l=!a;if(null==n)return!o;for(n=Object(n);s--;){var d=t[s];if(l&&d[2]?d[1]!==n[d[0]]:!(d[0]in n))return!1}for(;++s<o;){var c=(d=t[s])[0],u=n[c],p=d[1];if(l&&d[2]){if(void 0===u&&!(c in n))return!1}else{var m=new i;if(a)var h=a(u,p,c,n,e,m);if(!(void 0===h?r(p,u,3,a,m):h))return!1}}return!0}},function(n,e){n.exports=function(){this.__data__=[],this.size=0}},function(n,e,t){var i=t(20),r=Array.prototype.splice;n.exports=function(n){var e=this.__data__,t=i(e,n);return!(t<0)&&(t==e.length-1?e.pop():r.call(e,t,1),--this.size,!0)}},function(n,e,t){var i=t(20);n.exports=function(n){var e=this.__data__,t=i(e,n);return t<0?void 0:e[t][1]}},function(n,e,t){var i=t(20);n.exports=function(n){return i(this.__data__,n)>-1}},function(n,e,t){var i=t(20);n.exports=function(n,e){var t=this.__data__,r=i(t,n);return r<0?(++this.size,t.push([n,e])):t[r][1]=e,this}},function(n,e,t){var i=t(19);n.exports=function(){this.__data__=new i,this.size=0}},function(n,e){n.exports=function(n){var e=this.__data__,t=e.delete(n);return this.size=e.size,t}},function(n,e){n.exports=function(n){return this.__data__.get(n)}},function(n,e){n.exports=function(n){return this.__data__.has(n)}},function(n,e,t){var i=t(19),r=t(39),a=t(41);n.exports=function(n,e){var t=this.__data__;if(t instanceof i){var s=t.__data__;if(!r||s.length<199)return s.push([n,e]),this.size=++t.size,this;t=this.__data__=new a(s)}return t.set(n,e),this.size=t.size,this}},function(n,e,t){var i=t(72),r=t(165),a=t(40),s=t(73),o=/^\[object .+?Constructor\]$/,l=Function.prototype,d=Object.prototype,c=l.toString,u=d.hasOwnProperty,p=RegExp("^"+c.call(u).replace(/[\\^$.*+?()[\]{}|]/g,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$");n.exports=function(n){return!(!a(n)||r(n))&&(i(n)?p:o).test(s(n))}},function(n,e,t){var i,r=t(166),a=(i=/[^.]+$/.exec(r&&r.keys&&r.keys.IE_PROTO||""))?"Symbol(src)_1."+i:"";n.exports=function(n){return!!a&&a in n}},function(n,e,t){var i=t(6)["__core-js_shared__"];n.exports=i},function(n,e){n.exports=function(n,e){return null==n?void 0:n[e]}},function(n,e,t){var i=t(169),r=t(19),a=t(39);n.exports=function(){this.size=0,this.__data__={hash:new i,map:new(a||r),string:new i}}},function(n,e,t){var i=t(170),r=t(171),a=t(172),s=t(173),o=t(174);function l(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var i=n[e];this.set(i[0],i[1])}}l.prototype.clear=i,l.prototype.delete=r,l.prototype.get=a,l.prototype.has=s,l.prototype.set=o,n.exports=l},function(n,e,t){var i=t(21);n.exports=function(){this.__data__=i?i(null):{},this.size=0}},function(n,e){n.exports=function(n){var e=this.has(n)&&delete this.__data__[n];return this.size-=e?1:0,e}},function(n,e,t){var i=t(21),r=Object.prototype.hasOwnProperty;n.exports=function(n){var e=this.__data__;if(i){var t=e[n];return"__lodash_hash_undefined__"===t?void 0:t}return r.call(e,n)?e[n]:void 0}},function(n,e,t){var i=t(21),r=Object.prototype.hasOwnProperty;n.exports=function(n){var e=this.__data__;return i?void 0!==e[n]:r.call(e,n)}},function(n,e,t){var i=t(21);n.exports=function(n,e){var t=this.__data__;return this.size+=this.has(n)?0:1,t[n]=i&&void 0===e?"__lodash_hash_undefined__":e,this}},function(n,e,t){var i=t(22);n.exports=function(n){var e=i(this,n).delete(n);return this.size-=e?1:0,e}},function(n,e){n.exports=function(n){var e=typeof n;return"string"==e||"number"==e||"symbol"==e||"boolean"==e?"__proto__"!==n:null===n}},function(n,e,t){var i=t(22);n.exports=function(n){return i(this,n).get(n)}},function(n,e,t){var i=t(22);n.exports=function(n){return i(this,n).has(n)}},function(n,e,t){var i=t(22);n.exports=function(n,e){var t=i(this,n),r=t.size;return t.set(n,e),this.size+=t.size==r?0:1,this}},function(n,e,t){var i=t(70),r=t(75),a=t(184),s=t(187),o=t(203),l=t(5),d=t(79),c=t(81),u="[object Object]",p=Object.prototype.hasOwnProperty;n.exports=function(n,e,t,m,h,f){var g=l(n),b=l(e),v=g?"[object Array]":o(n),x=b?"[object Array]":o(e),y=(v="[object Arguments]"==v?u:v)==u,E=(x="[object Arguments]"==x?u:x)==u,_=v==x;if(_&&d(n)){if(!d(e))return!1;g=!0,y=!1}if(_&&!y)return f||(f=new i),g||c(n)?r(n,e,t,m,h,f):a(n,e,v,t,m,h,f);if(!(1&t)){var k=y&&p.call(n,"__wrapped__"),w=E&&p.call(e,"__wrapped__");if(k||w){var j=k?n.value():n,A=w?e.value():e;return f||(f=new i),h(j,A,t,m,f)}}return!!_&&(f||(f=new i),s(n,e,t,m,h,f))}},function(n,e){n.exports=function(n){return this.__data__.set(n,"__lodash_hash_undefined__"),this}},function(n,e){n.exports=function(n){return this.__data__.has(n)}},function(n,e){n.exports=function(n,e){for(var t=-1,i=null==n?0:n.length;++t<i;)if(e(n[t],t,n))return!0;return!1}},function(n,e,t){var i=t(15),r=t(185),a=t(71),s=t(75),o=t(186),l=t(42),d=i?i.prototype:void 0,c=d?d.valueOf:void 0;n.exports=function(n,e,t,i,d,u,p){switch(t){case"[object DataView]":if(n.byteLength!=e.byteLength||n.byteOffset!=e.byteOffset)return!1;n=n.buffer,e=e.buffer;case"[object ArrayBuffer]":return!(n.byteLength!=e.byteLength||!u(new r(n),new r(e)));case"[object Boolean]":case"[object Date]":case"[object Number]":return a(+n,+e);case"[object Error]":return n.name==e.name&&n.message==e.message;case"[object RegExp]":case"[object String]":return n==e+"";case"[object Map]":var m=o;case"[object Set]":var h=1&i;if(m||(m=l),n.size!=e.size&&!h)return!1;var f=p.get(n);if(f)return f==e;i|=2,p.set(n,e);var g=s(m(n),m(e),i,d,u,p);return p.delete(n),g;case"[object Symbol]":if(c)return c.call(n)==c.call(e)}return!1}},function(n,e,t){var i=t(6).Uint8Array;n.exports=i},function(n,e){n.exports=function(n){var e=-1,t=Array(n.size);return n.forEach((function(n,i){t[++e]=[i,n]})),t}},function(n,e,t){var i=t(188),r=Object.prototype.hasOwnProperty;n.exports=function(n,e,t,a,s,o){var l=1&t,d=i(n),c=d.length;if(c!=i(e).length&&!l)return!1;for(var u=c;u--;){var p=d[u];if(!(l?p in e:r.call(e,p)))return!1}var m=o.get(n),h=o.get(e);if(m&&h)return m==e&&h==n;var f=!0;o.set(n,e),o.set(e,n);for(var g=l;++u<c;){var b=n[p=d[u]],v=e[p];if(a)var x=l?a(v,b,p,e,n,o):a(b,v,p,n,e,o);if(!(void 0===x?b===v||s(b,v,t,a,o):x)){f=!1;break}g||(g="constructor"==p)}if(f&&!g){var y=n.constructor,E=e.constructor;y==E||!("constructor"in n)||!("constructor"in e)||"function"==typeof y&&y instanceof y&&"function"==typeof E&&E instanceof E||(f=!1)}return o.delete(n),o.delete(e),f}},function(n,e,t){var i=t(189),r=t(190),a=t(78);n.exports=function(n){return i(n,a,r)}},function(n,e,t){var i=t(68),r=t(5);n.exports=function(n,e,t){var a=e(n);return r(n)?a:i(a,t(n))}},function(n,e,t){var i=t(191),r=t(192),a=Object.prototype.propertyIsEnumerable,s=Object.getOwnPropertySymbols,o=s?function(n){return null==n?[]:(n=Object(n),i(s(n),(function(e){return a.call(n,e)})))}:r;n.exports=o},function(n,e){n.exports=function(n,e){for(var t=-1,i=null==n?0:n.length,r=0,a=[];++t<i;){var s=n[t];e(s,t,n)&&(a[r++]=s)}return a}},function(n,e){n.exports=function(){return[]}},function(n,e,t){var i=t(194),r=t(38),a=t(5),s=t(79),o=t(80),l=t(81),d=Object.prototype.hasOwnProperty;n.exports=function(n,e){var t=a(n),c=!t&&r(n),u=!t&&!c&&s(n),p=!t&&!c&&!u&&l(n),m=t||c||u||p,h=m?i(n.length,String):[],f=h.length;for(var g in n)!e&&!d.call(n,g)||m&&("length"==g||u&&("offset"==g||"parent"==g)||p&&("buffer"==g||"byteLength"==g||"byteOffset"==g)||o(g,f))||h.push(g);return h}},function(n,e){n.exports=function(n,e){for(var t=-1,i=Array(n);++t<n;)i[t]=e(t);return i}},function(n,e){n.exports=function(){return!1}},function(n,e,t){var i=t(13),r=t(43),a=t(12),s={};s["[object Float32Array]"]=s["[object Float64Array]"]=s["[object Int8Array]"]=s["[object Int16Array]"]=s["[object Int32Array]"]=s["[object Uint8Array]"]=s["[object Uint8ClampedArray]"]=s["[object Uint16Array]"]=s["[object Uint32Array]"]=!0,s["[object Arguments]"]=s["[object Array]"]=s["[object ArrayBuffer]"]=s["[object Boolean]"]=s["[object DataView]"]=s["[object Date]"]=s["[object Error]"]=s["[object Function]"]=s["[object Map]"]=s["[object Number]"]=s["[object Object]"]=s["[object RegExp]"]=s["[object Set]"]=s["[object String]"]=s["[object WeakMap]"]=!1,n.exports=function(n){return a(n)&&r(n.length)&&!!s[i(n)]}},function(n,e){n.exports=function(n){return function(e){return n(e)}}},function(n,e,t){(function(n){var i=t(69),r=e&&!e.nodeType&&e,a=r&&"object"==typeof n&&n&&!n.nodeType&&n,s=a&&a.exports===r&&i.process,o=function(){try{var n=a&&a.require&&a.require("util").types;return n||s&&s.binding&&s.binding("util")}catch(n){}}();n.exports=o}).call(this,t(49)(n))},function(n,e,t){var i=t(200),r=t(201),a=Object.prototype.hasOwnProperty;n.exports=function(n){if(!i(n))return r(n);var e=[];for(var t in Object(n))a.call(n,t)&&"constructor"!=t&&e.push(t);return e}},function(n,e){var t=Object.prototype;n.exports=function(n){var e=n&&n.constructor;return n===("function"==typeof e&&e.prototype||t)}},function(n,e,t){var i=t(202)(Object.keys,Object);n.exports=i},function(n,e){n.exports=function(n,e){return function(t){return n(e(t))}}},function(n,e,t){var i=t(204),r=t(39),a=t(205),s=t(83),o=t(206),l=t(13),d=t(73),c=d(i),u=d(r),p=d(a),m=d(s),h=d(o),f=l;(i&&"[object DataView]"!=f(new i(new ArrayBuffer(1)))||r&&"[object Map]"!=f(new r)||a&&"[object Promise]"!=f(a.resolve())||s&&"[object Set]"!=f(new s)||o&&"[object WeakMap]"!=f(new o))&&(f=function(n){var e=l(n),t="[object Object]"==e?n.constructor:void 0,i=t?d(t):"";if(i)switch(i){case c:return"[object DataView]";case u:return"[object Map]";case p:return"[object Promise]";case m:return"[object Set]";case h:return"[object WeakMap]"}return e}),n.exports=f},function(n,e,t){var i=t(10)(t(6),"DataView");n.exports=i},function(n,e,t){var i=t(10)(t(6),"Promise");n.exports=i},function(n,e,t){var i=t(10)(t(6),"WeakMap");n.exports=i},function(n,e,t){var i=t(84),r=t(78);n.exports=function(n){for(var e=r(n),t=e.length;t--;){var a=e[t],s=n[a];e[t]=[a,s,i(s)]}return e}},function(n,e,t){var i=t(74),r=t(209),a=t(216),s=t(44),o=t(84),l=t(85),d=t(23);n.exports=function(n,e){return s(n)&&o(e)?l(d(n),e):function(t){var s=r(t,n);return void 0===s&&s===e?a(t,n):i(e,s,3)}}},function(n,e,t){var i=t(86);n.exports=function(n,e,t){var r=null==n?void 0:i(n,e);return void 0===r?t:r}},function(n,e,t){var i=t(211),r=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,a=/\\(\\)?/g,s=i((function(n){var e=[];return 46===n.charCodeAt(0)&&e.push(""),n.replace(r,(function(n,t,i,r){e.push(i?r.replace(a,"$1"):t||n)})),e}));n.exports=s},function(n,e,t){var i=t(212);n.exports=function(n){var e=i(n,(function(n){return 500===t.size&&t.clear(),n})),t=e.cache;return e}},function(n,e,t){var i=t(41);function r(n,e){if("function"!=typeof n||null!=e&&"function"!=typeof e)throw new TypeError("Expected a function");var t=function(){var i=arguments,r=e?e.apply(this,i):i[0],a=t.cache;if(a.has(r))return a.get(r);var s=n.apply(this,i);return t.cache=a.set(r,s)||a,s};return t.cache=new(r.Cache||i),t}r.Cache=i,n.exports=r},function(n,e,t){var i=t(214);n.exports=function(n){return null==n?"":i(n)}},function(n,e,t){var i=t(15),r=t(215),a=t(5),s=t(45),o=i?i.prototype:void 0,l=o?o.toString:void 0;n.exports=function n(e){if("string"==typeof e)return e;if(a(e))return r(e,n)+"";if(s(e))return l?l.call(e):"";var t=e+"";return"0"==t&&1/e==-1/0?"-0":t}},function(n,e){n.exports=function(n,e){for(var t=-1,i=null==n?0:n.length,r=Array(i);++t<i;)r[t]=e(n[t],t,n);return r}},function(n,e,t){var i=t(217),r=t(218);n.exports=function(n,e){return null!=n&&r(n,e,i)}},function(n,e){n.exports=function(n,e){return null!=n&&e in Object(n)}},function(n,e,t){var i=t(87),r=t(38),a=t(5),s=t(80),o=t(43),l=t(23);n.exports=function(n,e,t){for(var d=-1,c=(e=i(e,n)).length,u=!1;++d<c;){var p=l(e[d]);if(!(u=null!=n&&t(n,p)))break;n=n[p]}return u||++d!=c?u:!!(c=null==n?0:n.length)&&o(c)&&s(p,c)&&(a(n)||r(n))}},function(n,e,t){var i=t(220),r=t(221),a=t(44),s=t(23);n.exports=function(n){return a(n)?i(s(n)):r(n)}},function(n,e){n.exports=function(n){return function(e){return null==e?void 0:e[n]}}},function(n,e,t){var i=t(86);n.exports=function(n){return function(e){return i(e,n)}}},function(n,e,t){var i=t(46),r=t(223),a=t(225);n.exports=function(n,e){return a(r(n,e,i),n+"")}},function(n,e,t){var i=t(224),r=Math.max;n.exports=function(n,e,t){return e=r(void 0===e?n.length-1:e,0),function(){for(var a=arguments,s=-1,o=r(a.length-e,0),l=Array(o);++s<o;)l[s]=a[e+s];s=-1;for(var d=Array(e+1);++s<e;)d[s]=a[s];return d[e]=t(l),i(n,this,d)}}},function(n,e){n.exports=function(n,e,t){switch(t.length){case 0:return n.call(e);case 1:return n.call(e,t[0]);case 2:return n.call(e,t[0],t[1]);case 3:return n.call(e,t[0],t[1],t[2])}return n.apply(e,t)}},function(n,e,t){var i=t(226),r=t(229)(i);n.exports=r},function(n,e,t){var i=t(227),r=t(228),a=t(46),s=r?function(n,e){return r(n,"toString",{configurable:!0,enumerable:!1,value:i(e),writable:!0})}:a;n.exports=s},function(n,e){n.exports=function(n){return function(){return n}}},function(n,e,t){var i=t(10),r=function(){try{var n=i(Object,"defineProperty");return n({},"",{}),n}catch(n){}}();n.exports=r},function(n,e){var t=Date.now;n.exports=function(n){var e=0,i=0;return function(){var r=t(),a=16-(r-i);if(i=r,a>0){if(++e>=800)return arguments[0]}else e=0;return n.apply(void 0,arguments)}}},function(n,e,t){var i=t(76),r=t(231),a=t(236),s=t(77),o=t(237),l=t(42);n.exports=function(n,e,t){var d=-1,c=r,u=n.length,p=!0,m=[],h=m;if(t)p=!1,c=a;else if(u>=200){var f=e?null:o(n);if(f)return l(f);p=!1,c=s,h=new i}else h=e?[]:m;n:for(;++d<u;){var g=n[d],b=e?e(g):g;if(g=t||0!==g?g:0,p&&b==b){for(var v=h.length;v--;)if(h[v]===b)continue n;e&&h.push(b),m.push(g)}else c(h,b,t)||(h!==m&&h.push(b),m.push(g))}return m}},function(n,e,t){var i=t(232);n.exports=function(n,e){return!!(null==n?0:n.length)&&i(n,e,0)>-1}},function(n,e,t){var i=t(233),r=t(234),a=t(235);n.exports=function(n,e,t){return e==e?a(n,e,t):i(n,r,t)}},function(n,e){n.exports=function(n,e,t,i){for(var r=n.length,a=t+(i?1:-1);i?a--:++a<r;)if(e(n[a],a,n))return a;return-1}},function(n,e){n.exports=function(n){return n!=n}},function(n,e){n.exports=function(n,e,t){for(var i=t-1,r=n.length;++i<r;)if(n[i]===e)return i;return-1}},function(n,e){n.exports=function(n,e,t){for(var i=-1,r=null==n?0:n.length;++i<r;)if(t(e,n[i]))return!0;return!1}},function(n,e,t){var i=t(83),r=t(238),a=t(42),s=i&&1/a(new i([,-0]))[1]==1/0?function(n){return new i(n)}:r;n.exports=s},function(n,e){n.exports=function(){}},function(n,e,t){var i=t(82),r=t(12);n.exports=function(n){return r(n)&&i(n)}},function(n,e,t){},function(n,e,t){},function(n,e,t){"use strict";t(89)},function(n,e,t){"use strict";t(90)},function(n,e,t){},function(n,e,t){},function(n,e,t){"use strict";t(91)},function(n,e,t){"use strict";t(92)},function(n,e,t){"use strict";t.r(e);
/*!
 * Vue.js v2.7.14
 * (c) 2014-2022 Evan You
 * Released under the MIT License.
 */
var i=Object.freeze({}),r=Array.isArray;function a(n){return null==n}function s(n){return null!=n}function o(n){return!0===n}function l(n){return"string"==typeof n||"number"==typeof n||"symbol"==typeof n||"boolean"==typeof n}function d(n){return"function"==typeof n}function c(n){return null!==n&&"object"==typeof n}var u=Object.prototype.toString;function p(n){return"[object Object]"===u.call(n)}function m(n){return"[object RegExp]"===u.call(n)}function h(n){var e=parseFloat(String(n));return e>=0&&Math.floor(e)===e&&isFinite(n)}function f(n){return s(n)&&"function"==typeof n.then&&"function"==typeof n.catch}function g(n){return null==n?"":Array.isArray(n)||p(n)&&n.toString===u?JSON.stringify(n,null,2):String(n)}function b(n){var e=parseFloat(n);return isNaN(e)?n:e}function v(n,e){for(var t=Object.create(null),i=n.split(","),r=0;r<i.length;r++)t[i[r]]=!0;return e?function(n){return t[n.toLowerCase()]}:function(n){return t[n]}}v("slot,component",!0);var x=v("key,ref,slot,slot-scope,is");function y(n,e){var t=n.length;if(t){if(e===n[t-1])return void(n.length=t-1);var i=n.indexOf(e);if(i>-1)return n.splice(i,1)}}var E=Object.prototype.hasOwnProperty;function _(n,e){return E.call(n,e)}function k(n){var e=Object.create(null);return function(t){return e[t]||(e[t]=n(t))}}var w=/-(\w)/g,j=k((function(n){return n.replace(w,(function(n,e){return e?e.toUpperCase():""}))})),A=k((function(n){return n.charAt(0).toUpperCase()+n.slice(1)})),T=/\B([A-Z])/g,C=k((function(n){return n.replace(T,"-$1").toLowerCase()}));var z=Function.prototype.bind?function(n,e){return n.bind(e)}:function(n,e){function t(t){var i=arguments.length;return i?i>1?n.apply(e,arguments):n.call(e,t):n.call(e)}return t._length=n.length,t};function B(n,e){e=e||0;for(var t=n.length-e,i=new Array(t);t--;)i[t]=n[t+e];return i}function I(n,e){for(var t in e)n[t]=e[t];return n}function S(n){for(var e={},t=0;t<n.length;t++)n[t]&&I(e,n[t]);return e}function L(n,e,t){}var P=function(n,e,t){return!1},q=function(n){return n};function N(n,e){if(n===e)return!0;var t=c(n),i=c(e);if(!t||!i)return!t&&!i&&String(n)===String(e);try{var r=Array.isArray(n),a=Array.isArray(e);if(r&&a)return n.length===e.length&&n.every((function(n,t){return N(n,e[t])}));if(n instanceof Date&&e instanceof Date)return n.getTime()===e.getTime();if(r||a)return!1;var s=Object.keys(n),o=Object.keys(e);return s.length===o.length&&s.every((function(t){return N(n[t],e[t])}))}catch(n){return!1}}function $(n,e){for(var t=0;t<n.length;t++)if(N(n[t],e))return t;return-1}function D(n){var e=!1;return function(){e||(e=!0,n.apply(this,arguments))}}function G(n,e){return n===e?0===n&&1/n!=1/e:n==n||e==e}var F=["component","directive","filter"],O=["beforeCreate","created","beforeMount","mounted","beforeUpdate","updated","beforeDestroy","destroyed","activated","deactivated","errorCaptured","serverPrefetch","renderTracked","renderTriggered"],U={optionMergeStrategies:Object.create(null),silent:!1,productionTip:!1,devtools:!1,performance:!1,errorHandler:null,warnHandler:null,ignoredElements:[],keyCodes:Object.create(null),isReservedTag:P,isReservedAttr:P,isUnknownElement:P,getTagNamespace:L,parsePlatformTagName:q,mustUseProp:P,async:!0,_lifecycleHooks:O},R=/a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD/;function M(n){var e=(n+"").charCodeAt(0);return 36===e||95===e}function H(n,e,t,i){Object.defineProperty(n,e,{value:t,enumerable:!!i,writable:!0,configurable:!0})}var V=new RegExp("[^".concat(R.source,".$_\\d]"));var Z="__proto__"in{},W="undefined"!=typeof window,K=W&&window.navigator.userAgent.toLowerCase(),X=K&&/msie|trident/.test(K),Y=K&&K.indexOf("msie 9.0")>0,J=K&&K.indexOf("edge/")>0;K&&K.indexOf("android");var Q=K&&/iphone|ipad|ipod|ios/.test(K);K&&/chrome\/\d+/.test(K),K&&/phantomjs/.test(K);var nn,en=K&&K.match(/firefox\/(\d+)/),tn={}.watch,rn=!1;if(W)try{var an={};Object.defineProperty(an,"passive",{get:function(){rn=!0}}),window.addEventListener("test-passive",null,an)}catch(n){}var sn=function(){return void 0===nn&&(nn=!W&&"undefined"!=typeof global&&(global.process&&"server"===global.process.env.VUE_ENV)),nn},on=W&&window.__VUE_DEVTOOLS_GLOBAL_HOOK__;function ln(n){return"function"==typeof n&&/native code/.test(n.toString())}var dn,cn="undefined"!=typeof Symbol&&ln(Symbol)&&"undefined"!=typeof Reflect&&ln(Reflect.ownKeys);dn="undefined"!=typeof Set&&ln(Set)?Set:function(){function n(){this.set=Object.create(null)}return n.prototype.has=function(n){return!0===this.set[n]},n.prototype.add=function(n){this.set[n]=!0},n.prototype.clear=function(){this.set=Object.create(null)},n}();var un=null;function pn(n){void 0===n&&(n=null),n||un&&un._scope.off(),un=n,n&&n._scope.on()}var mn=function(){function n(n,e,t,i,r,a,s,o){this.tag=n,this.data=e,this.children=t,this.text=i,this.elm=r,this.ns=void 0,this.context=a,this.fnContext=void 0,this.fnOptions=void 0,this.fnScopeId=void 0,this.key=e&&e.key,this.componentOptions=s,this.componentInstance=void 0,this.parent=void 0,this.raw=!1,this.isStatic=!1,this.isRootInsert=!0,this.isComment=!1,this.isCloned=!1,this.isOnce=!1,this.asyncFactory=o,this.asyncMeta=void 0,this.isAsyncPlaceholder=!1}return Object.defineProperty(n.prototype,"child",{get:function(){return this.componentInstance},enumerable:!1,configurable:!0}),n}(),hn=function(n){void 0===n&&(n="");var e=new mn;return e.text=n,e.isComment=!0,e};function fn(n){return new mn(void 0,void 0,void 0,String(n))}function gn(n){var e=new mn(n.tag,n.data,n.children&&n.children.slice(),n.text,n.elm,n.context,n.componentOptions,n.asyncFactory);return e.ns=n.ns,e.isStatic=n.isStatic,e.key=n.key,e.isComment=n.isComment,e.fnContext=n.fnContext,e.fnOptions=n.fnOptions,e.fnScopeId=n.fnScopeId,e.asyncMeta=n.asyncMeta,e.isCloned=!0,e}var bn=0,vn=[],xn=function(){function n(){this._pending=!1,this.id=bn++,this.subs=[]}return n.prototype.addSub=function(n){this.subs.push(n)},n.prototype.removeSub=function(n){this.subs[this.subs.indexOf(n)]=null,this._pending||(this._pending=!0,vn.push(this))},n.prototype.depend=function(e){n.target&&n.target.addDep(this)},n.prototype.notify=function(n){var e=this.subs.filter((function(n){return n}));for(var t=0,i=e.length;t<i;t++){0,e[t].update()}},n}();xn.target=null;var yn=[];function En(n){yn.push(n),xn.target=n}function _n(){yn.pop(),xn.target=yn[yn.length-1]}var kn=Array.prototype,wn=Object.create(kn);["push","pop","shift","unshift","splice","sort","reverse"].forEach((function(n){var e=kn[n];H(wn,n,(function(){for(var t=[],i=0;i<arguments.length;i++)t[i]=arguments[i];var r,a=e.apply(this,t),s=this.__ob__;switch(n){case"push":case"unshift":r=t;break;case"splice":r=t.slice(2)}return r&&s.observeArray(r),s.dep.notify(),a}))}));var jn=Object.getOwnPropertyNames(wn),An={},Tn=!0;function Cn(n){Tn=n}var zn={notify:L,depend:L,addSub:L,removeSub:L},Bn=function(){function n(n,e,t){if(void 0===e&&(e=!1),void 0===t&&(t=!1),this.value=n,this.shallow=e,this.mock=t,this.dep=t?zn:new xn,this.vmCount=0,H(n,"__ob__",this),r(n)){if(!t)if(Z)n.__proto__=wn;else for(var i=0,a=jn.length;i<a;i++){H(n,o=jn[i],wn[o])}e||this.observeArray(n)}else{var s=Object.keys(n);for(i=0;i<s.length;i++){var o;Sn(n,o=s[i],An,void 0,e,t)}}}return n.prototype.observeArray=function(n){for(var e=0,t=n.length;e<t;e++)In(n[e],!1,this.mock)},n}();function In(n,e,t){return n&&_(n,"__ob__")&&n.__ob__ instanceof Bn?n.__ob__:!Tn||!t&&sn()||!r(n)&&!p(n)||!Object.isExtensible(n)||n.__v_skip||Gn(n)||n instanceof mn?void 0:new Bn(n,e,t)}function Sn(n,e,t,i,a,s){var o=new xn,l=Object.getOwnPropertyDescriptor(n,e);if(!l||!1!==l.configurable){var d=l&&l.get,c=l&&l.set;d&&!c||t!==An&&2!==arguments.length||(t=n[e]);var u=!a&&In(t,!1,s);return Object.defineProperty(n,e,{enumerable:!0,configurable:!0,get:function(){var e=d?d.call(n):t;return xn.target&&(o.depend(),u&&(u.dep.depend(),r(e)&&qn(e))),Gn(e)&&!a?e.value:e},set:function(e){var i=d?d.call(n):t;if(G(i,e)){if(c)c.call(n,e);else{if(d)return;if(!a&&Gn(i)&&!Gn(e))return void(i.value=e);t=e}u=!a&&In(e,!1,s),o.notify()}}}),o}}function Ln(n,e,t){if(!Dn(n)){var i=n.__ob__;return r(n)&&h(e)?(n.length=Math.max(n.length,e),n.splice(e,1,t),i&&!i.shallow&&i.mock&&In(t,!1,!0),t):e in n&&!(e in Object.prototype)?(n[e]=t,t):n._isVue||i&&i.vmCount?t:i?(Sn(i.value,e,t,void 0,i.shallow,i.mock),i.dep.notify(),t):(n[e]=t,t)}}function Pn(n,e){if(r(n)&&h(e))n.splice(e,1);else{var t=n.__ob__;n._isVue||t&&t.vmCount||Dn(n)||_(n,e)&&(delete n[e],t&&t.dep.notify())}}function qn(n){for(var e=void 0,t=0,i=n.length;t<i;t++)(e=n[t])&&e.__ob__&&e.__ob__.dep.depend(),r(e)&&qn(e)}function Nn(n){return $n(n,!0),H(n,"__v_isShallow",!0),n}function $n(n,e){if(!Dn(n)){In(n,e,sn());0}}function Dn(n){return!(!n||!n.__v_isReadonly)}function Gn(n){return!(!n||!0!==n.__v_isRef)}function Fn(n,e,t){Object.defineProperty(n,t,{enumerable:!0,configurable:!0,get:function(){var n=e[t];if(Gn(n))return n.value;var i=n&&n.__ob__;return i&&i.dep.depend(),n},set:function(n){var i=e[t];Gn(i)&&!Gn(n)?i.value=n:e[t]=n}})}"".concat("watcher"," callback"),"".concat("watcher"," getter"),"".concat("watcher"," cleanup");var On;var Un=function(){function n(n){void 0===n&&(n=!1),this.detached=n,this.active=!0,this.effects=[],this.cleanups=[],this.parent=On,!n&&On&&(this.index=(On.scopes||(On.scopes=[])).push(this)-1)}return n.prototype.run=function(n){if(this.active){var e=On;try{return On=this,n()}finally{On=e}}else 0},n.prototype.on=function(){On=this},n.prototype.off=function(){On=this.parent},n.prototype.stop=function(n){if(this.active){var e=void 0,t=void 0;for(e=0,t=this.effects.length;e<t;e++)this.effects[e].teardown();for(e=0,t=this.cleanups.length;e<t;e++)this.cleanups[e]();if(this.scopes)for(e=0,t=this.scopes.length;e<t;e++)this.scopes[e].stop(!0);if(!this.detached&&this.parent&&!n){var i=this.parent.scopes.pop();i&&i!==this&&(this.parent.scopes[this.index]=i,i.index=this.index)}this.parent=void 0,this.active=!1}},n}();function Rn(n){var e=n._provided,t=n.$parent&&n.$parent._provided;return t===e?n._provided=Object.create(t):e}var Mn=k((function(n){var e="&"===n.charAt(0),t="~"===(n=e?n.slice(1):n).charAt(0),i="!"===(n=t?n.slice(1):n).charAt(0);return{name:n=i?n.slice(1):n,once:t,capture:i,passive:e}}));function Hn(n,e){function t(){var n=t.fns;if(!r(n))return Te(n,null,arguments,e,"v-on handler");for(var i=n.slice(),a=0;a<i.length;a++)Te(i[a],null,arguments,e,"v-on handler")}return t.fns=n,t}function Vn(n,e,t,i,r,s){var l,d,c,u;for(l in n)d=n[l],c=e[l],u=Mn(l),a(d)||(a(c)?(a(d.fns)&&(d=n[l]=Hn(d,s)),o(u.once)&&(d=n[l]=r(u.name,d,u.capture)),t(u.name,d,u.capture,u.passive,u.params)):d!==c&&(c.fns=d,n[l]=c));for(l in e)a(n[l])&&i((u=Mn(l)).name,e[l],u.capture)}function Zn(n,e,t){var i;n instanceof mn&&(n=n.data.hook||(n.data.hook={}));var r=n[e];function l(){t.apply(this,arguments),y(i.fns,l)}a(r)?i=Hn([l]):s(r.fns)&&o(r.merged)?(i=r).fns.push(l):i=Hn([r,l]),i.merged=!0,n[e]=i}function Wn(n,e,t,i,r){if(s(e)){if(_(e,t))return n[t]=e[t],r||delete e[t],!0;if(_(e,i))return n[t]=e[i],r||delete e[i],!0}return!1}function Kn(n){return l(n)?[fn(n)]:r(n)?function n(e,t){var i,d,c,u,p=[];for(i=0;i<e.length;i++)a(d=e[i])||"boolean"==typeof d||(c=p.length-1,u=p[c],r(d)?d.length>0&&(Xn((d=n(d,"".concat(t||"","_").concat(i)))[0])&&Xn(u)&&(p[c]=fn(u.text+d[0].text),d.shift()),p.push.apply(p,d)):l(d)?Xn(u)?p[c]=fn(u.text+d):""!==d&&p.push(fn(d)):Xn(d)&&Xn(u)?p[c]=fn(u.text+d.text):(o(e._isVList)&&s(d.tag)&&a(d.key)&&s(t)&&(d.key="__vlist".concat(t,"_").concat(i,"__")),p.push(d)));return p}(n):void 0}function Xn(n){return s(n)&&s(n.text)&&!1===n.isComment}function Yn(n,e){var t,i,a,o,l=null;if(r(n)||"string"==typeof n)for(l=new Array(n.length),t=0,i=n.length;t<i;t++)l[t]=e(n[t],t);else if("number"==typeof n)for(l=new Array(n),t=0;t<n;t++)l[t]=e(t+1,t);else if(c(n))if(cn&&n[Symbol.iterator]){l=[];for(var d=n[Symbol.iterator](),u=d.next();!u.done;)l.push(e(u.value,l.length)),u=d.next()}else for(a=Object.keys(n),l=new Array(a.length),t=0,i=a.length;t<i;t++)o=a[t],l[t]=e(n[o],o,t);return s(l)||(l=[]),l._isVList=!0,l}function Jn(n,e,t,i){var r,a=this.$scopedSlots[n];a?(t=t||{},i&&(t=I(I({},i),t)),r=a(t)||(d(e)?e():e)):r=this.$slots[n]||(d(e)?e():e);var s=t&&t.slot;return s?this.$createElement("template",{slot:s},r):r}function Qn(n){return Bt(this.$options,"filters",n,!0)||q}function ne(n,e){return r(n)?-1===n.indexOf(e):n!==e}function ee(n,e,t,i,r){var a=U.keyCodes[e]||t;return r&&i&&!U.keyCodes[e]?ne(r,i):a?ne(a,n):i?C(i)!==e:void 0===n}function te(n,e,t,i,a){if(t)if(c(t)){r(t)&&(t=S(t));var s=void 0,o=function(r){if("class"===r||"style"===r||x(r))s=n;else{var o=n.attrs&&n.attrs.type;s=i||U.mustUseProp(e,o,r)?n.domProps||(n.domProps={}):n.attrs||(n.attrs={})}var l=j(r),d=C(r);l in s||d in s||(s[r]=t[r],a&&((n.on||(n.on={}))["update:".concat(r)]=function(n){t[r]=n}))};for(var l in t)o(l)}else;return n}function ie(n,e){var t=this._staticTrees||(this._staticTrees=[]),i=t[n];return i&&!e||ae(i=t[n]=this.$options.staticRenderFns[n].call(this._renderProxy,this._c,this),"__static__".concat(n),!1),i}function re(n,e,t){return ae(n,"__once__".concat(e).concat(t?"_".concat(t):""),!0),n}function ae(n,e,t){if(r(n))for(var i=0;i<n.length;i++)n[i]&&"string"!=typeof n[i]&&se(n[i],"".concat(e,"_").concat(i),t);else se(n,e,t)}function se(n,e,t){n.isStatic=!0,n.key=e,n.isOnce=t}function oe(n,e){if(e)if(p(e)){var t=n.on=n.on?I({},n.on):{};for(var i in e){var r=t[i],a=e[i];t[i]=r?[].concat(r,a):a}}else;return n}function le(n,e,t,i){e=e||{$stable:!t};for(var a=0;a<n.length;a++){var s=n[a];r(s)?le(s,e,t):s&&(s.proxy&&(s.fn.proxy=!0),e[s.key]=s.fn)}return i&&(e.$key=i),e}function de(n,e){for(var t=0;t<e.length;t+=2){var i=e[t];"string"==typeof i&&i&&(n[e[t]]=e[t+1])}return n}function ce(n,e){return"string"==typeof n?e+n:n}function ue(n){n._o=re,n._n=b,n._s=g,n._l=Yn,n._t=Jn,n._q=N,n._i=$,n._m=ie,n._f=Qn,n._k=ee,n._b=te,n._v=fn,n._e=hn,n._u=le,n._g=oe,n._d=de,n._p=ce}function pe(n,e){if(!n||!n.length)return{};for(var t={},i=0,r=n.length;i<r;i++){var a=n[i],s=a.data;if(s&&s.attrs&&s.attrs.slot&&delete s.attrs.slot,a.context!==e&&a.fnContext!==e||!s||null==s.slot)(t.default||(t.default=[])).push(a);else{var o=s.slot,l=t[o]||(t[o]=[]);"template"===a.tag?l.push.apply(l,a.children||[]):l.push(a)}}for(var d in t)t[d].every(me)&&delete t[d];return t}function me(n){return n.isComment&&!n.asyncFactory||" "===n.text}function he(n){return n.isComment&&n.asyncFactory}function fe(n,e,t,r){var a,s=Object.keys(t).length>0,o=e?!!e.$stable:!s,l=e&&e.$key;if(e){if(e._normalized)return e._normalized;if(o&&r&&r!==i&&l===r.$key&&!s&&!r.$hasNormal)return r;for(var d in a={},e)e[d]&&"$"!==d[0]&&(a[d]=ge(n,t,d,e[d]))}else a={};for(var c in t)c in a||(a[c]=be(t,c));return e&&Object.isExtensible(e)&&(e._normalized=a),H(a,"$stable",o),H(a,"$key",l),H(a,"$hasNormal",s),a}function ge(n,e,t,i){var a=function(){var e=un;pn(n);var t=arguments.length?i.apply(null,arguments):i({}),a=(t=t&&"object"==typeof t&&!r(t)?[t]:Kn(t))&&t[0];return pn(e),t&&(!a||1===t.length&&a.isComment&&!he(a))?void 0:t};return i.proxy&&Object.defineProperty(e,t,{get:a,enumerable:!0,configurable:!0}),a}function be(n,e){return function(){return n[e]}}function ve(n){return{get attrs(){if(!n._attrsProxy){var e=n._attrsProxy={};H(e,"_v_attr_proxy",!0),xe(e,n.$attrs,i,n,"$attrs")}return n._attrsProxy},get listeners(){n._listenersProxy||xe(n._listenersProxy={},n.$listeners,i,n,"$listeners");return n._listenersProxy},get slots(){return function(n){n._slotsProxy||Ee(n._slotsProxy={},n.$scopedSlots);return n._slotsProxy}(n)},emit:z(n.$emit,n),expose:function(e){e&&Object.keys(e).forEach((function(t){return Fn(n,e,t)}))}}}function xe(n,e,t,i,r){var a=!1;for(var s in e)s in n?e[s]!==t[s]&&(a=!0):(a=!0,ye(n,s,i,r));for(var s in n)s in e||(a=!0,delete n[s]);return a}function ye(n,e,t,i){Object.defineProperty(n,e,{enumerable:!0,configurable:!0,get:function(){return t[i][e]}})}function Ee(n,e){for(var t in e)n[t]=e[t];for(var t in n)t in e||delete n[t]}var _e=null;function ke(n,e){return(n.__esModule||cn&&"Module"===n[Symbol.toStringTag])&&(n=n.default),c(n)?e.extend(n):n}function we(n){if(r(n))for(var e=0;e<n.length;e++){var t=n[e];if(s(t)&&(s(t.componentOptions)||he(t)))return t}}function je(n,e,t,i,u,p){return(r(t)||l(t))&&(u=i,i=t,t=void 0),o(p)&&(u=2),function(n,e,t,i,l){if(s(t)&&s(t.__ob__))return hn();s(t)&&s(t.is)&&(e=t.is);if(!e)return hn();0;r(i)&&d(i[0])&&((t=t||{}).scopedSlots={default:i[0]},i.length=0);2===l?i=Kn(i):1===l&&(i=function(n){for(var e=0;e<n.length;e++)if(r(n[e]))return Array.prototype.concat.apply([],n);return n}(i));var u,p;if("string"==typeof e){var m=void 0;p=n.$vnode&&n.$vnode.ns||U.getTagNamespace(e),u=U.isReservedTag(e)?new mn(U.parsePlatformTagName(e),t,i,void 0,void 0,n):t&&t.pre||!s(m=Bt(n.$options,"components",e))?new mn(e,t,i,void 0,void 0,n):yt(m,t,n,i,e)}else u=yt(e,t,n,i);return r(u)?u:s(u)?(s(p)&&function n(e,t,i){e.ns=t,"foreignObject"===e.tag&&(t=void 0,i=!0);if(s(e.children))for(var r=0,l=e.children.length;r<l;r++){var d=e.children[r];s(d.tag)&&(a(d.ns)||o(i)&&"svg"!==d.tag)&&n(d,t,i)}}(u,p),s(t)&&function(n){c(n.style)&&Ue(n.style);c(n.class)&&Ue(n.class)}(t),u):hn()}(n,e,t,i,u)}function Ae(n,e,t){En();try{if(e)for(var i=e;i=i.$parent;){var r=i.$options.errorCaptured;if(r)for(var a=0;a<r.length;a++)try{if(!1===r[a].call(i,n,e,t))return}catch(n){Ce(n,i,"errorCaptured hook")}}Ce(n,e,t)}finally{_n()}}function Te(n,e,t,i,r){var a;try{(a=t?n.apply(e,t):n.call(e))&&!a._isVue&&f(a)&&!a._handled&&(a.catch((function(n){return Ae(n,i,r+" (Promise/async)")})),a._handled=!0)}catch(n){Ae(n,i,r)}return a}function Ce(n,e,t){if(U.errorHandler)try{return U.errorHandler.call(null,n,e,t)}catch(e){e!==n&&ze(e,null,"config.errorHandler")}ze(n,e,t)}function ze(n,e,t){if(!W||"undefined"==typeof console)throw n;console.error(n)}var Be,Ie=!1,Se=[],Le=!1;function Pe(){Le=!1;var n=Se.slice(0);Se.length=0;for(var e=0;e<n.length;e++)n[e]()}if("undefined"!=typeof Promise&&ln(Promise)){var qe=Promise.resolve();Be=function(){qe.then(Pe),Q&&setTimeout(L)},Ie=!0}else if(X||"undefined"==typeof MutationObserver||!ln(MutationObserver)&&"[object MutationObserverConstructor]"!==MutationObserver.toString())Be="undefined"!=typeof setImmediate&&ln(setImmediate)?function(){setImmediate(Pe)}:function(){setTimeout(Pe,0)};else{var Ne=1,$e=new MutationObserver(Pe),De=document.createTextNode(String(Ne));$e.observe(De,{characterData:!0}),Be=function(){Ne=(Ne+1)%2,De.data=String(Ne)},Ie=!0}function Ge(n,e){var t;if(Se.push((function(){if(n)try{n.call(e)}catch(n){Ae(n,e,"nextTick")}else t&&t(e)})),Le||(Le=!0,Be()),!n&&"undefined"!=typeof Promise)return new Promise((function(n){t=n}))}function Fe(n){return function(e,t){if(void 0===t&&(t=un),t)return function(n,e,t){var i=n.$options;i[e]=At(i[e],t)}(t,n,e)}}Fe("beforeMount"),Fe("mounted"),Fe("beforeUpdate"),Fe("updated"),Fe("beforeDestroy"),Fe("destroyed"),Fe("activated"),Fe("deactivated"),Fe("serverPrefetch"),Fe("renderTracked"),Fe("renderTriggered"),Fe("errorCaptured");var Oe=new dn;function Ue(n){return function n(e,t){var i,a,s=r(e);if(!s&&!c(e)||e.__v_skip||Object.isFrozen(e)||e instanceof mn)return;if(e.__ob__){var o=e.__ob__.dep.id;if(t.has(o))return;t.add(o)}if(s)for(i=e.length;i--;)n(e[i],t);else if(Gn(e))n(e.value,t);else for(a=Object.keys(e),i=a.length;i--;)n(e[a[i]],t)}(n,Oe),Oe.clear(),n}var Re,Me=0,He=function(){function n(n,e,t,i,r){var a,s;a=this,void 0===(s=On&&!On._vm?On:n?n._scope:void 0)&&(s=On),s&&s.active&&s.effects.push(a),(this.vm=n)&&r&&(n._watcher=this),i?(this.deep=!!i.deep,this.user=!!i.user,this.lazy=!!i.lazy,this.sync=!!i.sync,this.before=i.before):this.deep=this.user=this.lazy=this.sync=!1,this.cb=t,this.id=++Me,this.active=!0,this.post=!1,this.dirty=this.lazy,this.deps=[],this.newDeps=[],this.depIds=new dn,this.newDepIds=new dn,this.expression="",d(e)?this.getter=e:(this.getter=function(n){if(!V.test(n)){var e=n.split(".");return function(n){for(var t=0;t<e.length;t++){if(!n)return;n=n[e[t]]}return n}}}(e),this.getter||(this.getter=L)),this.value=this.lazy?void 0:this.get()}return n.prototype.get=function(){var n;En(this);var e=this.vm;try{n=this.getter.call(e,e)}catch(n){if(!this.user)throw n;Ae(n,e,'getter for watcher "'.concat(this.expression,'"'))}finally{this.deep&&Ue(n),_n(),this.cleanupDeps()}return n},n.prototype.addDep=function(n){var e=n.id;this.newDepIds.has(e)||(this.newDepIds.add(e),this.newDeps.push(n),this.depIds.has(e)||n.addSub(this))},n.prototype.cleanupDeps=function(){for(var n=this.deps.length;n--;){var e=this.deps[n];this.newDepIds.has(e.id)||e.removeSub(this)}var t=this.depIds;this.depIds=this.newDepIds,this.newDepIds=t,this.newDepIds.clear(),t=this.deps,this.deps=this.newDeps,this.newDeps=t,this.newDeps.length=0},n.prototype.update=function(){this.lazy?this.dirty=!0:this.sync?this.run():pt(this)},n.prototype.run=function(){if(this.active){var n=this.get();if(n!==this.value||c(n)||this.deep){var e=this.value;if(this.value=n,this.user){var t='callback for watcher "'.concat(this.expression,'"');Te(this.cb,this.vm,[n,e],this.vm,t)}else this.cb.call(this.vm,n,e)}}},n.prototype.evaluate=function(){this.value=this.get(),this.dirty=!1},n.prototype.depend=function(){for(var n=this.deps.length;n--;)this.deps[n].depend()},n.prototype.teardown=function(){if(this.vm&&!this.vm._isBeingDestroyed&&y(this.vm._scope.effects,this),this.active){for(var n=this.deps.length;n--;)this.deps[n].removeSub(this);this.active=!1,this.onStop&&this.onStop()}},n}();function Ve(n,e){Re.$on(n,e)}function Ze(n,e){Re.$off(n,e)}function We(n,e){var t=Re;return function i(){var r=e.apply(null,arguments);null!==r&&t.$off(n,i)}}function Ke(n,e,t){Re=n,Vn(e,t||{},Ve,Ze,We,n),Re=void 0}var Xe=null;function Ye(n){var e=Xe;return Xe=n,function(){Xe=e}}function Je(n){for(;n&&(n=n.$parent);)if(n._inactive)return!0;return!1}function Qe(n,e){if(e){if(n._directInactive=!1,Je(n))return}else if(n._directInactive)return;if(n._inactive||null===n._inactive){n._inactive=!1;for(var t=0;t<n.$children.length;t++)Qe(n.$children[t]);nt(n,"activated")}}function nt(n,e,t,i){void 0===i&&(i=!0),En();var r=un;i&&pn(n);var a=n.$options[e],s="".concat(e," hook");if(a)for(var o=0,l=a.length;o<l;o++)Te(a[o],n,t||null,n,s);n._hasHookEvent&&n.$emit("hook:"+e),i&&pn(r),_n()}var et=[],tt=[],it={},rt=!1,at=!1,st=0;var ot=0,lt=Date.now;if(W&&!X){var dt=window.performance;dt&&"function"==typeof dt.now&&lt()>document.createEvent("Event").timeStamp&&(lt=function(){return dt.now()})}var ct=function(n,e){if(n.post){if(!e.post)return 1}else if(e.post)return-1;return n.id-e.id};function ut(){var n,e;for(ot=lt(),at=!0,et.sort(ct),st=0;st<et.length;st++)(n=et[st]).before&&n.before(),e=n.id,it[e]=null,n.run();var t=tt.slice(),i=et.slice();st=et.length=tt.length=0,it={},rt=at=!1,function(n){for(var e=0;e<n.length;e++)n[e]._inactive=!0,Qe(n[e],!0)}(t),function(n){var e=n.length;for(;e--;){var t=n[e],i=t.vm;i&&i._watcher===t&&i._isMounted&&!i._isDestroyed&&nt(i,"updated")}}(i),function(){for(var n=0;n<vn.length;n++){var e=vn[n];e.subs=e.subs.filter((function(n){return n})),e._pending=!1}vn.length=0}(),on&&U.devtools&&on.emit("flush")}function pt(n){var e=n.id;if(null==it[e]&&(n!==xn.target||!n.noRecurse)){if(it[e]=!0,at){for(var t=et.length-1;t>st&&et[t].id>n.id;)t--;et.splice(t+1,0,n)}else et.push(n);rt||(rt=!0,Ge(ut))}}function mt(n,e){if(n){for(var t=Object.create(null),i=cn?Reflect.ownKeys(n):Object.keys(n),r=0;r<i.length;r++){var a=i[r];if("__ob__"!==a){var s=n[a].from;if(s in e._provided)t[a]=e._provided[s];else if("default"in n[a]){var o=n[a].default;t[a]=d(o)?o.call(e):o}else 0}}return t}}function ht(n,e,t,a,s){var l,d=this,c=s.options;_(a,"_uid")?(l=Object.create(a))._original=a:(l=a,a=a._original);var u=o(c._compiled),p=!u;this.data=n,this.props=e,this.children=t,this.parent=a,this.listeners=n.on||i,this.injections=mt(c.inject,a),this.slots=function(){return d.$slots||fe(a,n.scopedSlots,d.$slots=pe(t,a)),d.$slots},Object.defineProperty(this,"scopedSlots",{enumerable:!0,get:function(){return fe(a,n.scopedSlots,this.slots())}}),u&&(this.$options=c,this.$slots=this.slots(),this.$scopedSlots=fe(a,n.scopedSlots,this.$slots)),c._scopeId?this._c=function(n,e,t,i){var s=je(l,n,e,t,i,p);return s&&!r(s)&&(s.fnScopeId=c._scopeId,s.fnContext=a),s}:this._c=function(n,e,t,i){return je(l,n,e,t,i,p)}}function ft(n,e,t,i,r){var a=gn(n);return a.fnContext=t,a.fnOptions=i,e.slot&&((a.data||(a.data={})).slot=e.slot),a}function gt(n,e){for(var t in e)n[j(t)]=e[t]}function bt(n){return n.name||n.__name||n._componentTag}ue(ht.prototype);var vt={init:function(n,e){if(n.componentInstance&&!n.componentInstance._isDestroyed&&n.data.keepAlive){var t=n;vt.prepatch(t,t)}else{(n.componentInstance=function(n,e){var t={_isComponent:!0,_parentVnode:n,parent:e},i=n.data.inlineTemplate;s(i)&&(t.render=i.render,t.staticRenderFns=i.staticRenderFns);return new n.componentOptions.Ctor(t)}(n,Xe)).$mount(e?n.elm:void 0,e)}},prepatch:function(n,e){var t=e.componentOptions;!function(n,e,t,r,a){var s=r.data.scopedSlots,o=n.$scopedSlots,l=!!(s&&!s.$stable||o!==i&&!o.$stable||s&&n.$scopedSlots.$key!==s.$key||!s&&n.$scopedSlots.$key),d=!!(a||n.$options._renderChildren||l),c=n.$vnode;n.$options._parentVnode=r,n.$vnode=r,n._vnode&&(n._vnode.parent=r),n.$options._renderChildren=a;var u=r.data.attrs||i;n._attrsProxy&&xe(n._attrsProxy,u,c.data&&c.data.attrs||i,n,"$attrs")&&(d=!0),n.$attrs=u,t=t||i;var p=n.$options._parentListeners;if(n._listenersProxy&&xe(n._listenersProxy,t,p||i,n,"$listeners"),n.$listeners=n.$options._parentListeners=t,Ke(n,t,p),e&&n.$options.props){Cn(!1);for(var m=n._props,h=n.$options._propKeys||[],f=0;f<h.length;f++){var g=h[f],b=n.$options.props;m[g]=It(g,b,e,n)}Cn(!0),n.$options.propsData=e}d&&(n.$slots=pe(a,r.context),n.$forceUpdate())}(e.componentInstance=n.componentInstance,t.propsData,t.listeners,e,t.children)},insert:function(n){var e,t=n.context,i=n.componentInstance;i._isMounted||(i._isMounted=!0,nt(i,"mounted")),n.data.keepAlive&&(t._isMounted?((e=i)._inactive=!1,tt.push(e)):Qe(i,!0))},destroy:function(n){var e=n.componentInstance;e._isDestroyed||(n.data.keepAlive?function n(e,t){if(!(t&&(e._directInactive=!0,Je(e))||e._inactive)){e._inactive=!0;for(var i=0;i<e.$children.length;i++)n(e.$children[i]);nt(e,"deactivated")}}(e,!0):e.$destroy())}},xt=Object.keys(vt);function yt(n,e,t,l,d){if(!a(n)){var u=t.$options._base;if(c(n)&&(n=u.extend(n)),"function"==typeof n){var p;if(a(n.cid)&&void 0===(n=function(n,e){if(o(n.error)&&s(n.errorComp))return n.errorComp;if(s(n.resolved))return n.resolved;var t=_e;if(t&&s(n.owners)&&-1===n.owners.indexOf(t)&&n.owners.push(t),o(n.loading)&&s(n.loadingComp))return n.loadingComp;if(t&&!s(n.owners)){var i=n.owners=[t],r=!0,l=null,d=null;t.$on("hook:destroyed",(function(){return y(i,t)}));var u=function(n){for(var e=0,t=i.length;e<t;e++)i[e].$forceUpdate();n&&(i.length=0,null!==l&&(clearTimeout(l),l=null),null!==d&&(clearTimeout(d),d=null))},p=D((function(t){n.resolved=ke(t,e),r?i.length=0:u(!0)})),m=D((function(e){s(n.errorComp)&&(n.error=!0,u(!0))})),h=n(p,m);return c(h)&&(f(h)?a(n.resolved)&&h.then(p,m):f(h.component)&&(h.component.then(p,m),s(h.error)&&(n.errorComp=ke(h.error,e)),s(h.loading)&&(n.loadingComp=ke(h.loading,e),0===h.delay?n.loading=!0:l=setTimeout((function(){l=null,a(n.resolved)&&a(n.error)&&(n.loading=!0,u(!1))}),h.delay||200)),s(h.timeout)&&(d=setTimeout((function(){d=null,a(n.resolved)&&m(null)}),h.timeout)))),r=!1,n.loading?n.loadingComp:n.resolved}}(p=n,u)))return function(n,e,t,i,r){var a=hn();return a.asyncFactory=n,a.asyncMeta={data:e,context:t,children:i,tag:r},a}(p,e,t,l,d);e=e||{},Ht(n),s(e.model)&&function(n,e){var t=n.model&&n.model.prop||"value",i=n.model&&n.model.event||"input";(e.attrs||(e.attrs={}))[t]=e.model.value;var a=e.on||(e.on={}),o=a[i],l=e.model.callback;s(o)?(r(o)?-1===o.indexOf(l):o!==l)&&(a[i]=[l].concat(o)):a[i]=l}(n.options,e);var m=function(n,e,t){var i=e.options.props;if(!a(i)){var r={},o=n.attrs,l=n.props;if(s(o)||s(l))for(var d in i){var c=C(d);Wn(r,l,d,c,!0)||Wn(r,o,d,c,!1)}return r}}(e,n);if(o(n.options.functional))return function(n,e,t,a,o){var l=n.options,d={},c=l.props;if(s(c))for(var u in c)d[u]=It(u,c,e||i);else s(t.attrs)&&gt(d,t.attrs),s(t.props)&&gt(d,t.props);var p=new ht(t,d,o,a,n),m=l.render.call(null,p._c,p);if(m instanceof mn)return ft(m,t,p.parent,l,p);if(r(m)){for(var h=Kn(m)||[],f=new Array(h.length),g=0;g<h.length;g++)f[g]=ft(h[g],t,p.parent,l,p);return f}}(n,m,e,t,l);var h=e.on;if(e.on=e.nativeOn,o(n.options.abstract)){var g=e.slot;e={},g&&(e.slot=g)}!function(n){for(var e=n.hook||(n.hook={}),t=0;t<xt.length;t++){var i=xt[t],r=e[i],a=vt[i];r===a||r&&r._merged||(e[i]=r?Et(a,r):a)}}(e);var b=bt(n.options)||d;return new mn("vue-component-".concat(n.cid).concat(b?"-".concat(b):""),e,void 0,void 0,void 0,t,{Ctor:n,propsData:m,listeners:h,tag:d,children:l},p)}}}function Et(n,e){var t=function(t,i){n(t,i),e(t,i)};return t._merged=!0,t}var _t=L,kt=U.optionMergeStrategies;function wt(n,e,t){if(void 0===t&&(t=!0),!e)return n;for(var i,r,a,s=cn?Reflect.ownKeys(e):Object.keys(e),o=0;o<s.length;o++)"__ob__"!==(i=s[o])&&(r=n[i],a=e[i],t&&_(n,i)?r!==a&&p(r)&&p(a)&&wt(r,a):Ln(n,i,a));return n}function jt(n,e,t){return t?function(){var i=d(e)?e.call(t,t):e,r=d(n)?n.call(t,t):n;return i?wt(i,r):r}:e?n?function(){return wt(d(e)?e.call(this,this):e,d(n)?n.call(this,this):n)}:e:n}function At(n,e){var t=e?n?n.concat(e):r(e)?e:[e]:n;return t?function(n){for(var e=[],t=0;t<n.length;t++)-1===e.indexOf(n[t])&&e.push(n[t]);return e}(t):t}function Tt(n,e,t,i){var r=Object.create(n||null);return e?I(r,e):r}kt.data=function(n,e,t){return t?jt(n,e,t):e&&"function"!=typeof e?n:jt(n,e)},O.forEach((function(n){kt[n]=At})),F.forEach((function(n){kt[n+"s"]=Tt})),kt.watch=function(n,e,t,i){if(n===tn&&(n=void 0),e===tn&&(e=void 0),!e)return Object.create(n||null);if(!n)return e;var a={};for(var s in I(a,n),e){var o=a[s],l=e[s];o&&!r(o)&&(o=[o]),a[s]=o?o.concat(l):r(l)?l:[l]}return a},kt.props=kt.methods=kt.inject=kt.computed=function(n,e,t,i){if(!n)return e;var r=Object.create(null);return I(r,n),e&&I(r,e),r},kt.provide=function(n,e){return n?function(){var t=Object.create(null);return wt(t,d(n)?n.call(this):n),e&&wt(t,d(e)?e.call(this):e,!1),t}:e};var Ct=function(n,e){return void 0===e?n:e};function zt(n,e,t){if(d(e)&&(e=e.options),function(n,e){var t=n.props;if(t){var i,a,s={};if(r(t))for(i=t.length;i--;)"string"==typeof(a=t[i])&&(s[j(a)]={type:null});else if(p(t))for(var o in t)a=t[o],s[j(o)]=p(a)?a:{type:a};else 0;n.props=s}}(e),function(n,e){var t=n.inject;if(t){var i=n.inject={};if(r(t))for(var a=0;a<t.length;a++)i[t[a]]={from:t[a]};else if(p(t))for(var s in t){var o=t[s];i[s]=p(o)?I({from:s},o):{from:o}}else 0}}(e),function(n){var e=n.directives;if(e)for(var t in e){var i=e[t];d(i)&&(e[t]={bind:i,update:i})}}(e),!e._base&&(e.extends&&(n=zt(n,e.extends,t)),e.mixins))for(var i=0,a=e.mixins.length;i<a;i++)n=zt(n,e.mixins[i],t);var s,o={};for(s in n)l(s);for(s in e)_(n,s)||l(s);function l(i){var r=kt[i]||Ct;o[i]=r(n[i],e[i],t,i)}return o}function Bt(n,e,t,i){if("string"==typeof t){var r=n[e];if(_(r,t))return r[t];var a=j(t);if(_(r,a))return r[a];var s=A(a);return _(r,s)?r[s]:r[t]||r[a]||r[s]}}function It(n,e,t,i){var r=e[n],a=!_(t,n),s=t[n],o=qt(Boolean,r.type);if(o>-1)if(a&&!_(r,"default"))s=!1;else if(""===s||s===C(n)){var l=qt(String,r.type);(l<0||o<l)&&(s=!0)}if(void 0===s){s=function(n,e,t){if(!_(e,"default"))return;var i=e.default;0;if(n&&n.$options.propsData&&void 0===n.$options.propsData[t]&&void 0!==n._props[t])return n._props[t];return d(i)&&"Function"!==Lt(e.type)?i.call(n):i}(i,r,n);var c=Tn;Cn(!0),In(s),Cn(c)}return s}var St=/^\s*function (\w+)/;function Lt(n){var e=n&&n.toString().match(St);return e?e[1]:""}function Pt(n,e){return Lt(n)===Lt(e)}function qt(n,e){if(!r(e))return Pt(e,n)?0:-1;for(var t=0,i=e.length;t<i;t++)if(Pt(e[t],n))return t;return-1}var Nt={enumerable:!0,configurable:!0,get:L,set:L};function $t(n,e,t){Nt.get=function(){return this[e][t]},Nt.set=function(n){this[e][t]=n},Object.defineProperty(n,t,Nt)}function Dt(n){var e=n.$options;if(e.props&&function(n,e){var t=n.$options.propsData||{},i=n._props=Nn({}),r=n.$options._propKeys=[];n.$parent&&Cn(!1);var a=function(a){r.push(a);var s=It(a,e,t,n);Sn(i,a,s),a in n||$t(n,"_props",a)};for(var s in e)a(s);Cn(!0)}(n,e.props),function(n){var e=n.$options,t=e.setup;if(t){var i=n._setupContext=ve(n);pn(n),En();var r=Te(t,null,[n._props||Nn({}),i],n,"setup");if(_n(),pn(),d(r))e.render=r;else if(c(r))if(n._setupState=r,r.__sfc){var a=n._setupProxy={};for(var s in r)"__sfc"!==s&&Fn(a,r,s)}else for(var s in r)M(s)||Fn(n,r,s);else 0}}(n),e.methods&&function(n,e){n.$options.props;for(var t in e)n[t]="function"!=typeof e[t]?L:z(e[t],n)}(n,e.methods),e.data)!function(n){var e=n.$options.data;p(e=n._data=d(e)?function(n,e){En();try{return n.call(e,e)}catch(n){return Ae(n,e,"data()"),{}}finally{_n()}}(e,n):e||{})||(e={});var t=Object.keys(e),i=n.$options.props,r=(n.$options.methods,t.length);for(;r--;){var a=t[r];0,i&&_(i,a)||M(a)||$t(n,"_data",a)}var s=In(e);s&&s.vmCount++}(n);else{var t=In(n._data={});t&&t.vmCount++}e.computed&&function(n,e){var t=n._computedWatchers=Object.create(null),i=sn();for(var r in e){var a=e[r],s=d(a)?a:a.get;0,i||(t[r]=new He(n,s||L,L,Gt)),r in n||Ft(n,r,a)}}(n,e.computed),e.watch&&e.watch!==tn&&function(n,e){for(var t in e){var i=e[t];if(r(i))for(var a=0;a<i.length;a++)Rt(n,t,i[a]);else Rt(n,t,i)}}(n,e.watch)}var Gt={lazy:!0};function Ft(n,e,t){var i=!sn();d(t)?(Nt.get=i?Ot(e):Ut(t),Nt.set=L):(Nt.get=t.get?i&&!1!==t.cache?Ot(e):Ut(t.get):L,Nt.set=t.set||L),Object.defineProperty(n,e,Nt)}function Ot(n){return function(){var e=this._computedWatchers&&this._computedWatchers[n];if(e)return e.dirty&&e.evaluate(),xn.target&&e.depend(),e.value}}function Ut(n){return function(){return n.call(this,this)}}function Rt(n,e,t,i){return p(t)&&(i=t,t=t.handler),"string"==typeof t&&(t=n[t]),n.$watch(e,t,i)}var Mt=0;function Ht(n){var e=n.options;if(n.super){var t=Ht(n.super);if(t!==n.superOptions){n.superOptions=t;var i=function(n){var e,t=n.options,i=n.sealedOptions;for(var r in t)t[r]!==i[r]&&(e||(e={}),e[r]=t[r]);return e}(n);i&&I(n.extendOptions,i),(e=n.options=zt(t,n.extendOptions)).name&&(e.components[e.name]=n)}}return e}function Vt(n){this._init(n)}function Zt(n){n.cid=0;var e=1;n.extend=function(n){n=n||{};var t=this,i=t.cid,r=n._Ctor||(n._Ctor={});if(r[i])return r[i];var a=bt(n)||bt(t.options);var s=function(n){this._init(n)};return(s.prototype=Object.create(t.prototype)).constructor=s,s.cid=e++,s.options=zt(t.options,n),s.super=t,s.options.props&&function(n){var e=n.options.props;for(var t in e)$t(n.prototype,"_props",t)}(s),s.options.computed&&function(n){var e=n.options.computed;for(var t in e)Ft(n.prototype,t,e[t])}(s),s.extend=t.extend,s.mixin=t.mixin,s.use=t.use,F.forEach((function(n){s[n]=t[n]})),a&&(s.options.components[a]=s),s.superOptions=t.options,s.extendOptions=n,s.sealedOptions=I({},s.options),r[i]=s,s}}function Wt(n){return n&&(bt(n.Ctor.options)||n.tag)}function Kt(n,e){return r(n)?n.indexOf(e)>-1:"string"==typeof n?n.split(",").indexOf(e)>-1:!!m(n)&&n.test(e)}function Xt(n,e){var t=n.cache,i=n.keys,r=n._vnode;for(var a in t){var s=t[a];if(s){var o=s.name;o&&!e(o)&&Yt(t,a,i,r)}}}function Yt(n,e,t,i){var r=n[e];!r||i&&r.tag===i.tag||r.componentInstance.$destroy(),n[e]=null,y(t,e)}!function(n){n.prototype._init=function(n){var e=this;e._uid=Mt++,e._isVue=!0,e.__v_skip=!0,e._scope=new Un(!0),e._scope._vm=!0,n&&n._isComponent?function(n,e){var t=n.$options=Object.create(n.constructor.options),i=e._parentVnode;t.parent=e.parent,t._parentVnode=i;var r=i.componentOptions;t.propsData=r.propsData,t._parentListeners=r.listeners,t._renderChildren=r.children,t._componentTag=r.tag,e.render&&(t.render=e.render,t.staticRenderFns=e.staticRenderFns)}(e,n):e.$options=zt(Ht(e.constructor),n||{},e),e._renderProxy=e,e._self=e,function(n){var e=n.$options,t=e.parent;if(t&&!e.abstract){for(;t.$options.abstract&&t.$parent;)t=t.$parent;t.$children.push(n)}n.$parent=t,n.$root=t?t.$root:n,n.$children=[],n.$refs={},n._provided=t?t._provided:Object.create(null),n._watcher=null,n._inactive=null,n._directInactive=!1,n._isMounted=!1,n._isDestroyed=!1,n._isBeingDestroyed=!1}(e),function(n){n._events=Object.create(null),n._hasHookEvent=!1;var e=n.$options._parentListeners;e&&Ke(n,e)}(e),function(n){n._vnode=null,n._staticTrees=null;var e=n.$options,t=n.$vnode=e._parentVnode,r=t&&t.context;n.$slots=pe(e._renderChildren,r),n.$scopedSlots=t?fe(n.$parent,t.data.scopedSlots,n.$slots):i,n._c=function(e,t,i,r){return je(n,e,t,i,r,!1)},n.$createElement=function(e,t,i,r){return je(n,e,t,i,r,!0)};var a=t&&t.data;Sn(n,"$attrs",a&&a.attrs||i,null,!0),Sn(n,"$listeners",e._parentListeners||i,null,!0)}(e),nt(e,"beforeCreate",void 0,!1),function(n){var e=mt(n.$options.inject,n);e&&(Cn(!1),Object.keys(e).forEach((function(t){Sn(n,t,e[t])})),Cn(!0))}(e),Dt(e),function(n){var e=n.$options.provide;if(e){var t=d(e)?e.call(n):e;if(!c(t))return;for(var i=Rn(n),r=cn?Reflect.ownKeys(t):Object.keys(t),a=0;a<r.length;a++){var s=r[a];Object.defineProperty(i,s,Object.getOwnPropertyDescriptor(t,s))}}}(e),nt(e,"created"),e.$options.el&&e.$mount(e.$options.el)}}(Vt),function(n){var e={get:function(){return this._data}},t={get:function(){return this._props}};Object.defineProperty(n.prototype,"$data",e),Object.defineProperty(n.prototype,"$props",t),n.prototype.$set=Ln,n.prototype.$delete=Pn,n.prototype.$watch=function(n,e,t){if(p(e))return Rt(this,n,e,t);(t=t||{}).user=!0;var i=new He(this,n,e,t);if(t.immediate){var r='callback for immediate watcher "'.concat(i.expression,'"');En(),Te(e,this,[i.value],this,r),_n()}return function(){i.teardown()}}}(Vt),function(n){var e=/^hook:/;n.prototype.$on=function(n,t){var i=this;if(r(n))for(var a=0,s=n.length;a<s;a++)i.$on(n[a],t);else(i._events[n]||(i._events[n]=[])).push(t),e.test(n)&&(i._hasHookEvent=!0);return i},n.prototype.$once=function(n,e){var t=this;function i(){t.$off(n,i),e.apply(t,arguments)}return i.fn=e,t.$on(n,i),t},n.prototype.$off=function(n,e){var t=this;if(!arguments.length)return t._events=Object.create(null),t;if(r(n)){for(var i=0,a=n.length;i<a;i++)t.$off(n[i],e);return t}var s,o=t._events[n];if(!o)return t;if(!e)return t._events[n]=null,t;for(var l=o.length;l--;)if((s=o[l])===e||s.fn===e){o.splice(l,1);break}return t},n.prototype.$emit=function(n){var e=this,t=e._events[n];if(t){t=t.length>1?B(t):t;for(var i=B(arguments,1),r='event handler for "'.concat(n,'"'),a=0,s=t.length;a<s;a++)Te(t[a],e,i,e,r)}return e}}(Vt),function(n){n.prototype._update=function(n,e){var t=this,i=t.$el,r=t._vnode,a=Ye(t);t._vnode=n,t.$el=r?t.__patch__(r,n):t.__patch__(t.$el,n,e,!1),a(),i&&(i.__vue__=null),t.$el&&(t.$el.__vue__=t);for(var s=t;s&&s.$vnode&&s.$parent&&s.$vnode===s.$parent._vnode;)s.$parent.$el=s.$el,s=s.$parent},n.prototype.$forceUpdate=function(){this._watcher&&this._watcher.update()},n.prototype.$destroy=function(){var n=this;if(!n._isBeingDestroyed){nt(n,"beforeDestroy"),n._isBeingDestroyed=!0;var e=n.$parent;!e||e._isBeingDestroyed||n.$options.abstract||y(e.$children,n),n._scope.stop(),n._data.__ob__&&n._data.__ob__.vmCount--,n._isDestroyed=!0,n.__patch__(n._vnode,null),nt(n,"destroyed"),n.$off(),n.$el&&(n.$el.__vue__=null),n.$vnode&&(n.$vnode.parent=null)}}}(Vt),function(n){ue(n.prototype),n.prototype.$nextTick=function(n){return Ge(n,this)},n.prototype._render=function(){var n,e=this,t=e.$options,i=t.render,a=t._parentVnode;a&&e._isMounted&&(e.$scopedSlots=fe(e.$parent,a.data.scopedSlots,e.$slots,e.$scopedSlots),e._slotsProxy&&Ee(e._slotsProxy,e.$scopedSlots)),e.$vnode=a;try{pn(e),_e=e,n=i.call(e._renderProxy,e.$createElement)}catch(t){Ae(t,e,"render"),n=e._vnode}finally{_e=null,pn()}return r(n)&&1===n.length&&(n=n[0]),n instanceof mn||(n=hn()),n.parent=a,n}}(Vt);var Jt=[String,RegExp,Array],Qt={KeepAlive:{name:"keep-alive",abstract:!0,props:{include:Jt,exclude:Jt,max:[String,Number]},methods:{cacheVNode:function(){var n=this.cache,e=this.keys,t=this.vnodeToCache,i=this.keyToCache;if(t){var r=t.tag,a=t.componentInstance,s=t.componentOptions;n[i]={name:Wt(s),tag:r,componentInstance:a},e.push(i),this.max&&e.length>parseInt(this.max)&&Yt(n,e[0],e,this._vnode),this.vnodeToCache=null}}},created:function(){this.cache=Object.create(null),this.keys=[]},destroyed:function(){for(var n in this.cache)Yt(this.cache,n,this.keys)},mounted:function(){var n=this;this.cacheVNode(),this.$watch("include",(function(e){Xt(n,(function(n){return Kt(e,n)}))})),this.$watch("exclude",(function(e){Xt(n,(function(n){return!Kt(e,n)}))}))},updated:function(){this.cacheVNode()},render:function(){var n=this.$slots.default,e=we(n),t=e&&e.componentOptions;if(t){var i=Wt(t),r=this.include,a=this.exclude;if(r&&(!i||!Kt(r,i))||a&&i&&Kt(a,i))return e;var s=this.cache,o=this.keys,l=null==e.key?t.Ctor.cid+(t.tag?"::".concat(t.tag):""):e.key;s[l]?(e.componentInstance=s[l].componentInstance,y(o,l),o.push(l)):(this.vnodeToCache=e,this.keyToCache=l),e.data.keepAlive=!0}return e||n&&n[0]}}};!function(n){var e={get:function(){return U}};Object.defineProperty(n,"config",e),n.util={warn:_t,extend:I,mergeOptions:zt,defineReactive:Sn},n.set=Ln,n.delete=Pn,n.nextTick=Ge,n.observable=function(n){return In(n),n},n.options=Object.create(null),F.forEach((function(e){n.options[e+"s"]=Object.create(null)})),n.options._base=n,I(n.options.components,Qt),function(n){n.use=function(n){var e=this._installedPlugins||(this._installedPlugins=[]);if(e.indexOf(n)>-1)return this;var t=B(arguments,1);return t.unshift(this),d(n.install)?n.install.apply(n,t):d(n)&&n.apply(null,t),e.push(n),this}}(n),function(n){n.mixin=function(n){return this.options=zt(this.options,n),this}}(n),Zt(n),function(n){F.forEach((function(e){n[e]=function(n,t){return t?("component"===e&&p(t)&&(t.name=t.name||n,t=this.options._base.extend(t)),"directive"===e&&d(t)&&(t={bind:t,update:t}),this.options[e+"s"][n]=t,t):this.options[e+"s"][n]}}))}(n)}(Vt),Object.defineProperty(Vt.prototype,"$isServer",{get:sn}),Object.defineProperty(Vt.prototype,"$ssrContext",{get:function(){return this.$vnode&&this.$vnode.ssrContext}}),Object.defineProperty(Vt,"FunctionalRenderContext",{value:ht}),Vt.version="2.7.14";var ni=v("style,class"),ei=v("input,textarea,option,select,progress"),ti=v("contenteditable,draggable,spellcheck"),ii=v("events,caret,typing,plaintext-only"),ri=v("allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,default,defaultchecked,defaultmuted,defaultselected,defer,disabled,enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,required,reversed,scoped,seamless,selected,sortable,truespeed,typemustmatch,visible"),ai="http://www.w3.org/1999/xlink",si=function(n){return":"===n.charAt(5)&&"xlink"===n.slice(0,5)},oi=function(n){return si(n)?n.slice(6,n.length):""},li=function(n){return null==n||!1===n};function di(n){for(var e=n.data,t=n,i=n;s(i.componentInstance);)(i=i.componentInstance._vnode)&&i.data&&(e=ci(i.data,e));for(;s(t=t.parent);)t&&t.data&&(e=ci(e,t.data));return function(n,e){if(s(n)||s(e))return ui(n,pi(e));return""}(e.staticClass,e.class)}function ci(n,e){return{staticClass:ui(n.staticClass,e.staticClass),class:s(n.class)?[n.class,e.class]:e.class}}function ui(n,e){return n?e?n+" "+e:n:e||""}function pi(n){return Array.isArray(n)?function(n){for(var e,t="",i=0,r=n.length;i<r;i++)s(e=pi(n[i]))&&""!==e&&(t&&(t+=" "),t+=e);return t}(n):c(n)?function(n){var e="";for(var t in n)n[t]&&(e&&(e+=" "),e+=t);return e}(n):"string"==typeof n?n:""}var mi={svg:"http://www.w3.org/2000/svg",math:"http://www.w3.org/1998/Math/MathML"},hi=v("html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,menuitem,summary,content,element,shadow,template,blockquote,iframe,tfoot"),fi=v("svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,foreignobject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view",!0),gi=function(n){return hi(n)||fi(n)};var bi=Object.create(null);var vi=v("text,number,password,search,email,tel,url");var xi=Object.freeze({__proto__:null,createElement:function(n,e){var t=document.createElement(n);return"select"!==n||e.data&&e.data.attrs&&void 0!==e.data.attrs.multiple&&t.setAttribute("multiple","multiple"),t},createElementNS:function(n,e){return document.createElementNS(mi[n],e)},createTextNode:function(n){return document.createTextNode(n)},createComment:function(n){return document.createComment(n)},insertBefore:function(n,e,t){n.insertBefore(e,t)},removeChild:function(n,e){n.removeChild(e)},appendChild:function(n,e){n.appendChild(e)},parentNode:function(n){return n.parentNode},nextSibling:function(n){return n.nextSibling},tagName:function(n){return n.tagName},setTextContent:function(n,e){n.textContent=e},setStyleScope:function(n,e){n.setAttribute(e,"")}}),yi={create:function(n,e){Ei(e)},update:function(n,e){n.data.ref!==e.data.ref&&(Ei(n,!0),Ei(e))},destroy:function(n){Ei(n,!0)}};function Ei(n,e){var t=n.data.ref;if(s(t)){var i=n.context,a=n.componentInstance||n.elm,o=e?null:a,l=e?void 0:a;if(d(t))Te(t,i,[o],i,"template ref function");else{var c=n.data.refInFor,u="string"==typeof t||"number"==typeof t,p=Gn(t),m=i.$refs;if(u||p)if(c){var h=u?m[t]:t.value;e?r(h)&&y(h,a):r(h)?h.includes(a)||h.push(a):u?(m[t]=[a],_i(i,t,m[t])):t.value=[a]}else if(u){if(e&&m[t]!==a)return;m[t]=l,_i(i,t,o)}else if(p){if(e&&t.value!==a)return;t.value=o}else 0}}}function _i(n,e,t){var i=n._setupState;i&&_(i,e)&&(Gn(i[e])?i[e].value=t:i[e]=t)}var ki=new mn("",{},[]),wi=["create","activate","update","remove","destroy"];function ji(n,e){return n.key===e.key&&n.asyncFactory===e.asyncFactory&&(n.tag===e.tag&&n.isComment===e.isComment&&s(n.data)===s(e.data)&&function(n,e){if("input"!==n.tag)return!0;var t,i=s(t=n.data)&&s(t=t.attrs)&&t.type,r=s(t=e.data)&&s(t=t.attrs)&&t.type;return i===r||vi(i)&&vi(r)}(n,e)||o(n.isAsyncPlaceholder)&&a(e.asyncFactory.error))}function Ai(n,e,t){var i,r,a={};for(i=e;i<=t;++i)s(r=n[i].key)&&(a[r]=i);return a}var Ti={create:Ci,update:Ci,destroy:function(n){Ci(n,ki)}};function Ci(n,e){(n.data.directives||e.data.directives)&&function(n,e){var t,i,r,a=n===ki,s=e===ki,o=Bi(n.data.directives,n.context),l=Bi(e.data.directives,e.context),d=[],c=[];for(t in l)i=o[t],r=l[t],i?(r.oldValue=i.value,r.oldArg=i.arg,Si(r,"update",e,n),r.def&&r.def.componentUpdated&&c.push(r)):(Si(r,"bind",e,n),r.def&&r.def.inserted&&d.push(r));if(d.length){var u=function(){for(var t=0;t<d.length;t++)Si(d[t],"inserted",e,n)};a?Zn(e,"insert",u):u()}c.length&&Zn(e,"postpatch",(function(){for(var t=0;t<c.length;t++)Si(c[t],"componentUpdated",e,n)}));if(!a)for(t in o)l[t]||Si(o[t],"unbind",n,n,s)}(n,e)}var zi=Object.create(null);function Bi(n,e){var t,i,r=Object.create(null);if(!n)return r;for(t=0;t<n.length;t++){if((i=n[t]).modifiers||(i.modifiers=zi),r[Ii(i)]=i,e._setupState&&e._setupState.__sfc){var a=i.def||Bt(e,"_setupState","v-"+i.name);i.def="function"==typeof a?{bind:a,update:a}:a}i.def=i.def||Bt(e.$options,"directives",i.name)}return r}function Ii(n){return n.rawName||"".concat(n.name,".").concat(Object.keys(n.modifiers||{}).join("."))}function Si(n,e,t,i,r){var a=n.def&&n.def[e];if(a)try{a(t.elm,n,t,i,r)}catch(i){Ae(i,t.context,"directive ".concat(n.name," ").concat(e," hook"))}}var Li=[yi,Ti];function Pi(n,e){var t=e.componentOptions;if(!(s(t)&&!1===t.Ctor.options.inheritAttrs||a(n.data.attrs)&&a(e.data.attrs))){var i,r,l=e.elm,d=n.data.attrs||{},c=e.data.attrs||{};for(i in(s(c.__ob__)||o(c._v_attr_proxy))&&(c=e.data.attrs=I({},c)),c)r=c[i],d[i]!==r&&qi(l,i,r,e.data.pre);for(i in(X||J)&&c.value!==d.value&&qi(l,"value",c.value),d)a(c[i])&&(si(i)?l.removeAttributeNS(ai,oi(i)):ti(i)||l.removeAttribute(i))}}function qi(n,e,t,i){i||n.tagName.indexOf("-")>-1?Ni(n,e,t):ri(e)?li(t)?n.removeAttribute(e):(t="allowfullscreen"===e&&"EMBED"===n.tagName?"true":e,n.setAttribute(e,t)):ti(e)?n.setAttribute(e,function(n,e){return li(e)||"false"===e?"false":"contenteditable"===n&&ii(e)?e:"true"}(e,t)):si(e)?li(t)?n.removeAttributeNS(ai,oi(e)):n.setAttributeNS(ai,e,t):Ni(n,e,t)}function Ni(n,e,t){if(li(t))n.removeAttribute(e);else{if(X&&!Y&&"TEXTAREA"===n.tagName&&"placeholder"===e&&""!==t&&!n.__ieph){var i=function(e){e.stopImmediatePropagation(),n.removeEventListener("input",i)};n.addEventListener("input",i),n.__ieph=!0}n.setAttribute(e,t)}}var $i={create:Pi,update:Pi};function Di(n,e){var t=e.elm,i=e.data,r=n.data;if(!(a(i.staticClass)&&a(i.class)&&(a(r)||a(r.staticClass)&&a(r.class)))){var o=di(e),l=t._transitionClasses;s(l)&&(o=ui(o,pi(l))),o!==t._prevClass&&(t.setAttribute("class",o),t._prevClass=o)}}var Gi,Fi={create:Di,update:Di};function Oi(n,e,t){var i=Gi;return function r(){var a=e.apply(null,arguments);null!==a&&Mi(n,r,t,i)}}var Ui=Ie&&!(en&&Number(en[1])<=53);function Ri(n,e,t,i){if(Ui){var r=ot,a=e;e=a._wrapper=function(n){if(n.target===n.currentTarget||n.timeStamp>=r||n.timeStamp<=0||n.target.ownerDocument!==document)return a.apply(this,arguments)}}Gi.addEventListener(n,e,rn?{capture:t,passive:i}:t)}function Mi(n,e,t,i){(i||Gi).removeEventListener(n,e._wrapper||e,t)}function Hi(n,e){if(!a(n.data.on)||!a(e.data.on)){var t=e.data.on||{},i=n.data.on||{};Gi=e.elm||n.elm,function(n){if(s(n.__r)){var e=X?"change":"input";n[e]=[].concat(n.__r,n[e]||[]),delete n.__r}s(n.__c)&&(n.change=[].concat(n.__c,n.change||[]),delete n.__c)}(t),Vn(t,i,Ri,Mi,Oi,e.context),Gi=void 0}}var Vi,Zi={create:Hi,update:Hi,destroy:function(n){return Hi(n,ki)}};function Wi(n,e){if(!a(n.data.domProps)||!a(e.data.domProps)){var t,i,r=e.elm,l=n.data.domProps||{},d=e.data.domProps||{};for(t in(s(d.__ob__)||o(d._v_attr_proxy))&&(d=e.data.domProps=I({},d)),l)t in d||(r[t]="");for(t in d){if(i=d[t],"textContent"===t||"innerHTML"===t){if(e.children&&(e.children.length=0),i===l[t])continue;1===r.childNodes.length&&r.removeChild(r.childNodes[0])}if("value"===t&&"PROGRESS"!==r.tagName){r._value=i;var c=a(i)?"":String(i);Ki(r,c)&&(r.value=c)}else if("innerHTML"===t&&fi(r.tagName)&&a(r.innerHTML)){(Vi=Vi||document.createElement("div")).innerHTML="<svg>".concat(i,"</svg>");for(var u=Vi.firstChild;r.firstChild;)r.removeChild(r.firstChild);for(;u.firstChild;)r.appendChild(u.firstChild)}else if(i!==l[t])try{r[t]=i}catch(n){}}}}function Ki(n,e){return!n.composing&&("OPTION"===n.tagName||function(n,e){var t=!0;try{t=document.activeElement!==n}catch(n){}return t&&n.value!==e}(n,e)||function(n,e){var t=n.value,i=n._vModifiers;if(s(i)){if(i.number)return b(t)!==b(e);if(i.trim)return t.trim()!==e.trim()}return t!==e}(n,e))}var Xi={create:Wi,update:Wi},Yi=k((function(n){var e={},t=/:(.+)/;return n.split(/;(?![^(]*\))/g).forEach((function(n){if(n){var i=n.split(t);i.length>1&&(e[i[0].trim()]=i[1].trim())}})),e}));function Ji(n){var e=Qi(n.style);return n.staticStyle?I(n.staticStyle,e):e}function Qi(n){return Array.isArray(n)?S(n):"string"==typeof n?Yi(n):n}var nr,er=/^--/,tr=/\s*!important$/,ir=function(n,e,t){if(er.test(e))n.style.setProperty(e,t);else if(tr.test(t))n.style.setProperty(C(e),t.replace(tr,""),"important");else{var i=ar(e);if(Array.isArray(t))for(var r=0,a=t.length;r<a;r++)n.style[i]=t[r];else n.style[i]=t}},rr=["Webkit","Moz","ms"],ar=k((function(n){if(nr=nr||document.createElement("div").style,"filter"!==(n=j(n))&&n in nr)return n;for(var e=n.charAt(0).toUpperCase()+n.slice(1),t=0;t<rr.length;t++){var i=rr[t]+e;if(i in nr)return i}}));function sr(n,e){var t=e.data,i=n.data;if(!(a(t.staticStyle)&&a(t.style)&&a(i.staticStyle)&&a(i.style))){var r,o,l=e.elm,d=i.staticStyle,c=i.normalizedStyle||i.style||{},u=d||c,p=Qi(e.data.style)||{};e.data.normalizedStyle=s(p.__ob__)?I({},p):p;var m=function(n,e){var t,i={};if(e)for(var r=n;r.componentInstance;)(r=r.componentInstance._vnode)&&r.data&&(t=Ji(r.data))&&I(i,t);(t=Ji(n.data))&&I(i,t);for(var a=n;a=a.parent;)a.data&&(t=Ji(a.data))&&I(i,t);return i}(e,!0);for(o in u)a(m[o])&&ir(l,o,"");for(o in m)(r=m[o])!==u[o]&&ir(l,o,null==r?"":r)}}var or={create:sr,update:sr},lr=/\s+/;function dr(n,e){if(e&&(e=e.trim()))if(n.classList)e.indexOf(" ")>-1?e.split(lr).forEach((function(e){return n.classList.add(e)})):n.classList.add(e);else{var t=" ".concat(n.getAttribute("class")||""," ");t.indexOf(" "+e+" ")<0&&n.setAttribute("class",(t+e).trim())}}function cr(n,e){if(e&&(e=e.trim()))if(n.classList)e.indexOf(" ")>-1?e.split(lr).forEach((function(e){return n.classList.remove(e)})):n.classList.remove(e),n.classList.length||n.removeAttribute("class");else{for(var t=" ".concat(n.getAttribute("class")||""," "),i=" "+e+" ";t.indexOf(i)>=0;)t=t.replace(i," ");(t=t.trim())?n.setAttribute("class",t):n.removeAttribute("class")}}function ur(n){if(n){if("object"==typeof n){var e={};return!1!==n.css&&I(e,pr(n.name||"v")),I(e,n),e}return"string"==typeof n?pr(n):void 0}}var pr=k((function(n){return{enterClass:"".concat(n,"-enter"),enterToClass:"".concat(n,"-enter-to"),enterActiveClass:"".concat(n,"-enter-active"),leaveClass:"".concat(n,"-leave"),leaveToClass:"".concat(n,"-leave-to"),leaveActiveClass:"".concat(n,"-leave-active")}})),mr=W&&!Y,hr="transition",fr="transitionend",gr="animation",br="animationend";mr&&(void 0===window.ontransitionend&&void 0!==window.onwebkittransitionend&&(hr="WebkitTransition",fr="webkitTransitionEnd"),void 0===window.onanimationend&&void 0!==window.onwebkitanimationend&&(gr="WebkitAnimation",br="webkitAnimationEnd"));var vr=W?window.requestAnimationFrame?window.requestAnimationFrame.bind(window):setTimeout:function(n){return n()};function xr(n){vr((function(){vr(n)}))}function yr(n,e){var t=n._transitionClasses||(n._transitionClasses=[]);t.indexOf(e)<0&&(t.push(e),dr(n,e))}function Er(n,e){n._transitionClasses&&y(n._transitionClasses,e),cr(n,e)}function _r(n,e,t){var i=wr(n,e),r=i.type,a=i.timeout,s=i.propCount;if(!r)return t();var o="transition"===r?fr:br,l=0,d=function(){n.removeEventListener(o,c),t()},c=function(e){e.target===n&&++l>=s&&d()};setTimeout((function(){l<s&&d()}),a+1),n.addEventListener(o,c)}var kr=/\b(transform|all)(,|$)/;function wr(n,e){var t,i=window.getComputedStyle(n),r=(i[hr+"Delay"]||"").split(", "),a=(i[hr+"Duration"]||"").split(", "),s=jr(r,a),o=(i[gr+"Delay"]||"").split(", "),l=(i[gr+"Duration"]||"").split(", "),d=jr(o,l),c=0,u=0;return"transition"===e?s>0&&(t="transition",c=s,u=a.length):"animation"===e?d>0&&(t="animation",c=d,u=l.length):u=(t=(c=Math.max(s,d))>0?s>d?"transition":"animation":null)?"transition"===t?a.length:l.length:0,{type:t,timeout:c,propCount:u,hasTransform:"transition"===t&&kr.test(i[hr+"Property"])}}function jr(n,e){for(;n.length<e.length;)n=n.concat(n);return Math.max.apply(null,e.map((function(e,t){return Ar(e)+Ar(n[t])})))}function Ar(n){return 1e3*Number(n.slice(0,-1).replace(",","."))}function Tr(n,e){var t=n.elm;s(t._leaveCb)&&(t._leaveCb.cancelled=!0,t._leaveCb());var i=ur(n.data.transition);if(!a(i)&&!s(t._enterCb)&&1===t.nodeType){for(var r=i.css,o=i.type,l=i.enterClass,u=i.enterToClass,p=i.enterActiveClass,m=i.appearClass,h=i.appearToClass,f=i.appearActiveClass,g=i.beforeEnter,v=i.enter,x=i.afterEnter,y=i.enterCancelled,E=i.beforeAppear,_=i.appear,k=i.afterAppear,w=i.appearCancelled,j=i.duration,A=Xe,T=Xe.$vnode;T&&T.parent;)A=T.context,T=T.parent;var C=!A._isMounted||!n.isRootInsert;if(!C||_||""===_){var z=C&&m?m:l,B=C&&f?f:p,I=C&&h?h:u,S=C&&E||g,L=C&&d(_)?_:v,P=C&&k||x,q=C&&w||y,N=b(c(j)?j.enter:j);0;var $=!1!==r&&!Y,G=Br(L),F=t._enterCb=D((function(){$&&(Er(t,I),Er(t,B)),F.cancelled?($&&Er(t,z),q&&q(t)):P&&P(t),t._enterCb=null}));n.data.show||Zn(n,"insert",(function(){var e=t.parentNode,i=e&&e._pending&&e._pending[n.key];i&&i.tag===n.tag&&i.elm._leaveCb&&i.elm._leaveCb(),L&&L(t,F)})),S&&S(t),$&&(yr(t,z),yr(t,B),xr((function(){Er(t,z),F.cancelled||(yr(t,I),G||(zr(N)?setTimeout(F,N):_r(t,o,F)))}))),n.data.show&&(e&&e(),L&&L(t,F)),$||G||F()}}}function Cr(n,e){var t=n.elm;s(t._enterCb)&&(t._enterCb.cancelled=!0,t._enterCb());var i=ur(n.data.transition);if(a(i)||1!==t.nodeType)return e();if(!s(t._leaveCb)){var r=i.css,o=i.type,l=i.leaveClass,d=i.leaveToClass,u=i.leaveActiveClass,p=i.beforeLeave,m=i.leave,h=i.afterLeave,f=i.leaveCancelled,g=i.delayLeave,v=i.duration,x=!1!==r&&!Y,y=Br(m),E=b(c(v)?v.leave:v);0;var _=t._leaveCb=D((function(){t.parentNode&&t.parentNode._pending&&(t.parentNode._pending[n.key]=null),x&&(Er(t,d),Er(t,u)),_.cancelled?(x&&Er(t,l),f&&f(t)):(e(),h&&h(t)),t._leaveCb=null}));g?g(k):k()}function k(){_.cancelled||(!n.data.show&&t.parentNode&&((t.parentNode._pending||(t.parentNode._pending={}))[n.key]=n),p&&p(t),x&&(yr(t,l),yr(t,u),xr((function(){Er(t,l),_.cancelled||(yr(t,d),y||(zr(E)?setTimeout(_,E):_r(t,o,_)))}))),m&&m(t,_),x||y||_())}}function zr(n){return"number"==typeof n&&!isNaN(n)}function Br(n){if(a(n))return!1;var e=n.fns;return s(e)?Br(Array.isArray(e)?e[0]:e):(n._length||n.length)>1}function Ir(n,e){!0!==e.data.show&&Tr(e)}var Sr=function(n){var e,t,i={},d=n.modules,c=n.nodeOps;for(e=0;e<wi.length;++e)for(i[wi[e]]=[],t=0;t<d.length;++t)s(d[t][wi[e]])&&i[wi[e]].push(d[t][wi[e]]);function u(n){var e=c.parentNode(n);s(e)&&c.removeChild(e,n)}function p(n,e,t,r,a,l,d){if(s(n.elm)&&s(l)&&(n=l[d]=gn(n)),n.isRootInsert=!a,!function(n,e,t,r){var a=n.data;if(s(a)){var l=s(n.componentInstance)&&a.keepAlive;if(s(a=a.hook)&&s(a=a.init)&&a(n,!1),s(n.componentInstance))return m(n,e),h(t,n.elm,r),o(l)&&function(n,e,t,r){var a,o=n;for(;o.componentInstance;)if(o=o.componentInstance._vnode,s(a=o.data)&&s(a=a.transition)){for(a=0;a<i.activate.length;++a)i.activate[a](ki,o);e.push(o);break}h(t,n.elm,r)}(n,e,t,r),!0}}(n,e,t,r)){var u=n.data,p=n.children,g=n.tag;s(g)?(n.elm=n.ns?c.createElementNS(n.ns,g):c.createElement(g,n),x(n),f(n,p,e),s(u)&&b(n,e),h(t,n.elm,r)):o(n.isComment)?(n.elm=c.createComment(n.text),h(t,n.elm,r)):(n.elm=c.createTextNode(n.text),h(t,n.elm,r))}}function m(n,e){s(n.data.pendingInsert)&&(e.push.apply(e,n.data.pendingInsert),n.data.pendingInsert=null),n.elm=n.componentInstance.$el,g(n)?(b(n,e),x(n)):(Ei(n),e.push(n))}function h(n,e,t){s(n)&&(s(t)?c.parentNode(t)===n&&c.insertBefore(n,e,t):c.appendChild(n,e))}function f(n,e,t){if(r(e)){0;for(var i=0;i<e.length;++i)p(e[i],t,n.elm,null,!0,e,i)}else l(n.text)&&c.appendChild(n.elm,c.createTextNode(String(n.text)))}function g(n){for(;n.componentInstance;)n=n.componentInstance._vnode;return s(n.tag)}function b(n,t){for(var r=0;r<i.create.length;++r)i.create[r](ki,n);s(e=n.data.hook)&&(s(e.create)&&e.create(ki,n),s(e.insert)&&t.push(n))}function x(n){var e;if(s(e=n.fnScopeId))c.setStyleScope(n.elm,e);else for(var t=n;t;)s(e=t.context)&&s(e=e.$options._scopeId)&&c.setStyleScope(n.elm,e),t=t.parent;s(e=Xe)&&e!==n.context&&e!==n.fnContext&&s(e=e.$options._scopeId)&&c.setStyleScope(n.elm,e)}function y(n,e,t,i,r,a){for(;i<=r;++i)p(t[i],a,n,e,!1,t,i)}function E(n){var e,t,r=n.data;if(s(r))for(s(e=r.hook)&&s(e=e.destroy)&&e(n),e=0;e<i.destroy.length;++e)i.destroy[e](n);if(s(e=n.children))for(t=0;t<n.children.length;++t)E(n.children[t])}function _(n,e,t){for(;e<=t;++e){var i=n[e];s(i)&&(s(i.tag)?(k(i),E(i)):u(i.elm))}}function k(n,e){if(s(e)||s(n.data)){var t,r=i.remove.length+1;for(s(e)?e.listeners+=r:e=function(n,e){function t(){0==--t.listeners&&u(n)}return t.listeners=e,t}(n.elm,r),s(t=n.componentInstance)&&s(t=t._vnode)&&s(t.data)&&k(t,e),t=0;t<i.remove.length;++t)i.remove[t](n,e);s(t=n.data.hook)&&s(t=t.remove)?t(n,e):e()}else u(n.elm)}function w(n,e,t,i){for(var r=t;r<i;r++){var a=e[r];if(s(a)&&ji(n,a))return r}}function j(n,e,t,r,l,d){if(n!==e){s(e.elm)&&s(r)&&(e=r[l]=gn(e));var u=e.elm=n.elm;if(o(n.isAsyncPlaceholder))s(e.asyncFactory.resolved)?C(n.elm,e,t):e.isAsyncPlaceholder=!0;else if(o(e.isStatic)&&o(n.isStatic)&&e.key===n.key&&(o(e.isCloned)||o(e.isOnce)))e.componentInstance=n.componentInstance;else{var m,h=e.data;s(h)&&s(m=h.hook)&&s(m=m.prepatch)&&m(n,e);var f=n.children,b=e.children;if(s(h)&&g(e)){for(m=0;m<i.update.length;++m)i.update[m](n,e);s(m=h.hook)&&s(m=m.update)&&m(n,e)}a(e.text)?s(f)&&s(b)?f!==b&&function(n,e,t,i,r){var o,l,d,u=0,m=0,h=e.length-1,f=e[0],g=e[h],b=t.length-1,v=t[0],x=t[b],E=!r;for(0;u<=h&&m<=b;)a(f)?f=e[++u]:a(g)?g=e[--h]:ji(f,v)?(j(f,v,i,t,m),f=e[++u],v=t[++m]):ji(g,x)?(j(g,x,i,t,b),g=e[--h],x=t[--b]):ji(f,x)?(j(f,x,i,t,b),E&&c.insertBefore(n,f.elm,c.nextSibling(g.elm)),f=e[++u],x=t[--b]):ji(g,v)?(j(g,v,i,t,m),E&&c.insertBefore(n,g.elm,f.elm),g=e[--h],v=t[++m]):(a(o)&&(o=Ai(e,u,h)),a(l=s(v.key)?o[v.key]:w(v,e,u,h))?p(v,i,n,f.elm,!1,t,m):ji(d=e[l],v)?(j(d,v,i,t,m),e[l]=void 0,E&&c.insertBefore(n,d.elm,f.elm)):p(v,i,n,f.elm,!1,t,m),v=t[++m]);u>h?y(n,a(t[b+1])?null:t[b+1].elm,t,m,b,i):m>b&&_(e,u,h)}(u,f,b,t,d):s(b)?(s(n.text)&&c.setTextContent(u,""),y(u,null,b,0,b.length-1,t)):s(f)?_(f,0,f.length-1):s(n.text)&&c.setTextContent(u,""):n.text!==e.text&&c.setTextContent(u,e.text),s(h)&&s(m=h.hook)&&s(m=m.postpatch)&&m(n,e)}}}function A(n,e,t){if(o(t)&&s(n.parent))n.parent.data.pendingInsert=e;else for(var i=0;i<e.length;++i)e[i].data.hook.insert(e[i])}var T=v("attrs,class,staticClass,staticStyle,key");function C(n,e,t,i){var r,a=e.tag,l=e.data,d=e.children;if(i=i||l&&l.pre,e.elm=n,o(e.isComment)&&s(e.asyncFactory))return e.isAsyncPlaceholder=!0,!0;if(s(l)&&(s(r=l.hook)&&s(r=r.init)&&r(e,!0),s(r=e.componentInstance)))return m(e,t),!0;if(s(a)){if(s(d))if(n.hasChildNodes())if(s(r=l)&&s(r=r.domProps)&&s(r=r.innerHTML)){if(r!==n.innerHTML)return!1}else{for(var c=!0,u=n.firstChild,p=0;p<d.length;p++){if(!u||!C(u,d[p],t,i)){c=!1;break}u=u.nextSibling}if(!c||u)return!1}else f(e,d,t);if(s(l)){var h=!1;for(var g in l)if(!T(g)){h=!0,b(e,t);break}!h&&l.class&&Ue(l.class)}}else n.data!==e.text&&(n.data=e.text);return!0}return function(n,e,t,r){if(!a(e)){var l,d=!1,u=[];if(a(n))d=!0,p(e,u);else{var m=s(n.nodeType);if(!m&&ji(n,e))j(n,e,u,null,null,r);else{if(m){if(1===n.nodeType&&n.hasAttribute("data-server-rendered")&&(n.removeAttribute("data-server-rendered"),t=!0),o(t)&&C(n,e,u))return A(e,u,!0),n;l=n,n=new mn(c.tagName(l).toLowerCase(),{},[],void 0,l)}var h=n.elm,f=c.parentNode(h);if(p(e,u,h._leaveCb?null:f,c.nextSibling(h)),s(e.parent))for(var b=e.parent,v=g(e);b;){for(var x=0;x<i.destroy.length;++x)i.destroy[x](b);if(b.elm=e.elm,v){for(var y=0;y<i.create.length;++y)i.create[y](ki,b);var k=b.data.hook.insert;if(k.merged)for(var w=1;w<k.fns.length;w++)k.fns[w]()}else Ei(b);b=b.parent}s(f)?_([n],0,0):s(n.tag)&&E(n)}}return A(e,u,d),e.elm}s(n)&&E(n)}}({nodeOps:xi,modules:[$i,Fi,Zi,Xi,or,W?{create:Ir,activate:Ir,remove:function(n,e){!0!==n.data.show?Cr(n,e):e()}}:{}].concat(Li)});Y&&document.addEventListener("selectionchange",(function(){var n=document.activeElement;n&&n.vmodel&&Fr(n,"input")}));var Lr={inserted:function(n,e,t,i){"select"===t.tag?(i.elm&&!i.elm._vOptions?Zn(t,"postpatch",(function(){Lr.componentUpdated(n,e,t)})):Pr(n,e,t.context),n._vOptions=[].map.call(n.options,$r)):("textarea"===t.tag||vi(n.type))&&(n._vModifiers=e.modifiers,e.modifiers.lazy||(n.addEventListener("compositionstart",Dr),n.addEventListener("compositionend",Gr),n.addEventListener("change",Gr),Y&&(n.vmodel=!0)))},componentUpdated:function(n,e,t){if("select"===t.tag){Pr(n,e,t.context);var i=n._vOptions,r=n._vOptions=[].map.call(n.options,$r);if(r.some((function(n,e){return!N(n,i[e])})))(n.multiple?e.value.some((function(n){return Nr(n,r)})):e.value!==e.oldValue&&Nr(e.value,r))&&Fr(n,"change")}}};function Pr(n,e,t){qr(n,e,t),(X||J)&&setTimeout((function(){qr(n,e,t)}),0)}function qr(n,e,t){var i=e.value,r=n.multiple;if(!r||Array.isArray(i)){for(var a,s,o=0,l=n.options.length;o<l;o++)if(s=n.options[o],r)a=$(i,$r(s))>-1,s.selected!==a&&(s.selected=a);else if(N($r(s),i))return void(n.selectedIndex!==o&&(n.selectedIndex=o));r||(n.selectedIndex=-1)}}function Nr(n,e){return e.every((function(e){return!N(e,n)}))}function $r(n){return"_value"in n?n._value:n.value}function Dr(n){n.target.composing=!0}function Gr(n){n.target.composing&&(n.target.composing=!1,Fr(n.target,"input"))}function Fr(n,e){var t=document.createEvent("HTMLEvents");t.initEvent(e,!0,!0),n.dispatchEvent(t)}function Or(n){return!n.componentInstance||n.data&&n.data.transition?n:Or(n.componentInstance._vnode)}var Ur={model:Lr,show:{bind:function(n,e,t){var i=e.value,r=(t=Or(t)).data&&t.data.transition,a=n.__vOriginalDisplay="none"===n.style.display?"":n.style.display;i&&r?(t.data.show=!0,Tr(t,(function(){n.style.display=a}))):n.style.display=i?a:"none"},update:function(n,e,t){var i=e.value;!i!=!e.oldValue&&((t=Or(t)).data&&t.data.transition?(t.data.show=!0,i?Tr(t,(function(){n.style.display=n.__vOriginalDisplay})):Cr(t,(function(){n.style.display="none"}))):n.style.display=i?n.__vOriginalDisplay:"none")},unbind:function(n,e,t,i,r){r||(n.style.display=n.__vOriginalDisplay)}}},Rr={name:String,appear:Boolean,css:Boolean,mode:String,type:String,enterClass:String,leaveClass:String,enterToClass:String,leaveToClass:String,enterActiveClass:String,leaveActiveClass:String,appearClass:String,appearActiveClass:String,appearToClass:String,duration:[Number,String,Object]};function Mr(n){var e=n&&n.componentOptions;return e&&e.Ctor.options.abstract?Mr(we(e.children)):n}function Hr(n){var e={},t=n.$options;for(var i in t.propsData)e[i]=n[i];var r=t._parentListeners;for(var i in r)e[j(i)]=r[i];return e}function Vr(n,e){if(/\d-keep-alive$/.test(e.tag))return n("keep-alive",{props:e.componentOptions.propsData})}var Zr=function(n){return n.tag||he(n)},Wr=function(n){return"show"===n.name},Kr={name:"transition",props:Rr,abstract:!0,render:function(n){var e=this,t=this.$slots.default;if(t&&(t=t.filter(Zr)).length){0;var i=this.mode;0;var r=t[0];if(function(n){for(;n=n.parent;)if(n.data.transition)return!0}(this.$vnode))return r;var a=Mr(r);if(!a)return r;if(this._leaving)return Vr(n,r);var s="__transition-".concat(this._uid,"-");a.key=null==a.key?a.isComment?s+"comment":s+a.tag:l(a.key)?0===String(a.key).indexOf(s)?a.key:s+a.key:a.key;var o=(a.data||(a.data={})).transition=Hr(this),d=this._vnode,c=Mr(d);if(a.data.directives&&a.data.directives.some(Wr)&&(a.data.show=!0),c&&c.data&&!function(n,e){return e.key===n.key&&e.tag===n.tag}(a,c)&&!he(c)&&(!c.componentInstance||!c.componentInstance._vnode.isComment)){var u=c.data.transition=I({},o);if("out-in"===i)return this._leaving=!0,Zn(u,"afterLeave",(function(){e._leaving=!1,e.$forceUpdate()})),Vr(n,r);if("in-out"===i){if(he(a))return d;var p,m=function(){p()};Zn(o,"afterEnter",m),Zn(o,"enterCancelled",m),Zn(u,"delayLeave",(function(n){p=n}))}}return r}}},Xr=I({tag:String,moveClass:String},Rr);function Yr(n){n.elm._moveCb&&n.elm._moveCb(),n.elm._enterCb&&n.elm._enterCb()}function Jr(n){n.data.newPos=n.elm.getBoundingClientRect()}function Qr(n){var e=n.data.pos,t=n.data.newPos,i=e.left-t.left,r=e.top-t.top;if(i||r){n.data.moved=!0;var a=n.elm.style;a.transform=a.WebkitTransform="translate(".concat(i,"px,").concat(r,"px)"),a.transitionDuration="0s"}}delete Xr.mode;var na={Transition:Kr,TransitionGroup:{props:Xr,beforeMount:function(){var n=this,e=this._update;this._update=function(t,i){var r=Ye(n);n.__patch__(n._vnode,n.kept,!1,!0),n._vnode=n.kept,r(),e.call(n,t,i)}},render:function(n){for(var e=this.tag||this.$vnode.data.tag||"span",t=Object.create(null),i=this.prevChildren=this.children,r=this.$slots.default||[],a=this.children=[],s=Hr(this),o=0;o<r.length;o++){if((c=r[o]).tag)if(null!=c.key&&0!==String(c.key).indexOf("__vlist"))a.push(c),t[c.key]=c,(c.data||(c.data={})).transition=s;else;}if(i){var l=[],d=[];for(o=0;o<i.length;o++){var c;(c=i[o]).data.transition=s,c.data.pos=c.elm.getBoundingClientRect(),t[c.key]?l.push(c):d.push(c)}this.kept=n(e,null,l),this.removed=d}return n(e,null,a)},updated:function(){var n=this.prevChildren,e=this.moveClass||(this.name||"v")+"-move";n.length&&this.hasMove(n[0].elm,e)&&(n.forEach(Yr),n.forEach(Jr),n.forEach(Qr),this._reflow=document.body.offsetHeight,n.forEach((function(n){if(n.data.moved){var t=n.elm,i=t.style;yr(t,e),i.transform=i.WebkitTransform=i.transitionDuration="",t.addEventListener(fr,t._moveCb=function n(i){i&&i.target!==t||i&&!/transform$/.test(i.propertyName)||(t.removeEventListener(fr,n),t._moveCb=null,Er(t,e))})}})))},methods:{hasMove:function(n,e){if(!mr)return!1;if(this._hasMove)return this._hasMove;var t=n.cloneNode();n._transitionClasses&&n._transitionClasses.forEach((function(n){cr(t,n)})),dr(t,e),t.style.display="none",this.$el.appendChild(t);var i=wr(t);return this.$el.removeChild(t),this._hasMove=i.hasTransform}}}};function ea(n,e){for(var t in e)n[t]=e[t];return n}Vt.config.mustUseProp=function(n,e,t){return"value"===t&&ei(n)&&"button"!==e||"selected"===t&&"option"===n||"checked"===t&&"input"===n||"muted"===t&&"video"===n},Vt.config.isReservedTag=gi,Vt.config.isReservedAttr=ni,Vt.config.getTagNamespace=function(n){return fi(n)?"svg":"math"===n?"math":void 0},Vt.config.isUnknownElement=function(n){if(!W)return!0;if(gi(n))return!1;if(n=n.toLowerCase(),null!=bi[n])return bi[n];var e=document.createElement(n);return n.indexOf("-")>-1?bi[n]=e.constructor===window.HTMLUnknownElement||e.constructor===window.HTMLElement:bi[n]=/HTMLUnknownElement/.test(e.toString())},I(Vt.options.directives,Ur),I(Vt.options.components,na),Vt.prototype.__patch__=W?Sr:L,Vt.prototype.$mount=function(n,e){return function(n,e,t){var i;n.$el=e,n.$options.render||(n.$options.render=hn),nt(n,"beforeMount"),i=function(){n._update(n._render(),t)},new He(n,i,L,{before:function(){n._isMounted&&!n._isDestroyed&&nt(n,"beforeUpdate")}},!0),t=!1;var r=n._preWatchers;if(r)for(var a=0;a<r.length;a++)r[a].run();return null==n.$vnode&&(n._isMounted=!0,nt(n,"mounted")),n}(this,n=n&&W?function(n){if("string"==typeof n){var e=document.querySelector(n);return e||document.createElement("div")}return n}(n):void 0,e)},W&&setTimeout((function(){U.devtools&&on&&on.emit("init",Vt)}),0);var ta=/[!'()*]/g,ia=function(n){return"%"+n.charCodeAt(0).toString(16)},ra=/%2C/g,aa=function(n){return encodeURIComponent(n).replace(ta,ia).replace(ra,",")};function sa(n){try{return decodeURIComponent(n)}catch(n){0}return n}var oa=function(n){return null==n||"object"==typeof n?n:String(n)};function la(n){var e={};return(n=n.trim().replace(/^(\?|#|&)/,""))?(n.split("&").forEach((function(n){var t=n.replace(/\+/g," ").split("="),i=sa(t.shift()),r=t.length>0?sa(t.join("=")):null;void 0===e[i]?e[i]=r:Array.isArray(e[i])?e[i].push(r):e[i]=[e[i],r]})),e):e}function da(n){var e=n?Object.keys(n).map((function(e){var t=n[e];if(void 0===t)return"";if(null===t)return aa(e);if(Array.isArray(t)){var i=[];return t.forEach((function(n){void 0!==n&&(null===n?i.push(aa(e)):i.push(aa(e)+"="+aa(n)))})),i.join("&")}return aa(e)+"="+aa(t)})).filter((function(n){return n.length>0})).join("&"):null;return e?"?"+e:""}var ca=/\/?$/;function ua(n,e,t,i){var r=i&&i.options.stringifyQuery,a=e.query||{};try{a=pa(a)}catch(n){}var s={name:e.name||n&&n.name,meta:n&&n.meta||{},path:e.path||"/",hash:e.hash||"",query:a,params:e.params||{},fullPath:fa(e,r),matched:n?ha(n):[]};return t&&(s.redirectedFrom=fa(t,r)),Object.freeze(s)}function pa(n){if(Array.isArray(n))return n.map(pa);if(n&&"object"==typeof n){var e={};for(var t in n)e[t]=pa(n[t]);return e}return n}var ma=ua(null,{path:"/"});function ha(n){for(var e=[];n;)e.unshift(n),n=n.parent;return e}function fa(n,e){var t=n.path,i=n.query;void 0===i&&(i={});var r=n.hash;return void 0===r&&(r=""),(t||"/")+(e||da)(i)+r}function ga(n,e,t){return e===ma?n===e:!!e&&(n.path&&e.path?n.path.replace(ca,"")===e.path.replace(ca,"")&&(t||n.hash===e.hash&&ba(n.query,e.query)):!(!n.name||!e.name)&&(n.name===e.name&&(t||n.hash===e.hash&&ba(n.query,e.query)&&ba(n.params,e.params))))}function ba(n,e){if(void 0===n&&(n={}),void 0===e&&(e={}),!n||!e)return n===e;var t=Object.keys(n).sort(),i=Object.keys(e).sort();return t.length===i.length&&t.every((function(t,r){var a=n[t];if(i[r]!==t)return!1;var s=e[t];return null==a||null==s?a===s:"object"==typeof a&&"object"==typeof s?ba(a,s):String(a)===String(s)}))}function va(n){for(var e=0;e<n.matched.length;e++){var t=n.matched[e];for(var i in t.instances){var r=t.instances[i],a=t.enteredCbs[i];if(r&&a){delete t.enteredCbs[i];for(var s=0;s<a.length;s++)r._isBeingDestroyed||a[s](r)}}}}var xa={name:"RouterView",functional:!0,props:{name:{type:String,default:"default"}},render:function(n,e){var t=e.props,i=e.children,r=e.parent,a=e.data;a.routerView=!0;for(var s=r.$createElement,o=t.name,l=r.$route,d=r._routerViewCache||(r._routerViewCache={}),c=0,u=!1;r&&r._routerRoot!==r;){var p=r.$vnode?r.$vnode.data:{};p.routerView&&c++,p.keepAlive&&r._directInactive&&r._inactive&&(u=!0),r=r.$parent}if(a.routerViewDepth=c,u){var m=d[o],h=m&&m.component;return h?(m.configProps&&ya(h,a,m.route,m.configProps),s(h,a,i)):s()}var f=l.matched[c],g=f&&f.components[o];if(!f||!g)return d[o]=null,s();d[o]={component:g},a.registerRouteInstance=function(n,e){var t=f.instances[o];(e&&t!==n||!e&&t===n)&&(f.instances[o]=e)},(a.hook||(a.hook={})).prepatch=function(n,e){f.instances[o]=e.componentInstance},a.hook.init=function(n){n.data.keepAlive&&n.componentInstance&&n.componentInstance!==f.instances[o]&&(f.instances[o]=n.componentInstance),va(l)};var b=f.props&&f.props[o];return b&&(ea(d[o],{route:l,configProps:b}),ya(g,a,l,b)),s(g,a,i)}};function ya(n,e,t,i){var r=e.props=function(n,e){switch(typeof e){case"undefined":return;case"object":return e;case"function":return e(n);case"boolean":return e?n.params:void 0;default:0}}(t,i);if(r){r=e.props=ea({},r);var a=e.attrs=e.attrs||{};for(var s in r)n.props&&s in n.props||(a[s]=r[s],delete r[s])}}function Ea(n,e,t){var i=n.charAt(0);if("/"===i)return n;if("?"===i||"#"===i)return e+n;var r=e.split("/");t&&r[r.length-1]||r.pop();for(var a=n.replace(/^\//,"").split("/"),s=0;s<a.length;s++){var o=a[s];".."===o?r.pop():"."!==o&&r.push(o)}return""!==r[0]&&r.unshift(""),r.join("/")}function _a(n){return n.replace(/\/(?:\s*\/)+/g,"/")}var ka=Array.isArray||function(n){return"[object Array]"==Object.prototype.toString.call(n)},wa=Da,ja=Ba,Aa=function(n,e){return Sa(Ba(n,e),e)},Ta=Sa,Ca=$a,za=new RegExp(["(\\\\.)","([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))"].join("|"),"g");function Ba(n,e){for(var t,i=[],r=0,a=0,s="",o=e&&e.delimiter||"/";null!=(t=za.exec(n));){var l=t[0],d=t[1],c=t.index;if(s+=n.slice(a,c),a=c+l.length,d)s+=d[1];else{var u=n[a],p=t[2],m=t[3],h=t[4],f=t[5],g=t[6],b=t[7];s&&(i.push(s),s="");var v=null!=p&&null!=u&&u!==p,x="+"===g||"*"===g,y="?"===g||"*"===g,E=t[2]||o,_=h||f;i.push({name:m||r++,prefix:p||"",delimiter:E,optional:y,repeat:x,partial:v,asterisk:!!b,pattern:_?Pa(_):b?".*":"[^"+La(E)+"]+?"})}}return a<n.length&&(s+=n.substr(a)),s&&i.push(s),i}function Ia(n){return encodeURI(n).replace(/[\/?#]/g,(function(n){return"%"+n.charCodeAt(0).toString(16).toUpperCase()}))}function Sa(n,e){for(var t=new Array(n.length),i=0;i<n.length;i++)"object"==typeof n[i]&&(t[i]=new RegExp("^(?:"+n[i].pattern+")$",Na(e)));return function(e,i){for(var r="",a=e||{},s=(i||{}).pretty?Ia:encodeURIComponent,o=0;o<n.length;o++){var l=n[o];if("string"!=typeof l){var d,c=a[l.name];if(null==c){if(l.optional){l.partial&&(r+=l.prefix);continue}throw new TypeError('Expected "'+l.name+'" to be defined')}if(ka(c)){if(!l.repeat)throw new TypeError('Expected "'+l.name+'" to not repeat, but received `'+JSON.stringify(c)+"`");if(0===c.length){if(l.optional)continue;throw new TypeError('Expected "'+l.name+'" to not be empty')}for(var u=0;u<c.length;u++){if(d=s(c[u]),!t[o].test(d))throw new TypeError('Expected all "'+l.name+'" to match "'+l.pattern+'", but received `'+JSON.stringify(d)+"`");r+=(0===u?l.prefix:l.delimiter)+d}}else{if(d=l.asterisk?encodeURI(c).replace(/[?#]/g,(function(n){return"%"+n.charCodeAt(0).toString(16).toUpperCase()})):s(c),!t[o].test(d))throw new TypeError('Expected "'+l.name+'" to match "'+l.pattern+'", but received "'+d+'"');r+=l.prefix+d}}else r+=l}return r}}function La(n){return n.replace(/([.+*?=^!:${}()[\]|\/\\])/g,"\\$1")}function Pa(n){return n.replace(/([=!:$\/()])/g,"\\$1")}function qa(n,e){return n.keys=e,n}function Na(n){return n&&n.sensitive?"":"i"}function $a(n,e,t){ka(e)||(t=e||t,e=[]);for(var i=(t=t||{}).strict,r=!1!==t.end,a="",s=0;s<n.length;s++){var o=n[s];if("string"==typeof o)a+=La(o);else{var l=La(o.prefix),d="(?:"+o.pattern+")";e.push(o),o.repeat&&(d+="(?:"+l+d+")*"),a+=d=o.optional?o.partial?l+"("+d+")?":"(?:"+l+"("+d+"))?":l+"("+d+")"}}var c=La(t.delimiter||"/"),u=a.slice(-c.length)===c;return i||(a=(u?a.slice(0,-c.length):a)+"(?:"+c+"(?=$))?"),a+=r?"$":i&&u?"":"(?="+c+"|$)",qa(new RegExp("^"+a,Na(t)),e)}function Da(n,e,t){return ka(e)||(t=e||t,e=[]),t=t||{},n instanceof RegExp?function(n,e){var t=n.source.match(/\((?!\?)/g);if(t)for(var i=0;i<t.length;i++)e.push({name:i,prefix:null,delimiter:null,optional:!1,repeat:!1,partial:!1,asterisk:!1,pattern:null});return qa(n,e)}(n,e):ka(n)?function(n,e,t){for(var i=[],r=0;r<n.length;r++)i.push(Da(n[r],e,t).source);return qa(new RegExp("(?:"+i.join("|")+")",Na(t)),e)}(n,e,t):function(n,e,t){return $a(Ba(n,t),e,t)}(n,e,t)}wa.parse=ja,wa.compile=Aa,wa.tokensToFunction=Ta,wa.tokensToRegExp=Ca;var Ga=Object.create(null);function Fa(n,e,t){e=e||{};try{var i=Ga[n]||(Ga[n]=wa.compile(n));return"string"==typeof e.pathMatch&&(e[0]=e.pathMatch),i(e,{pretty:!0})}catch(n){return""}finally{delete e[0]}}function Oa(n,e,t,i){var r="string"==typeof n?{path:n}:n;if(r._normalized)return r;if(r.name){var a=(r=ea({},n)).params;return a&&"object"==typeof a&&(r.params=ea({},a)),r}if(!r.path&&r.params&&e){(r=ea({},r))._normalized=!0;var s=ea(ea({},e.params),r.params);if(e.name)r.name=e.name,r.params=s;else if(e.matched.length){var o=e.matched[e.matched.length-1].path;r.path=Fa(o,s,e.path)}else 0;return r}var l=function(n){var e="",t="",i=n.indexOf("#");i>=0&&(e=n.slice(i),n=n.slice(0,i));var r=n.indexOf("?");return r>=0&&(t=n.slice(r+1),n=n.slice(0,r)),{path:n,query:t,hash:e}}(r.path||""),d=e&&e.path||"/",c=l.path?Ea(l.path,d,t||r.append):d,u=function(n,e,t){void 0===e&&(e={});var i,r=t||la;try{i=r(n||"")}catch(n){i={}}for(var a in e){var s=e[a];i[a]=Array.isArray(s)?s.map(oa):oa(s)}return i}(l.query,r.query,i&&i.options.parseQuery),p=r.hash||l.hash;return p&&"#"!==p.charAt(0)&&(p="#"+p),{_normalized:!0,path:c,query:u,hash:p}}var Ua,Ra=function(){},Ma={name:"RouterLink",props:{to:{type:[String,Object],required:!0},tag:{type:String,default:"a"},custom:Boolean,exact:Boolean,exactPath:Boolean,append:Boolean,replace:Boolean,activeClass:String,exactActiveClass:String,ariaCurrentValue:{type:String,default:"page"},event:{type:[String,Array],default:"click"}},render:function(n){var e=this,t=this.$router,i=this.$route,r=t.resolve(this.to,i,this.append),a=r.location,s=r.route,o=r.href,l={},d=t.options.linkActiveClass,c=t.options.linkExactActiveClass,u=null==d?"router-link-active":d,p=null==c?"router-link-exact-active":c,m=null==this.activeClass?u:this.activeClass,h=null==this.exactActiveClass?p:this.exactActiveClass,f=s.redirectedFrom?ua(null,Oa(s.redirectedFrom),null,t):s;l[h]=ga(i,f,this.exactPath),l[m]=this.exact||this.exactPath?l[h]:function(n,e){return 0===n.path.replace(ca,"/").indexOf(e.path.replace(ca,"/"))&&(!e.hash||n.hash===e.hash)&&function(n,e){for(var t in e)if(!(t in n))return!1;return!0}(n.query,e.query)}(i,f);var g=l[h]?this.ariaCurrentValue:null,b=function(n){Ha(n)&&(e.replace?t.replace(a,Ra):t.push(a,Ra))},v={click:Ha};Array.isArray(this.event)?this.event.forEach((function(n){v[n]=b})):v[this.event]=b;var x={class:l},y=!this.$scopedSlots.$hasNormal&&this.$scopedSlots.default&&this.$scopedSlots.default({href:o,route:s,navigate:b,isActive:l[m],isExactActive:l[h]});if(y){if(1===y.length)return y[0];if(y.length>1||!y.length)return 0===y.length?n():n("span",{},y)}if("a"===this.tag)x.on=v,x.attrs={href:o,"aria-current":g};else{var E=function n(e){var t;if(e)for(var i=0;i<e.length;i++){if("a"===(t=e[i]).tag)return t;if(t.children&&(t=n(t.children)))return t}}(this.$slots.default);if(E){E.isStatic=!1;var _=E.data=ea({},E.data);for(var k in _.on=_.on||{},_.on){var w=_.on[k];k in v&&(_.on[k]=Array.isArray(w)?w:[w])}for(var j in v)j in _.on?_.on[j].push(v[j]):_.on[j]=b;var A=E.data.attrs=ea({},E.data.attrs);A.href=o,A["aria-current"]=g}else x.on=v}return n(this.tag,x,this.$slots.default)}};function Ha(n){if(!(n.metaKey||n.altKey||n.ctrlKey||n.shiftKey||n.defaultPrevented||void 0!==n.button&&0!==n.button)){if(n.currentTarget&&n.currentTarget.getAttribute){var e=n.currentTarget.getAttribute("target");if(/\b_blank\b/i.test(e))return}return n.preventDefault&&n.preventDefault(),!0}}var Va="undefined"!=typeof window;function Za(n,e,t,i,r){var a=e||[],s=t||Object.create(null),o=i||Object.create(null);n.forEach((function(n){!function n(e,t,i,r,a,s){var o=r.path,l=r.name;0;var d=r.pathToRegexpOptions||{},c=function(n,e,t){t||(n=n.replace(/\/$/,""));if("/"===n[0])return n;if(null==e)return n;return _a(e.path+"/"+n)}(o,a,d.strict);"boolean"==typeof r.caseSensitive&&(d.sensitive=r.caseSensitive);var u={path:c,regex:Wa(c,d),components:r.components||{default:r.component},alias:r.alias?"string"==typeof r.alias?[r.alias]:r.alias:[],instances:{},enteredCbs:{},name:l,parent:a,matchAs:s,redirect:r.redirect,beforeEnter:r.beforeEnter,meta:r.meta||{},props:null==r.props?{}:r.components?r.props:{default:r.props}};r.children&&r.children.forEach((function(r){var a=s?_a(s+"/"+r.path):void 0;n(e,t,i,r,u,a)}));t[u.path]||(e.push(u.path),t[u.path]=u);if(void 0!==r.alias)for(var p=Array.isArray(r.alias)?r.alias:[r.alias],m=0;m<p.length;++m){0;var h={path:p[m],children:r.children};n(e,t,i,h,a,u.path||"/")}l&&(i[l]||(i[l]=u))}(a,s,o,n,r)}));for(var l=0,d=a.length;l<d;l++)"*"===a[l]&&(a.push(a.splice(l,1)[0]),d--,l--);return{pathList:a,pathMap:s,nameMap:o}}function Wa(n,e){return wa(n,[],e)}function Ka(n,e){var t=Za(n),i=t.pathList,r=t.pathMap,a=t.nameMap;function s(n,t,s){var o=Oa(n,t,!1,e),d=o.name;if(d){var c=a[d];if(!c)return l(null,o);var u=c.regex.keys.filter((function(n){return!n.optional})).map((function(n){return n.name}));if("object"!=typeof o.params&&(o.params={}),t&&"object"==typeof t.params)for(var p in t.params)!(p in o.params)&&u.indexOf(p)>-1&&(o.params[p]=t.params[p]);return o.path=Fa(c.path,o.params),l(c,o,s)}if(o.path){o.params={};for(var m=0;m<i.length;m++){var h=i[m],f=r[h];if(Xa(f.regex,o.path,o.params))return l(f,o,s)}}return l(null,o)}function o(n,t){var i=n.redirect,r="function"==typeof i?i(ua(n,t,null,e)):i;if("string"==typeof r&&(r={path:r}),!r||"object"!=typeof r)return l(null,t);var o=r,d=o.name,c=o.path,u=t.query,p=t.hash,m=t.params;if(u=o.hasOwnProperty("query")?o.query:u,p=o.hasOwnProperty("hash")?o.hash:p,m=o.hasOwnProperty("params")?o.params:m,d){a[d];return s({_normalized:!0,name:d,query:u,hash:p,params:m},void 0,t)}if(c){var h=function(n,e){return Ea(n,e.parent?e.parent.path:"/",!0)}(c,n);return s({_normalized:!0,path:Fa(h,m),query:u,hash:p},void 0,t)}return l(null,t)}function l(n,t,i){return n&&n.redirect?o(n,i||t):n&&n.matchAs?function(n,e,t){var i=s({_normalized:!0,path:Fa(t,e.params)});if(i){var r=i.matched,a=r[r.length-1];return e.params=i.params,l(a,e)}return l(null,e)}(0,t,n.matchAs):ua(n,t,i,e)}return{match:s,addRoute:function(n,e){var t="object"!=typeof n?a[n]:void 0;Za([e||n],i,r,a,t),t&&t.alias.length&&Za(t.alias.map((function(n){return{path:n,children:[e]}})),i,r,a,t)},getRoutes:function(){return i.map((function(n){return r[n]}))},addRoutes:function(n){Za(n,i,r,a)}}}function Xa(n,e,t){var i=e.match(n);if(!i)return!1;if(!t)return!0;for(var r=1,a=i.length;r<a;++r){var s=n.keys[r-1];s&&(t[s.name||"pathMatch"]="string"==typeof i[r]?sa(i[r]):i[r])}return!0}var Ya=Va&&window.performance&&window.performance.now?window.performance:Date;function Ja(){return Ya.now().toFixed(3)}var Qa=Ja();function ns(){return Qa}function es(n){return Qa=n}var ts=Object.create(null);function is(){"scrollRestoration"in window.history&&(window.history.scrollRestoration="manual");var n=window.location.protocol+"//"+window.location.host,e=window.location.href.replace(n,""),t=ea({},window.history.state);return t.key=ns(),window.history.replaceState(t,"",e),window.addEventListener("popstate",ss),function(){window.removeEventListener("popstate",ss)}}function rs(n,e,t,i){if(n.app){var r=n.options.scrollBehavior;r&&n.app.$nextTick((function(){var a=function(){var n=ns();if(n)return ts[n]}(),s=r.call(n,e,t,i?a:null);s&&("function"==typeof s.then?s.then((function(n){us(n,a)})).catch((function(n){0})):us(s,a))}))}}function as(){var n=ns();n&&(ts[n]={x:window.pageXOffset,y:window.pageYOffset})}function ss(n){as(),n.state&&n.state.key&&es(n.state.key)}function os(n){return ds(n.x)||ds(n.y)}function ls(n){return{x:ds(n.x)?n.x:window.pageXOffset,y:ds(n.y)?n.y:window.pageYOffset}}function ds(n){return"number"==typeof n}var cs=/^#\d/;function us(n,e){var t,i="object"==typeof n;if(i&&"string"==typeof n.selector){var r=cs.test(n.selector)?document.getElementById(n.selector.slice(1)):document.querySelector(n.selector);if(r){var a=n.offset&&"object"==typeof n.offset?n.offset:{};e=function(n,e){var t=document.documentElement.getBoundingClientRect(),i=n.getBoundingClientRect();return{x:i.left-t.left-e.x,y:i.top-t.top-e.y}}(r,a={x:ds((t=a).x)?t.x:0,y:ds(t.y)?t.y:0})}else os(n)&&(e=ls(n))}else i&&os(n)&&(e=ls(n));e&&("scrollBehavior"in document.documentElement.style?window.scrollTo({left:e.x,top:e.y,behavior:n.behavior}):window.scrollTo(e.x,e.y))}var ps,ms=Va&&((-1===(ps=window.navigator.userAgent).indexOf("Android 2.")&&-1===ps.indexOf("Android 4.0")||-1===ps.indexOf("Mobile Safari")||-1!==ps.indexOf("Chrome")||-1!==ps.indexOf("Windows Phone"))&&window.history&&"function"==typeof window.history.pushState);function hs(n,e){as();var t=window.history;try{if(e){var i=ea({},t.state);i.key=ns(),t.replaceState(i,"",n)}else t.pushState({key:es(Ja())},"",n)}catch(t){window.location[e?"replace":"assign"](n)}}function fs(n){hs(n,!0)}var gs={redirected:2,aborted:4,cancelled:8,duplicated:16};function bs(n,e){return xs(n,e,gs.redirected,'Redirected when going from "'+n.fullPath+'" to "'+function(n){if("string"==typeof n)return n;if("path"in n)return n.path;var e={};return ys.forEach((function(t){t in n&&(e[t]=n[t])})),JSON.stringify(e,null,2)}(e)+'" via a navigation guard.')}function vs(n,e){return xs(n,e,gs.cancelled,'Navigation cancelled from "'+n.fullPath+'" to "'+e.fullPath+'" with a new navigation.')}function xs(n,e,t,i){var r=new Error(i);return r._isRouter=!0,r.from=n,r.to=e,r.type=t,r}var ys=["params","query","hash"];function Es(n){return Object.prototype.toString.call(n).indexOf("Error")>-1}function _s(n,e){return Es(n)&&n._isRouter&&(null==e||n.type===e)}function ks(n,e,t){var i=function(r){r>=n.length?t():n[r]?e(n[r],(function(){i(r+1)})):i(r+1)};i(0)}function ws(n){return function(e,t,i){var r=!1,a=0,s=null;js(n,(function(n,e,t,o){if("function"==typeof n&&void 0===n.cid){r=!0,a++;var l,d=Cs((function(e){var r;((r=e).__esModule||Ts&&"Module"===r[Symbol.toStringTag])&&(e=e.default),n.resolved="function"==typeof e?e:Ua.extend(e),t.components[o]=e,--a<=0&&i()})),c=Cs((function(n){var e="Failed to resolve async component "+o+": "+n;s||(s=Es(n)?n:new Error(e),i(s))}));try{l=n(d,c)}catch(n){c(n)}if(l)if("function"==typeof l.then)l.then(d,c);else{var u=l.component;u&&"function"==typeof u.then&&u.then(d,c)}}})),r||i()}}function js(n,e){return As(n.map((function(n){return Object.keys(n.components).map((function(t){return e(n.components[t],n.instances[t],n,t)}))})))}function As(n){return Array.prototype.concat.apply([],n)}var Ts="function"==typeof Symbol&&"symbol"==typeof Symbol.toStringTag;function Cs(n){var e=!1;return function(){for(var t=[],i=arguments.length;i--;)t[i]=arguments[i];if(!e)return e=!0,n.apply(this,t)}}var zs=function(n,e){this.router=n,this.base=function(n){if(!n)if(Va){var e=document.querySelector("base");n=(n=e&&e.getAttribute("href")||"/").replace(/^https?:\/\/[^\/]+/,"")}else n="/";"/"!==n.charAt(0)&&(n="/"+n);return n.replace(/\/$/,"")}(e),this.current=ma,this.pending=null,this.ready=!1,this.readyCbs=[],this.readyErrorCbs=[],this.errorCbs=[],this.listeners=[]};function Bs(n,e,t,i){var r=js(n,(function(n,i,r,a){var s=function(n,e){"function"!=typeof n&&(n=Ua.extend(n));return n.options[e]}(n,e);if(s)return Array.isArray(s)?s.map((function(n){return t(n,i,r,a)})):t(s,i,r,a)}));return As(i?r.reverse():r)}function Is(n,e){if(e)return function(){return n.apply(e,arguments)}}zs.prototype.listen=function(n){this.cb=n},zs.prototype.onReady=function(n,e){this.ready?n():(this.readyCbs.push(n),e&&this.readyErrorCbs.push(e))},zs.prototype.onError=function(n){this.errorCbs.push(n)},zs.prototype.transitionTo=function(n,e,t){var i,r=this;try{i=this.router.match(n,this.current)}catch(n){throw this.errorCbs.forEach((function(e){e(n)})),n}var a=this.current;this.confirmTransition(i,(function(){r.updateRoute(i),e&&e(i),r.ensureURL(),r.router.afterHooks.forEach((function(n){n&&n(i,a)})),r.ready||(r.ready=!0,r.readyCbs.forEach((function(n){n(i)})))}),(function(n){t&&t(n),n&&!r.ready&&(_s(n,gs.redirected)&&a===ma||(r.ready=!0,r.readyErrorCbs.forEach((function(e){e(n)}))))}))},zs.prototype.confirmTransition=function(n,e,t){var i=this,r=this.current;this.pending=n;var a,s,o=function(n){!_s(n)&&Es(n)&&(i.errorCbs.length?i.errorCbs.forEach((function(e){e(n)})):console.error(n)),t&&t(n)},l=n.matched.length-1,d=r.matched.length-1;if(ga(n,r)&&l===d&&n.matched[l]===r.matched[d])return this.ensureURL(),n.hash&&rs(this.router,r,n,!1),o(((s=xs(a=r,n,gs.duplicated,'Avoided redundant navigation to current location: "'+a.fullPath+'".')).name="NavigationDuplicated",s));var c=function(n,e){var t,i=Math.max(n.length,e.length);for(t=0;t<i&&n[t]===e[t];t++);return{updated:e.slice(0,t),activated:e.slice(t),deactivated:n.slice(t)}}(this.current.matched,n.matched),u=c.updated,p=c.deactivated,m=c.activated,h=[].concat(function(n){return Bs(n,"beforeRouteLeave",Is,!0)}(p),this.router.beforeHooks,function(n){return Bs(n,"beforeRouteUpdate",Is)}(u),m.map((function(n){return n.beforeEnter})),ws(m)),f=function(e,t){if(i.pending!==n)return o(vs(r,n));try{e(n,r,(function(e){!1===e?(i.ensureURL(!0),o(function(n,e){return xs(n,e,gs.aborted,'Navigation aborted from "'+n.fullPath+'" to "'+e.fullPath+'" via a navigation guard.')}(r,n))):Es(e)?(i.ensureURL(!0),o(e)):"string"==typeof e||"object"==typeof e&&("string"==typeof e.path||"string"==typeof e.name)?(o(bs(r,n)),"object"==typeof e&&e.replace?i.replace(e):i.push(e)):t(e)}))}catch(n){o(n)}};ks(h,f,(function(){ks(function(n){return Bs(n,"beforeRouteEnter",(function(n,e,t,i){return function(n,e,t){return function(i,r,a){return n(i,r,(function(n){"function"==typeof n&&(e.enteredCbs[t]||(e.enteredCbs[t]=[]),e.enteredCbs[t].push(n)),a(n)}))}}(n,t,i)}))}(m).concat(i.router.resolveHooks),f,(function(){if(i.pending!==n)return o(vs(r,n));i.pending=null,e(n),i.router.app&&i.router.app.$nextTick((function(){va(n)}))}))}))},zs.prototype.updateRoute=function(n){this.current=n,this.cb&&this.cb(n)},zs.prototype.setupListeners=function(){},zs.prototype.teardown=function(){this.listeners.forEach((function(n){n()})),this.listeners=[],this.current=ma,this.pending=null};var Ss=function(n){function e(e,t){n.call(this,e,t),this._startLocation=Ls(this.base)}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.setupListeners=function(){var n=this;if(!(this.listeners.length>0)){var e=this.router,t=e.options.scrollBehavior,i=ms&&t;i&&this.listeners.push(is());var r=function(){var t=n.current,r=Ls(n.base);n.current===ma&&r===n._startLocation||n.transitionTo(r,(function(n){i&&rs(e,n,t,!0)}))};window.addEventListener("popstate",r),this.listeners.push((function(){window.removeEventListener("popstate",r)}))}},e.prototype.go=function(n){window.history.go(n)},e.prototype.push=function(n,e,t){var i=this,r=this.current;this.transitionTo(n,(function(n){hs(_a(i.base+n.fullPath)),rs(i.router,n,r,!1),e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var i=this,r=this.current;this.transitionTo(n,(function(n){fs(_a(i.base+n.fullPath)),rs(i.router,n,r,!1),e&&e(n)}),t)},e.prototype.ensureURL=function(n){if(Ls(this.base)!==this.current.fullPath){var e=_a(this.base+this.current.fullPath);n?hs(e):fs(e)}},e.prototype.getCurrentLocation=function(){return Ls(this.base)},e}(zs);function Ls(n){var e=window.location.pathname,t=e.toLowerCase(),i=n.toLowerCase();return!n||t!==i&&0!==t.indexOf(_a(i+"/"))||(e=e.slice(n.length)),(e||"/")+window.location.search+window.location.hash}var Ps=function(n){function e(e,t,i){n.call(this,e,t),i&&function(n){var e=Ls(n);if(!/^\/#/.test(e))return window.location.replace(_a(n+"/#"+e)),!0}(this.base)||qs()}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.setupListeners=function(){var n=this;if(!(this.listeners.length>0)){var e=this.router.options.scrollBehavior,t=ms&&e;t&&this.listeners.push(is());var i=function(){var e=n.current;qs()&&n.transitionTo(Ns(),(function(i){t&&rs(n.router,i,e,!0),ms||Gs(i.fullPath)}))},r=ms?"popstate":"hashchange";window.addEventListener(r,i),this.listeners.push((function(){window.removeEventListener(r,i)}))}},e.prototype.push=function(n,e,t){var i=this,r=this.current;this.transitionTo(n,(function(n){Ds(n.fullPath),rs(i.router,n,r,!1),e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var i=this,r=this.current;this.transitionTo(n,(function(n){Gs(n.fullPath),rs(i.router,n,r,!1),e&&e(n)}),t)},e.prototype.go=function(n){window.history.go(n)},e.prototype.ensureURL=function(n){var e=this.current.fullPath;Ns()!==e&&(n?Ds(e):Gs(e))},e.prototype.getCurrentLocation=function(){return Ns()},e}(zs);function qs(){var n=Ns();return"/"===n.charAt(0)||(Gs("/"+n),!1)}function Ns(){var n=window.location.href,e=n.indexOf("#");return e<0?"":n=n.slice(e+1)}function $s(n){var e=window.location.href,t=e.indexOf("#");return(t>=0?e.slice(0,t):e)+"#"+n}function Ds(n){ms?hs($s(n)):window.location.hash=n}function Gs(n){ms?fs($s(n)):window.location.replace($s(n))}var Fs=function(n){function e(e,t){n.call(this,e,t),this.stack=[],this.index=-1}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.push=function(n,e,t){var i=this;this.transitionTo(n,(function(n){i.stack=i.stack.slice(0,i.index+1).concat(n),i.index++,e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var i=this;this.transitionTo(n,(function(n){i.stack=i.stack.slice(0,i.index).concat(n),e&&e(n)}),t)},e.prototype.go=function(n){var e=this,t=this.index+n;if(!(t<0||t>=this.stack.length)){var i=this.stack[t];this.confirmTransition(i,(function(){var n=e.current;e.index=t,e.updateRoute(i),e.router.afterHooks.forEach((function(e){e&&e(i,n)}))}),(function(n){_s(n,gs.duplicated)&&(e.index=t)}))}},e.prototype.getCurrentLocation=function(){var n=this.stack[this.stack.length-1];return n?n.fullPath:"/"},e.prototype.ensureURL=function(){},e}(zs),Os=function(n){void 0===n&&(n={}),this.app=null,this.apps=[],this.options=n,this.beforeHooks=[],this.resolveHooks=[],this.afterHooks=[],this.matcher=Ka(n.routes||[],this);var e=n.mode||"hash";switch(this.fallback="history"===e&&!ms&&!1!==n.fallback,this.fallback&&(e="hash"),Va||(e="abstract"),this.mode=e,e){case"history":this.history=new Ss(this,n.base);break;case"hash":this.history=new Ps(this,n.base,this.fallback);break;case"abstract":this.history=new Fs(this,n.base);break;default:0}},Us={currentRoute:{configurable:!0}};Os.prototype.match=function(n,e,t){return this.matcher.match(n,e,t)},Us.currentRoute.get=function(){return this.history&&this.history.current},Os.prototype.init=function(n){var e=this;if(this.apps.push(n),n.$once("hook:destroyed",(function(){var t=e.apps.indexOf(n);t>-1&&e.apps.splice(t,1),e.app===n&&(e.app=e.apps[0]||null),e.app||e.history.teardown()})),!this.app){this.app=n;var t=this.history;if(t instanceof Ss||t instanceof Ps){var i=function(n){t.setupListeners(),function(n){var i=t.current,r=e.options.scrollBehavior;ms&&r&&"fullPath"in n&&rs(e,n,i,!1)}(n)};t.transitionTo(t.getCurrentLocation(),i,i)}t.listen((function(n){e.apps.forEach((function(e){e._route=n}))}))}},Os.prototype.beforeEach=function(n){return Ms(this.beforeHooks,n)},Os.prototype.beforeResolve=function(n){return Ms(this.resolveHooks,n)},Os.prototype.afterEach=function(n){return Ms(this.afterHooks,n)},Os.prototype.onReady=function(n,e){this.history.onReady(n,e)},Os.prototype.onError=function(n){this.history.onError(n)},Os.prototype.push=function(n,e,t){var i=this;if(!e&&!t&&"undefined"!=typeof Promise)return new Promise((function(e,t){i.history.push(n,e,t)}));this.history.push(n,e,t)},Os.prototype.replace=function(n,e,t){var i=this;if(!e&&!t&&"undefined"!=typeof Promise)return new Promise((function(e,t){i.history.replace(n,e,t)}));this.history.replace(n,e,t)},Os.prototype.go=function(n){this.history.go(n)},Os.prototype.back=function(){this.go(-1)},Os.prototype.forward=function(){this.go(1)},Os.prototype.getMatchedComponents=function(n){var e=n?n.matched?n:this.resolve(n).route:this.currentRoute;return e?[].concat.apply([],e.matched.map((function(n){return Object.keys(n.components).map((function(e){return n.components[e]}))}))):[]},Os.prototype.resolve=function(n,e,t){var i=Oa(n,e=e||this.history.current,t,this),r=this.match(i,e),a=r.redirectedFrom||r.fullPath;return{location:i,route:r,href:function(n,e,t){var i="hash"===t?"#"+e:e;return n?_a(n+"/"+i):i}(this.history.base,a,this.mode),normalizedTo:i,resolved:r}},Os.prototype.getRoutes=function(){return this.matcher.getRoutes()},Os.prototype.addRoute=function(n,e){this.matcher.addRoute(n,e),this.history.current!==ma&&this.history.transitionTo(this.history.getCurrentLocation())},Os.prototype.addRoutes=function(n){this.matcher.addRoutes(n),this.history.current!==ma&&this.history.transitionTo(this.history.getCurrentLocation())},Object.defineProperties(Os.prototype,Us);var Rs=Os;function Ms(n,e){return n.push(e),function(){var t=n.indexOf(e);t>-1&&n.splice(t,1)}}Os.install=function n(e){if(!n.installed||Ua!==e){n.installed=!0,Ua=e;var t=function(n){return void 0!==n},i=function(n,e){var i=n.$options._parentVnode;t(i)&&t(i=i.data)&&t(i=i.registerRouteInstance)&&i(n,e)};e.mixin({beforeCreate:function(){t(this.$options.router)?(this._routerRoot=this,this._router=this.$options.router,this._router.init(this),e.util.defineReactive(this,"_route",this._router.history.current)):this._routerRoot=this.$parent&&this.$parent._routerRoot||this,i(this,this)},destroyed:function(){i(this)}}),Object.defineProperty(e.prototype,"$router",{get:function(){return this._routerRoot._router}}),Object.defineProperty(e.prototype,"$route",{get:function(){return this._routerRoot._route}}),e.component("RouterView",xa),e.component("RouterLink",Ma);var r=e.config.optionMergeStrategies;r.beforeRouteEnter=r.beforeRouteLeave=r.beforeRouteUpdate=r.created}},Os.version="3.6.5",Os.isNavigationFailure=_s,Os.NavigationFailureType=gs,Os.START_LOCATION=ma,Va&&window.Vue&&window.Vue.use(Os);t(105);t(16),t(131);var Hs={NotFound:()=>Promise.all([t.e(0),t.e(4)]).then(t.bind(null,331)),Layout:()=>Promise.all([t.e(0),t.e(2)]).then(t.bind(null,330))},Vs={"v-4cb1244c":()=>t.e(5).then(t.bind(null,332)),"v-18efd267":()=>t.e(6).then(t.bind(null,333)),"v-7b26bc54":()=>t.e(7).then(t.bind(null,334)),"v-3ba697dd":()=>t.e(9).then(t.bind(null,335)),"v-79372922":()=>t.e(8).then(t.bind(null,336)),"v-1b448f46":()=>t.e(10).then(t.bind(null,337)),"v-7d18746a":()=>t.e(12).then(t.bind(null,338)),"v-5e53ef36":()=>t.e(13).then(t.bind(null,339)),"v-512a5f00":()=>t.e(11).then(t.bind(null,340)),"v-5a1e5a8f":()=>t.e(14).then(t.bind(null,341)),"v-529fd5e8":()=>t.e(15).then(t.bind(null,342)),"v-f6cde29c":()=>t.e(17).then(t.bind(null,343)),"v-08ca4e2c":()=>t.e(18).then(t.bind(null,344)),"v-5d1370e8":()=>t.e(16).then(t.bind(null,345)),"v-28bc7684":()=>t.e(21).then(t.bind(null,346)),"v-3cae0aa0":()=>t.e(22).then(t.bind(null,347)),"v-85e7f1bc":()=>t.e(20).then(t.bind(null,348)),"v-fa4616d8":()=>t.e(19).then(t.bind(null,349)),"v-06da7966":()=>t.e(23).then(t.bind(null,350)),"v-57adafc4":()=>t.e(24).then(t.bind(null,351)),"v-4477712c":()=>t.e(25).then(t.bind(null,352)),"v-74760cb8":()=>t.e(28).then(t.bind(null,353)),"v-0a5e0a62":()=>t.e(27).then(t.bind(null,354)),"v-032fbe38":()=>t.e(30).then(t.bind(null,355)),"v-2002d43c":()=>t.e(26).then(t.bind(null,356)),"v-10b51f52":()=>t.e(31).then(t.bind(null,357)),"v-42065d9a":()=>t.e(32).then(t.bind(null,358)),"v-270b393e":()=>t.e(33).then(t.bind(null,359)),"v-1d4eb24c":()=>t.e(34).then(t.bind(null,360)),"v-3f0ce116":()=>t.e(35).then(t.bind(null,361)),"v-96f454f6":()=>t.e(36).then(t.bind(null,362)),"v-5a00904b":()=>t.e(37).then(t.bind(null,363)),"v-4e2c513c":()=>t.e(39).then(t.bind(null,364)),"v-bdc2433c":()=>t.e(40).then(t.bind(null,365)),"v-72f63995":()=>t.e(38).then(t.bind(null,366)),"v-a83c2a9c":()=>t.e(29).then(t.bind(null,367)),"v-b34a2986":()=>t.e(41).then(t.bind(null,368)),"v-dec39b1a":()=>t.e(42).then(t.bind(null,369)),"v-a12e0342":()=>t.e(43).then(t.bind(null,370)),"v-3842244f":()=>t.e(44).then(t.bind(null,371)),"v-60717c59":()=>t.e(45).then(t.bind(null,372)),"v-4b7cce06":()=>t.e(46).then(t.bind(null,373)),"v-78213b4e":()=>t.e(48).then(t.bind(null,374)),"v-5590ed59":()=>t.e(47).then(t.bind(null,375)),"v-3094c696":()=>t.e(49).then(t.bind(null,376)),"v-a241b3e0":()=>t.e(50).then(t.bind(null,377)),"v-00efbfe0":()=>t.e(55).then(t.bind(null,378)),"v-8fb6558c":()=>t.e(53).then(t.bind(null,379)),"v-f18cce36":()=>t.e(54).then(t.bind(null,380)),"v-0ba825b2":()=>t.e(56).then(t.bind(null,381)),"v-74e5670c":()=>t.e(59).then(t.bind(null,382)),"v-45d40013":()=>t.e(57).then(t.bind(null,383)),"v-c166e812":()=>t.e(61).then(t.bind(null,384)),"v-1b6e1506":()=>t.e(62).then(t.bind(null,385)),"v-bbc963f8":()=>t.e(58).then(t.bind(null,386)),"v-19942982":()=>t.e(63).then(t.bind(null,387)),"v-a1dd7d26":()=>t.e(60).then(t.bind(null,388)),"v-23bee3d7":()=>t.e(66).then(t.bind(null,389)),"v-373e1bea":()=>t.e(65).then(t.bind(null,390)),"v-7596a1ba":()=>t.e(64).then(t.bind(null,391)),"v-d7b3967a":()=>t.e(68).then(t.bind(null,392)),"v-55610c8f":()=>t.e(67).then(t.bind(null,393)),"v-044a4948":()=>t.e(69).then(t.bind(null,394)),"v-2ded1aae":()=>t.e(71).then(t.bind(null,395)),"v-510b3c03":()=>t.e(70).then(t.bind(null,396)),"v-5d57353a":()=>t.e(72).then(t.bind(null,397)),"v-660c2778":()=>t.e(73).then(t.bind(null,398)),"v-1e4a90e6":()=>t.e(74).then(t.bind(null,399)),"v-8a647390":()=>t.e(76).then(t.bind(null,400)),"v-40025290":()=>t.e(75).then(t.bind(null,401)),"v-56fb6266":()=>t.e(77).then(t.bind(null,402)),"v-3cef2a45":()=>t.e(78).then(t.bind(null,403)),"v-5911eb5e":()=>t.e(79).then(t.bind(null,404)),"v-ca702032":()=>t.e(80).then(t.bind(null,405)),"v-4c5a063e":()=>t.e(81).then(t.bind(null,406)),"v-9ff0e312":()=>t.e(83).then(t.bind(null,407)),"v-df77c33a":()=>t.e(82).then(t.bind(null,408)),"v-ef6f3572":()=>t.e(84).then(t.bind(null,409)),"v-a2a462c6":()=>t.e(85).then(t.bind(null,410)),"v-2e7b6e04":()=>t.e(86).then(t.bind(null,411)),"v-321f68a4":()=>t.e(87).then(t.bind(null,412)),"v-72db9d7e":()=>t.e(88).then(t.bind(null,413)),"v-2ccb02d9":()=>t.e(90).then(t.bind(null,414)),"v-7386757a":()=>t.e(91).then(t.bind(null,415)),"v-bfa92168":()=>t.e(92).then(t.bind(null,416)),"v-e2468eaa":()=>t.e(89).then(t.bind(null,417)),"v-0c19afd3":()=>t.e(93).then(t.bind(null,418)),"v-59c0df46":()=>t.e(94).then(t.bind(null,419)),"v-2eca7826":()=>t.e(96).then(t.bind(null,420)),"v-70c9603f":()=>t.e(97).then(t.bind(null,421)),"v-b6beb69c":()=>t.e(98).then(t.bind(null,422)),"v-0dbfcf13":()=>t.e(95).then(t.bind(null,423)),"v-6b98cea6":()=>t.e(100).then(t.bind(null,424)),"v-aa15e9b4":()=>t.e(99).then(t.bind(null,425)),"v-43523836":()=>t.e(102).then(t.bind(null,426)),"v-0565826e":()=>t.e(103).then(t.bind(null,427)),"v-5dd3c9a7":()=>t.e(104).then(t.bind(null,428)),"v-13231700":()=>t.e(101).then(t.bind(null,429)),"v-66dc6312":()=>t.e(105).then(t.bind(null,430)),"v-5699caf5":()=>t.e(106).then(t.bind(null,431)),"v-098887ea":()=>t.e(108).then(t.bind(null,432)),"v-596b536f":()=>t.e(109).then(t.bind(null,433)),"v-5222397a":()=>t.e(107).then(t.bind(null,434)),"v-53e283aa":()=>t.e(110).then(t.bind(null,435)),"v-c0ef0954":()=>t.e(111).then(t.bind(null,436)),"v-788365e1":()=>t.e(112).then(t.bind(null,437)),"v-5f9bf296":()=>t.e(51).then(t.bind(null,438)),"v-9a42f894":()=>t.e(52).then(t.bind(null,439)),"v-47781b60":()=>t.e(115).then(t.bind(null,440)),"v-0cdcbd20":()=>t.e(117).then(t.bind(null,441)),"v-04db88ef":()=>t.e(119).then(t.bind(null,442)),"v-3dbcc9aa":()=>t.e(118).then(t.bind(null,443)),"v-48d02f81":()=>t.e(120).then(t.bind(null,444)),"v-bc4d0168":()=>t.e(121).then(t.bind(null,445)),"v-4604aeb0":()=>t.e(113).then(t.bind(null,446)),"v-f90fe7f6":()=>t.e(124).then(t.bind(null,447)),"v-48c7850e":()=>t.e(126).then(t.bind(null,448)),"v-dbe28e3a":()=>t.e(123).then(t.bind(null,449)),"v-4f96c767":()=>t.e(125).then(t.bind(null,450)),"v-f4f09eee":()=>t.e(127).then(t.bind(null,451)),"v-c39fe9c4":()=>t.e(128).then(t.bind(null,452)),"v-4081237d":()=>t.e(129).then(t.bind(null,453)),"v-3dee8977":()=>t.e(130).then(t.bind(null,454)),"v-5501acb0":()=>t.e(131).then(t.bind(null,455)),"v-03606fac":()=>t.e(132).then(t.bind(null,456)),"v-3b3a9bf2":()=>t.e(135).then(t.bind(null,457)),"v-3dd5939c":()=>t.e(134).then(t.bind(null,458)),"v-6e30d232":()=>t.e(133).then(t.bind(null,459)),"v-e354f03c":()=>t.e(136).then(t.bind(null,460)),"v-511ed1c1":()=>t.e(122).then(t.bind(null,461)),"v-5789cebf":()=>t.e(137).then(t.bind(null,462)),"v-c7498540":()=>t.e(140).then(t.bind(null,463)),"v-b1312a2c":()=>t.e(139).then(t.bind(null,464)),"v-3106070c":()=>t.e(138).then(t.bind(null,465)),"v-5f16ac72":()=>t.e(116).then(t.bind(null,466)),"v-3999f758":()=>t.e(141).then(t.bind(null,467)),"v-43552b36":()=>t.e(142).then(t.bind(null,468)),"v-12d068a5":()=>t.e(144).then(t.bind(null,469)),"v-26aabec5":()=>t.e(145).then(t.bind(null,470)),"v-7b47030e":()=>t.e(146).then(t.bind(null,471)),"v-7cae4d1f":()=>t.e(147).then(t.bind(null,472)),"v-698342a0":()=>t.e(148).then(t.bind(null,473)),"v-2ce72fc6":()=>t.e(149).then(t.bind(null,474)),"v-26153a30":()=>t.e(150).then(t.bind(null,475)),"v-4236935a":()=>t.e(151).then(t.bind(null,476)),"v-fe412f70":()=>t.e(143).then(t.bind(null,477)),"v-7b4b4b8e":()=>t.e(152).then(t.bind(null,478)),"v-efad95c8":()=>t.e(153).then(t.bind(null,479)),"v-f5673184":()=>t.e(154).then(t.bind(null,480)),"v-c67256e6":()=>t.e(156).then(t.bind(null,481)),"v-60adb5e5":()=>t.e(155).then(t.bind(null,482)),"v-0fec5a68":()=>t.e(157).then(t.bind(null,483)),"v-4a5cc4cc":()=>t.e(159).then(t.bind(null,484)),"v-d6569084":()=>t.e(158).then(t.bind(null,485)),"v-d5f84b34":()=>t.e(160).then(t.bind(null,486)),"v-7eca6e6d":()=>t.e(161).then(t.bind(null,487)),"v-10fa8822":()=>t.e(162).then(t.bind(null,488)),"v-24cfacec":()=>t.e(163).then(t.bind(null,489)),"v-300c680b":()=>t.e(114).then(t.bind(null,490)),"v-c6e0a240":()=>t.e(165).then(t.bind(null,491)),"v-e9633f54":()=>t.e(167).then(t.bind(null,492)),"v-4d0b7bc2":()=>t.e(169).then(t.bind(null,493)),"v-010c2c3e":()=>t.e(164).then(t.bind(null,494)),"v-0aaf80f1":()=>t.e(168).then(t.bind(null,495)),"v-e53dc4e2":()=>t.e(171).then(t.bind(null,496)),"v-618f02ea":()=>t.e(166).then(t.bind(null,497)),"v-33e54f21":()=>t.e(170).then(t.bind(null,498)),"v-51acde98":()=>t.e(172).then(t.bind(null,499)),"v-590f3efc":()=>t.e(173).then(t.bind(null,500)),"v-c7d5fea8":()=>t.e(174).then(t.bind(null,501)),"v-68c52d46":()=>t.e(175).then(t.bind(null,502)),"v-0dd9388e":()=>t.e(176).then(t.bind(null,503)),"v-35460c03":()=>t.e(178).then(t.bind(null,504)),"v-6a78bbac":()=>t.e(177).then(t.bind(null,505))};function Zs(n){const e=Object.create(null);return function(t){return e[t]||(e[t]=n(t))}}const Ws=/-(\w)/g,Ks=Zs(n=>n.replace(Ws,(n,e)=>e?e.toUpperCase():"")),Xs=/\B([A-Z])/g,Ys=Zs(n=>n.replace(Xs,"-$1").toLowerCase()),Js=Zs(n=>n.charAt(0).toUpperCase()+n.slice(1));function Qs(n,e){if(!e)return;if(n(e))return n(e);return e.includes("-")?n(Js(Ks(e))):n(Js(e))||n(Ys(e))}const no=Object.assign({},Hs,Vs),eo=n=>no[n],to=n=>Vs[n],io=n=>Hs[n],ro=n=>Vt.component(n);function ao(n){return Qs(to,n)}function so(n){return Qs(io,n)}function oo(n){return Qs(eo,n)}function lo(n){return Qs(ro,n)}function co(...n){return Promise.all(n.filter(n=>n).map(async n=>{if(!lo(n)&&oo(n)){const e=await oo(n)();Vt.component(n,e.default)}}))}function uo(n,e){"undefined"!=typeof window&&window.__VUEPRESS__&&(window.__VUEPRESS__[n]=e)}var po=t(93),mo=t.n(po),ho=t(94),fo=t.n(ho),go={created(){if(this.siteMeta=this.$site.headTags.filter(([n])=>"meta"===n).map(([n,e])=>e),this.$ssrContext){const e=this.getMergedMetaTags();this.$ssrContext.title=this.$title,this.$ssrContext.lang=this.$lang,this.$ssrContext.pageMeta=(n=e)?n.map(n=>{let e="<meta";return Object.keys(n).forEach(t=>{e+=` ${t}="${fo()(n[t])}"`}),e+">"}).join("\n    "):"",this.$ssrContext.canonicalLink=vo(this.$canonicalUrl)}var n},mounted(){this.currentMetaTags=[...document.querySelectorAll("meta")],this.updateMeta(),this.updateCanonicalLink()},methods:{updateMeta(){document.title=this.$title,document.documentElement.lang=this.$lang;const n=this.getMergedMetaTags();this.currentMetaTags=xo(n,this.currentMetaTags)},getMergedMetaTags(){const n=this.$page.frontmatter.meta||[];return mo()([{name:"description",content:this.$description}],n,this.siteMeta,yo)},updateCanonicalLink(){bo(),this.$canonicalUrl&&document.head.insertAdjacentHTML("beforeend",vo(this.$canonicalUrl))}},watch:{$page(){this.updateMeta(),this.updateCanonicalLink()}},beforeDestroy(){xo(null,this.currentMetaTags),bo()}};function bo(){const n=document.querySelector("link[rel='canonical']");n&&n.remove()}function vo(n=""){return n?`<link href="${n}" rel="canonical" />`:""}function xo(n,e){if(e&&[...e].filter(n=>n.parentNode===document.head).forEach(n=>document.head.removeChild(n)),n)return n.map(n=>{const e=document.createElement("meta");return Object.keys(n).forEach(t=>{e.setAttribute(t,n[t])}),document.head.appendChild(e),e})}function yo(n){for(const e of["name","property","itemprop"])if(n.hasOwnProperty(e))return n[e]+e;return JSON.stringify(n)}var Eo=t(50),_o={mounted(){window.addEventListener("scroll",this.onScroll)},methods:{onScroll:t.n(Eo)()((function(){this.setActiveHash()}),300),setActiveHash(){const n=[].slice.call(document.querySelectorAll(".sidebar-link")),e=[].slice.call(document.querySelectorAll(".header-anchor")).filter(e=>n.some(n=>n.hash===e.hash)),t=Math.max(window.pageYOffset,document.documentElement.scrollTop,document.body.scrollTop),i=Math.max(document.documentElement.scrollHeight,document.body.scrollHeight),r=window.innerHeight+t;for(let n=0;n<e.length;n++){const a=e[n],s=e[n+1],o=0===n&&0===t||t>=a.parentElement.offsetTop+10&&(!s||t<s.parentElement.offsetTop-10),l=decodeURIComponent(this.$route.hash);if(o&&l!==decodeURIComponent(a.hash)){const t=a;if(r===i)for(let t=n+1;t<e.length;t++)if(l===decodeURIComponent(e[t].hash))return;return this.$vuepress.$set("disableScrollBehavior",!0),void this.$router.replace(decodeURIComponent(t.hash),()=>{this.$nextTick(()=>{this.$vuepress.$set("disableScrollBehavior",!1)})})}}}},beforeDestroy(){window.removeEventListener("scroll",this.onScroll)}},ko=t(24),wo=t.n(ko),jo={mounted(){wo.a.configure({showSpinner:!1}),this.$router.beforeEach((n,e,t)=>{n.path===e.path||Vt.component(n.name)||wo.a.start(),t()}),this.$router.afterEach(()=>{wo.a.done(),this.isSidebarOpen=!1})}};t(240),t(241);class Ao{constructor(){this.containerEl=document.getElementById("message-container"),this.containerEl||(this.containerEl=document.createElement("div"),this.containerEl.id="message-container",document.body.appendChild(this.containerEl))}show({text:n="",duration:e=3e3}){let t=document.createElement("div");t.className="message move-in",t.innerHTML=`\n      <i style="fill: #06a35a;font-size: 14px;display:inline-flex;align-items: center;">\n        <svg style="fill: #06a35a;font-size: 14px;" t="1572421810237" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2323" width="16" height="16"><path d="M822.811993 824.617989c-83.075838 81.99224-188.546032 124.613757-316.049383 127.86455-122.085362-3.250794-223.943563-45.87231-305.935802-127.86455s-124.613757-184.21164-127.86455-305.935802c3.250794-127.503351 45.87231-232.973545 127.86455-316.049383 81.99224-83.075838 184.21164-126.058554 305.935802-129.309347 127.503351 3.250794 232.973545 46.23351 316.049383 129.309347 83.075838 83.075838 126.058554 188.546032 129.309347 316.049383C949.231746 640.406349 905.887831 742.62575 822.811993 824.617989zM432.716755 684.111464c3.973192 3.973192 8.307584 5.779189 13.364374 6.140388 5.05679 0.361199 9.752381-1.444797 13.364374-5.417989l292.571429-287.514638c3.973192-3.973192 5.779189-8.307584 5.779189-13.364374 0-5.05679-1.805996-9.752381-5.779189-13.364374l1.805996 1.805996c-3.973192-3.973192-8.668783-5.779189-14.086772-6.140388-5.417989-0.361199-10.47478 1.444797-14.809171 5.417989l-264.397884 220.33157c-3.973192 3.250794-8.668783 4.695591-14.447972 4.695591-5.779189 0-10.835979-1.444797-15.53157-3.973192l-94.273016-72.962257c-4.334392-3.250794-9.391182-4.334392-14.447972-3.973192s-9.391182 3.250794-12.641975 7.585185l-2.889594 3.973192c-3.250794 4.334392-4.334392 9.391182-3.973192 14.809171 0.722399 5.417989 2.528395 10.11358 5.779189 14.086772L432.716755 684.111464z" p-id="2324"></path></svg>\n      </i>\n      <div class="text">${n}</div>\n    `,this.containerEl.appendChild(t),e>0&&setTimeout(()=>{this.close(t)},e)}close(n){n.className=n.className.replace("move-in",""),n.className+="move-out",n.addEventListener("animationend",()=>{n.remove()})}}var To={mounted(){!!/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||this.updateCopy()},updated(){!!/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||this.updateCopy()},methods:{updateCopy(){setTimeout(()=>{(['div[class*="language-"] pre','div[class*="aside-code"] aside']instanceof Array||Array.isArray(['div[class*="language-"] pre','div[class*="aside-code"] aside']))&&['div[class*="language-"] pre','div[class*="aside-code"] aside'].forEach(n=>{document.querySelectorAll(n).forEach(this.generateCopyButton)})},1e3)},generateCopyButton(n){if(n.classList.contains("codecopy-enabled"))return;const e=document.createElement("i");e.className="code-copy",e.innerHTML='<svg  style="color:#aaa;font-size:14px" t="1572422231464" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3201" width="14" height="14"><path d="M866.461538 39.384615H354.461538c-43.323077 0-78.769231 35.446154-78.76923 78.769231v39.384616h472.615384c43.323077 0 78.769231 35.446154 78.769231 78.76923v551.384616h39.384615c43.323077 0 78.769231-35.446154 78.769231-78.769231V118.153846c0-43.323077-35.446154-78.769231-78.769231-78.769231z m-118.153846 275.692308c0-43.323077-35.446154-78.769231-78.76923-78.769231H157.538462c-43.323077 0-78.769231 35.446154-78.769231 78.769231v590.769231c0 43.323077 35.446154 78.769231 78.769231 78.769231h512c43.323077 0 78.769231-35.446154 78.76923-78.769231V315.076923z m-354.461538 137.846154c0 11.815385-7.876923 19.692308-19.692308 19.692308h-157.538461c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h157.538461c11.815385 0 19.692308 7.876923 19.692308 19.692308v39.384615z m157.538461 315.076923c0 11.815385-7.876923 19.692308-19.692307 19.692308H216.615385c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h315.076923c11.815385 0 19.692308 7.876923 19.692307 19.692308v39.384615z m78.769231-157.538462c0 11.815385-7.876923 19.692308-19.692308 19.692308H216.615385c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h393.846153c11.815385 0 19.692308 7.876923 19.692308 19.692308v39.384615z" p-id="3202"></path></svg>',e.title="Copy to clipboard",e.addEventListener("click",()=>{this.copyToClipboard(n.innerText)}),n.appendChild(e),n.classList.add("codecopy-enabled")},copyToClipboard(n){const e=document.createElement("textarea");e.value=n,e.setAttribute("readonly",""),e.style.position="absolute",e.style.left="-9999px",document.body.appendChild(e);const t=document.getSelection().rangeCount>0&&document.getSelection().getRangeAt(0);e.select(),document.execCommand("copy");(new Ao).show({text:"复制成功",duration:1e3}),document.body.removeChild(e),t&&(document.getSelection().removeAllRanges(),document.getSelection().addRange(t))}}};!function(n,e){void 0===e&&(e={});var t=e.insertAt;if(n&&"undefined"!=typeof document){var i=document.head||document.getElementsByTagName("head")[0],r=document.createElement("style");r.type="text/css","top"===t&&i.firstChild?i.insertBefore(r,i.firstChild):i.appendChild(r),r.styleSheet?r.styleSheet.cssText=n:r.appendChild(document.createTextNode(n))}}("@media (max-width: 1000px) {\n  .vuepress-plugin-demo-block__h_code {\n    display: none;\n  }\n  .vuepress-plugin-demo-block__app {\n    margin-left: auto !important;\n    margin-right: auto !important;\n  }\n}\n.vuepress-plugin-demo-block__wrapper {\n  margin-top: 10px;\n  border: 1px solid #ebebeb;\n  border-radius: 4px;\n  transition: all 0.2s;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display {\n  height: 400px;\n  display: flex;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display .vuepress-plugin-demo-block__app {\n  width: 300px;\n  border: 1px solid #ebebeb;\n  box-shadow: 1px 1px 3px #ebebeb;\n  margin-right: 5px;\n  overflow: auto;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display .vuepress-plugin-demo-block__h_code {\n  flex: 1;\n  overflow: auto;\n  height: 100%;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display .vuepress-plugin-demo-block__h_code > pre {\n  overflow: visible;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__display {\n  max-height: 400px;\n  overflow: auto;\n}\n.vuepress-plugin-demo-block__wrapper div {\n  box-sizing: border-box;\n}\n.vuepress-plugin-demo-block__wrapper:hover {\n  box-shadow: 0 0 11px rgba(33, 33, 33, 0.2);\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__code {\n  overflow: hidden;\n  height: 0;\n  padding: 0 !important;\n  background-color: #282c34;\n  border-radius: 0 !important;\n  transition: height 0.5s;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__code pre {\n  margin: 0 !important;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__display {\n  padding: 20px;\n  border-bottom: 1px solid #ebebeb;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer {\n  position: relative;\n  text-align: center;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer.vuepress-plugin-demo-block__show-link .vuepress-plugin-demo-block__jsfiddle,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer.vuepress-plugin-demo-block__show-link .vuepress-plugin-demo-block__codepen {\n  opacity: 1;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer.vuepress-plugin-demo-block__show-link .vuepress-plugin-demo-block__expand::before {\n  border-top: none;\n  border-right: 6px solid transparent;\n  border-bottom: 6px solid #ccc;\n  border-left: 6px solid transparent;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__jsfiddle,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__codepen,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__expand span,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__expand {\n  opacity: 1;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__expand::before {\n  border-top-color: #3eaf7c !important;\n  border-bottom-color: #3eaf7c !important;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover svg {\n  fill: #3eaf7c !important;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__expand-text {\n  transition: all 0.5s;\n  opacity: 0;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer form:nth-last-child(2) {\n  right: 50px;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer form:last-child {\n  right: 10px;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button {\n  border-color: transparent;\n  background-color: transparent;\n  font-size: 14px;\n  color: #3eaf7c;\n  cursor: pointer;\n  outline: none;\n  margin: 0;\n  width: 46px;\n  position: relative;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button:hover::before {\n  content: attr(data-tip);\n  white-space: nowrap;\n  position: absolute;\n  top: -30px;\n  left: 50%;\n  color: #eee;\n  line-height: 1;\n  z-index: 1000;\n  border-radius: 4px;\n  padding: 6px;\n  -webkit-transform: translateX(-50%);\n          transform: translateX(-50%);\n  background-color: rgba(0, 0, 0, 0.8);\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button:hover::after {\n  content: '' !important;\n  display: block;\n  position: absolute;\n  left: 50%;\n  top: -5px;\n  -webkit-transform: translateX(-50%);\n          transform: translateX(-50%);\n  border: 5px solid transparent;\n  border-top-color: rgba(0, 0, 0, 0.8);\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button svg {\n  width: 34px;\n  height: 20px;\n  fill: #ccc;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__jsfiddle,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__codepen {\n  position: absolute;\n  top: 10px;\n  transition: all 0.5s;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__expand {\n  position: relative;\n  width: 100px;\n  height: 40px;\n  margin: 0;\n  color: #3eaf7c;\n  font-size: 14px;\n  background-color: transparent;\n  border-color: transparent;\n  outline: none;\n  transition: all 0.5s;\n  cursor: pointer;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__expand::before {\n  content: \"\";\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  width: 0;\n  height: 0;\n  border-top: 6px solid #ccc;\n  border-right: 6px solid transparent;\n  border-left: 6px solid transparent;\n  -webkit-transform: translate(-50%, -50%);\n          transform: translate(-50%, -50%);\n}\n");var Co={jsLib:[],cssLib:[],jsfiddle:!0,codepen:!0,codepenLayout:"left",codepenJsProcessor:"babel",codepenEditors:"101",horizontal:!1,vue:"https://cdn.jsdelivr.net/npm/vue/dist/vue.min.js",react:"https://cdn.jsdelivr.net/npm/react/umd/react.production.min.js",reactDOM:"https://cdn.jsdelivr.net/npm/react-dom/umd/react-dom.production.min.js"},zo={},Bo=function(n){return'<div id="app">\n'.concat(n,"\n</div>")},Io=function(n){return window.$VUEPRESS_DEMO_BLOCK&&void 0!==window.$VUEPRESS_DEMO_BLOCK[n]?window.$VUEPRESS_DEMO_BLOCK[n]:Co[n]},So=function n(e,t,i){var r=document.createElement(e);return t&&Object.keys(t).forEach((function(n){if(n.indexOf("data"))r[n]=t[n];else{var e=n.replace("data","");r.dataset[e]=t[n]}})),i&&i.forEach((function(e){var t=e.tag,i=e.attrs,a=e.children;r.appendChild(n(t,i,a))})),r},Lo=function(n,e,t){var i,r=(i=n.querySelectorAll(".".concat(e)),Array.prototype.slice.call(i));return 1!==r.length||t?r:r[0]},Po=function(n,e){var t,i,r=n.match(/<style>([\s\S]+)<\/style>/),a=n.match(/<template>([\s\S]+)<\/template>/),s=n.match(/<script>([\s\S]+)<\/script>/),o={css:r&&r[1].replace(/^\n|\n$/g,""),html:a&&a[1].replace(/^\n|\n$/g,""),js:s&&s[1].replace(/^\n|\n$/g,""),jsLib:e.jsLib||[],cssLib:e.cssLib||[]};o.htmlTpl=Bo(o.html),o.jsTpl=(t=o.js,i=t.replace(/export\s+default\s*?\{\n*/,"").replace(/\n*\}\s*$/,"").trim(),"new Vue({\n  el: '#app',\n  ".concat(i,"\n})")),o.script=function(n,e){var t=n.split(/export\s+default/),i="(function() {".concat(t[0]," ; return ").concat(t[1],"})()"),r=window.Babel?window.Babel.transform(i,{presets:["es2015"]}).code:i,a=[eval][0](r);return a.template=e,a}(o.js,o.html);var l=Io("vue");return o.jsLib.unshift(l),o},qo=function(n,e){var t,i=n.match(/<style>([\s\S]+)<\/style>/),r=n.match(/<html>([\s\S]+)<\/html>/),a=n.match(/<script>([\s\S]+)<\/script>/),s={css:i&&i[1].replace(/^\n|\n$/g,""),html:r&&r[1].replace(/^\n|\n$/g,""),js:a&&a[1].replace(/^\n|\n$/g,""),jsLib:e.jsLib||[],cssLib:e.cssLib||[]};return s.htmlTpl=s.html,s.jsTpl=s.js,s.script=(t=s.js,window.Babel?window.Babel.transform(t,{presets:["es2015"]}).code:t),s},No=function(n){return n=n.replace("export default ","").replace(/App\.__style__(\s*)=(\s*)`([\s\S]*)?`/,""),n+='ReactDOM.render(React.createElement(App), document.getElementById("app"))'};function $o(){var n=Lo(document,"vuepress-plugin-demo-block__wrapper",!0);n.length?n.forEach((function(n){if("true"!==n.dataset.created){n.style.display="block";var e=Lo(n,"vuepress-plugin-demo-block__code"),t=Lo(n,"vuepress-plugin-demo-block__display"),i=Lo(n,"vuepress-plugin-demo-block__footer"),r=Lo(t,"vuepress-plugin-demo-block__app"),a=decodeURIComponent(n.dataset.code),s=decodeURIComponent(n.dataset.config),o=decodeURIComponent(n.dataset.type);s=s?JSON.parse(s):{};var l=e.querySelector("div").clientHeight,d="react"===o?function(n,e){var t=(0,window.Babel.transform)(n,{presets:["es2015","react"]}).code,i="(function(exports){var module={};module.exports=exports;".concat(t,";return module.exports.__esModule?module.exports.default:module.exports;})({})"),r=new Function("return ".concat(i))(),a={js:r,css:r.__style__||"",jsLib:e.jsLib||[],cssLib:e.cssLib||[],jsTpl:No(n),htmlTpl:Bo("")},s=Io("react"),o=Io("reactDOM");return a.jsLib.unshift(s,o),a}(a,s):"vanilla"===o?qo(a,s):Po(a,s),c=So("button",{className:"".concat("vuepress-plugin-demo-block__expand")});if(i.appendChild(c),c.addEventListener("click",Do.bind(null,c,l,e,i)),Io("jsfiddle")&&i.appendChild(function(n){var e=n.css,t=n.htmlTpl,i=n.jsTpl,r=n.jsLib,a=n.cssLib,s=r.concat(a).concat(Io("cssLib")).concat(Io("jsLib")).join(",");return So("form",{className:"vuepress-plugin-demo-block__jsfiddle",target:"_blank",action:"https://jsfiddle.net/api/post/library/pure/",method:"post"},[{tag:"input",attrs:{type:"hidden",name:"css",value:e}},{tag:"input",attrs:{type:"hidden",name:"html",value:t}},{tag:"input",attrs:{type:"hidden",name:"js",value:i}},{tag:"input",attrs:{type:"hidden",name:"panel_js",value:3}},{tag:"input",attrs:{type:"hidden",name:"wrap",value:1}},{tag:"input",attrs:{type:"hidden",name:"resources",value:s}},{tag:"button",attrs:{type:"submit",className:"vuepress-plugin-demo-block__button",innerHTML:'<?xml version="1.0" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg t="1547088289967" class="icon" style="" viewBox="0 0 1170 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1952" xmlns:xlink="http://www.w3.org/1999/xlink" width="228.515625" height="200"><defs><style type="text/css"></style></defs><path d="M1028.571429 441.142857q63.428571 26.285714 102.571428 83.142857T1170.285714 650.857143q0 93.714286-67.428571 160.285714T940 877.714286q-2.285714 0-6.571429-0.285715t-6-0.285714H232q-97.142857-5.714286-164.571429-71.714286T0 645.142857q0-62.857143 31.428571-116t84-84q-6.857143-22.285714-6.857142-46.857143 0-65.714286 46.857142-112t113.714286-46.285714q54.285714 0 98.285714 33.142857 42.857143-88 127.142858-141.714286t186.571428-53.714285q94.857143 0 174.857143 46T982.571429 248.571429t46.571428 172q0 3.428571-0.285714 10.285714t-0.285714 10.285714zM267.428571 593.142857q0 69.714286 48 110.285714t118.857143 40.571429q78.285714 0 137.142857-56.571429-9.142857-11.428571-27.142857-32.285714T519.428571 626.285714q-38.285714 37.142857-82.285714 37.142857-31.428571 0-53.428571-19.142857T361.714286 594.285714q0-30.285714 22-49.714285t52.285714-19.428572q25.142857 0 48.285714 12t41.714286 31.428572 37.142857 42.857142 39.428572 46.857143 44 42.857143 55.428571 31.428572 69.428571 12q69.142857 0 116.857143-40.857143T936 594.857143q0-69.142857-48-109.714286t-118.285714-40.571428q-81.714286 0-137.714286 55.428571l53.142857 61.714286q37.714286-36.571429 81.142857-36.571429 29.714286 0 52.571429 18.857143t22.857143 48q0 32.571429-21.142857 52.285714t-53.714286 19.714286q-24.571429 0-47.142857-12t-41.142857-31.428571-37.428572-42.857143-39.714286-46.857143-44.285714-42.857143-55.142857-31.428571T434.285714 444.571429q-69.714286 0-118.285714 40.285714T267.428571 593.142857z" p-id="1953"></path></svg>',datatip:"JSFiddle"}}])}(d)),Io("codepen")&&i.appendChild(function(n){var e=n.css,t=n.htmlTpl,i=n.jsTpl,r=n.jsLib,a=n.cssLib,s=JSON.stringify({css:e,html:t,js:i,js_external:r.concat(Io("jsLib")).join(";"),css_external:a.concat(Io("cssLib")).join(";"),layout:Io("codepenLayout"),js_pre_processor:Io("codepenJsProcessor"),editors:Io("codepenEditors")});return So("form",{className:"vuepress-plugin-demo-block__codepen",target:"_blank",action:"https://codepen.io/pen/define",method:"post"},[{tag:"input",attrs:{type:"hidden",name:"data",value:s}},{tag:"button",attrs:{type:"submit",innerHTML:'<?xml version="1.0" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg t="1547088271207" class="icon" style="" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1737" xmlns:xlink="http://www.w3.org/1999/xlink" width="200" height="200"><defs><style type="text/css"></style></defs><path d="M123.428571 668l344.571429 229.714286v-205.142857L277.142857 565.142857z m-35.428571-82.285714l110.285714-73.714286-110.285714-73.714286v147.428572z m468 312l344.571429-229.714286-153.714286-102.857143-190.857143 127.428572v205.142857z m-44-281.714286l155.428571-104-155.428571-104-155.428571 104zM277.142857 458.857143l190.857143-127.428572V126.285714L123.428571 356z m548.571429 53.142857l110.285714 73.714286V438.285714z m-78.857143-53.142857l153.714286-102.857143-344.571429-229.714286v205.142857z m277.142857-102.857143v312q0 23.428571-19.428571 36.571429l-468 312q-12 7.428571-24.571429 7.428571t-24.571429-7.428571L19.428571 704.571429q-19.428571-13.142857-19.428571-36.571429V356q0-23.428571 19.428571-36.571429L487.428571 7.428571q12-7.428571 24.571429-7.428571t24.571429 7.428571l468 312q19.428571 13.142857 19.428571 36.571429z" p-id="1738"></path></svg>',className:"vuepress-plugin-demo-block__button",datatip:"Codepen"}}])}(d)),void 0!==s.horizontal?s.horizontal:Io("horizontal")){n.classList.add("vuepress-plugin-demo-block__horizontal");var u=e.firstChild.cloneNode(!0);u.classList.add("vuepress-plugin-demo-block__h_code"),t.appendChild(u)}if(d.css&&function(n){if(!zo[n]){var e=So("style",{innerHTML:n});document.body.appendChild(e),zo[n]=!0}}(d.css),"react"===o)ReactDOM.render(React.createElement(d.js),r);else if("vue"===o){var p=(new(Vue.extend(d.script))).$mount();r.appendChild(p.$el)}else"vanilla"===o&&(r.innerHTML=d.html,new Function("return (function(){".concat(d.script,"})()"))());n.dataset.created="true"}})):setTimeout((function(n){$o()}),300)}function Do(n,e,t,i){var r="1"!==n.dataset.isExpand;t.style.height=r?"".concat(e,"px"):0,r?i.classList.add("vuepress-plugin-demo-block__show-link"):i.classList.remove("vuepress-plugin-demo-block__show-link"),n.dataset.isExpand=r?"1":"0"}var Go={mounted:function(){window.$VUEPRESS_DEMO_BLOCK={jsfiddle:!1,codepen:!0,horizontal:!1},$o()},updated:function(){$o()}},Fo="auto",Oo="zoom-in",Uo="zoom-out",Ro="grab",Mo="move";function Ho(n,e,t){var i=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],r={passive:!1};i?n.addEventListener(e,t,r):n.removeEventListener(e,t,r)}function Vo(n,e){if(n){var t=new Image;t.onload=function(){e&&e(t)},t.src=n}}function Zo(n){return n.dataset.original?n.dataset.original:"A"===n.parentNode.tagName?n.parentNode.getAttribute("href"):null}function Wo(n,e,t){!function(n){var e=Ko,t=Xo;if(n.transition){var i=n.transition;delete n.transition,n[e]=i}if(n.transform){var r=n.transform;delete n.transform,n[t]=r}}(e);var i=n.style,r={};for(var a in e)t&&(r[a]=i[a]||""),i[a]=e[a];return r}var Ko="transition",Xo="transform",Yo="transform",Jo="transitionend";var Qo=function(){},nl={enableGrab:!0,preloadImage:!1,closeOnWindowResize:!0,transitionDuration:.4,transitionTimingFunction:"cubic-bezier(0.4, 0, 0, 1)",bgColor:"rgb(255, 255, 255)",bgOpacity:1,scaleBase:1,scaleExtra:.5,scrollThreshold:40,zIndex:998,customSize:null,onOpen:Qo,onClose:Qo,onGrab:Qo,onMove:Qo,onRelease:Qo,onBeforeOpen:Qo,onBeforeClose:Qo,onBeforeGrab:Qo,onBeforeRelease:Qo,onImageLoading:Qo,onImageLoaded:Qo},el={init:function(n){var e,t;e=this,t=n,Object.getOwnPropertyNames(Object.getPrototypeOf(e)).forEach((function(n){e[n]=e[n].bind(t)}))},click:function(n){if(n.preventDefault(),il(n))return window.open(this.target.srcOriginal||n.currentTarget.src,"_blank");this.shown?this.released?this.close():this.release():this.open(n.currentTarget)},scroll:function(){var n=document.documentElement||document.body.parentNode||document.body,e=window.pageXOffset||n.scrollLeft,t=window.pageYOffset||n.scrollTop;null===this.lastScrollPosition&&(this.lastScrollPosition={x:e,y:t});var i=this.lastScrollPosition.x-e,r=this.lastScrollPosition.y-t,a=this.options.scrollThreshold;(Math.abs(r)>=a||Math.abs(i)>=a)&&(this.lastScrollPosition=null,this.close())},keydown:function(n){(function(n){return"Escape"===(n.key||n.code)||27===n.keyCode})(n)&&(this.released?this.close():this.release(this.close))},mousedown:function(n){if(tl(n)&&!il(n)){n.preventDefault();var e=n.clientX,t=n.clientY;this.pressTimer=setTimeout(function(){this.grab(e,t)}.bind(this),200)}},mousemove:function(n){this.released||this.move(n.clientX,n.clientY)},mouseup:function(n){tl(n)&&!il(n)&&(clearTimeout(this.pressTimer),this.released?this.close():this.release())},touchstart:function(n){n.preventDefault();var e=n.touches[0],t=e.clientX,i=e.clientY;this.pressTimer=setTimeout(function(){this.grab(t,i)}.bind(this),200)},touchmove:function(n){if(!this.released){var e=n.touches[0],t=e.clientX,i=e.clientY;this.move(t,i)}},touchend:function(n){(function(n){n.targetTouches.length})(n)||(clearTimeout(this.pressTimer),this.released?this.close():this.release())},clickOverlay:function(){this.close()},resizeWindow:function(){this.close()}};function tl(n){return 0===n.button}function il(n){return n.metaKey||n.ctrlKey}var rl={init:function(n){this.el=document.createElement("div"),this.instance=n,this.parent=document.body,Wo(this.el,{position:"fixed",top:0,left:0,right:0,bottom:0,opacity:0}),this.updateStyle(n.options),Ho(this.el,"click",n.handler.clickOverlay.bind(n))},updateStyle:function(n){Wo(this.el,{zIndex:n.zIndex,backgroundColor:n.bgColor,transition:"opacity\n        "+n.transitionDuration+"s\n        "+n.transitionTimingFunction})},insert:function(){this.parent.appendChild(this.el)},remove:function(){this.parent.removeChild(this.el)},fadeIn:function(){this.el.offsetWidth,this.el.style.opacity=this.instance.options.bgOpacity},fadeOut:function(){this.el.style.opacity=0}},al="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(n){return typeof n}:function(n){return n&&"function"==typeof Symbol&&n.constructor===Symbol&&n!==Symbol.prototype?"symbol":typeof n},sl=function(){function n(n,e){for(var t=0;t<e.length;t++){var i=e[t];i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),Object.defineProperty(n,i.key,i)}}return function(e,t,i){return t&&n(e.prototype,t),i&&n(e,i),e}}(),ol=Object.assign||function(n){for(var e=1;e<arguments.length;e++){var t=arguments[e];for(var i in t)Object.prototype.hasOwnProperty.call(t,i)&&(n[i]=t[i])}return n},ll={init:function(n,e){this.el=n,this.instance=e,this.srcThumbnail=this.el.getAttribute("src"),this.srcset=this.el.getAttribute("srcset"),this.srcOriginal=Zo(this.el),this.rect=this.el.getBoundingClientRect(),this.translate=null,this.scale=null,this.styleOpen=null,this.styleClose=null},zoomIn:function(){var n=this.instance.options,e=n.zIndex,t=n.enableGrab,i=n.transitionDuration,r=n.transitionTimingFunction;this.translate=this.calculateTranslate(),this.scale=this.calculateScale(),this.styleOpen={position:"relative",zIndex:e+1,cursor:t?Ro:Uo,transition:Yo+"\n        "+i+"s\n        "+r,transform:"translate3d("+this.translate.x+"px, "+this.translate.y+"px, 0px)\n        scale("+this.scale.x+","+this.scale.y+")",height:this.rect.height+"px",width:this.rect.width+"px"},this.el.offsetWidth,this.styleClose=Wo(this.el,this.styleOpen,!0)},zoomOut:function(){this.el.offsetWidth,Wo(this.el,{transform:"none"})},grab:function(n,e,t){var i=dl(),r=i.x-n,a=i.y-e;Wo(this.el,{cursor:Mo,transform:"translate3d(\n        "+(this.translate.x+r)+"px, "+(this.translate.y+a)+"px, 0px)\n        scale("+(this.scale.x+t)+","+(this.scale.y+t)+")"})},move:function(n,e,t){var i=dl(),r=i.x-n,a=i.y-e;Wo(this.el,{transition:Yo,transform:"translate3d(\n        "+(this.translate.x+r)+"px, "+(this.translate.y+a)+"px, 0px)\n        scale("+(this.scale.x+t)+","+(this.scale.y+t)+")"})},restoreCloseStyle:function(){Wo(this.el,this.styleClose)},restoreOpenStyle:function(){Wo(this.el,this.styleOpen)},upgradeSource:function(){if(this.srcOriginal){var n=this.el.parentNode;this.srcset&&this.el.removeAttribute("srcset");var e=this.el.cloneNode(!1);e.setAttribute("src",this.srcOriginal),e.style.position="fixed",e.style.visibility="hidden",n.appendChild(e),setTimeout(function(){this.el.setAttribute("src",this.srcOriginal),n.removeChild(e)}.bind(this),50)}},downgradeSource:function(){this.srcOriginal&&(this.srcset&&this.el.setAttribute("srcset",this.srcset),this.el.setAttribute("src",this.srcThumbnail))},calculateTranslate:function(){var n=dl(),e=this.rect.left+this.rect.width/2,t=this.rect.top+this.rect.height/2;return{x:n.x-e,y:n.y-t}},calculateScale:function(){var n=this.el.dataset,e=n.zoomingHeight,t=n.zoomingWidth,i=this.instance.options,r=i.customSize,a=i.scaleBase;if(!r&&e&&t)return{x:t/this.rect.width,y:e/this.rect.height};if(r&&"object"===(void 0===r?"undefined":al(r)))return{x:r.width/this.rect.width,y:r.height/this.rect.height};var s=this.rect.width/2,o=this.rect.height/2,l=dl(),d={x:l.x-s,y:l.y-o},c=d.x/s,u=d.y/o,p=a+Math.min(c,u);if(r&&"string"==typeof r){var m=t||this.el.naturalWidth,h=e||this.el.naturalHeight,f=parseFloat(r)*m/(100*this.rect.width),g=parseFloat(r)*h/(100*this.rect.height);if(p>f||p>g)return{x:f,y:g}}return{x:p,y:p}}};function dl(){var n=document.documentElement;return{x:Math.min(n.clientWidth,window.innerWidth)/2,y:Math.min(n.clientHeight,window.innerHeight)/2}}function cl(n,e,t){["mousedown","mousemove","mouseup","touchstart","touchmove","touchend"].forEach((function(i){Ho(n,i,e[i],t)}))}var ul=function(){function n(e){!function(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}(this,n),this.target=Object.create(ll),this.overlay=Object.create(rl),this.handler=Object.create(el),this.body=document.body,this.shown=!1,this.lock=!1,this.released=!0,this.lastScrollPosition=null,this.pressTimer=null,this.options=ol({},nl,e),this.overlay.init(this),this.handler.init(this)}return sl(n,[{key:"listen",value:function(n){if("string"==typeof n)for(var e=document.querySelectorAll(n),t=e.length;t--;)this.listen(e[t]);else"IMG"===n.tagName&&(n.style.cursor=Oo,Ho(n,"click",this.handler.click),this.options.preloadImage&&Vo(Zo(n)));return this}},{key:"config",value:function(n){return n?(ol(this.options,n),this.overlay.updateStyle(this.options),this):this.options}},{key:"open",value:function(n){var e=this,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.options.onOpen;if(!this.shown&&!this.lock){var i="string"==typeof n?document.querySelector(n):n;if("IMG"===i.tagName){if(this.options.onBeforeOpen(i),this.target.init(i,this),!this.options.preloadImage){var r=this.target.srcOriginal;null!=r&&(this.options.onImageLoading(i),Vo(r,this.options.onImageLoaded))}this.shown=!0,this.lock=!0,this.target.zoomIn(),this.overlay.insert(),this.overlay.fadeIn(),Ho(document,"scroll",this.handler.scroll),Ho(document,"keydown",this.handler.keydown),this.options.closeOnWindowResize&&Ho(window,"resize",this.handler.resizeWindow);var a=function n(){Ho(i,Jo,n,!1),e.lock=!1,e.target.upgradeSource(),e.options.enableGrab&&cl(document,e.handler,!0),t(i)};return Ho(i,Jo,a),this}}}},{key:"close",value:function(){var n=this,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.options.onClose;if(this.shown&&!this.lock){var t=this.target.el;this.options.onBeforeClose(t),this.lock=!0,this.body.style.cursor=Fo,this.overlay.fadeOut(),this.target.zoomOut(),Ho(document,"scroll",this.handler.scroll,!1),Ho(document,"keydown",this.handler.keydown,!1),this.options.closeOnWindowResize&&Ho(window,"resize",this.handler.resizeWindow,!1);var i=function i(){Ho(t,Jo,i,!1),n.shown=!1,n.lock=!1,n.target.downgradeSource(),n.options.enableGrab&&cl(document,n.handler,!1),n.target.restoreCloseStyle(),n.overlay.remove(),e(t)};return Ho(t,Jo,i),this}}},{key:"grab",value:function(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:this.options.scaleExtra,i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:this.options.onGrab;if(this.shown&&!this.lock){var r=this.target.el;this.options.onBeforeGrab(r),this.released=!1,this.target.grab(n,e,t);var a=function n(){Ho(r,Jo,n,!1),i(r)};return Ho(r,Jo,a),this}}},{key:"move",value:function(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:this.options.scaleExtra,i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:this.options.onMove;if(this.shown&&!this.lock){this.released=!1,this.body.style.cursor=Mo,this.target.move(n,e,t);var r=this.target.el,a=function n(){Ho(r,Jo,n,!1),i(r)};return Ho(r,Jo,a),this}}},{key:"release",value:function(){var n=this,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.options.onRelease;if(this.shown&&!this.lock){var t=this.target.el;this.options.onBeforeRelease(t),this.lock=!0,this.body.style.cursor=Fo,this.target.restoreOpenStyle();var i=function i(){Ho(t,Jo,i,!1),n.lock=!1,n.released=!0,e(t)};return Ho(t,Jo,i),this}}}]),n}();const pl=JSON.parse('{"bgColor":"rgba(0,0,0,0.6)"}'),ml=Number("500");class hl{constructor(){this.instance=new ul(pl)}update(n=".theme-vdoing-content img:not(.no-zoom)"){"undefined"!=typeof window&&this.instance.listen(n)}updateDelay(n=".theme-vdoing-content img:not(.no-zoom)",e=ml){setTimeout(()=>this.update(n),e)}}var fl=[go,_o,jo,To,Go,{watch:{"$page.path"(){void 0!==this.$vuepress.zooming&&this.$vuepress.zooming.updateDelay()}},mounted(){this.$vuepress.zooming=new hl,this.$vuepress.zooming.updateDelay()}}],gl={name:"GlobalLayout",computed:{layout(){const n=this.getLayout();return uo("layout",n),Vt.component(n)}},methods:{getLayout(){if(this.$page.path){const n=this.$page.frontmatter.layout;return n&&(this.$vuepress.getLayoutAsyncComponent(n)||this.$vuepress.getVueComponent(n))?n:"Layout"}return"NotFound"}}},bl=t(7),vl=Object(bl.a)(gl,(function(){return(0,this._self._c)(this.layout,{tag:"component"})}),[],!1,null,null,null).exports;!function(n,e,t){switch(e){case"components":n[e]||(n[e]={}),Object.assign(n[e],t);break;case"mixins":n[e]||(n[e]=[]),n[e].push(...t);break;default:throw new Error("Unknown option name.")}}(vl,"mixins",fl);const xl=[{name:"v-4cb1244c",path:"/pages/9b85e0/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-4cb1244c").then(t)}},{path:"/pages/9b85e0/index.html",redirect:"/pages/9b85e0/"},{path:"/00.目录导航/00.全站导航.html",redirect:"/pages/9b85e0/"},{name:"v-18efd267",path:"/pages/fa0f35/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-18efd267").then(t)}},{path:"/pages/fa0f35/index.html",redirect:"/pages/fa0f35/"},{path:"/00.目录导航/01.计算机基础.html",redirect:"/pages/fa0f35/"},{name:"v-7b26bc54",path:"/pages/240fd4/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-7b26bc54").then(t)}},{path:"/pages/240fd4/index.html",redirect:"/pages/240fd4/"},{path:"/00.目录导航/02.分布式系统.html",redirect:"/pages/240fd4/"},{name:"v-3ba697dd",path:"/pages/0232db/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-3ba697dd").then(t)}},{path:"/pages/0232db/index.html",redirect:"/pages/0232db/"},{path:"/00.目录导航/04.胡思乱想.html",redirect:"/pages/0232db/"},{name:"v-79372922",path:"/pages/93824d/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-79372922").then(t)}},{path:"/pages/93824d/index.html",redirect:"/pages/93824d/"},{path:"/00.目录导航/03.我的开源项目.html",redirect:"/pages/93824d/"},{name:"v-1b448f46",path:"/pages/bb810c/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-1b448f46").then(t)}},{path:"/pages/bb810c/index.html",redirect:"/pages/bb810c/"},{path:"/01.C&Cpp学习笔记/01.C语言基础/01.数据类型.html",redirect:"/pages/bb810c/"},{name:"v-7d18746a",path:"/pages/d1c8a2/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-7d18746a").then(t)}},{path:"/pages/d1c8a2/index.html",redirect:"/pages/d1c8a2/"},{path:"/01.C&Cpp学习笔记/01.C语言基础/03.结构类型.html",redirect:"/pages/d1c8a2/"},{name:"v-5e53ef36",path:"/pages/8a62ea/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-5e53ef36").then(t)}},{path:"/pages/8a62ea/index.html",redirect:"/pages/8a62ea/"},{path:"/01.C&Cpp学习笔记/01.C语言基础/04.链表.html",redirect:"/pages/8a62ea/"},{name:"v-512a5f00",path:"/pages/28b16e/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-512a5f00").then(t)}},{path:"/pages/28b16e/index.html",redirect:"/pages/28b16e/"},{path:"/01.C&Cpp学习笔记/01.C语言基础/02.指针与字符串.html",redirect:"/pages/28b16e/"},{name:"v-5a1e5a8f",path:"/pages/4c654b/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-5a1e5a8f").then(t)}},{path:"/pages/4c654b/index.html",redirect:"/pages/4c654b/"},{path:"/01.C&Cpp学习笔记/01.C语言基础/05.程序结构.html",redirect:"/pages/4c654b/"},{name:"v-529fd5e8",path:"/pages/31eb8a/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-529fd5e8").then(t)}},{path:"/pages/31eb8a/index.html",redirect:"/pages/31eb8a/"},{path:"/01.C&Cpp学习笔记/01.C语言基础/06.文件.html",redirect:"/pages/31eb8a/"},{name:"v-f6cde29c",path:"/pages/f80b37/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-f6cde29c").then(t)}},{path:"/pages/f80b37/index.html",redirect:"/pages/f80b37/"},{path:"/01.C&Cpp学习笔记/02.C++面向对象编程/01.C++面向对象/02.C++ 类和对象基础.html",redirect:"/pages/f80b37/"},{name:"v-08ca4e2c",path:"/pages/c03a08/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-08ca4e2c").then(t)}},{path:"/pages/c03a08/index.html",redirect:"/pages/c03a08/"},{path:"/01.C&Cpp学习笔记/02.C++面向对象编程/01.C++面向对象/03.C++ 构造函数与析构函数.html",redirect:"/pages/c03a08/"},{name:"v-5d1370e8",path:"/pages/1718db/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-5d1370e8").then(t)}},{path:"/pages/1718db/index.html",redirect:"/pages/1718db/"},{path:"/01.C&Cpp学习笔记/02.C++面向对象编程/01.C++面向对象/01.从 C 到 C++.html",redirect:"/pages/1718db/"},{name:"v-28bc7684",path:"/pages/7e1638/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-28bc7684").then(t)}},{path:"/pages/7e1638/index.html",redirect:"/pages/7e1638/"},{path:"/01.C&Cpp学习笔记/02.C++面向对象编程/01.C++面向对象/06.C++ 继承.html",redirect:"/pages/7e1638/"},{name:"v-3cae0aa0",path:"/pages/7df88b/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-3cae0aa0").then(t)}},{path:"/pages/7df88b/index.html",redirect:"/pages/7df88b/"},{path:"/01.C&Cpp学习笔记/02.C++面向对象编程/01.C++面向对象/07.C++ 多态.html",redirect:"/pages/7df88b/"},{name:"v-85e7f1bc",path:"/pages/8176d2/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-85e7f1bc").then(t)}},{path:"/pages/8176d2/index.html",redirect:"/pages/8176d2/"},{path:"/01.C&Cpp学习笔记/02.C++面向对象编程/01.C++面向对象/05.运算符重载.html",redirect:"/pages/8176d2/"},{name:"v-fa4616d8",path:"/pages/bbcad6/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-fa4616d8").then(t)}},{path:"/pages/bbcad6/index.html",redirect:"/pages/bbcad6/"},{path:"/01.C&Cpp学习笔记/02.C++面向对象编程/01.C++面向对象/04.C++ 类和对象提高.html",redirect:"/pages/bbcad6/"},{name:"v-06da7966",path:"/pages/f0b4b2/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-06da7966").then(t)}},{path:"/pages/f0b4b2/index.html",redirect:"/pages/f0b4b2/"},{path:"/01.C&Cpp学习笔记/02.C++面向对象编程/02.C++ STL/01.C++ 输入输出流.html",redirect:"/pages/f0b4b2/"},{name:"v-57adafc4",path:"/pages/b3a5d5/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-57adafc4").then(t)}},{path:"/pages/b3a5d5/index.html",redirect:"/pages/b3a5d5/"},{path:"/01.C&Cpp学习笔记/02.C++面向对象编程/02.C++ STL/02.C++ 泛型编程.html",redirect:"/pages/b3a5d5/"},{name:"v-4477712c",path:"/pages/9b802c/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-4477712c").then(t)}},{path:"/pages/9b802c/index.html",redirect:"/pages/9b802c/"},{path:"/01.C&Cpp学习笔记/02.C++面向对象编程/02.C++ STL/03.C++ string类.html",redirect:"/pages/9b802c/"},{name:"v-74760cb8",path:"/pages/2fa612/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-74760cb8").then(t)}},{path:"/pages/2fa612/index.html",redirect:"/pages/2fa612/"},{path:"/01.C&Cpp学习笔记/02.C++面向对象编程/02.C++ STL/06.C++ 标准模板库 STL 函数对象.html",redirect:"/pages/2fa612/"},{name:"v-0a5e0a62",path:"/pages/6cbf31/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-0a5e0a62").then(t)}},{path:"/pages/6cbf31/index.html",redirect:"/pages/6cbf31/"},{path:"/01.C&Cpp学习笔记/02.C++面向对象编程/02.C++ STL/05.C++ 标准模板库 STL 顺序容器.html",redirect:"/pages/6cbf31/"},{name:"v-032fbe38",path:"/pages/c24021/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-032fbe38").then(t)}},{path:"/pages/c24021/index.html",redirect:"/pages/c24021/"},{path:"/01.C&Cpp学习笔记/02.C++面向对象编程/02.C++ STL/08.C++ 标准模板库 STL 容器适配器.html",redirect:"/pages/c24021/"},{name:"v-2002d43c",path:"/pages/79b686/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-2002d43c").then(t)}},{path:"/pages/79b686/index.html",redirect:"/pages/79b686/"},{path:"/01.C&Cpp学习笔记/02.C++面向对象编程/02.C++ STL/04.C++ 标准模板库 STL 概述.html",redirect:"/pages/79b686/"},{name:"v-10b51f52",path:"/pages/dc0db4/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-10b51f52").then(t)}},{path:"/pages/dc0db4/index.html",redirect:"/pages/dc0db4/"},{path:"/01.C&Cpp学习笔记/02.C++面向对象编程/03.C++ 新特性/01.C++11 新特性.html",redirect:"/pages/dc0db4/"},{name:"v-42065d9a",path:"/pages/4b9df2/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-42065d9a").then(t)}},{path:"/pages/4b9df2/index.html",redirect:"/pages/4b9df2/"},{path:"/02.Golang学习笔记/01.Golang基础/01.数据类型/01.变量与常量.html",redirect:"/pages/4b9df2/"},{name:"v-270b393e",path:"/pages/97e5f5/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-270b393e").then(t)}},{path:"/pages/97e5f5/index.html",redirect:"/pages/97e5f5/"},{path:"/02.Golang学习笔记/01.Golang基础/01.数据类型/02.基础数据类型之值类型.html",redirect:"/pages/97e5f5/"},{name:"v-1d4eb24c",path:"/pages/410fb6/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-1d4eb24c").then(t)}},{path:"/pages/410fb6/index.html",redirect:"/pages/410fb6/"},{path:"/02.Golang学习笔记/01.Golang基础/01.数据类型/03.基础数据类型之引用类型.html",redirect:"/pages/410fb6/"},{name:"v-3f0ce116",path:"/pages/d8dd95/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-3f0ce116").then(t)}},{path:"/pages/d8dd95/index.html",redirect:"/pages/d8dd95/"},{path:"/02.Golang学习笔记/01.Golang基础/02.流程控制/01.条件判断.html",redirect:"/pages/d8dd95/"},{name:"v-96f454f6",path:"/pages/3a35c4/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-96f454f6").then(t)}},{path:"/pages/3a35c4/index.html",redirect:"/pages/3a35c4/"},{path:"/02.Golang学习笔记/01.Golang基础/02.流程控制/02.循环控制.html",redirect:"/pages/3a35c4/"},{name:"v-5a00904b",path:"/pages/06199f/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-5a00904b").then(t)}},{path:"/pages/06199f/index.html",redirect:"/pages/06199f/"},{path:"/02.Golang学习笔记/01.Golang基础/03.函数/01.函数基础.html",redirect:"/pages/06199f/"},{name:"v-4e2c513c",path:"/pages/f5e003/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-4e2c513c").then(t)}},{path:"/pages/f5e003/index.html",redirect:"/pages/f5e003/"},{path:"/02.Golang学习笔记/01.Golang基础/03.函数/03.延迟调用.html",redirect:"/pages/f5e003/"},{name:"v-bdc2433c",path:"/pages/0f3851/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-bdc2433c").then(t)}},{path:"/pages/0f3851/index.html",redirect:"/pages/0f3851/"},{path:"/03.LeetCode刷题笔记/01.基础算法/01.双指针/01.双指针基础.html",redirect:"/pages/0f3851/"},{name:"v-72f63995",path:"/pages/95ec3d/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-72f63995").then(t)}},{path:"/pages/95ec3d/index.html",redirect:"/pages/95ec3d/"},{path:"/02.Golang学习笔记/01.Golang基础/03.函数/02.匿名函数与闭包.html",redirect:"/pages/95ec3d/"},{name:"v-a83c2a9c",path:"/pages/56c2ea/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-a83c2a9c").then(t)}},{path:"/pages/56c2ea/index.html",redirect:"/pages/56c2ea/"},{path:"/01.C&Cpp学习笔记/02.C++面向对象编程/02.C++ STL/07.C++ 标准模板库 STL 关联容器.html",redirect:"/pages/56c2ea/"},{name:"v-b34a2986",path:"/pages/700e2e/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-b34a2986").then(t)}},{path:"/pages/700e2e/index.html",redirect:"/pages/700e2e/"},{path:"/03.LeetCode刷题笔记/01.基础算法/01.双指针/02.碰撞指针.html",redirect:"/pages/700e2e/"},{name:"v-dec39b1a",path:"/pages/85ec9f/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-dec39b1a").then(t)}},{path:"/pages/85ec9f/index.html",redirect:"/pages/85ec9f/"},{path:"/03.LeetCode刷题笔记/01.基础算法/01.双指针/03.快慢指针.html",redirect:"/pages/85ec9f/"},{name:"v-a12e0342",path:"/pages/90a84d/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-a12e0342").then(t)}},{path:"/pages/90a84d/index.html",redirect:"/pages/90a84d/"},{path:"/03.LeetCode刷题笔记/01.基础算法/01.双指针/04.滑动窗口.html",redirect:"/pages/90a84d/"},{name:"v-3842244f",path:"/pages/2971fd/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-3842244f").then(t)}},{path:"/pages/2971fd/index.html",redirect:"/pages/2971fd/"},{path:"/03.LeetCode刷题笔记/01.基础算法/01.双指针/TwoPointer.html",redirect:"/pages/2971fd/"},{name:"v-60717c59",path:"/pages/3b46c0/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-60717c59").then(t)}},{path:"/pages/3b46c0/index.html",redirect:"/pages/3b46c0/"},{path:"/03.LeetCode刷题笔记/01.基础算法/02.二分查找/01.基础应用.html",redirect:"/pages/3b46c0/"},{name:"v-4b7cce06",path:"/pages/0a4983/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-4b7cce06").then(t)}},{path:"/pages/0a4983/index.html",redirect:"/pages/0a4983/"},{path:"/03.LeetCode刷题笔记/01.基础算法/02.二分查找/02.边界收缩.html",redirect:"/pages/0a4983/"},{name:"v-78213b4e",path:"/pages/b8ad26/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-78213b4e").then(t)}},{path:"/pages/b8ad26/index.html",redirect:"/pages/b8ad26/"},{path:"/03.LeetCode刷题笔记/01.基础算法/02.二分查找/BinSearch.html",redirect:"/pages/b8ad26/"},{name:"v-5590ed59",path:"/pages/d09927/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-5590ed59").then(t)}},{path:"/pages/d09927/index.html",redirect:"/pages/d09927/"},{path:"/03.LeetCode刷题笔记/01.基础算法/02.二分查找/03.局部有序.html",redirect:"/pages/d09927/"},{name:"v-3094c696",path:"/pages/3aa832/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-3094c696").then(t)}},{path:"/pages/3aa832/index.html",redirect:"/pages/3aa832/"},{path:"/03.LeetCode刷题笔记/01.基础算法/03.排序算法/01.八大排序.html",redirect:"/pages/3aa832/"},{name:"v-a241b3e0",path:"/pages/8c54f6/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-a241b3e0").then(t)}},{path:"/pages/8c54f6/index.html",redirect:"/pages/8c54f6/"},{path:"/03.LeetCode刷题笔记/01.基础算法/03.排序算法/02.快速排序.html",redirect:"/pages/8c54f6/"},{name:"v-00efbfe0",path:"/pages/88ecc3/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-00efbfe0").then(t)}},{path:"/pages/88ecc3/index.html",redirect:"/pages/88ecc3/"},{path:"/03.LeetCode刷题笔记/01.基础算法/04.优先搜索/02.网格结构深度优先搜索.html",redirect:"/pages/88ecc3/"},{name:"v-8fb6558c",path:"/pages/c2b2d7/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-8fb6558c").then(t)}},{path:"/pages/c2b2d7/index.html",redirect:"/pages/c2b2d7/"},{path:"/03.LeetCode刷题笔记/01.基础算法/03.排序算法/05.堆排序.html",redirect:"/pages/c2b2d7/"},{name:"v-f18cce36",path:"/pages/9c6520/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-f18cce36").then(t)}},{path:"/pages/9c6520/index.html",redirect:"/pages/9c6520/"},{path:"/03.LeetCode刷题笔记/01.基础算法/04.优先搜索/01.递归.html",redirect:"/pages/9c6520/"},{name:"v-0ba825b2",path:"/pages/35b7a7/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-0ba825b2").then(t)}},{path:"/pages/35b7a7/index.html",redirect:"/pages/35b7a7/"},{path:"/03.LeetCode刷题笔记/01.基础算法/04.优先搜索/03.树结构深度优先搜索.html",redirect:"/pages/35b7a7/"},{name:"v-74e5670c",path:"/pages/5134a9/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-74e5670c").then(t)}},{path:"/pages/5134a9/index.html",redirect:"/pages/5134a9/"},{path:"/03.LeetCode刷题笔记/01.基础算法/04.优先搜索/06.树结构广度优先搜索.html",redirect:"/pages/5134a9/"},{name:"v-45d40013",path:"/pages/13d287/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-45d40013").then(t)}},{path:"/pages/13d287/index.html",redirect:"/pages/13d287/"},{path:"/03.LeetCode刷题笔记/01.基础算法/04.优先搜索/04.图结构深度优先搜索.html",redirect:"/pages/13d287/"},{name:"v-c166e812",path:"/pages/b6a984/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-c166e812").then(t)}},{path:"/pages/b6a984/index.html",redirect:"/pages/b6a984/"},{path:"/03.LeetCode刷题笔记/01.基础算法/04.优先搜索/FirstSearch.html",redirect:"/pages/b6a984/"},{name:"v-1b6e1506",path:"/pages/9c7a53/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-1b6e1506").then(t)}},{path:"/pages/9c7a53/index.html",redirect:"/pages/9c7a53/"},{path:"/03.LeetCode刷题笔记/01.基础算法/05.回溯算法/01.递归.html",redirect:"/pages/9c7a53/"},{name:"v-bbc963f8",path:"/pages/3cb71c/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-bbc963f8").then(t)}},{path:"/pages/3cb71c/index.html",redirect:"/pages/3cb71c/"},{path:"/03.LeetCode刷题笔记/01.基础算法/04.优先搜索/05.网格结构广度优先搜索.html",redirect:"/pages/3cb71c/"},{name:"v-19942982",path:"/pages/cbe7a5/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-19942982").then(t)}},{path:"/pages/cbe7a5/index.html",redirect:"/pages/cbe7a5/"},{path:"/03.LeetCode刷题笔记/01.基础算法/05.回溯算法/02.子集问题.html",redirect:"/pages/cbe7a5/"},{name:"v-a1dd7d26",path:"/pages/4da67f/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-a1dd7d26").then(t)}},{path:"/pages/4da67f/index.html",redirect:"/pages/4da67f/"},{path:"/03.LeetCode刷题笔记/01.基础算法/04.优先搜索/07.图结构广度优先搜索.html",redirect:"/pages/4da67f/"},{name:"v-23bee3d7",path:"/pages/e9a845/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-23bee3d7").then(t)}},{path:"/pages/e9a845/index.html",redirect:"/pages/e9a845/"},{path:"/03.LeetCode刷题笔记/01.基础算法/05.回溯算法/05.回溯搜索问题.html",redirect:"/pages/e9a845/"},{name:"v-373e1bea",path:"/pages/21e47b/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-373e1bea").then(t)}},{path:"/pages/21e47b/index.html",redirect:"/pages/21e47b/"},{path:"/03.LeetCode刷题笔记/01.基础算法/05.回溯算法/04.组合问题.html",redirect:"/pages/21e47b/"},{name:"v-7596a1ba",path:"/pages/71f066/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-7596a1ba").then(t)}},{path:"/pages/71f066/index.html",redirect:"/pages/71f066/"},{path:"/03.LeetCode刷题笔记/01.基础算法/05.回溯算法/03.全排列问题.html",redirect:"/pages/71f066/"},{name:"v-d7b3967a",path:"/pages/e3b123/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-d7b3967a").then(t)}},{path:"/pages/e3b123/index.html",redirect:"/pages/e3b123/"},{path:"/03.LeetCode刷题笔记/02.基础数据结构/01.线性表与哈希表/01.数组.html",redirect:"/pages/e3b123/"},{name:"v-55610c8f",path:"/pages/c428b1/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-55610c8f").then(t)}},{path:"/pages/c428b1/index.html",redirect:"/pages/c428b1/"},{path:"/03.LeetCode刷题笔记/01.基础算法/05.回溯算法/Backtrack.html",redirect:"/pages/c428b1/"},{name:"v-044a4948",path:"/pages/c3fc14/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-044a4948").then(t)}},{path:"/pages/c3fc14/index.html",redirect:"/pages/c3fc14/"},{path:"/03.LeetCode刷题笔记/02.基础数据结构/01.线性表与哈希表/02.栈和队列.html",redirect:"/pages/c3fc14/"},{name:"v-2ded1aae",path:"/pages/366d13/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-2ded1aae").then(t)}},{path:"/pages/366d13/index.html",redirect:"/pages/366d13/"},{path:"/03.LeetCode刷题笔记/02.基础数据结构/01.线性表与哈希表/04.优先队列.html",redirect:"/pages/366d13/"},{name:"v-510b3c03",path:"/pages/45a757/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-510b3c03").then(t)}},{path:"/pages/45a757/index.html",redirect:"/pages/45a757/"},{path:"/03.LeetCode刷题笔记/02.基础数据结构/01.线性表与哈希表/03.单调栈.html",redirect:"/pages/45a757/"},{name:"v-5d57353a",path:"/pages/dfe85c/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-5d57353a").then(t)}},{path:"/pages/dfe85c/index.html",redirect:"/pages/dfe85c/"},{path:"/03.LeetCode刷题笔记/02.基础数据结构/01.线性表与哈希表/05.双端队列.html",redirect:"/pages/dfe85c/"},{name:"v-660c2778",path:"/pages/d9969b/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-660c2778").then(t)}},{path:"/pages/d9969b/index.html",redirect:"/pages/d9969b/"},{path:"/03.LeetCode刷题笔记/02.基础数据结构/01.线性表与哈希表/06.哈希表.html",redirect:"/pages/d9969b/"},{name:"v-1e4a90e6",path:"/pages/52cdea/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-1e4a90e6").then(t)}},{path:"/pages/52cdea/index.html",redirect:"/pages/52cdea/"},{path:"/03.LeetCode刷题笔记/02.基础数据结构/01.线性表与哈希表/07.多重集合.html",redirect:"/pages/52cdea/"},{name:"v-8a647390",path:"/pages/7a84c5/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-8a647390").then(t)}},{path:"/pages/7a84c5/index.html",redirect:"/pages/7a84c5/"},{path:"/03.LeetCode刷题笔记/02.基础数据结构/01.线性表与哈希表/09.数据结构设计.html",redirect:"/pages/7a84c5/"},{name:"v-40025290",path:"/pages/45a8d1/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-40025290").then(t)}},{path:"/pages/45a8d1/index.html",redirect:"/pages/45a8d1/"},{path:"/03.LeetCode刷题笔记/02.基础数据结构/01.线性表与哈希表/08.前缀和.html",redirect:"/pages/45a8d1/"},{name:"v-56fb6266",path:"/pages/d4f794/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-56fb6266").then(t)}},{path:"/pages/d4f794/index.html",redirect:"/pages/d4f794/"},{path:"/03.LeetCode刷题笔记/02.基础数据结构/01.线性表与哈希表/STL.html",redirect:"/pages/d4f794/"},{name:"v-3cef2a45",path:"/pages/5f258c/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-3cef2a45").then(t)}},{path:"/pages/5f258c/index.html",redirect:"/pages/5f258c/"},{path:"/03.LeetCode刷题笔记/02.基础数据结构/02.字符串/01.字符串比较.html",redirect:"/pages/5f258c/"},{name:"v-5911eb5e",path:"/pages/8a4607/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-5911eb5e").then(t)}},{path:"/pages/8a4607/index.html",redirect:"/pages/8a4607/"},{path:"/03.LeetCode刷题笔记/02.基础数据结构/02.字符串/02.回文字符串.html",redirect:"/pages/8a4607/"},{name:"v-ca702032",path:"/pages/d0219a/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-ca702032").then(t)}},{path:"/pages/d0219a/index.html",redirect:"/pages/d0219a/"},{path:"/03.LeetCode刷题笔记/02.基础数据结构/02.字符串/03.字符串匹配.html",redirect:"/pages/d0219a/"},{name:"v-4c5a063e",path:"/pages/9ad0e3/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-4c5a063e").then(t)}},{path:"/pages/9ad0e3/index.html",redirect:"/pages/9ad0e3/"},{path:"/03.LeetCode刷题笔记/02.基础数据结构/02.字符串/04.字符串算术表达式.html",redirect:"/pages/9ad0e3/"},{name:"v-9ff0e312",path:"/pages/1b79f3/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-9ff0e312").then(t)}},{path:"/pages/1b79f3/index.html",redirect:"/pages/1b79f3/"},{path:"/03.LeetCode刷题笔记/02.基础数据结构/03.单链表/01.链表基础操作.html",redirect:"/pages/1b79f3/"},{name:"v-df77c33a",path:"/pages/9c89cf/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-df77c33a").then(t)}},{path:"/pages/9c89cf/index.html",redirect:"/pages/9c89cf/"},{path:"/03.LeetCode刷题笔记/02.基础数据结构/02.字符串/Str.html",redirect:"/pages/9c89cf/"},{name:"v-ef6f3572",path:"/pages/3871a6/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-ef6f3572").then(t)}},{path:"/pages/3871a6/index.html",redirect:"/pages/3871a6/"},{path:"/03.LeetCode刷题笔记/02.基础数据结构/03.单链表/02.链表遍历.html",redirect:"/pages/3871a6/"},{name:"v-a2a462c6",path:"/pages/2fa8a0/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-a2a462c6").then(t)}},{path:"/pages/2fa8a0/index.html",redirect:"/pages/2fa8a0/"},{path:"/03.LeetCode刷题笔记/02.基础数据结构/03.单链表/LinkList.html",redirect:"/pages/2fa8a0/"},{name:"v-2e7b6e04",path:"/pages/334633/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-2e7b6e04").then(t)}},{path:"/pages/334633/index.html",redirect:"/pages/334633/"},{path:"/03.LeetCode刷题笔记/02.基础数据结构/04.二叉树/01.二叉树的属性.html",redirect:"/pages/334633/"},{name:"v-321f68a4",path:"/pages/f97107/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-321f68a4").then(t)}},{path:"/pages/f97107/index.html",redirect:"/pages/f97107/"},{path:"/03.LeetCode刷题笔记/02.基础数据结构/04.二叉树/02.二叉树的操作.html",redirect:"/pages/f97107/"},{name:"v-72db9d7e",path:"/pages/22355f/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-72db9d7e").then(t)}},{path:"/pages/22355f/index.html",redirect:"/pages/22355f/"},{path:"/03.LeetCode刷题笔记/02.基础数据结构/04.二叉树/03.层次遍历.html",redirect:"/pages/22355f/"},{name:"v-2ccb02d9",path:"/pages/b9029c/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-2ccb02d9").then(t)}},{path:"/pages/b9029c/index.html",redirect:"/pages/b9029c/"},{path:"/03.LeetCode刷题笔记/02.基础数据结构/04.二叉树/05.二叉搜索树的属性.html",redirect:"/pages/b9029c/"},{name:"v-7386757a",path:"/pages/8995b9/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-7386757a").then(t)}},{path:"/pages/8995b9/index.html",redirect:"/pages/8995b9/"},{path:"/03.LeetCode刷题笔记/02.基础数据结构/04.二叉树/06.二叉搜索树的操作.html",redirect:"/pages/8995b9/"},{name:"v-bfa92168",path:"/pages/5c0017/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-bfa92168").then(t)}},{path:"/pages/5c0017/index.html",redirect:"/pages/5c0017/"},{path:"/03.LeetCode刷题笔记/02.基础数据结构/04.二叉树/07.字典树.html",redirect:"/pages/5c0017/"},{name:"v-e2468eaa",path:"/pages/0480d5/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-e2468eaa").then(t)}},{path:"/pages/0480d5/index.html",redirect:"/pages/0480d5/"},{path:"/03.LeetCode刷题笔记/02.基础数据结构/04.二叉树/04.前中后序遍历.html",redirect:"/pages/0480d5/"},{name:"v-0c19afd3",path:"/pages/01f1e6/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-0c19afd3").then(t)}},{path:"/pages/01f1e6/index.html",redirect:"/pages/01f1e6/"},{path:"/03.LeetCode刷题笔记/02.基础数据结构/04.二叉树/08.二叉搜索树BST.html",redirect:"/pages/01f1e6/"},{name:"v-59c0df46",path:"/pages/000c1c/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-59c0df46").then(t)}},{path:"/pages/000c1c/index.html",redirect:"/pages/000c1c/"},{path:"/03.LeetCode刷题笔记/02.基础数据结构/04.二叉树/Tree.html",redirect:"/pages/000c1c/"},{name:"v-2eca7826",path:"/pages/f51192/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-2eca7826").then(t)}},{path:"/pages/f51192/index.html",redirect:"/pages/f51192/"},{path:"/03.LeetCode刷题笔记/02.基础数据结构/05.图/02.拓扑排序.html",redirect:"/pages/f51192/"},{name:"v-70c9603f",path:"/pages/e70bde/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-70c9603f").then(t)}},{path:"/pages/e70bde/index.html",redirect:"/pages/e70bde/"},{path:"/03.LeetCode刷题笔记/02.基础数据结构/05.图/03.并查集.html",redirect:"/pages/e70bde/"},{name:"v-b6beb69c",path:"/pages/599b16/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-b6beb69c").then(t)}},{path:"/pages/599b16/index.html",redirect:"/pages/599b16/"},{path:"/03.LeetCode刷题笔记/02.基础数据结构/05.图/04.最小生成树.html",redirect:"/pages/599b16/"},{name:"v-0dbfcf13",path:"/pages/208d53/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-0dbfcf13").then(t)}},{path:"/pages/208d53/index.html",redirect:"/pages/208d53/"},{path:"/03.LeetCode刷题笔记/02.基础数据结构/05.图/01.二分图.html",redirect:"/pages/208d53/"},{name:"v-6b98cea6",path:"/pages/68e203/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-6b98cea6").then(t)}},{path:"/pages/68e203/index.html",redirect:"/pages/68e203/"},{path:"/03.LeetCode刷题笔记/02.基础数据结构/05.图/Graph.html",redirect:"/pages/68e203/"},{name:"v-aa15e9b4",path:"/pages/cc367b/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-aa15e9b4").then(t)}},{path:"/pages/cc367b/index.html",redirect:"/pages/cc367b/"},{path:"/03.LeetCode刷题笔记/02.基础数据结构/05.图/05.最短路径.html",redirect:"/pages/cc367b/"},{name:"v-43523836",path:"/pages/82a324/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-43523836").then(t)}},{path:"/pages/82a324/index.html",redirect:"/pages/82a324/"},{path:"/03.LeetCode刷题笔记/03.进阶算法/01.贪心算法/02.分配问题.html",redirect:"/pages/82a324/"},{name:"v-0565826e",path:"/pages/df21f6/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-0565826e").then(t)}},{path:"/pages/df21f6/index.html",redirect:"/pages/df21f6/"},{path:"/03.LeetCode刷题笔记/03.进阶算法/01.贪心算法/03.区间问题.html",redirect:"/pages/df21f6/"},{name:"v-5dd3c9a7",path:"/pages/a967a6/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-5dd3c9a7").then(t)}},{path:"/pages/a967a6/index.html",redirect:"/pages/a967a6/"},{path:"/03.LeetCode刷题笔记/03.进阶算法/02.分治策略/DC.html",redirect:"/pages/a967a6/"},{name:"v-13231700",path:"/pages/fbf15c/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-13231700").then(t)}},{path:"/pages/fbf15c/index.html",redirect:"/pages/fbf15c/"},{path:"/03.LeetCode刷题笔记/03.进阶算法/01.贪心算法/01.跳跃游戏.html",redirect:"/pages/fbf15c/"},{name:"v-66dc6312",path:"/pages/be1ad8/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-66dc6312").then(t)}},{path:"/pages/be1ad8/index.html",redirect:"/pages/be1ad8/"},{path:"/03.LeetCode刷题笔记/03.进阶算法/03.动态规划/01.一维动态规划.html",redirect:"/pages/be1ad8/"},{name:"v-5699caf5",path:"/pages/5b4acb/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-5699caf5").then(t)}},{path:"/pages/5b4acb/index.html",redirect:"/pages/5b4acb/"},{path:"/03.LeetCode刷题笔记/03.进阶算法/03.动态规划/02.二维动态规划.html",redirect:"/pages/5b4acb/"},{name:"v-098887ea",path:"/pages/221930/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-098887ea").then(t)}},{path:"/pages/221930/index.html",redirect:"/pages/221930/"},{path:"/03.LeetCode刷题笔记/03.进阶算法/03.动态规划/04.子序列问题.html",redirect:"/pages/221930/"},{name:"v-596b536f",path:"/pages/6417f0/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-596b536f").then(t)}},{path:"/pages/6417f0/index.html",redirect:"/pages/6417f0/"},{path:"/03.LeetCode刷题笔记/03.进阶算法/03.动态规划/05.背包问题.html",redirect:"/pages/6417f0/"},{name:"v-5222397a",path:"/pages/4015bd/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-5222397a").then(t)}},{path:"/pages/4015bd/index.html",redirect:"/pages/4015bd/"},{path:"/03.LeetCode刷题笔记/03.进阶算法/03.动态规划/03.分割型动态规划.html",redirect:"/pages/4015bd/"},{name:"v-53e283aa",path:"/pages/ef03e8/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-53e283aa").then(t)}},{path:"/pages/ef03e8/index.html",redirect:"/pages/ef03e8/"},{path:"/03.LeetCode刷题笔记/03.进阶算法/03.动态规划/06.字符串编辑问题.html",redirect:"/pages/ef03e8/"},{name:"v-c0ef0954",path:"/pages/c50903/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-c0ef0954").then(t)}},{path:"/pages/c50903/index.html",redirect:"/pages/c50903/"},{path:"/03.LeetCode刷题笔记/03.进阶算法/03.动态规划/07.股票交易问题.html",redirect:"/pages/c50903/"},{name:"v-788365e1",path:"/pages/78cc80/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-788365e1").then(t)}},{path:"/pages/78cc80/index.html",redirect:"/pages/78cc80/"},{path:"/03.LeetCode刷题笔记/03.进阶算法/03.动态规划/DP.html",redirect:"/pages/78cc80/"},{name:"v-5f9bf296",path:"/pages/832c90/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-5f9bf296").then(t)}},{path:"/pages/832c90/index.html",redirect:"/pages/832c90/"},{path:"/03.LeetCode刷题笔记/01.基础算法/03.排序算法/03.归并排序.html",redirect:"/pages/832c90/"},{name:"v-9a42f894",path:"/pages/a40ad8/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-9a42f894").then(t)}},{path:"/pages/a40ad8/index.html",redirect:"/pages/a40ad8/"},{path:"/03.LeetCode刷题笔记/01.基础算法/03.排序算法/04.桶排序.html",redirect:"/pages/a40ad8/"},{name:"v-47781b60",path:"/pages/aef702/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-47781b60").then(t)}},{path:"/pages/aef702/index.html",redirect:"/pages/aef702/"},{path:"/03.LeetCode刷题笔记/05.其他内容/01.数学问题/03.进制转换问题.html",redirect:"/pages/aef702/"},{name:"v-0cdcbd20",path:"/pages/be2fa2/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-0cdcbd20").then(t)}},{path:"/pages/be2fa2/index.html",redirect:"/pages/be2fa2/"},{path:"/03.LeetCode刷题笔记/05.其他内容/01.数学问题/05.众数问题.html",redirect:"/pages/be2fa2/"},{name:"v-04db88ef",path:"/pages/261fe5/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-04db88ef").then(t)}},{path:"/pages/261fe5/index.html",redirect:"/pages/261fe5/"},{path:"/03.LeetCode刷题笔记/05.其他内容/01.数学问题/07.数字处理问题.html",redirect:"/pages/261fe5/"},{name:"v-3dbcc9aa",path:"/pages/a8b0f0/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-3dbcc9aa").then(t)}},{path:"/pages/a8b0f0/index.html",redirect:"/pages/a8b0f0/"},{path:"/03.LeetCode刷题笔记/05.其他内容/01.数学问题/06.中位数问题.html",redirect:"/pages/a8b0f0/"},{name:"v-48d02f81",path:"/pages/708f52/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-48d02f81").then(t)}},{path:"/pages/708f52/index.html",redirect:"/pages/708f52/"},{path:"/03.LeetCode刷题笔记/05.其他内容/01.数学问题/08.随机数问题.html",redirect:"/pages/708f52/"},{name:"v-bc4d0168",path:"/pages/49deb8/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-bc4d0168").then(t)}},{path:"/pages/49deb8/index.html",redirect:"/pages/49deb8/"},{path:"/03.LeetCode刷题笔记/05.其他内容/01.数学问题/MathP.html",redirect:"/pages/49deb8/"},{name:"v-4604aeb0",path:"/pages/1a23eb/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-4604aeb0").then(t)}},{path:"/pages/1a23eb/index.html",redirect:"/pages/1a23eb/"},{path:"/03.LeetCode刷题笔记/05.其他内容/01.数学问题/01.公倍数与公因数.html",redirect:"/pages/1a23eb/"},{name:"v-f90fe7f6",path:"/pages/d88bb5/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-f90fe7f6").then(t)}},{path:"/pages/d88bb5/index.html",redirect:"/pages/d88bb5/"},{path:"/03.LeetCode刷题笔记/05.其他内容/02.位运算/03.二进制特性.html",redirect:"/pages/d88bb5/"},{name:"v-48c7850e",path:"/pages/bcf4de/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-48c7850e").then(t)}},{path:"/pages/bcf4de/index.html",redirect:"/pages/bcf4de/"},{path:"/04.Linux操作系统编程/01.Linux 基础/01.基本 Linux 命令.html",redirect:"/pages/bcf4de/"},{name:"v-dbe28e3a",path:"/pages/bec6ef/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-dbe28e3a").then(t)}},{path:"/pages/bec6ef/index.html",redirect:"/pages/bec6ef/"},{path:"/03.LeetCode刷题笔记/05.其他内容/02.位运算/02.妙用异或运算.html",redirect:"/pages/bec6ef/"},{name:"v-4f96c767",path:"/pages/0c3d5e/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-4f96c767").then(t)}},{path:"/pages/0c3d5e/index.html",redirect:"/pages/0c3d5e/"},{path:"/03.LeetCode刷题笔记/05.其他内容/02.位运算/BitOp.html",redirect:"/pages/0c3d5e/"},{name:"v-f4f09eee",path:"/pages/f56384/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-f4f09eee").then(t)}},{path:"/pages/f56384/index.html",redirect:"/pages/f56384/"},{path:"/04.Linux操作系统编程/01.Linux 基础/02.文件与目录操作.html",redirect:"/pages/f56384/"},{name:"v-c39fe9c4",path:"/pages/0b3143/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-c39fe9c4").then(t)}},{path:"/pages/0b3143/index.html",redirect:"/pages/0b3143/"},{path:"/04.Linux操作系统编程/01.Linux 基础/03.进程与线程.html",redirect:"/pages/0b3143/"},{name:"v-4081237d",path:"/pages/ff5e65/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-4081237d").then(t)}},{path:"/pages/ff5e65/index.html",redirect:"/pages/ff5e65/"},{path:"/04.Linux操作系统编程/01.Linux 基础/04.线程同步与进程通信.html",redirect:"/pages/ff5e65/"},{name:"v-3dee8977",path:"/pages/5d33e8/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-3dee8977").then(t)}},{path:"/pages/5d33e8/index.html",redirect:"/pages/5d33e8/"},{path:"/04.Linux操作系统编程/01.Linux 基础/05.Linux 文件权限.html",redirect:"/pages/5d33e8/"},{name:"v-5501acb0",path:"/pages/154d65/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-5501acb0").then(t)}},{path:"/pages/154d65/index.html",redirect:"/pages/154d65/"},{path:"/04.Linux操作系统编程/01.Linux 基础/06.Linux 命令行快捷键.html",redirect:"/pages/154d65/"},{name:"v-03606fac",path:"/pages/875f14/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-03606fac").then(t)}},{path:"/pages/875f14/index.html",redirect:"/pages/875f14/"},{path:"/04.Linux操作系统编程/02.Vim 实用技巧/00.Vim常用技巧.html",redirect:"/pages/875f14/"},{name:"v-3b3a9bf2",path:"/pages/aab584/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-3b3a9bf2").then(t)}},{path:"/pages/aab584/index.html",redirect:"/pages/aab584/"},{path:"/04.Linux操作系统编程/02.Vim 实用技巧/03.Vim插入模式.html",redirect:"/pages/aab584/"},{name:"v-3dd5939c",path:"/pages/7fbd14/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-3dd5939c").then(t)}},{path:"/pages/7fbd14/index.html",redirect:"/pages/7fbd14/"},{path:"/04.Linux操作系统编程/02.Vim 实用技巧/02.Vim普通模式.html",redirect:"/pages/7fbd14/"},{name:"v-6e30d232",path:"/pages/dfff1a/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-6e30d232").then(t)}},{path:"/pages/dfff1a/index.html",redirect:"/pages/dfff1a/"},{path:"/04.Linux操作系统编程/02.Vim 实用技巧/01.Vim解决问题的方式.html",redirect:"/pages/dfff1a/"},{name:"v-e354f03c",path:"/pages/2a0740/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-e354f03c").then(t)}},{path:"/pages/2a0740/index.html",redirect:"/pages/2a0740/"},{path:"/04.Linux操作系统编程/02.Vim 实用技巧/04.Vim可视模式.html",redirect:"/pages/2a0740/"},{name:"v-511ed1c1",path:"/pages/296a65/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-511ed1c1").then(t)}},{path:"/pages/296a65/index.html",redirect:"/pages/296a65/"},{path:"/03.LeetCode刷题笔记/05.其他内容/02.位运算/01.位运算基础.html",redirect:"/pages/296a65/"},{name:"v-5789cebf",path:"/pages/d598a0/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-5789cebf").then(t)}},{path:"/pages/d598a0/index.html",redirect:"/pages/d598a0/"},{path:"/04.Linux操作系统编程/02.Vim 实用技巧/05.Vim命令行模式.html",redirect:"/pages/d598a0/"},{name:"v-c7498540",path:"/pages/2f33c0/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-c7498540").then(t)}},{path:"/pages/2f33c0/index.html",redirect:"/pages/2f33c0/"},{path:"/04.Linux操作系统编程/04.GDB学习笔记/02.GDB调试Coredump.html",redirect:"/pages/2f33c0/"},{name:"v-b1312a2c",path:"/pages/f4281d/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-b1312a2c").then(t)}},{path:"/pages/f4281d/index.html",redirect:"/pages/f4281d/"},{path:"/04.Linux操作系统编程/04.GDB学习笔记/01.GDB基础调试.html",redirect:"/pages/f4281d/"},{name:"v-3106070c",path:"/pages/028d7e/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-3106070c").then(t)}},{path:"/pages/028d7e/index.html",redirect:"/pages/028d7e/"},{path:"/04.Linux操作系统编程/03.Shell 脚本编程/00.目录.html",redirect:"/pages/028d7e/"},{name:"v-5f16ac72",path:"/pages/65cf94/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-5f16ac72").then(t)}},{path:"/pages/65cf94/index.html",redirect:"/pages/65cf94/"},{path:"/03.LeetCode刷题笔记/05.其他内容/01.数学问题/04.数字字符串求和问题.html",redirect:"/pages/65cf94/"},{name:"v-3999f758",path:"/pages/8292d8/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-3999f758").then(t)}},{path:"/pages/8292d8/index.html",redirect:"/pages/8292d8/"},{path:"/05.Git 学习笔记/10.Git 常用技巧/01.常用Git命令清单.html",redirect:"/pages/8292d8/"},{name:"v-43552b36",path:"/pages/9a7ee40fc232253e/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-43552b36").then(t)}},{path:"/pages/9a7ee40fc232253e/index.html",redirect:"/pages/9a7ee40fc232253e/"},{path:"/05.Git 学习笔记/10.Git 常用技巧/02.Git使用手册.html",redirect:"/pages/9a7ee40fc232253e/"},{name:"v-12d068a5",path:"/pages/4cbc21/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-12d068a5").then(t)}},{path:"/pages/4cbc21/index.html",redirect:"/pages/4cbc21/"},{path:"/05.Git 学习笔记/10.Git 常用技巧/04.Git命令思维导图.html",redirect:"/pages/4cbc21/"},{name:"v-26aabec5",path:"/pages/922650/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-26aabec5").then(t)}},{path:"/pages/922650/index.html",redirect:"/pages/922650/"},{path:"/05.Git 学习笔记/10.Git 常用技巧/05.Git修改分支名.html",redirect:"/pages/922650/"},{name:"v-7b47030e",path:"/pages/ad247c4332211551/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-7b47030e").then(t)}},{path:"/pages/ad247c4332211551/index.html",redirect:"/pages/ad247c4332211551/"},{path:"/05.Git 学习笔记/10.Git 常用技巧/06.Markdown使用教程.html",redirect:"/pages/ad247c4332211551/"},{name:"v-7cae4d1f",path:"/pages/172ab2/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-7cae4d1f").then(t)}},{path:"/pages/172ab2/index.html",redirect:"/pages/172ab2/"},{path:"/05.Git 学习笔记/10.Git 常用技巧/07.Git提交规范.html",redirect:"/pages/172ab2/"},{name:"v-698342a0",path:"/pages/1d2468/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-698342a0").then(t)}},{path:"/pages/1d2468/index.html",redirect:"/pages/1d2468/"},{path:"/05.Git 学习笔记/10.Git 常用技巧/08.Git合并多个提交.html",redirect:"/pages/1d2468/"},{name:"v-2ce72fc6",path:"/pages/4c778760be26d8b3/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-2ce72fc6").then(t)}},{path:"/pages/4c778760be26d8b3/index.html",redirect:"/pages/4c778760be26d8b3/"},{path:"/05.Git 学习笔记/20.GitHub 高级技巧/11.GitHub高级搜索技巧.html",redirect:"/pages/4c778760be26d8b3/"},{name:"v-26153a30",path:"/pages/6b9d359ec5aa5019/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-26153a30").then(t)}},{path:"/pages/6b9d359ec5aa5019/index.html",redirect:"/pages/6b9d359ec5aa5019/"},{path:"/05.Git 学习笔记/20.GitHub 高级技巧/12.GitHub Actions 实现自动部署静态博客.html",redirect:"/pages/6b9d359ec5aa5019/"},{name:"v-4236935a",path:"/pages/f44d2f9ad04ab8d3/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-4236935a").then(t)}},{path:"/pages/f44d2f9ad04ab8d3/index.html",redirect:"/pages/f44d2f9ad04ab8d3/"},{path:"/05.Git 学习笔记/20.GitHub 高级技巧/13.GitHub Actions 定时运行代码：每天定时百度链接推送.html",redirect:"/pages/f44d2f9ad04ab8d3/"},{name:"v-fe412f70",path:"/pages/c10281/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-fe412f70").then(t)}},{path:"/pages/c10281/index.html",redirect:"/pages/c10281/"},{path:"/05.Git 学习笔记/10.Git 常用技巧/03.Git变基合并.html",redirect:"/pages/c10281/"},{name:"v-7b4b4b8e",path:"/pages/95331c6a9613faf8/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-7b4b4b8e").then(t)}},{path:"/pages/95331c6a9613faf8/index.html",redirect:"/pages/95331c6a9613faf8/"},{path:"/05.Git 学习笔记/20.GitHub 高级技巧/14.GitHub加速下载项目的方法.html",redirect:"/pages/95331c6a9613faf8/"},{name:"v-efad95c8",path:"/pages/fcb482/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-efad95c8").then(t)}},{path:"/pages/fcb482/index.html",redirect:"/pages/fcb482/"},{path:"/05.Git 学习笔记/20.GitHub 高级技巧/15.GitHub提交MR分支合并请求.html",redirect:"/pages/fcb482/"},{name:"v-f5673184",path:"/pages/635088/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-f5673184").then(t)}},{path:"/pages/635088/index.html",redirect:"/pages/635088/"},{path:"/05.Git 学习笔记/30.Git 官方文档笔记/10.Git基础与命令.html",redirect:"/pages/635088/"},{name:"v-c67256e6",path:"/pages/d9e9c6/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-c67256e6").then(t)}},{path:"/pages/d9e9c6/index.html",redirect:"/pages/d9e9c6/"},{path:"/05.Git 学习笔记/30.Git 官方文档笔记/110.Git工具-重置揭密.html",redirect:"/pages/d9e9c6/"},{name:"v-60adb5e5",path:"/pages/1832fe/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-60adb5e5").then(t)}},{path:"/pages/1832fe/index.html",redirect:"/pages/1832fe/"},{path:"/05.Git 学习笔记/30.Git 官方文档笔记/100.Git工具-重写历史.html",redirect:"/pages/1832fe/"},{name:"v-0fec5a68",path:"/pages/4bef1a/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-0fec5a68").then(t)}},{path:"/pages/4bef1a/index.html",redirect:"/pages/4bef1a/"},{path:"/05.Git 学习笔记/30.Git 官方文档笔记/20.Git分支-分支原理.html",redirect:"/pages/4bef1a/"},{name:"v-4a5cc4cc",path:"/pages/a399b3/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-4a5cc4cc").then(t)}},{path:"/pages/a399b3/index.html",redirect:"/pages/a399b3/"},{path:"/05.Git 学习笔记/30.Git 官方文档笔记/40.Git分支管理-查看分支.html",redirect:"/pages/a399b3/"},{name:"v-d6569084",path:"/pages/ea5a8c/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-d6569084").then(t)}},{path:"/pages/ea5a8c/index.html",redirect:"/pages/ea5a8c/"},{path:"/05.Git 学习笔记/30.Git 官方文档笔记/30.Git分支的新建与合并-分支操作.html",redirect:"/pages/ea5a8c/"},{name:"v-d5f84b34",path:"/pages/49ee30/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-d5f84b34").then(t)}},{path:"/pages/49ee30/index.html",redirect:"/pages/49ee30/"},{path:"/05.Git 学习笔记/30.Git 官方文档笔记/50.Git分支开发工作流.html",redirect:"/pages/49ee30/"},{name:"v-7eca6e6d",path:"/pages/574d62/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-7eca6e6d").then(t)}},{path:"/pages/574d62/index.html",redirect:"/pages/574d62/"},{path:"/05.Git 学习笔记/30.Git 官方文档笔记/60.Git分支-远程分支.html",redirect:"/pages/574d62/"},{name:"v-10fa8822",path:"/pages/3a3247/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-10fa8822").then(t)}},{path:"/pages/3a3247/index.html",redirect:"/pages/3a3247/"},{path:"/05.Git 学习笔记/30.Git 官方文档笔记/70.Git分支-变基.html",redirect:"/pages/3a3247/"},{name:"v-24cfacec",path:"/pages/c984d1/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-24cfacec").then(t)}},{path:"/pages/c984d1/index.html",redirect:"/pages/c984d1/"},{path:"/05.Git 学习笔记/30.Git 官方文档笔记/80.Git工具-查看修订版本.html",redirect:"/pages/c984d1/"},{name:"v-300c680b",path:"/pages/8d884e/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-300c680b").then(t)}},{path:"/pages/8d884e/index.html",redirect:"/pages/8d884e/"},{path:"/03.LeetCode刷题笔记/05.其他内容/01.数学问题/02.质数问题.html",redirect:"/pages/8d884e/"},{name:"v-c6e0a240",path:"/pages/9cc27d/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-c6e0a240").then(t)}},{path:"/pages/9cc27d/index.html",redirect:"/pages/9cc27d/"},{path:"/06.FixBug/01.问答.html",redirect:"/pages/9cc27d/"},{name:"v-e9633f54",path:"/pages/dcebaf/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-e9633f54").then(t)}},{path:"/pages/dcebaf/index.html",redirect:"/pages/dcebaf/"},{path:"/07.胡思乱想/01.实用技巧/02.一行代码“黑”掉任意网站.html",redirect:"/pages/dcebaf/"},{name:"v-4d0b7bc2",path:"/pages/f2a556/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-4d0b7bc2").then(t)}},{path:"/pages/f2a556/index.html",redirect:"/pages/f2a556/"},{path:"/07.胡思乱想/02.学习方法/00.费曼学习法.html",redirect:"/pages/f2a556/"},{name:"v-010c2c3e",path:"/pages/76d859/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-010c2c3e").then(t)}},{path:"/pages/76d859/index.html",redirect:"/pages/76d859/"},{path:"/05.Git 学习笔记/30.Git 官方文档笔记/90.Git工具-交互式暂存.html",redirect:"/pages/76d859/"},{name:"v-0aaf80f1",path:"/pages/ce818a/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-0aaf80f1").then(t)}},{path:"/pages/ce818a/index.html",redirect:"/pages/ce818a/"},{path:"/07.胡思乱想/01.实用技巧/03.搜索引擎使用技巧.html",redirect:"/pages/ce818a/"},{name:"v-e53dc4e2",path:"/pages/a8692ab3bdcb4588/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-e53dc4e2").then(t)}},{path:"/pages/a8692ab3bdcb4588/index.html",redirect:"/pages/a8692ab3bdcb4588/"},{path:"/07.胡思乱想/02.学习方法/02.提高学习效率的策略.html",redirect:"/pages/a8692ab3bdcb4588/"},{name:"v-618f02ea",path:"/pages/baaa02/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-618f02ea").then(t)}},{path:"/pages/baaa02/index.html",redirect:"/pages/baaa02/"},{path:"/07.胡思乱想/01.实用技巧/01.2分钟规则.html",redirect:"/pages/baaa02/"},{name:"v-33e54f21",path:"/pages/e60c81/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-33e54f21").then(t)}},{path:"/pages/e60c81/index.html",redirect:"/pages/e60c81/"},{path:"/07.胡思乱想/02.学习方法/01.笔记方法.html",redirect:"/pages/e60c81/"},{name:"v-51acde98",path:"/pages/996822b2a2ca6e3b/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-51acde98").then(t)}},{path:"/pages/996822b2a2ca6e3b/index.html",redirect:"/pages/996822b2a2ca6e3b/"},{path:"/07.胡思乱想/02.学习方法/03.提高记忆的技巧.html",redirect:"/pages/996822b2a2ca6e3b/"},{name:"v-590f3efc",path:"/pages/c3f302a03c8daf79/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-590f3efc").then(t)}},{path:"/pages/c3f302a03c8daf79/index.html",redirect:"/pages/c3f302a03c8daf79/"},{path:"/07.胡思乱想/02.学习方法/04.自律小建议.html",redirect:"/pages/c3f302a03c8daf79/"},{name:"v-c7d5fea8",path:"/pages/9ba2b8fb13de1957/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-c7d5fea8").then(t)}},{path:"/pages/9ba2b8fb13de1957/index.html",redirect:"/pages/9ba2b8fb13de1957/"},{path:"/07.胡思乱想/02.学习方法/05.处理问题的思路.html",redirect:"/pages/9ba2b8fb13de1957/"},{name:"v-68c52d46",path:"/pages/35750f/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-68c52d46").then(t)}},{path:"/pages/35750f/index.html",redirect:"/pages/35750f/"},{path:"/07.胡思乱想/03.资源分享/01.站点扩展.html",redirect:"/pages/35750f/"},{name:"v-0dd9388e",path:"/pages/023f1a/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-0dd9388e").then(t)}},{path:"/pages/023f1a/index.html",redirect:"/pages/023f1a/"},{path:"/07.胡思乱想/03.资源分享/02.素材资源.html",redirect:"/pages/023f1a/"},{name:"v-35460c03",path:"/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-35460c03").then(t)}},{path:"/index.html",redirect:"/"},{name:"v-6a78bbac",path:"/blog/",component:vl,beforeEnter:(n,e,t)=>{co("Layout","v-6a78bbac").then(t)}},{path:"/blog/index.html",redirect:"/blog/"},{path:"/@pages/archivesPage.html",redirect:"/blog/"},{path:"*",component:vl}],yl={title:"王清欢Randy",description:"解决问题，担当责任，优雅生活。",base:"/",headTags:[["link",{rel:"icon",href:"/img/favicon.ico"}],["meta",{name:"keywords",content:"vuepress,it,blog"}],["meta",{name:"theme-color",content:"#cf2825"}]],pages:[{title:"全站导航",frontmatter:{title:"全站导航",date:"2023-11-18T16:50:16.000Z",permalink:"/pages/9b85e0/"},regularPath:"/00.%E7%9B%AE%E5%BD%95%E5%AF%BC%E8%88%AA/00.%E5%85%A8%E7%AB%99%E5%AF%BC%E8%88%AA.html",relativePath:"00.目录导航/00.全站导航.md",key:"v-4cb1244c",path:"/pages/9b85e0/",headers:[{level:2,title:"01 编程基础",slug:"_01-编程基础",normalizedTitle:"01 编程基础",charIndex:19},{level:3,title:"✏️ 编程语言",slug:"编程语言",normalizedTitle:"✏️ 编程语言",charIndex:31},{level:3,title:"🤔 算法分析",slug:"算法分析",normalizedTitle:"🤔 算法分析",charIndex:85},{level:3,title:"💻 操作系统",slug:"操作系统",normalizedTitle:"💻 操作系统",charIndex:132},{level:3,title:"🔧 开发工具",slug:"开发工具",normalizedTitle:"🔧 开发工具",charIndex:219},{level:2,title:"02 理论知识",slug:"_02-理论知识",normalizedTitle:"02 理论知识",charIndex:247},{level:3,title:"🤔 分布式理论",slug:"分布式理论",normalizedTitle:"🤔 分布式理论",charIndex:259},{level:2,title:"03 开源实践",slug:"_03-开源实践",normalizedTitle:"03 开源实践",charIndex:299},{level:3,title:"📦 数据库内核",slug:"数据库内核",normalizedTitle:"📦 数据库内核",charIndex:311},{level:2,title:"04 胡思乱想",slug:"_04-胡思乱想",normalizedTitle:"04 胡思乱想",charIndex:366},{level:3,title:"✏️ 实用技巧",slug:"实用技巧",normalizedTitle:"✏️ 实用技巧",charIndex:378},{level:3,title:"🤔 学习方法",slug:"学习方法",normalizedTitle:"🤔 学习方法",charIndex:390},{level:3,title:"💻 资源分享",slug:"资源分享",normalizedTitle:"💻 资源分享",charIndex:402}],headersStr:"01 编程基础 ✏️ 编程语言 🤔 算法分析 💻 操作系统 🔧 开发工具 02 理论知识 🤔 分布式理论 03 开源实践 📦 数据库内核 04 胡思乱想 ✏️ 实用技巧 🤔 学习方法 💻 资源分享",content:"# 全站导航\n\n全站目录汇总\n\n\n# 01 编程基础\n\n\n# ✏️ 编程语言\n\n * 👨‍🏫 C/C++ 学习笔记\n * 👨‍🏫 Golang 学习笔记\n\n\n# 🤔 算法分析\n\n * 👨‍🏫 算法基础\n * 📑 LeetCode 刷题笔记\n\n\n# 💻 操作系统\n\n * 👨‍🏫 Linux 基础\n * 👨‍🏫 Vim 实用技巧\n * 👨‍🏫 Shell 脚本编程\n * 👨‍🏫 GDB 学习笔记\n\n\n# 🔧 开发工具\n\n * 🚀 Git 学习笔记\n\n\n# 02 理论知识\n\n\n# 🤔 分布式理论\n\n * 👨‍🏫 共识算法\n * 📑 分布式事务\n\n\n# 03 开源实践\n\n\n# 📦 数据库内核\n\n * 👨‍🏫 PostgreSQL\n * 👨‍🏫 Postgres-XL\n\n\n# 04 胡思乱想\n\n\n# ✏️ 实用技巧\n\n\n# 🤔 学习方法\n\n\n# 💻 资源分享",normalizedContent:"# 全站导航\n\n全站目录汇总\n\n\n# 01 编程基础\n\n\n# ✏️ 编程语言\n\n * 👨‍🏫 c/c++ 学习笔记\n * 👨‍🏫 golang 学习笔记\n\n\n# 🤔 算法分析\n\n * 👨‍🏫 算法基础\n * 📑 leetcode 刷题笔记\n\n\n# 💻 操作系统\n\n * 👨‍🏫 linux 基础\n * 👨‍🏫 vim 实用技巧\n * 👨‍🏫 shell 脚本编程\n * 👨‍🏫 gdb 学习笔记\n\n\n# 🔧 开发工具\n\n * 🚀 git 学习笔记\n\n\n# 02 理论知识\n\n\n# 🤔 分布式理论\n\n * 👨‍🏫 共识算法\n * 📑 分布式事务\n\n\n# 03 开源实践\n\n\n# 📦 数据库内核\n\n * 👨‍🏫 postgresql\n * 👨‍🏫 postgres-xl\n\n\n# 04 胡思乱想\n\n\n# ✏️ 实用技巧\n\n\n# 🤔 学习方法\n\n\n# 💻 资源分享",charsets:{cjk:!0},lastUpdated:"2024/12/21, 13:59:01",lastUpdatedTimestamp:1734760741e3},{title:"计算机基础",frontmatter:{title:"计算机基础",date:"2023-11-18T14:32:32.000Z",permalink:"/pages/fa0f35/"},regularPath:"/00.%E7%9B%AE%E5%BD%95%E5%AF%BC%E8%88%AA/01.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80.html",relativePath:"00.目录导航/01.计算机基础.md",key:"v-18efd267",path:"/pages/fa0f35/",headers:[{level:2,title:"📚 目录",slug:"目录",normalizedTitle:"📚 目录",charIndex:70},{level:3,title:"✏️ 编程语言",slug:"编程语言",normalizedTitle:"✏️ 编程语言",charIndex:80},{level:3,title:"🤔 算法分析",slug:"算法分析",normalizedTitle:"🤔 算法分析",charIndex:134},{level:3,title:"💻 操作系统",slug:"操作系统",normalizedTitle:"💻 操作系统",charIndex:181},{level:3,title:"🔧 开发工具",slug:"开发工具",normalizedTitle:"🔧 开发工具",charIndex:268}],headersStr:"📚 目录 ✏️ 编程语言 🤔 算法分析 💻 操作系统 🔧 开发工具",content:"# 计算机基础\n\n包括编程语言、数据结构与算法、Linux 操作系统和开发工具等的知识整理，形成体系化的基础架构开发知识体系 🕌\n\n\n# 📚 目录\n\n\n# ✏️ 编程语言\n\n * 👨‍🏫 C/C++ 学习笔记\n * 👨‍🏫 Golang 学习笔记\n\n\n# 🤔 算法分析\n\n * 👨‍🏫 算法基础\n * 📑 LeetCode 刷题笔记\n\n\n# 💻 操作系统\n\n * 👨‍🏫 Linux 基础\n * 👨‍🏫 Vim 实用技巧\n * 👨‍🏫 Shell 脚本编程\n * 👨‍🏫 GDB 学习笔记\n\n\n# 🔧 开发工具\n\n * 🚀 Git 学习笔记",normalizedContent:"# 计算机基础\n\n包括编程语言、数据结构与算法、linux 操作系统和开发工具等的知识整理，形成体系化的基础架构开发知识体系 🕌\n\n\n# 📚 目录\n\n\n# ✏️ 编程语言\n\n * 👨‍🏫 c/c++ 学习笔记\n * 👨‍🏫 golang 学习笔记\n\n\n# 🤔 算法分析\n\n * 👨‍🏫 算法基础\n * 📑 leetcode 刷题笔记\n\n\n# 💻 操作系统\n\n * 👨‍🏫 linux 基础\n * 👨‍🏫 vim 实用技巧\n * 👨‍🏫 shell 脚本编程\n * 👨‍🏫 gdb 学习笔记\n\n\n# 🔧 开发工具\n\n * 🚀 git 学习笔记",charsets:{cjk:!0},lastUpdated:"2023/11/19, 12:55:48",lastUpdatedTimestamp:1700369748e3},{title:"分布式系统",frontmatter:{title:"分布式系统",date:"2023-11-18T14:32:45.000Z",permalink:"/pages/240fd4/"},regularPath:"/00.%E7%9B%AE%E5%BD%95%E5%AF%BC%E8%88%AA/02.%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F.html",relativePath:"00.目录导航/02.分布式系统.md",key:"v-7b26bc54",path:"/pages/240fd4/",headers:[{level:2,title:"📚 目录",slug:"目录",normalizedTitle:"📚 目录",charIndex:70},{level:3,title:"📦 数据库内核",slug:"数据库内核",normalizedTitle:"📦 数据库内核",charIndex:80},{level:3,title:"🤔 分布式理论",slug:"分布式理论",normalizedTitle:"🤔 分布式理论",charIndex:135}],headersStr:"📚 目录 📦 数据库内核 🤔 分布式理论",content:"# 分布式系统\n\n包括编程语言、数据结构与算法、Linux 操作系统和开发工具等的知识整理，形成体系化的基础架构开发知识体系 🕌\n\n\n# 📚 目录\n\n\n# 📦 数据库内核\n\n * 👨‍🏫 PostgreSQL\n * 👨‍🏫 Postgres-XL\n\n\n# 🤔 分布式理论\n\n * 👨‍🏫 共识算法\n * 📑 分布式事务",normalizedContent:"# 分布式系统\n\n包括编程语言、数据结构与算法、linux 操作系统和开发工具等的知识整理，形成体系化的基础架构开发知识体系 🕌\n\n\n# 📚 目录\n\n\n# 📦 数据库内核\n\n * 👨‍🏫 postgresql\n * 👨‍🏫 postgres-xl\n\n\n# 🤔 分布式理论\n\n * 👨‍🏫 共识算法\n * 📑 分布式事务",charsets:{cjk:!0},lastUpdated:"2023/11/18, 16:44:06",lastUpdatedTimestamp:1700297046e3},{title:"胡思乱想",frontmatter:{title:"胡思乱想",date:"2023-11-18T16:50:29.000Z",permalink:"/pages/0232db/"},regularPath:"/00.%E7%9B%AE%E5%BD%95%E5%AF%BC%E8%88%AA/04.%E8%83%A1%E6%80%9D%E4%B9%B1%E6%83%B3.html",relativePath:"00.目录导航/04.胡思乱想.md",key:"v-3ba697dd",path:"/pages/0232db/",headers:[{level:2,title:"📚 目录",slug:"目录",normalizedTitle:"📚 目录",charIndex:20},{level:3,title:"✏️ 实用技巧",slug:"实用技巧",normalizedTitle:"✏️ 实用技巧",charIndex:30},{level:3,title:"🤔 学习方法",slug:"学习方法",normalizedTitle:"🤔 学习方法",charIndex:42},{level:3,title:"💻 资源分享",slug:"资源分享",normalizedTitle:"💻 资源分享",charIndex:54}],headersStr:"📚 目录 ✏️ 实用技巧 🤔 学习方法 💻 资源分享",content:"# 胡思乱想\n\n资源和经验记录\n\n\n# 📚 目录\n\n\n# ✏️ 实用技巧\n\n\n# 🤔 学习方法\n\n\n# 💻 资源分享",normalizedContent:"# 胡思乱想\n\n资源和经验记录\n\n\n# 📚 目录\n\n\n# ✏️ 实用技巧\n\n\n# 🤔 学习方法\n\n\n# 💻 资源分享",charsets:{cjk:!0},lastUpdated:"2023/11/18, 17:26:15",lastUpdatedTimestamp:1700299575e3},{title:"我的开源项目",frontmatter:{title:"我的开源项目",date:"2023-11-18T14:33:25.000Z",permalink:"/pages/93824d/"},regularPath:"/00.%E7%9B%AE%E5%BD%95%E5%AF%BC%E8%88%AA/03.%E6%88%91%E7%9A%84%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE.html",relativePath:"00.目录导航/03.我的开源项目.md",key:"v-79372922",path:"/pages/93824d/",headers:[{level:2,title:"HiDB",slug:"hidb",normalizedTitle:"hidb",charIndex:11}],headersStr:"HiDB",content:"# 我的作品\n\n\n# HiDB\n\n----------------------------------------\n\nundefined\n\n- img: https://xxx.jpg # 图片地址\n  link: https://xxx.com # 链接地址\n  name: HiDB\n  desc: 极简数据库内核 # 可选\n  author: 王清欢 # 可选\n#   avatar: https://xxx.jpg # 作者头像，可选\n",normalizedContent:"# 我的作品\n\n\n# hidb\n\n----------------------------------------\n\nundefined\n\n- img: https://xxx.jpg # 图片地址\n  link: https://xxx.com # 链接地址\n  name: hidb\n  desc: 极简数据库内核 # 可选\n  author: 王清欢 # 可选\n#   avatar: https://xxx.jpg # 作者头像，可选\n",charsets:{cjk:!0},lastUpdated:"2023/11/18, 16:44:06",lastUpdatedTimestamp:1700297046e3},{title:"数据类型",frontmatter:{title:"数据类型",date:"2023-11-18T15:45:38.000Z",permalink:"/pages/bb810c/"},regularPath:"/01.C&Cpp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/01.C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/01.%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.html",relativePath:"01.C&Cpp学习笔记/01.C语言基础/01.数据类型.md",key:"v-1b448f46",path:"/pages/bb810c/",headers:[{level:2,title:"整数类型",slug:"整数类型",normalizedTitle:"整数类型",charIndex:401},{level:2,title:"浮点类型",slug:"浮点类型",normalizedTitle:"浮点类型",charIndex:882},{level:2,title:"逻辑类型",slug:"逻辑类型",normalizedTitle:"逻辑类型",charIndex:1302},{level:2,title:"类型转换",slug:"类型转换",normalizedTitle:"类型转换",charIndex:1435}],headersStr:"整数类型 浮点类型 逻辑类型 类型转换",content:'# 数据类型\n\nC语言是有数据类型的语言，C之后分为C++/Java为代表的更加强调类型的语言与Python/JS这种弱化类型的语言，强调类型的语言更加适合底层开发。\n\nC语言中类型的作用：1.占据空间大小 2.输出格式 3.sizeof是静态运算符\n\n#include <stdio.h>\nint main()\n{\n    int a;\n    printf("sizeof(a++)=%ld\\n",sizeof(a++));\n    printf("a=%d\\n",a);\n    printf("sizeof(a+1.0)=%ld\\n",sizeof(a+1.0));\n    printf("a=%d\\n",a);\n    return 0;\n    /*\n    sizeof(a++)=4\n    a=6\n    sizeof(a+1.0)=8\n    a=6\n    */\n}\n\n\n\n# 整数类型\n\n * 一个int类型表示的CPU中寄存器的宽度\n\n * 补码运算的使用就是为了避免在有符号数运算的过程中对符号的特殊考虑，例如为了得到1+(-1)=0可以利用溢出00000001+11111111=00000000，可以看出补码的意义在于用补码和原码相加得出一个溢出的零。\n\n * 补码的表示范围，8位补码可以表示256个数，即-128~-1和0~127\n\n * 八进制，十六进制输入输出\n\nint main()\n{\n    int a = 012; //数字前加0表示八进制\n    int b = 0x12; //数字前加0x表示十六进制\n    printf("a=%d, b=%d\\n",a,b);\n    printf("a=0%o,b=0x%x\\n",a,b);\n    return 0;\n    /*\n    a=10,b=18\n    a=012,b=0x12\n    */\n}\n\n\n * 编程中没有特别需要用int（内存对齐问题，可能会耗损CPU处理时间）；unsigned只会用在底层硬件操作中，在编程时不用特别区分。\n\n\n# 浮点类型\n\n * 浮点类型输出，%e科学计数法；%.10f输出十位小数；浮点数输出是四舍五入的，因为二进制数只能离散地表达十进制数。\n * 超过范围的浮点数，无穷大inf，不存在nan\n * 浮点数比较相等可能失败，用fabs(f1-f2)<le-12，浮点数在计算机中是不准确的，一般计算用BCD数或者整数，不用浮点数。\n\nint main()\n{\n    float a,b,c;\n    a = 1.345f;\n    b = 1.123f;\n    c = a + b;\n    if(c == 2.468)\n    {\n        printf("不相等\\n");\n    }else{\n        printf("不相等!=c%.10f,或%f\\n",c,c);\n    }\n}\n\n\n * 没有特殊需要，只使用double，与int理由相似，使用double进行运算，CPU内容也只需要一次内存存取就可以完成。\n\n\n# 逻辑类型\n\n * bool类型不是原生类型，使用时导入头文件#include <stdbool.h>\n * 逻辑运算，与或非，! > && > ||\n * 短路现象：逻辑运算自左向右，左边运算完成就可以得到结果，不进行右边。不要把赋值语句写进逻辑判断表达式\n\n\n# 类型转换\n\n * **自动类型转换：**当运算符的两边类型不一样时，会向字长长的的转换。\n * 强制类型转换：（类型+值，类型转换要注意表示范围越界，强制类型转换得到的是新变量。\n * 逗号运算：只用在for循环中，使用逗号右侧值。',normalizedContent:'# 数据类型\n\nc语言是有数据类型的语言，c之后分为c++/java为代表的更加强调类型的语言与python/js这种弱化类型的语言，强调类型的语言更加适合底层开发。\n\nc语言中类型的作用：1.占据空间大小 2.输出格式 3.sizeof是静态运算符\n\n#include <stdio.h>\nint main()\n{\n    int a;\n    printf("sizeof(a++)=%ld\\n",sizeof(a++));\n    printf("a=%d\\n",a);\n    printf("sizeof(a+1.0)=%ld\\n",sizeof(a+1.0));\n    printf("a=%d\\n",a);\n    return 0;\n    /*\n    sizeof(a++)=4\n    a=6\n    sizeof(a+1.0)=8\n    a=6\n    */\n}\n\n\n\n# 整数类型\n\n * 一个int类型表示的cpu中寄存器的宽度\n\n * 补码运算的使用就是为了避免在有符号数运算的过程中对符号的特殊考虑，例如为了得到1+(-1)=0可以利用溢出00000001+11111111=00000000，可以看出补码的意义在于用补码和原码相加得出一个溢出的零。\n\n * 补码的表示范围，8位补码可以表示256个数，即-128~-1和0~127\n\n * 八进制，十六进制输入输出\n\nint main()\n{\n    int a = 012; //数字前加0表示八进制\n    int b = 0x12; //数字前加0x表示十六进制\n    printf("a=%d, b=%d\\n",a,b);\n    printf("a=0%o,b=0x%x\\n",a,b);\n    return 0;\n    /*\n    a=10,b=18\n    a=012,b=0x12\n    */\n}\n\n\n * 编程中没有特别需要用int（内存对齐问题，可能会耗损cpu处理时间）；unsigned只会用在底层硬件操作中，在编程时不用特别区分。\n\n\n# 浮点类型\n\n * 浮点类型输出，%e科学计数法；%.10f输出十位小数；浮点数输出是四舍五入的，因为二进制数只能离散地表达十进制数。\n * 超过范围的浮点数，无穷大inf，不存在nan\n * 浮点数比较相等可能失败，用fabs(f1-f2)<le-12，浮点数在计算机中是不准确的，一般计算用bcd数或者整数，不用浮点数。\n\nint main()\n{\n    float a,b,c;\n    a = 1.345f;\n    b = 1.123f;\n    c = a + b;\n    if(c == 2.468)\n    {\n        printf("不相等\\n");\n    }else{\n        printf("不相等!=c%.10f,或%f\\n",c,c);\n    }\n}\n\n\n * 没有特殊需要，只使用double，与int理由相似，使用double进行运算，cpu内容也只需要一次内存存取就可以完成。\n\n\n# 逻辑类型\n\n * bool类型不是原生类型，使用时导入头文件#include <stdbool.h>\n * 逻辑运算，与或非，! > && > ||\n * 短路现象：逻辑运算自左向右，左边运算完成就可以得到结果，不进行右边。不要把赋值语句写进逻辑判断表达式\n\n\n# 类型转换\n\n * **自动类型转换：**当运算符的两边类型不一样时，会向字长长的的转换。\n * 强制类型转换：（类型+值，类型转换要注意表示范围越界，强制类型转换得到的是新变量。\n * 逗号运算：只用在for循环中，使用逗号右侧值。',charsets:{cjk:!0},lastUpdated:"2023/11/19, 12:55:48",lastUpdatedTimestamp:1700369748e3},{title:"结构类型",frontmatter:{title:"结构类型",date:"2023-11-18T15:45:38.000Z",permalink:"/pages/d1c8a2/"},regularPath:"/01.C&Cpp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/01.C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/03.%E7%BB%93%E6%9E%84%E7%B1%BB%E5%9E%8B.html",relativePath:"01.C&Cpp学习笔记/01.C语言基础/03.结构类型.md",key:"v-7d18746a",path:"/pages/d1c8a2/",headers:[{level:2,title:"3.1枚举",slug:"_3-1枚举",normalizedTitle:"3.1枚举",charIndex:11},{level:2,title:"3.2结构体",slug:"_3-2结构体",normalizedTitle:"3.2结构体",charIndex:211},{level:2,title:"3.3类型",slug:"_3-3类型",normalizedTitle:"3.3类型",charIndex:1608}],headersStr:"3.1枚举 3.2结构体 3.3类型",content:'# 结构类型\n\n\n# 3.1枚举\n\n * 常量符号化：增加代码可读性，用名称代替固定的数字常量\n * 枚举类型：enum name{elem1,elem2,elem3};,枚举量都是int\n * 自动计数的枚举：enum name{elem1,elem2,elem3,len};其中len的值可以直接作为枚举类型的枚举量个数及其长度\n * 枚举的作用：声明有排比意义的符号化常量，枚举比const int更加方便\n\n\n# 3.2结构体\n\n * 结构体的声明：结构体是抽象的，结构变量是实体\n   \n   //有名结构体\n   struct date{\n   \tint year;\n   \tint month;\n   \tint day;\n   };\n   \n   struct date today = {2019,11,29};//初始化\n   struct date today = {.month=11,.day=29};//用this指针部分初始化，未赋值给0\n   \n   //无名结构体\n   struct {\n       int month;\n       int day;\n   }day1,day2;\n   \n   day1.month = 11;\n   day1.day = 27;\n   day2.month = 11;\n   day2.day = 28;\n   \n   //有名结构体，并声明结构体变量\n   struct date{\n   \tint year;\n   \tint month;\n   \tint day;\n   }today;\n   \n   today.year = 2019;\n   today.month = 11;\n   today.day = 29;\n   \n\n * 结构体的运算3.2.1.c\n   \n   >  * 直接用结构变量名字访问\n   > \n   >  * 整个结构可以赋值，取地址也可以传递函数参数\n   >    \n   >    p = (struct date){2019,11,29};\n   >    \n   >    p1 = p2;\n\n * 结构体的指针：结构变量的名称不是其地址，需要&today来取地址。\n\n结构体与函数\n\n * 结构体作为函数参数int numberOfDays(struct date d){}，3.2.2.c\n   \n   >  1. 结构体可以作为形式参数传入函数，在该函数内结构体变量被拷贝\n   >  2. 函数可以返回一个结构变量\n\n * 结构体作为输入：不像数组一样传值也传地址，结构体变量只传值\n\n * 结构体输入并返回\n   \n   >  1. 在函数内创建一个临时的结构体变量，将改变的值通过临时变量返回\n   >     \n   >     struct date getStruct()\n   >     {\n   >     \tstruct date p;\n   >     \tscanf("%d",&p.x);\n   >     \tscanf("%d",&p.y);\n   >     \treturn p;\n   >     }\n   >     \n   > \n   >  2. 通过指向结构的指针，传地址：用->表示指针所指向的结构体变量的成员\n   >     \n   >     struct point* getStruct(struct point *p)\n   >     {\n   >     \tscanf("%d",&p->x);\n   >     \tscanf("%d",&p->y);\n   >     \treturn p;\n   >     }\n   >     \n\n结构体中的结构体\n\n * 结构体数组\n * 结构体中的结构体\n * 结构体中的结构体的数组\n\n\n# 3.3类型\n\n * 自定义数据类型：使用typedef声明一个已有的数据类型的新名字\n\n * 使用typedef定义结构体的别名 ： typedef oldname newname;\n   \n   typedef struct Date\n   {\n    \tint month;\n       int day;\n       int year;\n   };\n   \n   Date d = {2019,11,27};\n   \n\n * union共享存储空间的结构体',normalizedContent:'# 结构类型\n\n\n# 3.1枚举\n\n * 常量符号化：增加代码可读性，用名称代替固定的数字常量\n * 枚举类型：enum name{elem1,elem2,elem3};,枚举量都是int\n * 自动计数的枚举：enum name{elem1,elem2,elem3,len};其中len的值可以直接作为枚举类型的枚举量个数及其长度\n * 枚举的作用：声明有排比意义的符号化常量，枚举比const int更加方便\n\n\n# 3.2结构体\n\n * 结构体的声明：结构体是抽象的，结构变量是实体\n   \n   //有名结构体\n   struct date{\n   \tint year;\n   \tint month;\n   \tint day;\n   };\n   \n   struct date today = {2019,11,29};//初始化\n   struct date today = {.month=11,.day=29};//用this指针部分初始化，未赋值给0\n   \n   //无名结构体\n   struct {\n       int month;\n       int day;\n   }day1,day2;\n   \n   day1.month = 11;\n   day1.day = 27;\n   day2.month = 11;\n   day2.day = 28;\n   \n   //有名结构体，并声明结构体变量\n   struct date{\n   \tint year;\n   \tint month;\n   \tint day;\n   }today;\n   \n   today.year = 2019;\n   today.month = 11;\n   today.day = 29;\n   \n\n * 结构体的运算3.2.1.c\n   \n   >  * 直接用结构变量名字访问\n   > \n   >  * 整个结构可以赋值，取地址也可以传递函数参数\n   >    \n   >    p = (struct date){2019,11,29};\n   >    \n   >    p1 = p2;\n\n * 结构体的指针：结构变量的名称不是其地址，需要&today来取地址。\n\n结构体与函数\n\n * 结构体作为函数参数int numberofdays(struct date d){}，3.2.2.c\n   \n   >  1. 结构体可以作为形式参数传入函数，在该函数内结构体变量被拷贝\n   >  2. 函数可以返回一个结构变量\n\n * 结构体作为输入：不像数组一样传值也传地址，结构体变量只传值\n\n * 结构体输入并返回\n   \n   >  1. 在函数内创建一个临时的结构体变量，将改变的值通过临时变量返回\n   >     \n   >     struct date getstruct()\n   >     {\n   >     \tstruct date p;\n   >     \tscanf("%d",&p.x);\n   >     \tscanf("%d",&p.y);\n   >     \treturn p;\n   >     }\n   >     \n   > \n   >  2. 通过指向结构的指针，传地址：用->表示指针所指向的结构体变量的成员\n   >     \n   >     struct point* getstruct(struct point *p)\n   >     {\n   >     \tscanf("%d",&p->x);\n   >     \tscanf("%d",&p->y);\n   >     \treturn p;\n   >     }\n   >     \n\n结构体中的结构体\n\n * 结构体数组\n * 结构体中的结构体\n * 结构体中的结构体的数组\n\n\n# 3.3类型\n\n * 自定义数据类型：使用typedef声明一个已有的数据类型的新名字\n\n * 使用typedef定义结构体的别名 ： typedef oldname newname;\n   \n   typedef struct date\n   {\n    \tint month;\n       int day;\n       int year;\n   };\n   \n   date d = {2019,11,27};\n   \n\n * union共享存储空间的结构体',charsets:{cjk:!0},lastUpdated:"2023/11/19, 12:55:48",lastUpdatedTimestamp:1700369748e3},{title:"链表",frontmatter:{title:"链表",date:"2023-11-18T15:45:38.000Z",permalink:"/pages/8a62ea/"},regularPath:"/01.C&Cpp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/01.C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/04.%E9%93%BE%E8%A1%A8.html",relativePath:"01.C&Cpp学习笔记/01.C语言基础/04.链表.md",key:"v-5e53ef36",path:"/pages/8a62ea/",headers:[{level:2,title:"4.1可变数组",slug:"_4-1可变数组",normalizedTitle:"4.1可变数组",charIndex:9},{level:2,title:"4.2链表",slug:"_4-2链表",normalizedTitle:"4.2链表",charIndex:745}],headersStr:"4.1可变数组 4.2链表",content:"# 链表\n\n\n# 4.1可变数组\n\n * 数据结构线性表的顺序结构4.1.1\n   \n   typedef struct {\n       int *array;\n       int size;\n   }Array;\n   \n   Array arrayCreate(int arrraySize);\n   void arrayFree(Array *a);\n   int arraySize(const Array *a); //封装类型属性\n   int* arrayAt(Array *a,int index); //返回指针 *arrayAt(&a,0) = 10; 可以直接对指定位置赋值\n   /*\n   \tarrayAt()可以使用 arrayGet()和arraySet()一对方法来替换\n   \tvoid arrayGet(Array *a,int index);\n   \tvoid arraySet(Array *a,int index,int value);\n   */\n   void arrayInflate(Array *a, int moreSize); //改变数组大小 重新申请空间 并将原始数据拷贝 \n   \n   //按照block的大小增长\n   int* arrayAt(Array *a, int index)\n   {\n       if(index >= a->size)\n       {\n           arrayInflate(a,(index/BLOCK_SIZE+1)*BLOCK_SIZE-a->size);\n       }\n       return &(a->array[index]);\n   }\n   \n\n\n# 4.2链表\n\n * 数据结构线性表的链式结构4.2.1\n   \n   typedef struct LNode{\n       int value;\n       struct LNode *next;\n   }Linklist;\n   \n   int initList(Linklist *L);\n   void creatListHead(Linklist *L);\n   void createListTail(Linklist *L):\n   int lengthList(const Linklist *L);\n   int getElem(const Linklist *L, int i, int *e); //查\n   int insertList(Linklist *L, int i, int e); //增\n   int deleteList(Linklist *L, int i, int *e); //删\n   int updateList(Linklist *L, int i, int *e); //改\n   int freeList(Linklist *L);\n   int displayList(const Linklist *L);\n   \n   ",normalizedContent:"# 链表\n\n\n# 4.1可变数组\n\n * 数据结构线性表的顺序结构4.1.1\n   \n   typedef struct {\n       int *array;\n       int size;\n   }array;\n   \n   array arraycreate(int arrraysize);\n   void arrayfree(array *a);\n   int arraysize(const array *a); //封装类型属性\n   int* arrayat(array *a,int index); //返回指针 *arrayat(&a,0) = 10; 可以直接对指定位置赋值\n   /*\n   \tarrayat()可以使用 arrayget()和arrayset()一对方法来替换\n   \tvoid arrayget(array *a,int index);\n   \tvoid arrayset(array *a,int index,int value);\n   */\n   void arrayinflate(array *a, int moresize); //改变数组大小 重新申请空间 并将原始数据拷贝 \n   \n   //按照block的大小增长\n   int* arrayat(array *a, int index)\n   {\n       if(index >= a->size)\n       {\n           arrayinflate(a,(index/block_size+1)*block_size-a->size);\n       }\n       return &(a->array[index]);\n   }\n   \n\n\n# 4.2链表\n\n * 数据结构线性表的链式结构4.2.1\n   \n   typedef struct lnode{\n       int value;\n       struct lnode *next;\n   }linklist;\n   \n   int initlist(linklist *l);\n   void creatlisthead(linklist *l);\n   void createlisttail(linklist *l):\n   int lengthlist(const linklist *l);\n   int getelem(const linklist *l, int i, int *e); //查\n   int insertlist(linklist *l, int i, int e); //增\n   int deletelist(linklist *l, int i, int *e); //删\n   int updatelist(linklist *l, int i, int *e); //改\n   int freelist(linklist *l);\n   int displaylist(const linklist *l);\n   \n   ",charsets:{cjk:!0},lastUpdated:"2023/11/19, 12:55:48",lastUpdatedTimestamp:1700369748e3},{title:"指针与字符串",frontmatter:{title:"指针与字符串",date:"2023-11-18T15:45:38.000Z",permalink:"/pages/28b16e/"},regularPath:"/01.C&Cpp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/01.C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/02.%E6%8C%87%E9%92%88%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2.html",relativePath:"01.C&Cpp学习笔记/01.C语言基础/02.指针与字符串.md",key:"v-512a5f00",path:"/pages/28b16e/",headers:[{level:2,title:"2.1指针的使用",slug:"_2-1指针的使用",normalizedTitle:"2.1指针的使用",charIndex:13},{level:2,title:"2.2指针的计算",slug:"_2-2指针的计算",normalizedTitle:"2.2指针的计算",charIndex:609},{level:2,title:"2.3字符串操作",slug:"_2-3字符串操作",normalizedTitle:"2.3字符串操作",charIndex:1020},{level:2,title:"2.4函数的指针",slug:"_2-4函数的指针",normalizedTitle:"2.4函数的指针",charIndex:1344}],headersStr:"2.1指针的使用 2.2指针的计算 2.3字符串操作 2.4函数的指针",content:'# 指针与字符串\n\n\n# 2.1指针的使用\n\n * 函数返回多个值，通过指针返回结果，指针作为形式参数 2.1.1.c\n * 函数返回运算状态，结果通过指针返回。即C语言中的try/catch 2.1.2.c\n * 指针在使用之前一定要初始化，赋予指针变量地址\n * 对数组进行操作\n * 动态申请内存空间\n\n指针与数组\n\n * 数组变量是特殊的指针\n   \n   //以下四中函数原型是等价的  数组名即为数组首地址是特殊的指针\n   int sum(int *array, int n);\n   int sum(int *, int);\n   int sum(int array[], int n);\n   int sum(int [], int);\n   \n   int array[5]; // array ==  &array[0]\n   \n\n * 数组变量是const类型的指针，不可以被改变，不能被赋值\n\n指针与const\n\n * const指针，int * const p ;与数组变量类似，表示一旦得到了某个变量地址，不能再指向其他变量，即不能作为游标来扫描。(指针不可修改)\n * const int *p;或者int const *p表示不能通过该指针去修改这个变量，*p是const不可修改。（通过指针不可修改）\n * const int a[5]; const数组，数组元素不可修改\n\n\n# 2.2指针的计算\n\n * 指针计算：对应地址空间（地址块为单位移动）\n\n * 指针可以进行的运算：\n   \n   >  1. 指针加或减一个整数\n   >  2. 递增递减 ++/--\n   >  3. 两个指针相减（得到sizeof的个数）\n\n * *p++用于地址空间遍历：2.2.1.c\n   \n   >  1. *p++的含义：取出p所指的内容，并移到下一个位置\n   >  2. ++的优先级高于*\n   >  3. 常用于连续地址空间的遍历\n\n * 0地址，不可使用的地址一般编译器中用NULL表示\n\n动态内存分配malloc free 2.2.2.c\n\n * malloc申请内存空间的大小是以字节为单位的\n * malloc返回的结果是void*类型的，使用时需要进行类型转换\n * malloc申请空间失败会返回NULL\n * free只能用于malloc申请来的地址，地址被修改后无法free\n\n\n# 2.3字符串操作\n\n * putchar(),getchar()：在保准输入输出读写单个字符\n\n * 字符串数组：\n   \n   >  1. char **a：a是一个指针，指向另一个指向字符（串）的指针\n   >  2. char a[][]：a是一个字符二位数组\n   >  3. char *a[]：a是一个指针数组，数组元素都是指向另一个字符串的指针\n\n * int main(int argc, int const *argv[]):argv[0]是命令本身，后续为符号链接的名字（额外学习busybox）\n\n * 字符串函数:#include <string.h>: strlen(); strcmp(); strcpy();\n\n\n# 2.4函数的指针\n\n * 指向函数的指针：void (*pf)(int) = f;\n\n * 根据用户输入决定调用的目标函数2.4.1.c\n   \n   int i = 0;\n   void (*fa[])(int) = {f,g,h,k};\n   scanf("%d",&i);\n   if(i>=0 && i<sizeof(fa)/sizeof(fa[0])){\n       (*fa[i])(0);\n   }\n   ',normalizedContent:'# 指针与字符串\n\n\n# 2.1指针的使用\n\n * 函数返回多个值，通过指针返回结果，指针作为形式参数 2.1.1.c\n * 函数返回运算状态，结果通过指针返回。即c语言中的try/catch 2.1.2.c\n * 指针在使用之前一定要初始化，赋予指针变量地址\n * 对数组进行操作\n * 动态申请内存空间\n\n指针与数组\n\n * 数组变量是特殊的指针\n   \n   //以下四中函数原型是等价的  数组名即为数组首地址是特殊的指针\n   int sum(int *array, int n);\n   int sum(int *, int);\n   int sum(int array[], int n);\n   int sum(int [], int);\n   \n   int array[5]; // array ==  &array[0]\n   \n\n * 数组变量是const类型的指针，不可以被改变，不能被赋值\n\n指针与const\n\n * const指针，int * const p ;与数组变量类似，表示一旦得到了某个变量地址，不能再指向其他变量，即不能作为游标来扫描。(指针不可修改)\n * const int *p;或者int const *p表示不能通过该指针去修改这个变量，*p是const不可修改。（通过指针不可修改）\n * const int a[5]; const数组，数组元素不可修改\n\n\n# 2.2指针的计算\n\n * 指针计算：对应地址空间（地址块为单位移动）\n\n * 指针可以进行的运算：\n   \n   >  1. 指针加或减一个整数\n   >  2. 递增递减 ++/--\n   >  3. 两个指针相减（得到sizeof的个数）\n\n * *p++用于地址空间遍历：2.2.1.c\n   \n   >  1. *p++的含义：取出p所指的内容，并移到下一个位置\n   >  2. ++的优先级高于*\n   >  3. 常用于连续地址空间的遍历\n\n * 0地址，不可使用的地址一般编译器中用null表示\n\n动态内存分配malloc free 2.2.2.c\n\n * malloc申请内存空间的大小是以字节为单位的\n * malloc返回的结果是void*类型的，使用时需要进行类型转换\n * malloc申请空间失败会返回null\n * free只能用于malloc申请来的地址，地址被修改后无法free\n\n\n# 2.3字符串操作\n\n * putchar(),getchar()：在保准输入输出读写单个字符\n\n * 字符串数组：\n   \n   >  1. char **a：a是一个指针，指向另一个指向字符（串）的指针\n   >  2. char a[][]：a是一个字符二位数组\n   >  3. char *a[]：a是一个指针数组，数组元素都是指向另一个字符串的指针\n\n * int main(int argc, int const *argv[]):argv[0]是命令本身，后续为符号链接的名字（额外学习busybox）\n\n * 字符串函数:#include <string.h>: strlen(); strcmp(); strcpy();\n\n\n# 2.4函数的指针\n\n * 指向函数的指针：void (*pf)(int) = f;\n\n * 根据用户输入决定调用的目标函数2.4.1.c\n   \n   int i = 0;\n   void (*fa[])(int) = {f,g,h,k};\n   scanf("%d",&i);\n   if(i>=0 && i<sizeof(fa)/sizeof(fa[0])){\n       (*fa[i])(0);\n   }\n   ',charsets:{cjk:!0},lastUpdated:"2023/11/19, 12:55:48",lastUpdatedTimestamp:1700369748e3},{title:"程序结构",frontmatter:{title:"程序结构",date:"2023-11-18T15:45:38.000Z",permalink:"/pages/4c654b/"},regularPath:"/01.C&Cpp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/01.C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/05.%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84.html",relativePath:"01.C&Cpp学习笔记/01.C语言基础/05.程序结构.md",key:"v-5a1e5a8f",path:"/pages/4c654b/",headers:[{level:2,title:"5.1全局变量",slug:"_5-1全局变量",normalizedTitle:"5.1全局变量",charIndex:11},{level:2,title:"5.2编译预处理",slug:"_5-2编译预处理",normalizedTitle:"5.2编译预处理",charIndex:331},{level:2,title:"5.3大程序结构",slug:"_5-3大程序结构",normalizedTitle:"5.3大程序结构",charIndex:889}],headersStr:"5.1全局变量 5.2编译预处理 5.3大程序结构",content:'# 程序结构\n\n\n# 5.1全局变量\n\n * 全局变量具有全局的作用域和生存周期\n   * 全局变量的使用与函数无关\n   * 局部变量的作用域和生存期是一致的\n * 全局变量的初始化，未初始化的全局变量会被编译器自动初始化为0或者NULL\n * 全局变量与局部变量同名时，全局变量会被隐藏\n\n静态本地变量\n\n * 当函数离开时，静态本地变量将继续存在并保持原值；对静态本地变量的初始化只会在第一次使用时被初始化\n * 静态本地变量是一种特殊的全局变量，具有全局的生存周期但是只有本地的作用域\n\n函数的返回结果是指针\n\n * 本地变量的存储空间是共享的，不要返回本地变量的地址\n * 不要使用全局变量传参和传结果\n * 在并行程序中，尽量不使用全局变量\n\n\n# 5.2编译预处理\n\n * # 开头的编译预处理指令不是C语言语句\n\n * #define定义宏：#define PI 3.1415926在编译预处理的过程中，会对宏进行完全的文本替换\n   \n   #include<stdio.h>\n   \n   #define PI 3.1415926\n   #define FORMAT "%f\\n"\n   #define PI2 PI*2 3\n   \n   int main(int argc,char const *argv[])\n   {\n       printf(FORMAT,PI2*3.0);\n       return 0;\n   }\n   \n\n * 带参数的宏定义：#define cube(x) ((x)*(x)*(x)),带参数的宏定义整个的值和内部参数都要带括号才能够在文本替换的过程中不会出现语义上的改变\n   \n   #include<stdio.h>\n   \n   #define cube(x) ((x)*(x)*(x))\n   \n   int main(int argc,char const *argv[])\n   {\n       printf("%d\\n",cube(5));\n       return 0;\n   }\n   \n\n\n# 5.3大程序结构\n\n * 多个源代码文件的整合，通过建立项目来建立文件之间的链接\n * 头文件：存放函数原型，调用函数的文件#include头文件，确定函数调用文件与函数实现文件间参数类型的一致\n * #include编译预处理指令：将include的文件内容直接插入到引用位置\n * 加static的函数是不对外公开的，只能在文件内使用\n\n声明与定义\n\n * extern int i;是变量的声明，声明是不产生代码的东西\n\n * int i;是变量的定义，是产生代码的东西\n\n * 一般情况下只将声明放在头文件中，否则在不同的#include头文件的过程中，会导致重复定义错误，可以使用#ifndef #define #endif来避免头文件中重复引用情况\n   \n   //标准头文件结构\n   #ifndef __LIST_HEAD__\n   #define __LIST_HEAD__\n   \n   #endif\n   ',normalizedContent:'# 程序结构\n\n\n# 5.1全局变量\n\n * 全局变量具有全局的作用域和生存周期\n   * 全局变量的使用与函数无关\n   * 局部变量的作用域和生存期是一致的\n * 全局变量的初始化，未初始化的全局变量会被编译器自动初始化为0或者null\n * 全局变量与局部变量同名时，全局变量会被隐藏\n\n静态本地变量\n\n * 当函数离开时，静态本地变量将继续存在并保持原值；对静态本地变量的初始化只会在第一次使用时被初始化\n * 静态本地变量是一种特殊的全局变量，具有全局的生存周期但是只有本地的作用域\n\n函数的返回结果是指针\n\n * 本地变量的存储空间是共享的，不要返回本地变量的地址\n * 不要使用全局变量传参和传结果\n * 在并行程序中，尽量不使用全局变量\n\n\n# 5.2编译预处理\n\n * # 开头的编译预处理指令不是c语言语句\n\n * #define定义宏：#define pi 3.1415926在编译预处理的过程中，会对宏进行完全的文本替换\n   \n   #include<stdio.h>\n   \n   #define pi 3.1415926\n   #define format "%f\\n"\n   #define pi2 pi*2 3\n   \n   int main(int argc,char const *argv[])\n   {\n       printf(format,pi2*3.0);\n       return 0;\n   }\n   \n\n * 带参数的宏定义：#define cube(x) ((x)*(x)*(x)),带参数的宏定义整个的值和内部参数都要带括号才能够在文本替换的过程中不会出现语义上的改变\n   \n   #include<stdio.h>\n   \n   #define cube(x) ((x)*(x)*(x))\n   \n   int main(int argc,char const *argv[])\n   {\n       printf("%d\\n",cube(5));\n       return 0;\n   }\n   \n\n\n# 5.3大程序结构\n\n * 多个源代码文件的整合，通过建立项目来建立文件之间的链接\n * 头文件：存放函数原型，调用函数的文件#include头文件，确定函数调用文件与函数实现文件间参数类型的一致\n * #include编译预处理指令：将include的文件内容直接插入到引用位置\n * 加static的函数是不对外公开的，只能在文件内使用\n\n声明与定义\n\n * extern int i;是变量的声明，声明是不产生代码的东西\n\n * int i;是变量的定义，是产生代码的东西\n\n * 一般情况下只将声明放在头文件中，否则在不同的#include头文件的过程中，会导致重复定义错误，可以使用#ifndef #define #endif来避免头文件中重复引用情况\n   \n   //标准头文件结构\n   #ifndef __list_head__\n   #define __list_head__\n   \n   #endif\n   ',charsets:{cjk:!0},lastUpdated:"2023/11/19, 12:55:48",lastUpdatedTimestamp:1700369748e3},{title:"文件",frontmatter:{title:"文件",date:"2023-11-18T15:45:38.000Z",permalink:"/pages/31eb8a/"},regularPath:"/01.C&Cpp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/01.C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/06.%E6%96%87%E4%BB%B6.html",relativePath:"01.C&Cpp学习笔记/01.C语言基础/06.文件.md",key:"v-529fd5e8",path:"/pages/31eb8a/",headers:[{level:2,title:"6.1文件",slug:"_6-1文件",normalizedTitle:"6.1文件",charIndex:14},{level:3,title:"底层操作",slug:"底层操作",normalizedTitle:"底层操作",charIndex:5}],headersStr:"6.1文件 底层操作",content:'# 文件与底层操作\n\n\n# 6.1文件\n\n格式化输入输出\n\n * printf("%[flags][width][.prec][hlL]type")\n\n * scanf("%[flag]type")\n\n * printf和scanf的返回值：读入的项目数，输出的字符数\n   \n   #include<stdio.h>\n   \n   int main(int argc, char const *argv[])\n   {\n       int number;\n       int i = scanf("&i",&number);\n       int j = printf("%d\\n",number);\n       printf("%d::%d",i,j);\n       \n       return 0;\n   }\n   \n\n文件的输入输出\n\n * 运行程序时使用>和<：对文件的输入输出进行文件重定向\n\n * FILE结构完成文件读写6.1.2\n   \n   FILE* fp = fopen("file","r");\n   if(fp){\n       fscanf(fp,...);\n       fclose(fp);size_t fread(void *restrict ptr, size_t size, size_t nitems, FILE *restric stream);\n   }else{\n       ...\n   }\n   \n\n * 文本文件可以通过more,tail,cat来查看，Unix是文本文件，而DOS是二进制文件\n\n * 二进制读写\n   \n   size_t fread(void *restrict ptr, size_t size, size_t nitems, FILE *restric stream);\n   size_t fwrite(void *restrict ptr, size_t size, size_t nitems, FILE *restric stream);\n   //内存位置，内存单元大小，内存单元个数，文件指针\n   \n\n * 在二进制文件中定位\n   \n   long ftell(FILE *stream);\n   int fseek(FILE *stream, long offset, int whence);\n   \n\n * 二进制文件不可跨平台，多用文本文件\n\n\n# 底层操作\n\n * 按位运算符& | ~ ^ << >>，与 或 非 异或 左移 右移\n\n * 位段\n   \n   struct U {\n       unsigned int leading : 3;\n       unsigned int flag1 : 1;\n       unsigned int flag2 : 1;\n       int trailing : 11;\n   };\n   ',normalizedContent:'# 文件与底层操作\n\n\n# 6.1文件\n\n格式化输入输出\n\n * printf("%[flags][width][.prec][hll]type")\n\n * scanf("%[flag]type")\n\n * printf和scanf的返回值：读入的项目数，输出的字符数\n   \n   #include<stdio.h>\n   \n   int main(int argc, char const *argv[])\n   {\n       int number;\n       int i = scanf("&i",&number);\n       int j = printf("%d\\n",number);\n       printf("%d::%d",i,j);\n       \n       return 0;\n   }\n   \n\n文件的输入输出\n\n * 运行程序时使用>和<：对文件的输入输出进行文件重定向\n\n * file结构完成文件读写6.1.2\n   \n   file* fp = fopen("file","r");\n   if(fp){\n       fscanf(fp,...);\n       fclose(fp);size_t fread(void *restrict ptr, size_t size, size_t nitems, file *restric stream);\n   }else{\n       ...\n   }\n   \n\n * 文本文件可以通过more,tail,cat来查看，unix是文本文件，而dos是二进制文件\n\n * 二进制读写\n   \n   size_t fread(void *restrict ptr, size_t size, size_t nitems, file *restric stream);\n   size_t fwrite(void *restrict ptr, size_t size, size_t nitems, file *restric stream);\n   //内存位置，内存单元大小，内存单元个数，文件指针\n   \n\n * 在二进制文件中定位\n   \n   long ftell(file *stream);\n   int fseek(file *stream, long offset, int whence);\n   \n\n * 二进制文件不可跨平台，多用文本文件\n\n\n# 底层操作\n\n * 按位运算符& | ~ ^ << >>，与 或 非 异或 左移 右移\n\n * 位段\n   \n   struct u {\n       unsigned int leading : 3;\n       unsigned int flag1 : 1;\n       unsigned int flag2 : 1;\n       int trailing : 11;\n   };\n   ',charsets:{cjk:!0},lastUpdated:"2023/11/19, 12:55:48",lastUpdatedTimestamp:1700369748e3},{title:"C++ 类和对象基础",frontmatter:{title:"C++ 类和对象基础",date:"2023-11-18T15:46:10.000Z",permalink:"/pages/f80b37/"},regularPath:"/01.C&Cpp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/02.C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/01.C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/02.C++%20%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80.html",relativePath:"01.C&Cpp学习笔记/02.C++面向对象编程/01.C++面向对象/02.C++ 类和对象基础.md",key:"v-f6cde29c",path:"/pages/f80b37/",headers:[{level:2,title:"结构化程序设计",slug:"结构化程序设计",normalizedTitle:"结构化程序设计",charIndex:17},{level:2,title:"面向对象的程序设计",slug:"面向对象的程序设计",normalizedTitle:"面向对象的程序设计",charIndex:827},{level:2,title:"类的定义",slug:"类的定义",normalizedTitle:"类的定义",charIndex:2115},{level:2,title:"Reference",slug:"reference",normalizedTitle:"reference",charIndex:3518}],headersStr:"结构化程序设计 面向对象的程序设计 类的定义 Reference",content:'# C++ 类和对象基础\n\n\n# 结构化程序设计\n\n结构化程序设计的概念：是进行以**模块**功能和处理过程设计为主的详细设计的基本原则。结构化程序设计是面向过程程序设计的一个子集，它对写入的程序使用逻辑结构，使得理解和修改更有效更容易。\n\n结构化程序设计的基本结构：\n\n结构化程序是由若干个基本结构组合而成，每一个结构可以包含若干条语句和其他基本结构。结构化程序设计中包含三种基本的结构：顺序结构、选择结构和循环结构。\n\n * 顺序结构：表示程序中的各操作是按照它们出现的先后线性，有序地执行。顺序结构的程序又称简单程序，这种结构的程序是顺序执行的，无分支，无转移，无循环，程序本身的逻辑很简单，它只依赖于计算机能够顺序执行指令的特点，依次执行个语句模块。\n * 选择结构：表示程序的处理步骤出现了分支，它需要根据某一特定的条件选择其中的一个分支执行，选择结构有单选择、双选择和多选择三种形式。\n * 循环结构：循环结构表示程序反复执行某个或某些操作，直到某条件为假（或为真）时才可终止循环。在循环结构中最主要的是：什么情况下执行循环？哪些操作需要循环执行？循环结构的基本形式有两种：当型循环和直到型循环。\n\n结构化程序设计的不足：随着程序规模的扩大，难以理解、难以扩充、难以查错、难以重用。\n\n * 在结构化程序设计中，函数和其所操纵的数据结构没有直观的联系。\n * 程序理解难度与程序规模正相关：随着程序规模的增加，函数与被操作的数据结构之间的关系难以理解；函数之间的调用关系难以理解。\n * 程序维护和扩充难度大：在结构化程序设计中没有封装和隐藏的概念，使得数据结构的变量都可以被直接访问，一旦发生改动，要修改所有变量访问语句。\n * 错误发现难度大：数据结构和函数之间的复杂关系使得当数据结构中值出错时，难以找到发生错误的函数。\n * 代码可重用率低：随着程序规模的扩大，由于函数和变量之间错综复杂的关系，很难抽取出整块代码进行重用。\n\n\n# 面向对象的程序设计\n\n面向对象的程序设计方法：客观事物的抽象过程\n\n * 归纳客观事物的属性：将某类客观事物的共同特点归纳出来，形成一个数据结构，可以用多个变量描述事物的属性。\n * 归纳客观事物的行为：将该类客观事物所能进行的行为也归纳出来，形成多个函数，这些函数可以用来操作数据结构。\n\n面向对象程序设计的封装：通过某种语法形式，将客观事物抽象的数据结构和对应操作的函数捆绑在一起，形成一个类 (class)，从而使得数据结构和操作函数呈现出清晰的关系，这称为封装。\n\n面向对象程序设计的四个特点：抽象、封装、继承、多态\n\n抽象出类的一个简单例子：计算矩形的周长和面积\n\n> 矩形的属性：长和宽，可以用两个变量表示\n> \n> 矩形的行为：1. 设置长和宽的值 2. 计算周长 3. 计算面积 这三种行为可以分别使用一个函数来实现\n> \n> 矩形类：将上述矩形属性和行为封装在一起就形成了一个矩形类，长、宽变量称为该类的成员变量，三个函数称为该类的成员函数\n> \n> class Rectangle{\n>     public:\n>     \tint width, height;\n>     \tvoid Init(int width_, int height_){\n>             width = width_;\n>             height = height_;\n>         }\n>     \tint Area(){\n>             return width * height;\n>         }\n>     \tint Perimeter(){\n>             return 2*(width + height);\n>         }\n> };\n\n通过类定义对象：C++ 中类的名字就是用户自定义类型的名字，使用方式和基本数据类型一样，通过类定义出来的变量，也成为类的实例即为对象。\n\nint main(){\n    int w,h;\n    Rectangle rec; // 声明一个对象 rec\n    cin >> w >> h;\n    rec.Init(w,h);\n    cout << rec.Area() << endl << rec.Perimeter();\n    \n    // 用指针访问对象成员\n    Rectangle r1, r2;\n    Rectangle* p1 = &r1;\n    Rectangle* p2 = &r2;\n    p1->w = 6;\n    p2->Init(5,4);\n    \n    // 用引用访问对象成员\n    Rectangle r3;\n    Rectangle &rr = r3;\n    rr.w = 6;\n    rr.Init(5,4);\n    return 0;\n}\n\n\n对象的内存空间分配：对象所占用的内存空间大小等于所有成员变量的大小之和，成员函数不占用对象的内存空间，类的成员函数被所有对象共享。\n\n\n# 类的定义\n\n类的成员函数和类的定义分开：\n\nclass Rectangle{\n    public:\n    \tint width, height;\n    \tvoid Init(int width_, int height_){\n            width = width_;\n            height = height_;\n        }\n    \tint Area();\n    \tint Perimeter();\n};\n\n// :: 声明函数属于类成员\nint Rectangle::Area(){\n    return width * height;\n}\n\nint Rectangle::Perimeter(){\n    return 2 *(width + height);\n}\n\n\n类成员的可访问范围：\n\n在类的定义中，用关键字说明类成员可被访问的范围：\n\n * private： 私有成员，可以被该类中的函数、友元函数访问，但不可以由子类的函数、该类的对象、访问；\n   * 如果声明不写 public、protected、private，则默认为 private；\n   * 私有成员机制称为隐藏：目的在于强制对成员变量的访问一定要通过成员函数进行，这种机制使得在成员变量修改时，可以将修改范围缩小在成员函数中，而不需要修改整个项目中所有的成员变量访问语句。\n * public：公有成员，可以被该类中的函数、子类的函数、友元函数访问，也可以由该类的对象访问；\n * protected：保护成员，可以被该类中的函数、子类的函数、友元函数访问，但不可以由该类的对象访问；\n\nclass Employee{\n    private:\n    \tchar szName[30];\n    public:\n    \tint salary;\n    \tint setName(char* name);\n    \tint getName(char* name);\n    \tvoid averageSalary(Employee e1, Employee e2);\n};\n\nint Employee::setName(char* name){\n    strcpy(szName, name);\n}\n\nint Employee::getName(char* name){\n    strcpy(name,szName);\n}\n\nvoid Employee::averageSalary(Employee e1, Employee e2){\n    cout << e1.szName;\n    salary = (e1.salary + e2.salary) / 2;\n}\n\nint main(){\n    Employee e;\n    strcpy(e.szName, "Tom"); // 错误语句，szName是私有的，无法在类外访问\n    e.setName("Tom");\n    e.salary = 1000; // salary是公有的，可以类外访问\n    return 0;\n}\n\n\n成员函数的重载与参数缺省：和普通函数一样，类的成员函数也是可以重载和进行参数缺省的，但是要注意避免二义性，详情参考从 C 到 C++：03 C++的函数 。\n\n\n# Reference\n\n结构化程序设计\n\nC++类成员的三种访问权限',normalizedContent:'# c++ 类和对象基础\n\n\n# 结构化程序设计\n\n结构化程序设计的概念：是进行以**模块**功能和处理过程设计为主的详细设计的基本原则。结构化程序设计是面向过程程序设计的一个子集，它对写入的程序使用逻辑结构，使得理解和修改更有效更容易。\n\n结构化程序设计的基本结构：\n\n结构化程序是由若干个基本结构组合而成，每一个结构可以包含若干条语句和其他基本结构。结构化程序设计中包含三种基本的结构：顺序结构、选择结构和循环结构。\n\n * 顺序结构：表示程序中的各操作是按照它们出现的先后线性，有序地执行。顺序结构的程序又称简单程序，这种结构的程序是顺序执行的，无分支，无转移，无循环，程序本身的逻辑很简单，它只依赖于计算机能够顺序执行指令的特点，依次执行个语句模块。\n * 选择结构：表示程序的处理步骤出现了分支，它需要根据某一特定的条件选择其中的一个分支执行，选择结构有单选择、双选择和多选择三种形式。\n * 循环结构：循环结构表示程序反复执行某个或某些操作，直到某条件为假（或为真）时才可终止循环。在循环结构中最主要的是：什么情况下执行循环？哪些操作需要循环执行？循环结构的基本形式有两种：当型循环和直到型循环。\n\n结构化程序设计的不足：随着程序规模的扩大，难以理解、难以扩充、难以查错、难以重用。\n\n * 在结构化程序设计中，函数和其所操纵的数据结构没有直观的联系。\n * 程序理解难度与程序规模正相关：随着程序规模的增加，函数与被操作的数据结构之间的关系难以理解；函数之间的调用关系难以理解。\n * 程序维护和扩充难度大：在结构化程序设计中没有封装和隐藏的概念，使得数据结构的变量都可以被直接访问，一旦发生改动，要修改所有变量访问语句。\n * 错误发现难度大：数据结构和函数之间的复杂关系使得当数据结构中值出错时，难以找到发生错误的函数。\n * 代码可重用率低：随着程序规模的扩大，由于函数和变量之间错综复杂的关系，很难抽取出整块代码进行重用。\n\n\n# 面向对象的程序设计\n\n面向对象的程序设计方法：客观事物的抽象过程\n\n * 归纳客观事物的属性：将某类客观事物的共同特点归纳出来，形成一个数据结构，可以用多个变量描述事物的属性。\n * 归纳客观事物的行为：将该类客观事物所能进行的行为也归纳出来，形成多个函数，这些函数可以用来操作数据结构。\n\n面向对象程序设计的封装：通过某种语法形式，将客观事物抽象的数据结构和对应操作的函数捆绑在一起，形成一个类 (class)，从而使得数据结构和操作函数呈现出清晰的关系，这称为封装。\n\n面向对象程序设计的四个特点：抽象、封装、继承、多态\n\n抽象出类的一个简单例子：计算矩形的周长和面积\n\n> 矩形的属性：长和宽，可以用两个变量表示\n> \n> 矩形的行为：1. 设置长和宽的值 2. 计算周长 3. 计算面积 这三种行为可以分别使用一个函数来实现\n> \n> 矩形类：将上述矩形属性和行为封装在一起就形成了一个矩形类，长、宽变量称为该类的成员变量，三个函数称为该类的成员函数\n> \n> class rectangle{\n>     public:\n>     \tint width, height;\n>     \tvoid init(int width_, int height_){\n>             width = width_;\n>             height = height_;\n>         }\n>     \tint area(){\n>             return width * height;\n>         }\n>     \tint perimeter(){\n>             return 2*(width + height);\n>         }\n> };\n\n通过类定义对象：c++ 中类的名字就是用户自定义类型的名字，使用方式和基本数据类型一样，通过类定义出来的变量，也成为类的实例即为对象。\n\nint main(){\n    int w,h;\n    rectangle rec; // 声明一个对象 rec\n    cin >> w >> h;\n    rec.init(w,h);\n    cout << rec.area() << endl << rec.perimeter();\n    \n    // 用指针访问对象成员\n    rectangle r1, r2;\n    rectangle* p1 = &r1;\n    rectangle* p2 = &r2;\n    p1->w = 6;\n    p2->init(5,4);\n    \n    // 用引用访问对象成员\n    rectangle r3;\n    rectangle &rr = r3;\n    rr.w = 6;\n    rr.init(5,4);\n    return 0;\n}\n\n\n对象的内存空间分配：对象所占用的内存空间大小等于所有成员变量的大小之和，成员函数不占用对象的内存空间，类的成员函数被所有对象共享。\n\n\n# 类的定义\n\n类的成员函数和类的定义分开：\n\nclass rectangle{\n    public:\n    \tint width, height;\n    \tvoid init(int width_, int height_){\n            width = width_;\n            height = height_;\n        }\n    \tint area();\n    \tint perimeter();\n};\n\n// :: 声明函数属于类成员\nint rectangle::area(){\n    return width * height;\n}\n\nint rectangle::perimeter(){\n    return 2 *(width + height);\n}\n\n\n类成员的可访问范围：\n\n在类的定义中，用关键字说明类成员可被访问的范围：\n\n * private： 私有成员，可以被该类中的函数、友元函数访问，但不可以由子类的函数、该类的对象、访问；\n   * 如果声明不写 public、protected、private，则默认为 private；\n   * 私有成员机制称为隐藏：目的在于强制对成员变量的访问一定要通过成员函数进行，这种机制使得在成员变量修改时，可以将修改范围缩小在成员函数中，而不需要修改整个项目中所有的成员变量访问语句。\n * public：公有成员，可以被该类中的函数、子类的函数、友元函数访问，也可以由该类的对象访问；\n * protected：保护成员，可以被该类中的函数、子类的函数、友元函数访问，但不可以由该类的对象访问；\n\nclass employee{\n    private:\n    \tchar szname[30];\n    public:\n    \tint salary;\n    \tint setname(char* name);\n    \tint getname(char* name);\n    \tvoid averagesalary(employee e1, employee e2);\n};\n\nint employee::setname(char* name){\n    strcpy(szname, name);\n}\n\nint employee::getname(char* name){\n    strcpy(name,szname);\n}\n\nvoid employee::averagesalary(employee e1, employee e2){\n    cout << e1.szname;\n    salary = (e1.salary + e2.salary) / 2;\n}\n\nint main(){\n    employee e;\n    strcpy(e.szname, "tom"); // 错误语句，szname是私有的，无法在类外访问\n    e.setname("tom");\n    e.salary = 1000; // salary是公有的，可以类外访问\n    return 0;\n}\n\n\n成员函数的重载与参数缺省：和普通函数一样，类的成员函数也是可以重载和进行参数缺省的，但是要注意避免二义性，详情参考从 c 到 c++：03 c++的函数 。\n\n\n# reference\n\n结构化程序设计\n\nc++类成员的三种访问权限',charsets:{cjk:!0},lastUpdated:"2023/11/19, 12:55:48",lastUpdatedTimestamp:1700369748e3},{title:"C++ 构造函数与析构函数",frontmatter:{title:"C++ 构造函数与析构函数",date:"2023-11-18T15:46:10.000Z",permalink:"/pages/c03a08/"},regularPath:"/01.C&Cpp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/02.C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/01.C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/03.C++%20%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8E%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0.html",relativePath:"01.C&Cpp学习笔记/02.C++面向对象编程/01.C++面向对象/03.C++ 构造函数与析构函数.md",key:"v-08ca4e2c",path:"/pages/c03a08/",headers:[{level:2,title:"构造函数的基本概念",slug:"构造函数的基本概念",normalizedTitle:"构造函数的基本概念",charIndex:20},{level:2,title:"拷贝构造函数",slug:"拷贝构造函数",normalizedTitle:"拷贝构造函数",charIndex:2014},{level:2,title:"类型转换构造函数",slug:"类型转换构造函数",normalizedTitle:"类型转换构造函数",charIndex:3955},{level:2,title:"析构函数",slug:"析构函数",normalizedTitle:"析构函数",charIndex:11},{level:2,title:"Reference",slug:"reference",normalizedTitle:"reference",charIndex:6106}],headersStr:"构造函数的基本概念 拷贝构造函数 类型转换构造函数 析构函数 Reference",content:'# C++ 构造函数与析构函数\n\n\n# 构造函数的基本概念\n\n构造函数：\n\n构造函数是类的一种特殊成员函数，它的名字和类名相同，可以有参数，但是没有返回值。类中定义的构造函数在对象生成时被调用，其作用是对对象初始化，进行成员变量赋值之类的操作。如果类中没有定义构造函数，编译器在编译过程中会为类生成一个默认的无参构造函数，并不进行任何操作。\n\n构造函数的意义：简化了对象的初始化工作，有了构造函数就不用专门再写初始化函数，也不用担心在生成对象时忘记调用初始化函数。对象名也相当于一个指针，如果没被初始化就使用将导致程序出错。\n\nclass Complex{\n    private:\n    \tdouble real;\n    \tdouble img;\n    public:\n    \t// 一个类可以声明多个重载的构造函数，参数个数或参数类型不同\n    \tComplex(double r){real = r;}\n    \tComplex(double real_, double img_ = 0);\n    \tComplex(Complex c1, Complex c2);\n};\n\nComplex::Complex(double real_, double img_){\n    real = real_;\n    img = img_;\n}\n\nComplex::Complex(Complex c1, Complex c2){\n    real = c1.real + c2.real;\n    img = c1.img + c2.img;\n}\n\nint main(){\n    Complex c1; // 这种声明方式是错误的，应为定义的构造函数为 Complex(r,i); 缺少构造函数参数\n    Complex* pc = new Complex; // 也是错误的，没有参数\n    Complex c2(2);\n    Complex* pc2 = new Complex(2,3);\n    return 0;\n}\n\n\n构造函数在数组中的使用：\n\nclass Sample{\n    private:\n    \tint x;\n    \tint y;\n    public:\n    \tSample(){cout<<"Constructor 1 called"<<endl;}\n    \tSample(int x_){x = x_; y = 0; cout<<"Constructor 2 called"<<endl;}\n    \tSample(int x_, int y_){x = x_; y = y_; cout<<"Constructor 3 called"<<endl;}\n};\n\nint main(){\n    Sample array1[2];\n    cout<<"step1"<<endl;\n    Sample array2[2] = {4,5};\n    cout<<"step2"<<endl;\n    Sample array3[2] = {3}; // array3[0]用Sample(3)初始化，array3[1]用Sample()初始化\n    cout<<"step3"<<endl;\n    Sample array4[3] = {3, Sample(4,5)};\n    cout<<"step4"<<endl;\n    Sample* array4 = new Sample[2];\n    cout<<"step5"<<endl;\n    Sample* parray[3] = {new Sample(3), new Sample(4,5)}; // 注意和第18行代码对比，parray是指针，没有进行初始化就是空指针不会调用构造函数\n    delete [] parray;\n    delete [] array4; // 被new出来的对象一定要用delete释放\n    return 0;\n}\n/* output:\nConstructor 1 called\nConstructor 1 called\nstep1\nConstructor 2 called\nConstructor 2 called\nstep2\nConstructor 2 called\nConstructor 1 called\nstep3\nConstructor 2 called\nConstructor 3 called\nConstructor 1 called\nstep4\nConstructor 1 called\nConstructor 1 called\nstep5\nConstructor 2 called\nConstructor 3 called\n*/\n\n\n\n# 拷贝构造函数\n\n拷贝构造函数：\n\n拷贝构造函数有且仅有一个同类对象引用的参数 （参数只能是引用不能是对象），形如 Object::Object(const Object &) 使用常量对象作为参数更安全，当然也可以不用 const。如果类中没有定义拷贝构造函数，编译器会在编译过程中为类生成默认的拷贝构造函数，其功能就是完成拷贝功能。\n\nclass Complex{\n    private:\n    \tdouble real;\n    \tdouble img;\n    public:\n    \tComplex(int r, int i){real = r; img = i;}\n    \tComplex(const Complex & c);\n};\n\nComplex::Complex(const Complex & c){\n    real = c.real;\n    img = c.img;\n    cout<<"Copy Constructor called"<<endl;\n}\n\nint main(){\n    Complex c1(1,2);\n    Complex c2(c1);\n}\n\n\n拷贝构造函数起作用的情况\n\n * 用对象进行初始化：当用一个对象去初始化同类的另一个对象时，会引发拷贝构造函数被调用。\n   \n   Complex c2(c1);\n   Complex c2 = c1; //调用拷贝构造函数\n   \n   \n   上述示例中的两条语句都会引发拷贝构造函数的调用，这两条语句是等价的，都用以初始化 c2。值得注意的是，第二条语句是初始化语句，不是赋值语句。赋值语句的等号左边通常是一个早已有定义的变量，赋值语句不会引发复制构造函数的调用，示例如下：\n   \n   Complex c1(1,2);\n   Complex c2;\n   c2 = c1; //赋值语句\n   \n\n * 对象作为函数形参：如果函数 F 的一个参数是类 A 的对象，那么当 F 被调用时，类 A 的拷贝构造函数将被调用。换句话说，作为形参的对象是用拷贝构造函数初始化的，而且调用拷贝构造函数对其进行初始化的参数就是调用函数时所给的实参。\n\n * 对象作为函数返回值：如果函数的返冋值是类 A 的对象，则函数返冋时，类 A 的拷贝构造函数被调用。换言之，作为函数返回值的对象是用拷贝构造函数初始化的，而调用拷贝构造函数时的实参，就是 return 语句所返回的对象。\n   \n   class A{\n       public:\n       \tint x;\n       \tA(int n){x=n;}\n       \tA(const A & a){\n               x = a.x; // 这个语句说明，拷贝构造函数的实参和形参的值不一定一样，这取决于该类的拷贝构造函数的定义方式(x = 100;)\n               cout<<"Copy construct called"<<endl;\n           }\n   };\n   \n   void F(A a){ // a做为形参，通过拷贝构造函数进行初始化\n       cout<<a.x<<endl;\n   }\n   // 对象形参常引用参数的使用:优点在于减少了生成形参对象是调用拷贝构造函数的开销，如果需要保证实参的值不被改变加上 const\n   void F(const A & a){\n       cout<<a.x<<endl;\n   }\n   \n   A Func(){\n       A b(2);\n       return b; // b作为返回值，通过拷贝构造函数进行初始化\n   }\n   \n   int main(){\n       A a1(1);\n       F(a1); // a1作为拷贝构造函数的实参\n       cout << Func().v << endl;\n       return 0;\n   }\n   \n\n深拷贝和浅拷贝：\n\n * 浅拷贝：又称值拷贝，将源对象的值拷贝到目标对象中去，本质上来说源对象和目标对象共用一份实体，只是所引用的变量名不同，地址其实还是相同的。（问题：浅拷贝和对象引用的区别是什么？）\n * 深拷贝：深拷贝的时候先开辟出和源对象大小一样的空间，然后将源对象里的内容拷贝到目标对象中去，这样两个指针就指向了不同的内存位置。\n * 深拷贝和浅拷贝可以简单理解为：如果一个类拥有资源，当这个类的对象发生复制过程的时候，资源重新分配，这个过程就是深拷贝，反之，没有重新分配资源，就是浅拷贝。\n\n\n# 类型转换构造函数\n\n类型转换构造函数：用途在于自动将其他类型的数据对象转换为该类对象。类型转化构造函数和拷贝构造函数类似，只有一个参数，但是其参数不是该类对象。在需要的时候，编译系统在编译过程中自动调用转换构造函数，建立一个无名的临时对象。\n\nclass Complex(){\n    private:\n    \tdouble real,img;\n    public:\n    \tComplex(double r, double i){\n            real = r;\n            img = i;\n        }\n    \tComplex(int n){\n            real = n;\n            img = 0;\n            cout << "Int Constructor called"<<endl;\n        }\n    \tgetReal(){return real;}\n    \tgetImg(){return img;}\n};\n\nint main(){\n    Complex c1(1,2);\n    c1 = 3; // 调用类型构造函数，将3转换一个临时Complex对象\n    cout << c1.getReal() << c1.getImg() << endl;\n    return 0;\n}\n/* output:\n3 0\n*/\n\n\n\n# 析构函数\n\n析构函数：\n\n析构函数与构造函数对应，在对象生命周期结束时被自动调用，析构函数的作用是在对象消亡前做类似释放内存空间等善后工作。其名字和类目相同，在前面加 ~ ，没有参数和返回值，一个类最多只有一个析构函数。如果类中没有定义析构函数，编译器在编译过程中会生成缺省析构函数，并不进行任何操作。\n\nclass String{\n    private:\n    \tchar* p;\n    public:\n    \tString(){\n            p = new char[10]; // new 申请动态内存空间\n        }\n    \t~String();\n};\nString::~String(){\n    delete [] p; // delete 释放动态内存空间\n}\n\n\n析构函数在数组中的使用：对象数组生命周期结束时，对象数组中的每个元素的析构函数都会被调用。\n\n析构函数与 delete ：被 new 出来的对象一定要用 delete 释放，否则不会调用析构函数去释放对象；如果 new 的是一个对象数组，那么使用 delete [] 释放，如果只使用 delete ，那么只会调用一次析构函数释放一个对象。\n\n构造函数和析构函数的调用时机：值得注意的是，对象作为函数形参和返回值均会调用拷贝构造函数产生临时对象，那么这些对象在函数调用完成之后会自动调用析构函数释放资源。\n\nclass Sample{\n    private:\n    \tint x;\n    public:\n    \tSample(int n){x=n; cout<<x<<"constructor called"<<endl;}\n    \t~Sample(){cout<<x<<"destructor called"<<endl;}\n};\n\nSample s1(1); // 全局变量，调用构造函数 \n\nvoid F(){\n    static Sample s2(2); // 静态局部变量在函数调用结束时不会消亡，整个程序执行完毕之和才会消亡\n    Sample s3(3);\n    cout << "F called" << endl;\n}\n\nint main(){\n    Sample s4(4); \n    s4 = 6; // 类型转换构造函数参数临时对象 \n    cout<<"main"<<endl;\n    if(true){\n        Sample s5(5); // 局部变量在生命周期结束后调用析构\n    }\n    F();\n    cout<<"main end"<<endl;\n    return 0;\n}\n\n/* output:\n1 constructor called\n4 constructor called\n6 constructor called\n6 destructor called\nmain\n5 constructor called\n5 destructor called\n2 constructor called\n3 constructor called\nF called\n3 destructor called\nmain end\n6 destructor called (s4)\n2 destructor called (static)\n1 destructor called (global)\n*/\n\n\n值得注意的是，构造函数只负责初始化工作不负责内存空间分配，析构函数不负责内存空间回收；将对象比作房子，入住之前调用构造函数进行装修，拆迁之前调用析构函数搬东西。\n\n\n# Reference\n\n拷贝构造函数详解\n\n深拷贝于浅拷贝',normalizedContent:'# c++ 构造函数与析构函数\n\n\n# 构造函数的基本概念\n\n构造函数：\n\n构造函数是类的一种特殊成员函数，它的名字和类名相同，可以有参数，但是没有返回值。类中定义的构造函数在对象生成时被调用，其作用是对对象初始化，进行成员变量赋值之类的操作。如果类中没有定义构造函数，编译器在编译过程中会为类生成一个默认的无参构造函数，并不进行任何操作。\n\n构造函数的意义：简化了对象的初始化工作，有了构造函数就不用专门再写初始化函数，也不用担心在生成对象时忘记调用初始化函数。对象名也相当于一个指针，如果没被初始化就使用将导致程序出错。\n\nclass complex{\n    private:\n    \tdouble real;\n    \tdouble img;\n    public:\n    \t// 一个类可以声明多个重载的构造函数，参数个数或参数类型不同\n    \tcomplex(double r){real = r;}\n    \tcomplex(double real_, double img_ = 0);\n    \tcomplex(complex c1, complex c2);\n};\n\ncomplex::complex(double real_, double img_){\n    real = real_;\n    img = img_;\n}\n\ncomplex::complex(complex c1, complex c2){\n    real = c1.real + c2.real;\n    img = c1.img + c2.img;\n}\n\nint main(){\n    complex c1; // 这种声明方式是错误的，应为定义的构造函数为 complex(r,i); 缺少构造函数参数\n    complex* pc = new complex; // 也是错误的，没有参数\n    complex c2(2);\n    complex* pc2 = new complex(2,3);\n    return 0;\n}\n\n\n构造函数在数组中的使用：\n\nclass sample{\n    private:\n    \tint x;\n    \tint y;\n    public:\n    \tsample(){cout<<"constructor 1 called"<<endl;}\n    \tsample(int x_){x = x_; y = 0; cout<<"constructor 2 called"<<endl;}\n    \tsample(int x_, int y_){x = x_; y = y_; cout<<"constructor 3 called"<<endl;}\n};\n\nint main(){\n    sample array1[2];\n    cout<<"step1"<<endl;\n    sample array2[2] = {4,5};\n    cout<<"step2"<<endl;\n    sample array3[2] = {3}; // array3[0]用sample(3)初始化，array3[1]用sample()初始化\n    cout<<"step3"<<endl;\n    sample array4[3] = {3, sample(4,5)};\n    cout<<"step4"<<endl;\n    sample* array4 = new sample[2];\n    cout<<"step5"<<endl;\n    sample* parray[3] = {new sample(3), new sample(4,5)}; // 注意和第18行代码对比，parray是指针，没有进行初始化就是空指针不会调用构造函数\n    delete [] parray;\n    delete [] array4; // 被new出来的对象一定要用delete释放\n    return 0;\n}\n/* output:\nconstructor 1 called\nconstructor 1 called\nstep1\nconstructor 2 called\nconstructor 2 called\nstep2\nconstructor 2 called\nconstructor 1 called\nstep3\nconstructor 2 called\nconstructor 3 called\nconstructor 1 called\nstep4\nconstructor 1 called\nconstructor 1 called\nstep5\nconstructor 2 called\nconstructor 3 called\n*/\n\n\n\n# 拷贝构造函数\n\n拷贝构造函数：\n\n拷贝构造函数有且仅有一个同类对象引用的参数 （参数只能是引用不能是对象），形如 object::object(const object &) 使用常量对象作为参数更安全，当然也可以不用 const。如果类中没有定义拷贝构造函数，编译器会在编译过程中为类生成默认的拷贝构造函数，其功能就是完成拷贝功能。\n\nclass complex{\n    private:\n    \tdouble real;\n    \tdouble img;\n    public:\n    \tcomplex(int r, int i){real = r; img = i;}\n    \tcomplex(const complex & c);\n};\n\ncomplex::complex(const complex & c){\n    real = c.real;\n    img = c.img;\n    cout<<"copy constructor called"<<endl;\n}\n\nint main(){\n    complex c1(1,2);\n    complex c2(c1);\n}\n\n\n拷贝构造函数起作用的情况\n\n * 用对象进行初始化：当用一个对象去初始化同类的另一个对象时，会引发拷贝构造函数被调用。\n   \n   complex c2(c1);\n   complex c2 = c1; //调用拷贝构造函数\n   \n   \n   上述示例中的两条语句都会引发拷贝构造函数的调用，这两条语句是等价的，都用以初始化 c2。值得注意的是，第二条语句是初始化语句，不是赋值语句。赋值语句的等号左边通常是一个早已有定义的变量，赋值语句不会引发复制构造函数的调用，示例如下：\n   \n   complex c1(1,2);\n   complex c2;\n   c2 = c1; //赋值语句\n   \n\n * 对象作为函数形参：如果函数 f 的一个参数是类 a 的对象，那么当 f 被调用时，类 a 的拷贝构造函数将被调用。换句话说，作为形参的对象是用拷贝构造函数初始化的，而且调用拷贝构造函数对其进行初始化的参数就是调用函数时所给的实参。\n\n * 对象作为函数返回值：如果函数的返冋值是类 a 的对象，则函数返冋时，类 a 的拷贝构造函数被调用。换言之，作为函数返回值的对象是用拷贝构造函数初始化的，而调用拷贝构造函数时的实参，就是 return 语句所返回的对象。\n   \n   class a{\n       public:\n       \tint x;\n       \ta(int n){x=n;}\n       \ta(const a & a){\n               x = a.x; // 这个语句说明，拷贝构造函数的实参和形参的值不一定一样，这取决于该类的拷贝构造函数的定义方式(x = 100;)\n               cout<<"copy construct called"<<endl;\n           }\n   };\n   \n   void f(a a){ // a做为形参，通过拷贝构造函数进行初始化\n       cout<<a.x<<endl;\n   }\n   // 对象形参常引用参数的使用:优点在于减少了生成形参对象是调用拷贝构造函数的开销，如果需要保证实参的值不被改变加上 const\n   void f(const a & a){\n       cout<<a.x<<endl;\n   }\n   \n   a func(){\n       a b(2);\n       return b; // b作为返回值，通过拷贝构造函数进行初始化\n   }\n   \n   int main(){\n       a a1(1);\n       f(a1); // a1作为拷贝构造函数的实参\n       cout << func().v << endl;\n       return 0;\n   }\n   \n\n深拷贝和浅拷贝：\n\n * 浅拷贝：又称值拷贝，将源对象的值拷贝到目标对象中去，本质上来说源对象和目标对象共用一份实体，只是所引用的变量名不同，地址其实还是相同的。（问题：浅拷贝和对象引用的区别是什么？）\n * 深拷贝：深拷贝的时候先开辟出和源对象大小一样的空间，然后将源对象里的内容拷贝到目标对象中去，这样两个指针就指向了不同的内存位置。\n * 深拷贝和浅拷贝可以简单理解为：如果一个类拥有资源，当这个类的对象发生复制过程的时候，资源重新分配，这个过程就是深拷贝，反之，没有重新分配资源，就是浅拷贝。\n\n\n# 类型转换构造函数\n\n类型转换构造函数：用途在于自动将其他类型的数据对象转换为该类对象。类型转化构造函数和拷贝构造函数类似，只有一个参数，但是其参数不是该类对象。在需要的时候，编译系统在编译过程中自动调用转换构造函数，建立一个无名的临时对象。\n\nclass complex(){\n    private:\n    \tdouble real,img;\n    public:\n    \tcomplex(double r, double i){\n            real = r;\n            img = i;\n        }\n    \tcomplex(int n){\n            real = n;\n            img = 0;\n            cout << "int constructor called"<<endl;\n        }\n    \tgetreal(){return real;}\n    \tgetimg(){return img;}\n};\n\nint main(){\n    complex c1(1,2);\n    c1 = 3; // 调用类型构造函数，将3转换一个临时complex对象\n    cout << c1.getreal() << c1.getimg() << endl;\n    return 0;\n}\n/* output:\n3 0\n*/\n\n\n\n# 析构函数\n\n析构函数：\n\n析构函数与构造函数对应，在对象生命周期结束时被自动调用，析构函数的作用是在对象消亡前做类似释放内存空间等善后工作。其名字和类目相同，在前面加 ~ ，没有参数和返回值，一个类最多只有一个析构函数。如果类中没有定义析构函数，编译器在编译过程中会生成缺省析构函数，并不进行任何操作。\n\nclass string{\n    private:\n    \tchar* p;\n    public:\n    \tstring(){\n            p = new char[10]; // new 申请动态内存空间\n        }\n    \t~string();\n};\nstring::~string(){\n    delete [] p; // delete 释放动态内存空间\n}\n\n\n析构函数在数组中的使用：对象数组生命周期结束时，对象数组中的每个元素的析构函数都会被调用。\n\n析构函数与 delete ：被 new 出来的对象一定要用 delete 释放，否则不会调用析构函数去释放对象；如果 new 的是一个对象数组，那么使用 delete [] 释放，如果只使用 delete ，那么只会调用一次析构函数释放一个对象。\n\n构造函数和析构函数的调用时机：值得注意的是，对象作为函数形参和返回值均会调用拷贝构造函数产生临时对象，那么这些对象在函数调用完成之后会自动调用析构函数释放资源。\n\nclass sample{\n    private:\n    \tint x;\n    public:\n    \tsample(int n){x=n; cout<<x<<"constructor called"<<endl;}\n    \t~sample(){cout<<x<<"destructor called"<<endl;}\n};\n\nsample s1(1); // 全局变量，调用构造函数 \n\nvoid f(){\n    static sample s2(2); // 静态局部变量在函数调用结束时不会消亡，整个程序执行完毕之和才会消亡\n    sample s3(3);\n    cout << "f called" << endl;\n}\n\nint main(){\n    sample s4(4); \n    s4 = 6; // 类型转换构造函数参数临时对象 \n    cout<<"main"<<endl;\n    if(true){\n        sample s5(5); // 局部变量在生命周期结束后调用析构\n    }\n    f();\n    cout<<"main end"<<endl;\n    return 0;\n}\n\n/* output:\n1 constructor called\n4 constructor called\n6 constructor called\n6 destructor called\nmain\n5 constructor called\n5 destructor called\n2 constructor called\n3 constructor called\nf called\n3 destructor called\nmain end\n6 destructor called (s4)\n2 destructor called (static)\n1 destructor called (global)\n*/\n\n\n值得注意的是，构造函数只负责初始化工作不负责内存空间分配，析构函数不负责内存空间回收；将对象比作房子，入住之前调用构造函数进行装修，拆迁之前调用析构函数搬东西。\n\n\n# reference\n\n拷贝构造函数详解\n\n深拷贝于浅拷贝',charsets:{cjk:!0},lastUpdated:"2023/11/19, 12:55:48",lastUpdatedTimestamp:1700369748e3},{title:"从 C 到 C++",frontmatter:{title:"从 C 到 C++",date:"2023-11-18T15:46:10.000Z",permalink:"/pages/1718db/"},regularPath:"/01.C&Cpp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/02.C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/01.C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/01.%E4%BB%8E%20C%20%E5%88%B0%20C++.html",relativePath:"01.C&Cpp学习笔记/02.C++面向对象编程/01.C++面向对象/01.从 C 到 C++.md",key:"v-5d1370e8",path:"/pages/1718db/",headers:[{level:2,title:"从 C 到 C++",slug:"从-c-到-c",normalizedTitle:"从 c 到 c++",charIndex:2},{level:2,title:"01 引用",slug:"_01-引用",normalizedTitle:"01 引用",charIndex:16},{level:2,title:"02 动态内存分配",slug:"_02-动态内存分配",normalizedTitle:"02 动态内存分配",charIndex:1576},{level:3,title:"C语言中的动态内存分配",slug:"c语言中的动态内存分配",normalizedTitle:"c语言中的动态内存分配",charIndex:1590},{level:3,title:"C++ 中的动态内存分配",slug:"c-中的动态内存分配",normalizedTitle:"c++ 中的动态内存分配",charIndex:2957},{level:2,title:"03 C++的函数",slug:"_03-c-的函数",normalizedTitle:"03 c++的函数",charIndex:4658},{level:2,title:"Reference",slug:"reference",normalizedTitle:"reference",charIndex:5759}],headersStr:"从 C 到 C++ 01 引用 02 动态内存分配 C语言中的动态内存分配 C++ 中的动态内存分配 03 C++的函数 Reference",content:'# 从 C 到 C++\n\n\n# 01 引用\n\n引用的概念：某个变量的引用，等价于这个变量，相当于该变量的一个别名\n\n引用的定义： 类型名 & 引用名 = 某变量名；\n\nint param = 4;\nint & alias = param; // alias 引用了 param, alias 的类型是 int &\n\n\n引用与指针的区别：\n\nC++ 中对对象的定义为：对象是指一块能存储数据并具有某种类型的内存空间。一个对象 a，它有值和地址 &a；运行程序时，计算机会为该对象分配存储空间，来存储该对象的值，并可以通过该对象的地址来访问其存储空间中的值。对象又有常量和变量之分，常量是指存储了固定值并具有某种类型的存储空间，可读不可写；而变量则是相对的，是指具有某种类型并可供操作的存储空间，可读也可写。\n\n指针 p 也是对象，它同样有地址 &p 和存储的值 p，只不过，p 存储的数据类型是数据的地址。如果要通过 p 中存储的数据作为地址来访问该指针对象的值，则要在 p 前加解引用操作符 "*"，即 *p。指针作为一种对象也有常量和变量之分，指针常量 DataType * const p = param; 是指该指针对象存储的地址 &p 是不可改变的，但是可以修改该指针对象存储的值 p \\*p = (DataType) value；常量指针 DataType const * p = param; OR const DataType * p = param; 是指该指针对象存储的值 p 是不可改变的，即不能通过指针对象 *p 直接修改其存储的值；常指针常量 const DataType * const p = param; 是指针常量和常量指针的结合。\n\n根据引用的概念可以看出，C++ 中引用就是指针常量，定义一个引用的时候，程序把该引用和它的初始值绑定在一起，而不是拷贝它。为此，引用有如下三个特点：\n\n * 在声明引用时一定要对其初始化\n * 引用经初始化后，就不可以再和其他对象绑定在一起了，一直引用该对象（从一而终）\n * 引用只能引用变量，不能引用常量和表达式，& 是取地址符\n\n常引用：\n\n常引用可以看作是常指针常量，常引用 const DataTye & 和非常引用(普通引用) DataType & 是不同的数据类型，普通引用和普通变量都可以用来初始化常引用，但是常变量 const DataType 和常引用不能用来初始化普通引用，除非进行强制类型转换。\n\n引用的应用：\n\n 1. 引用作为函数形参传值\n\n// swap函数实现数值交换\n\n// C 语言实现\nvoid swap(int *a, int *b){\n    int temp;\n    temp = *a; *a = *b; *b = temp;\n}\n\nint main(){\n    int m, n;\n    m = 1; n = 2;\n    swap(&m, &n);\n    return 0;\n}\n\n// C++ 实现\nvoid swap(int &a, int &b){\n    int temp;\n    temp = a; a = b; b = temp;\n    // temp = a; 赋值的为什么不是 &a 地址值\n}\n\nint main(){\n    int m, n;\n    m = 1; n = 2;\n    swap(m, n);\n    return 0;\n}\n\n\n 2. 引用作为函数的返回值\n\nint n = 4;\nint & set_n(){\n    return n;\n}\n\nint main(){\n    set_n() = 100;\n    cout << n;\n    return 0;\n}\n\n\n\n# 02 动态内存分配\n\n\n# C语言中的动态内存分配\n\nmalloc 分配内存：\n\nC/C++中可以使用 malloc 开辟一块连续的内存空间，并返回一个指向被分配内存空间起始地址的指针 DataType * p = (DataType *) malloc(sizeof(DataType)*number);。malloc 函数的实质是它有一个将可用的内存块连接为一个长长的列表的空闲链表，**即所谓的一级内存池。**内存池的作用是提高 malloc 向操作系统申请内存空间的效率。通过系统调用向操作系统申请/返还空间需要时间开销，所以 malloc 索性一次性申请 128K 的内存，当上层内存申请小于一级内存池的内存可用量时，直接返还，就不用和操作系统通信，从而提高效率。而实践中，小额的内存频繁申请的机会占大多数，所以内存池能够有效提高效率。\n\n调用 malloc 函数时，它沿连接表寻找一个大到足以满足用户请求所需要的内存块；然后，将该内存块一分为二，一块的大小与用户请求的大小相等，另一块的大小就是剩下的字节；接下来，将分配给用户的那块内存传给用户，并将剩下的那块返回到连接表上。如果用户申请一个较大的内存空间，malloc 的内存池中没有直接满足该大小的内存空间时，malloc 检查空闲链表上的个内存片段，并对它们进行整理，将相邻的小空闲块合并成较大的内存块。如果最后仍然无法获得符合要求的内存块，malloc 函数会返回 NULL 指针。\n\n操作系统为进程分配的内存中往往包含一块用户空间 (User Space)，用户空间中分为多个内存段主要包含以下几段：\n\n * 程序段 Code Segmentation：位于整个用户空间的最低地址部分，存放指令即程序所编译成的可执行机器码\n * 数据段 Data Segmentation：存放初始化过的全局变量\n * BSS 段 BSS Segmentation：存放未初始化的全局变量\n * 堆 Heap：用于存放进程运行中被动态分配的内存段，堆的大小不是固定的，可以动态变化。当进程调用 malloc / free 等函数分配内存时，新分配的内存就被动态添加到堆上，或将被释放的内存从堆中剔除。\n * 栈 Stack：存放程序的局部变量，在函数调用过程中也是通过栈来传递参数和返回值，利用先进后出特性方便保存和恢复调用现场。\n\nmalloc 函数的申请内存空间就是通过系统调用从操作系统（即堆 Heap 空间中）获得，也就是说函数返回的指针是指向堆里面的一块内存。操作系统中有一个记录空闲内存地址的链表，当操作系统收到程序的申请时，就会遍历该链表，然后就寻找第一个空间大于所申请空间的堆结点，将该结点从空闲结点链表中删除，并将该结点的空间分配给程序。\n\nfree 释放内存：\n\nC/C++中可以使用 free 释放内存空间，调用free函数时，它将用户释放的内存块连接到空闲链上，即将不用的内存返还给 malloc 维护的一级内存池。值得注意的是，free 释放的是指针指向的内存，而非指针本身，指针作为一个对象，只有程序运行结束时才被销毁。释放了内存空间后，原来指向这块空间的指针还是存在，只不过现在指针指向的是未定义的内容。因此，在释放内存后，要把指针指向 NULL，防止指针被解引用。\n\n\n# C++ 中的动态内存分配\n\nnew/delete 动态管理对象：\n\n相较于 malloc/free，new/delete 可以更加自动化地申请和释放内存，因为 new/delete 在对象创建的时候自动执行构造函数，对象消亡之前会自动执行析构函数。如下示例代码所示，在编译器层面针对各种对象，系统调用了默认的构造函数来初始化以及默认的析构函数来析构，这种方式能保证对象一被创建出来便被初始化，出了作用域便被自动清理。\n\n// 调用示例\nComplex *pc = new Complex(1,2);\n...\ndelete pc;\n\n// 编译器优化：在编译器中对上述代码过程进行优化如下\n// new 过程\nComplex *pc;\ntry{\n    void *mem = operator new(sizeof(Complex)); // 申请内存空间\n    pc = static_cast<Complex*>(mem);\n    pc->Complex::Complex(1,2); //调用构造函数\n} catch(std::bad_alloc) {\n    // 失败就不执行构造函数\n}\n// delete 过程\npc->Complex(); // 调用析构函数\noperator delete(pc); // 释放内存空间\n\n\n从本质去看待 new/delete 和 malloc/free，前者就是对后者的一层封装。上述示例中的 operator new(); 和 operator delete(); 的源码实现如下所示：\n\nvoid *operator new(size_t size, const std::nothrow_t&)_THROW0()\n{\n    void *p;\n    while((p = malloc(size)) == 0){\n        _TRY_BEGIN\n            if(_callnewh(size) == 0) break;\n        _CATCH(std::bad_alloc) return (0);\n        _CATCH_END\n    }\n    \n    return(p);\n}\n\nvoid _cdecl operator delete(void *p)_THROW0()\n{\n    free(p);\n}\n\n\n在 new 中，先由 operator new();调用 malloc 根据对象申请数据存储大小（非全局静态成员变量+虚函数表指针大小*数量）的空间，然后赋给一个空指针，并将静态转型为目标型的指针，赋值给刚开始定义对象类型指针，最后调用了类的构造函数，对内对中的对象空间初始化赋值。在 delete 中，则是先调用了对象的析构函数，然后通过 operator delete(); 调用 free 来释放空间。\n\nnew[]/delete[] 动态管理对象数组：\n\n动态分配一个数组的声明方式 string *psa = new string[10]; int *pia = new int[10]; 在 string 数组中分配了保存对象的内存空间之后，将调用 string 类型的默认构造函数依次初始化数组中每个元素；而 int 是内置类型的数组，该过程中分配了存储 10 个 int 对象的内存空间，但并没有初始化。\n\n释放对象数组空间的声明方式 delete [] psa; delete [] pia; 在 string 数组中对 10 个 string 对象分别调用析构函数，然后调用operator delete[]();，该函数中调用operator delete(); ，由上述代码可知delete函数底层用 free 释放掉为对象分配的所有内存空间；而 int[] 是内置类型不存在析构函数，直接释放为 10 个 int 型分配的所有内存空间。\n\nnew/delete new[]/delete[]的调用过程如下图所示：(图片来源网络，如有侵权，请及时告知)\n\n\n# 03 C++的函数\n\n内联函数 inline：inline int Max(int a, int b);\n\n函数调用过程中存在一定的系统开销，为了减少函数调用的开销，C++ 中引入了内联函数机制。如果函数本身语句较少，执行时长很短，但是函数被反复调用，那么可以采用内联函数。编译器在处理对内联函数的调用语句时，直接将整个被调函数的代码块插入到调用语句处，而不会产生调用函数的语句。\n\n内联函数的优点在于：a) 在调用时直接替换，减少了函数调用的开销，提高了代码执行效率。b) 编译器在处理内联函数时会对其参数类型进行检查，这样可以消除替换过程中的安全隐患和局限性。c) 内联函数可以作为一个类的成员函数，与类的普通成员函数作用相同，可以访问一个类的私有成员和保护成员。\n\n内联函数的局限性在于函数体不能太大，inline 对编译器只是一种建议，当内联函数的函数体过大时，编译器会选择忽略这种建议，采用普通的函数调用方式执行程序，这就失去了声明内联函数的意义。\n\n函数重载：\n\n一个或多个函数，名字相同，参数个数或参数类型不同，这种方式叫做函数的重载。函数名字可以相同使得编码过程中函数命名变得简单；在编译过程中，编译器根据调用语句中实参的个数和类型判断应该调用哪个函数。但是函数重载在调用过程中要避免二义性，这会导致编译错误，示例如下所示：\n\nint Max(double d1, double d2){} // (1)\nint Max(int n1, double n2){} // (2)\nint Max(int n1, int n2, int n3){} // (3)\n// 调用\nMax(3.4,2.5); // (1)\nMax(2,3); // (2)\nMax(1,2,3); // (3)\nMax(2,3.4); // error 存在二义性\n\n\n函数的缺省参数：\n\n在 C++ 中定义函数的时候可以让最右边的连续若干个参数有缺省值，在调用函数的时候，若相应位置不写参数，参数就是缺省值。函数参数可缺省的目的在于提高程序的可扩充性，为未来可能要扩充的函数参数预留位置；如果某个已经写好的函数需要添加新的参数，而原先调用该函数的语句可能不需要使用新增的参数，那么为了避免溯源对调用语句进行修改，使用缺省参数达到目的。\n\nvoid func(int x1, int x2 = 2, int x3 = 3){}\n// 调用\nfunc(10); // complete!\nfunc(10,8); // complete!\nfunc(10, ,8); // error, 不能间隔参数缺省\n\n\n\n# Reference\n\nC++引用与指针的区别\n\nC++动态内存分配，malloc 与 new 的区别\n\n深入理解C++ new/delete, new []/delete[]动态内存管理',normalizedContent:'# 从 c 到 c++\n\n\n# 01 引用\n\n引用的概念：某个变量的引用，等价于这个变量，相当于该变量的一个别名\n\n引用的定义： 类型名 & 引用名 = 某变量名；\n\nint param = 4;\nint & alias = param; // alias 引用了 param, alias 的类型是 int &\n\n\n引用与指针的区别：\n\nc++ 中对对象的定义为：对象是指一块能存储数据并具有某种类型的内存空间。一个对象 a，它有值和地址 &a；运行程序时，计算机会为该对象分配存储空间，来存储该对象的值，并可以通过该对象的地址来访问其存储空间中的值。对象又有常量和变量之分，常量是指存储了固定值并具有某种类型的存储空间，可读不可写；而变量则是相对的，是指具有某种类型并可供操作的存储空间，可读也可写。\n\n指针 p 也是对象，它同样有地址 &p 和存储的值 p，只不过，p 存储的数据类型是数据的地址。如果要通过 p 中存储的数据作为地址来访问该指针对象的值，则要在 p 前加解引用操作符 "*"，即 *p。指针作为一种对象也有常量和变量之分，指针常量 datatype * const p = param; 是指该指针对象存储的地址 &p 是不可改变的，但是可以修改该指针对象存储的值 p \\*p = (datatype) value；常量指针 datatype const * p = param; or const datatype * p = param; 是指该指针对象存储的值 p 是不可改变的，即不能通过指针对象 *p 直接修改其存储的值；常指针常量 const datatype * const p = param; 是指针常量和常量指针的结合。\n\n根据引用的概念可以看出，c++ 中引用就是指针常量，定义一个引用的时候，程序把该引用和它的初始值绑定在一起，而不是拷贝它。为此，引用有如下三个特点：\n\n * 在声明引用时一定要对其初始化\n * 引用经初始化后，就不可以再和其他对象绑定在一起了，一直引用该对象（从一而终）\n * 引用只能引用变量，不能引用常量和表达式，& 是取地址符\n\n常引用：\n\n常引用可以看作是常指针常量，常引用 const datatye & 和非常引用(普通引用) datatype & 是不同的数据类型，普通引用和普通变量都可以用来初始化常引用，但是常变量 const datatype 和常引用不能用来初始化普通引用，除非进行强制类型转换。\n\n引用的应用：\n\n 1. 引用作为函数形参传值\n\n// swap函数实现数值交换\n\n// c 语言实现\nvoid swap(int *a, int *b){\n    int temp;\n    temp = *a; *a = *b; *b = temp;\n}\n\nint main(){\n    int m, n;\n    m = 1; n = 2;\n    swap(&m, &n);\n    return 0;\n}\n\n// c++ 实现\nvoid swap(int &a, int &b){\n    int temp;\n    temp = a; a = b; b = temp;\n    // temp = a; 赋值的为什么不是 &a 地址值\n}\n\nint main(){\n    int m, n;\n    m = 1; n = 2;\n    swap(m, n);\n    return 0;\n}\n\n\n 2. 引用作为函数的返回值\n\nint n = 4;\nint & set_n(){\n    return n;\n}\n\nint main(){\n    set_n() = 100;\n    cout << n;\n    return 0;\n}\n\n\n\n# 02 动态内存分配\n\n\n# c语言中的动态内存分配\n\nmalloc 分配内存：\n\nc/c++中可以使用 malloc 开辟一块连续的内存空间，并返回一个指向被分配内存空间起始地址的指针 datatype * p = (datatype *) malloc(sizeof(datatype)*number);。malloc 函数的实质是它有一个将可用的内存块连接为一个长长的列表的空闲链表，**即所谓的一级内存池。**内存池的作用是提高 malloc 向操作系统申请内存空间的效率。通过系统调用向操作系统申请/返还空间需要时间开销，所以 malloc 索性一次性申请 128k 的内存，当上层内存申请小于一级内存池的内存可用量时，直接返还，就不用和操作系统通信，从而提高效率。而实践中，小额的内存频繁申请的机会占大多数，所以内存池能够有效提高效率。\n\n调用 malloc 函数时，它沿连接表寻找一个大到足以满足用户请求所需要的内存块；然后，将该内存块一分为二，一块的大小与用户请求的大小相等，另一块的大小就是剩下的字节；接下来，将分配给用户的那块内存传给用户，并将剩下的那块返回到连接表上。如果用户申请一个较大的内存空间，malloc 的内存池中没有直接满足该大小的内存空间时，malloc 检查空闲链表上的个内存片段，并对它们进行整理，将相邻的小空闲块合并成较大的内存块。如果最后仍然无法获得符合要求的内存块，malloc 函数会返回 null 指针。\n\n操作系统为进程分配的内存中往往包含一块用户空间 (user space)，用户空间中分为多个内存段主要包含以下几段：\n\n * 程序段 code segmentation：位于整个用户空间的最低地址部分，存放指令即程序所编译成的可执行机器码\n * 数据段 data segmentation：存放初始化过的全局变量\n * bss 段 bss segmentation：存放未初始化的全局变量\n * 堆 heap：用于存放进程运行中被动态分配的内存段，堆的大小不是固定的，可以动态变化。当进程调用 malloc / free 等函数分配内存时，新分配的内存就被动态添加到堆上，或将被释放的内存从堆中剔除。\n * 栈 stack：存放程序的局部变量，在函数调用过程中也是通过栈来传递参数和返回值，利用先进后出特性方便保存和恢复调用现场。\n\nmalloc 函数的申请内存空间就是通过系统调用从操作系统（即堆 heap 空间中）获得，也就是说函数返回的指针是指向堆里面的一块内存。操作系统中有一个记录空闲内存地址的链表，当操作系统收到程序的申请时，就会遍历该链表，然后就寻找第一个空间大于所申请空间的堆结点，将该结点从空闲结点链表中删除，并将该结点的空间分配给程序。\n\nfree 释放内存：\n\nc/c++中可以使用 free 释放内存空间，调用free函数时，它将用户释放的内存块连接到空闲链上，即将不用的内存返还给 malloc 维护的一级内存池。值得注意的是，free 释放的是指针指向的内存，而非指针本身，指针作为一个对象，只有程序运行结束时才被销毁。释放了内存空间后，原来指向这块空间的指针还是存在，只不过现在指针指向的是未定义的内容。因此，在释放内存后，要把指针指向 null，防止指针被解引用。\n\n\n# c++ 中的动态内存分配\n\nnew/delete 动态管理对象：\n\n相较于 malloc/free，new/delete 可以更加自动化地申请和释放内存，因为 new/delete 在对象创建的时候自动执行构造函数，对象消亡之前会自动执行析构函数。如下示例代码所示，在编译器层面针对各种对象，系统调用了默认的构造函数来初始化以及默认的析构函数来析构，这种方式能保证对象一被创建出来便被初始化，出了作用域便被自动清理。\n\n// 调用示例\ncomplex *pc = new complex(1,2);\n...\ndelete pc;\n\n// 编译器优化：在编译器中对上述代码过程进行优化如下\n// new 过程\ncomplex *pc;\ntry{\n    void *mem = operator new(sizeof(complex)); // 申请内存空间\n    pc = static_cast<complex*>(mem);\n    pc->complex::complex(1,2); //调用构造函数\n} catch(std::bad_alloc) {\n    // 失败就不执行构造函数\n}\n// delete 过程\npc->complex(); // 调用析构函数\noperator delete(pc); // 释放内存空间\n\n\n从本质去看待 new/delete 和 malloc/free，前者就是对后者的一层封装。上述示例中的 operator new(); 和 operator delete(); 的源码实现如下所示：\n\nvoid *operator new(size_t size, const std::nothrow_t&)_throw0()\n{\n    void *p;\n    while((p = malloc(size)) == 0){\n        _try_begin\n            if(_callnewh(size) == 0) break;\n        _catch(std::bad_alloc) return (0);\n        _catch_end\n    }\n    \n    return(p);\n}\n\nvoid _cdecl operator delete(void *p)_throw0()\n{\n    free(p);\n}\n\n\n在 new 中，先由 operator new();调用 malloc 根据对象申请数据存储大小（非全局静态成员变量+虚函数表指针大小*数量）的空间，然后赋给一个空指针，并将静态转型为目标型的指针，赋值给刚开始定义对象类型指针，最后调用了类的构造函数，对内对中的对象空间初始化赋值。在 delete 中，则是先调用了对象的析构函数，然后通过 operator delete(); 调用 free 来释放空间。\n\nnew[]/delete[] 动态管理对象数组：\n\n动态分配一个数组的声明方式 string *psa = new string[10]; int *pia = new int[10]; 在 string 数组中分配了保存对象的内存空间之后，将调用 string 类型的默认构造函数依次初始化数组中每个元素；而 int 是内置类型的数组，该过程中分配了存储 10 个 int 对象的内存空间，但并没有初始化。\n\n释放对象数组空间的声明方式 delete [] psa; delete [] pia; 在 string 数组中对 10 个 string 对象分别调用析构函数，然后调用operator delete[]();，该函数中调用operator delete(); ，由上述代码可知delete函数底层用 free 释放掉为对象分配的所有内存空间；而 int[] 是内置类型不存在析构函数，直接释放为 10 个 int 型分配的所有内存空间。\n\nnew/delete new[]/delete[]的调用过程如下图所示：(图片来源网络，如有侵权，请及时告知)\n\n\n# 03 c++的函数\n\n内联函数 inline：inline int max(int a, int b);\n\n函数调用过程中存在一定的系统开销，为了减少函数调用的开销，c++ 中引入了内联函数机制。如果函数本身语句较少，执行时长很短，但是函数被反复调用，那么可以采用内联函数。编译器在处理对内联函数的调用语句时，直接将整个被调函数的代码块插入到调用语句处，而不会产生调用函数的语句。\n\n内联函数的优点在于：a) 在调用时直接替换，减少了函数调用的开销，提高了代码执行效率。b) 编译器在处理内联函数时会对其参数类型进行检查，这样可以消除替换过程中的安全隐患和局限性。c) 内联函数可以作为一个类的成员函数，与类的普通成员函数作用相同，可以访问一个类的私有成员和保护成员。\n\n内联函数的局限性在于函数体不能太大，inline 对编译器只是一种建议，当内联函数的函数体过大时，编译器会选择忽略这种建议，采用普通的函数调用方式执行程序，这就失去了声明内联函数的意义。\n\n函数重载：\n\n一个或多个函数，名字相同，参数个数或参数类型不同，这种方式叫做函数的重载。函数名字可以相同使得编码过程中函数命名变得简单；在编译过程中，编译器根据调用语句中实参的个数和类型判断应该调用哪个函数。但是函数重载在调用过程中要避免二义性，这会导致编译错误，示例如下所示：\n\nint max(double d1, double d2){} // (1)\nint max(int n1, double n2){} // (2)\nint max(int n1, int n2, int n3){} // (3)\n// 调用\nmax(3.4,2.5); // (1)\nmax(2,3); // (2)\nmax(1,2,3); // (3)\nmax(2,3.4); // error 存在二义性\n\n\n函数的缺省参数：\n\n在 c++ 中定义函数的时候可以让最右边的连续若干个参数有缺省值，在调用函数的时候，若相应位置不写参数，参数就是缺省值。函数参数可缺省的目的在于提高程序的可扩充性，为未来可能要扩充的函数参数预留位置；如果某个已经写好的函数需要添加新的参数，而原先调用该函数的语句可能不需要使用新增的参数，那么为了避免溯源对调用语句进行修改，使用缺省参数达到目的。\n\nvoid func(int x1, int x2 = 2, int x3 = 3){}\n// 调用\nfunc(10); // complete!\nfunc(10,8); // complete!\nfunc(10, ,8); // error, 不能间隔参数缺省\n\n\n\n# reference\n\nc++引用与指针的区别\n\nc++动态内存分配，malloc 与 new 的区别\n\n深入理解c++ new/delete, new []/delete[]动态内存管理',charsets:{cjk:!0},lastUpdated:"2023/11/19, 12:55:48",lastUpdatedTimestamp:1700369748e3},{title:"C++ 继承",frontmatter:{title:"C++ 继承",date:"2023-11-18T15:46:10.000Z",permalink:"/pages/7e1638/"},regularPath:"/01.C&Cpp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/02.C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/01.C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/06.C++%20%E7%BB%A7%E6%89%BF.html",relativePath:"01.C&Cpp学习笔记/02.C++面向对象编程/01.C++面向对象/06.C++ 继承.md",key:"v-28bc7684",path:"/pages/7e1638/",headers:[{level:2,title:"继承和派生的概念",slug:"继承和派生的概念",normalizedTitle:"继承和派生的概念",charIndex:13},{level:2,title:"类之间的关系",slug:"类之间的关系",normalizedTitle:"类之间的关系",charIndex:2446},{level:2,title:"公有继承的赋值兼容",slug:"公有继承的赋值兼容",normalizedTitle:"公有继承的赋值兼容",charIndex:2666}],headersStr:"继承和派生的概念 类之间的关系 公有继承的赋值兼容",content:'# C++ 继承\n\n\n# 继承和派生的概念\n\n继承：在定义一个新的类 B 时，如果该类与某个已有的类 A 相似，指的是 B 拥有 A 的全部特点，在属性上 A 是 B 的子集；那么就可以把 A 作为一个基类，而把 B 作为基类的一个派生类也称为子类。\n\n派生类：派生类是通过对基类进行修改和扩充得到的。在派生类中，继承了基类的全部成员函数和成员变量，不论是 private, protected , public，但是在派生类的各成员函数中，仍旧不能直接访问基类中的 private 成员；除此之外派生类还可以扩充新的成员变量和成员函数。派生类被定义之后，可以独立使用，不依赖于基类。\n\n派生类的写法：\n\nclass SubClassName:public BaseClassName\n{ \n    // class body \n};\n\n\n派生类对象的内存空间：派生类对象占用的内存空间等于基类对象占用的内存空间，再加上自身成员变量所占用的内存空间。在派生类对象中包含这基类对象，而且基类对象的存储位置位于派生类对象自身成员变量之前。\n\n覆盖：派生类可以定义一个和基类成员同名的成员，这种机制称为覆盖。在派生类中访问由基类定义的同名成员时，要使用作用域符号 ClassName::Member ；在派生类中同名成员没有使用作用域符号 :: 的缺省情况时，访问的是派生类自身定义的成员。\n\n派生类的构造函数：\n\n和封闭类类似，派生类的构造函数也使用参数表的形式进行初始化，详细内容请参考 C++ 类和对象提高：成员对象和封闭类 。\n\n派生类的构造函数执行顺序和封闭类也类似，在创建派生类的对象时，需要先调用基类的构造函数初始化派生类从基类继承来的成员，再调用自身的构造函数初始化自身成员变量。同理，在派生类对象消亡时，派生类的析构函数总是先于基类析构函数被调用。如果派生类包含成员对象，成员对象的构造函数后于基类构造函数调用，先于派生类自身构造函数调用；析构函数反之。\n\nclass Student{\n    private:\n    \tstring name;\n    \tstring id;\n    \tchar gender;\n    \tint age;\n    public:\n    \tStudent(const string & name_, const string & id_, char gender_, int age_){\n            name = name_;\n            id = id_;\n            gender = gender_;\n            age = age_;\n        }\n    \t~Student(){cout<<"base class destructor called"<<endl;}\n    \tvoid printInfo(){\n            cout<<"name:"<<name<<endl<<"id:"<<id<<endl<<"gender:"<<gender<<endl<<"age:"<<age<<endl;\n        }\n    \tvoid setInfo(const string & name_, const string & id_, char gender_, int age_){\n            name = name_;\n            id = id_;\n            gender = gender_;\n            age = age_;\n        } // 基类的成员变量是 private 的，派生类无法直接访问，通过成员函数隐藏\n    \tstring getName(){\n            return name;\n        }\n};\n\nclass UnderStudent:public Student{\n    private:\n    \tstring department;\n    public:\n    \tUnderStudent(const string & name_, const string & id_, char gender_, int age_, const string & department_):Student(name_, id_, gender_, age_){\n            department = department_;\n        } // 派生类的构造函数使用参数表进行初始化\n    \t~UnderStudent(){cout<<"sub class destructor called"<<endl;}\n    \tvoid qulifiedForBaoYan(){\n            cout<<"QulifiedForBaoYan"<<endl;\n        }\n    \tvoid printInfo(){\n            Student::printInfo(); //调用基类成员函数\n            cout<<"department:"<<department<<endl;\n        }\n    \tvoid setInfo(const string & name_, const string & id_, char gender_, int age_, const string & department_){\n            Student::setInfo(name_, id_, gender_, age_); //调用基类成员函数\n            department = department_;\n        }\n};\n\n\n\n# 类之间的关系\n\n继承关系：\n\nB 是 A 的派生类，那么 B 的对象也是 A 的对象，则 A 和 B 是继承关系。\n\n例如：Man 类与 Woman 类和 Human 类都是继承关系\n\n复合关系：\n\nD 的对象是 C 的对象的固有属性或组成部分，即 C 是封闭类其成员对象是 D，则 C 和 D 是复合关系。\n\n例如：Point 类和 Circle 类是复合关系，圆不是点，所以圆心 Point 作为 Circle 类的成员对象。\n\n\n# 公有继承的赋值兼容\n\npublic 继承的赋值兼容规则：如果继承方式为 private 或 protected 则下述规则不成立\n\n * 派生类对象可以赋值给基类对象\n * 派生类对象可以初始化基类引用\n * 派生类对象的地址可以赋值给基类指针\n\n间接基类：派生类在声明时只需要列出其直接基类，并自动沿着类的层次关系继承其他间接基类；在派生类中也继承了间接基类的所有成员。\n\nclass Base{\n    public:\n    \tint base;\n    \tBase(int base_):base(base_){cout<<"base constructor called"<<endl;}\n    \t~Base(){cout<<"base destructor called"<<endl;}\n};\n\nclass Derived:public Base{\n    public:\n    \tDerived(int base_):Base(base_){cout<<"derived constructor called"<<endl;}\n    \t~Derived(){cout<<"derived destructor called"<<endl;}\n};\n\nclass MoreDerived:public Derived{\n    public:\n    \tMoreDerived(int base_):Derived(base_){cout<<"moreDerived constructor called"<<endl;} // 间接基类的初始化\n    \t~MoreDerived(){cout<<"moreDerived destructor called"<<endl;}\n};\n\nint main(){\n    MoreDerived obj(4);\n    return 0;\n}\n/* output:\nbase constructor called\nderived constructor called\nmoreDerived constructor called\nmoreDerived destructor called\nderived destructor called\nbase destructor called\n*/\n',normalizedContent:'# c++ 继承\n\n\n# 继承和派生的概念\n\n继承：在定义一个新的类 b 时，如果该类与某个已有的类 a 相似，指的是 b 拥有 a 的全部特点，在属性上 a 是 b 的子集；那么就可以把 a 作为一个基类，而把 b 作为基类的一个派生类也称为子类。\n\n派生类：派生类是通过对基类进行修改和扩充得到的。在派生类中，继承了基类的全部成员函数和成员变量，不论是 private, protected , public，但是在派生类的各成员函数中，仍旧不能直接访问基类中的 private 成员；除此之外派生类还可以扩充新的成员变量和成员函数。派生类被定义之后，可以独立使用，不依赖于基类。\n\n派生类的写法：\n\nclass subclassname:public baseclassname\n{ \n    // class body \n};\n\n\n派生类对象的内存空间：派生类对象占用的内存空间等于基类对象占用的内存空间，再加上自身成员变量所占用的内存空间。在派生类对象中包含这基类对象，而且基类对象的存储位置位于派生类对象自身成员变量之前。\n\n覆盖：派生类可以定义一个和基类成员同名的成员，这种机制称为覆盖。在派生类中访问由基类定义的同名成员时，要使用作用域符号 classname::member ；在派生类中同名成员没有使用作用域符号 :: 的缺省情况时，访问的是派生类自身定义的成员。\n\n派生类的构造函数：\n\n和封闭类类似，派生类的构造函数也使用参数表的形式进行初始化，详细内容请参考 c++ 类和对象提高：成员对象和封闭类 。\n\n派生类的构造函数执行顺序和封闭类也类似，在创建派生类的对象时，需要先调用基类的构造函数初始化派生类从基类继承来的成员，再调用自身的构造函数初始化自身成员变量。同理，在派生类对象消亡时，派生类的析构函数总是先于基类析构函数被调用。如果派生类包含成员对象，成员对象的构造函数后于基类构造函数调用，先于派生类自身构造函数调用；析构函数反之。\n\nclass student{\n    private:\n    \tstring name;\n    \tstring id;\n    \tchar gender;\n    \tint age;\n    public:\n    \tstudent(const string & name_, const string & id_, char gender_, int age_){\n            name = name_;\n            id = id_;\n            gender = gender_;\n            age = age_;\n        }\n    \t~student(){cout<<"base class destructor called"<<endl;}\n    \tvoid printinfo(){\n            cout<<"name:"<<name<<endl<<"id:"<<id<<endl<<"gender:"<<gender<<endl<<"age:"<<age<<endl;\n        }\n    \tvoid setinfo(const string & name_, const string & id_, char gender_, int age_){\n            name = name_;\n            id = id_;\n            gender = gender_;\n            age = age_;\n        } // 基类的成员变量是 private 的，派生类无法直接访问，通过成员函数隐藏\n    \tstring getname(){\n            return name;\n        }\n};\n\nclass understudent:public student{\n    private:\n    \tstring department;\n    public:\n    \tunderstudent(const string & name_, const string & id_, char gender_, int age_, const string & department_):student(name_, id_, gender_, age_){\n            department = department_;\n        } // 派生类的构造函数使用参数表进行初始化\n    \t~understudent(){cout<<"sub class destructor called"<<endl;}\n    \tvoid qulifiedforbaoyan(){\n            cout<<"qulifiedforbaoyan"<<endl;\n        }\n    \tvoid printinfo(){\n            student::printinfo(); //调用基类成员函数\n            cout<<"department:"<<department<<endl;\n        }\n    \tvoid setinfo(const string & name_, const string & id_, char gender_, int age_, const string & department_){\n            student::setinfo(name_, id_, gender_, age_); //调用基类成员函数\n            department = department_;\n        }\n};\n\n\n\n# 类之间的关系\n\n继承关系：\n\nb 是 a 的派生类，那么 b 的对象也是 a 的对象，则 a 和 b 是继承关系。\n\n例如：man 类与 woman 类和 human 类都是继承关系\n\n复合关系：\n\nd 的对象是 c 的对象的固有属性或组成部分，即 c 是封闭类其成员对象是 d，则 c 和 d 是复合关系。\n\n例如：point 类和 circle 类是复合关系，圆不是点，所以圆心 point 作为 circle 类的成员对象。\n\n\n# 公有继承的赋值兼容\n\npublic 继承的赋值兼容规则：如果继承方式为 private 或 protected 则下述规则不成立\n\n * 派生类对象可以赋值给基类对象\n * 派生类对象可以初始化基类引用\n * 派生类对象的地址可以赋值给基类指针\n\n间接基类：派生类在声明时只需要列出其直接基类，并自动沿着类的层次关系继承其他间接基类；在派生类中也继承了间接基类的所有成员。\n\nclass base{\n    public:\n    \tint base;\n    \tbase(int base_):base(base_){cout<<"base constructor called"<<endl;}\n    \t~base(){cout<<"base destructor called"<<endl;}\n};\n\nclass derived:public base{\n    public:\n    \tderived(int base_):base(base_){cout<<"derived constructor called"<<endl;}\n    \t~derived(){cout<<"derived destructor called"<<endl;}\n};\n\nclass morederived:public derived{\n    public:\n    \tmorederived(int base_):derived(base_){cout<<"morederived constructor called"<<endl;} // 间接基类的初始化\n    \t~morederived(){cout<<"morederived destructor called"<<endl;}\n};\n\nint main(){\n    morederived obj(4);\n    return 0;\n}\n/* output:\nbase constructor called\nderived constructor called\nmorederived constructor called\nmorederived destructor called\nderived destructor called\nbase destructor called\n*/\n',charsets:{cjk:!0},lastUpdated:"2023/11/19, 12:55:48",lastUpdatedTimestamp:1700369748e3},{title:"C++ 多态",frontmatter:{title:"C++ 多态",date:"2023-11-18T15:46:10.000Z",permalink:"/pages/7df88b/"},regularPath:"/01.C&Cpp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/02.C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/01.C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/07.C++%20%E5%A4%9A%E6%80%81.html",relativePath:"01.C&Cpp学习笔记/02.C++面向对象编程/01.C++面向对象/07.C++ 多态.md",key:"v-3cae0aa0",path:"/pages/7df88b/",headers:[{level:2,title:"虚函数和多态的概念",slug:"虚函数和多态的概念",normalizedTitle:"虚函数和多态的概念",charIndex:13},{level:2,title:"纯虚函数和抽象类",slug:"纯虚函数和抽象类",normalizedTitle:"纯虚函数和抽象类",charIndex:2079},{level:2,title:"多态的实现原理",slug:"多态的实现原理",normalizedTitle:"多态的实现原理",charIndex:2368},{level:3,title:"虚函数表",slug:"虚函数表",normalizedTitle:"虚函数表",charIndex:1784},{level:2,title:"Reference",slug:"reference",normalizedTitle:"reference",charIndex:7402}],headersStr:"虚函数和多态的概念 纯虚函数和抽象类 多态的实现原理 虚函数表 Reference",content:'# C++ 多态\n\n\n# 虚函数和多态的概念\n\n虚函数：\n\n * 在类的定义中，有 virtual 关键字的成员函数就是虚函数，形如：\n   \n   class Base{\n       public:\n       \tvirtual int get();  \n   };\n   int Base::get(){} // virtual 关键字只需要在类内声明\n   \n   class Derived:public Base{\n       public:\n       \tvirtual int get();\n   };\n   int Derived::get(){}\n   \n   int main(){\n       Derived de;\n       Base b;\n       Base* p = & de;\n       Base& r = de;\n       p->get(); // 多态 调用派生类虚函数\n       r.get();\n       p = & b;\n       p->get(); // 多态 调用ji类虚函数\n       return 0;\n   }\n   \n\n * virtual 关键字只用在类定义内的函数声明中使用，在类外写函数体时不用写 virtual 关键字。\n\n * 构造函数和静态成员函数不能是虚函数\n\n * 虚函数和普通函数的区别在于：虚函数能够参与多态，而普通函数不可以\n\n * 在非构造函数和非析构函数的成员函数中调用虚函数，就是多态。反之在构造函数和析构函数中调用虚函数，不是多态；因为在编译时就能确定被调用的虚函数是基类还是派生类的，不用等到运行才确定。**为什么构造函数中调用函数不是多态？**因为派生类调用构造函数期间会先调用基类构造函数，如果基类构造函数中存在多态并调用了派生类的虚函数，这时派生类还未调用构造函数进行初始化，这将导致错误的运行结果。\n\n * 在派生类中和基类中虚函数同名同参数表的函数，不加 virtual 关键字也自动成为虚函数\n\n#include <iostream>\nusing namespace std;\n\nclass Base{\n    public:\n        void func1(){ func2(); } // void func1(){ this->func2(); }  this指针指向当前被调对象 多态\n        virtual void func2(){cout<< "Base func2 called!"<<endl;}\n        virtual void hello(){cout<<"Base hello"<<endl;}\n};\n\nclass Derived:public Base{\n    public:  \n        virtual void func2(){cout<< "Derived func2 called!"<<endl;}\n        void hello(){cout<<"Derived hello"<<endl;}\n        Derived(){hello();} // 不是多态\n        ~Derived(){hello();}\n};\n\nint main(){\n    Derived d;\n    Base* pb = &d;\n    pb->func1();\n    return 0;\n}\n\n\n多态的表现形式：\n\n * 通过基类指针调用基类和派生类中的同名虚函数时：\n   * 指针指向一个基类的对象，那么被调用的是基类的虚函数\n   * 指针指向一个派生类的对象，那么被调用的是派生类的虚函数\n * 通过基类引用调用基类和派生类中的同名虚函数时：\n   * 引用引用的是一个基类的对象，那么被调用的是基类的虚函数\n   * 引用引用的是一个派生类的对象，那么被调用的是派生类的虚函数\n\n多态的作用：\n\n在面向对象的程序设计中使用多态能够增强程序的可扩充性，即程序需要修改或增加功能的时候，避免大量代码的改动和增加。但是多态的机制会增加程序执行时在时间和空间上的开销，空间上是由于存在虚函数的类的每个对象在创建时都会多出 4 个字节的额外空间开销用于存放虚函数表的地址；时间上是由于在查虚函数表的过程中需要消耗一定的时间。\n\n虚析构函数：\n\n当通过基类指针销毁派生类对象时，通常只有基类的构造函数被调用，一般是先调用派生类析构函数，再调用基类构造函数，这就出现了析构不完整的情况。为此，可以将基类的析构函数声明为虚函数，即虚析构函数，派生类的析构函数就不需要进行虚函数声明，自动成为虚函数；这时，通过基类指针析构派生类对象时调用的就是派生类的析构函数，派生类的析构函数中会调用基类的析构函数。\n\n一般来说，一个类定义了虚函数，则应该将该类的析构函数声明为虚函数；另外，如果一个类要被作为基类使用，则也应该将该类的析构函数声明为虚函数。\n\n\n# 纯虚函数和抽象类\n\n纯虚函数：没有函数体的虚函数，virtual void Print() = 0;\n\n抽象类：包含纯虚函数的类称为抽象类\n\n * 抽象类只能作为基类来派生新类使用，不能创建抽象类的对象\n * 抽象类的指针/引用可以用来指向/引用由抽象类派生出来的类的对象\n * 抽象类的成员函数内可以调用纯虚函数（如果能够创建抽象类的对象，而其成员函数调用了没有函数体的纯虚函数将导致程序错误），但是在其构造函数和析构函数中不能调用纯虚函数\n * 如果一个类从抽象类派生而来，那么当且仅当它实现了基类中的所有纯虚函数时，它才能成为非抽象类（类似 Java 中的接口）\n\n\n# 多态的实现原理\n\n多态的关键在于通过基类指针或基类引用调用虚函数时，编译时还不确定该语句调用的是基类函数还是派生类函数，直到运行时才能确定，这种机制也称为动态联编。\n\n\n# 虚函数表\n\n每一个有虚函数的类（或有虚函数的类的派生类）都有一个虚函数表，该类的任何对象中都放着该虚函数表的指针（可以认为这是由编译器自动添加到构造函数中的指令完成的）。虚函数表中列出了该类的虚函数地址，有虚函数的类会多出 4 个字节（64 位中是 8 个字节）用于存放虚函数表的地址。虚函数表是编译器生成的，程序运行时被载入内存。\n\n#include <iostream>\nusing namespace std;\nclass A\n{\npublic:\n    int i;\n    virtual void func() {cout << "A func" <<endl;}\n    virtual void func2() {}\n};\nclass B : public A\n{\n    int j;\n    void func() {cout << "B func" <<endl;}\n};\nint main()\n{\n    cout << sizeof(A) << ", " << sizeof(B);  // A B都多出4/8个字节存虚函数表地址\n    A* pa = new B();\n    pa->func();\n    // 64位程序指针是 8 个字节与 long long * 所占空间相同\n\tA a;\n    long long * p1 = (long long *)& a; // 取对象 a 的前 8 个字节即虚函数表地址存储位置\n    long long * p2 = (long long *) pa; \n    * p2 = * p1; // 将虚函数表地址互换\n    pa->func(); // pa 的虚函数表地址变成了 a 的\n    return 0;\n}\n\n\n上述类 A 和类 B 的内存空间占用如下图所示，首部 4 个字节用于存放该类的虚函数表地址接着再存成员变量。根据虚函数表可以更好的理解多态机制，在编译过程中，存在多态的函数语句被编译成一系列依据基类指针/基类引用所指向/引用的对象中存放的虚函数表的地址，在虚函数表中查找虚函数地址，并调用虚函数的指令。例如上述代码中第一个 pa->func(); ，pa 指向 B 的对象，则依据类 B 的虚函数表地址找到虚函数表，然后在虚函数表中找到 虚函数 B::func 的地址，最后根据地址找到并调用虚函数 B:func 的指令 。\n\n多态实例-野怪\n\n * 每个野怪类都要有 Attack(),FightBack(),Hurted() 成员函数\n * Attack() 函数表现攻击动作，攻击某个野怪，并调用被攻击野怪的 Hurted() 函数，以减少被攻击野怪的生命值，同时也调用被攻击野怪的 FightBack() 成员函数，遭受被攻击野怪反击。\n\n// 基类 Creature\nclass Creature{\n    protected:\n    \tint m_nLifeValue, m_nPower;\n    public:\n    \tvirtual void Attack(Creature* pC){}\n    \tvirtual void Hurted(int nPower){}\n    \tvirtual void FightBack(Creature* pc){}\n};\n\nclass Dragon:public Creature{\n    public:\n    \tvirtual void Attack(Creature* pC);\n    \tvirtual void Hurted(int nPower);\n    \tvirtual void FightBack(Creature* pc);    \t\n};\n\nvoid Dragon::Attack(Creature* p){\n    p->Hurted(m_nPower);\n    p->FightBack(this);\n}\nvoid Dragon::Hurted(int nPower){\n    m_nLifeValue -= nPower;\n}\nvoid Dragon::FightBack(Creature* p){\n    p->Hurted(m_nPower/2);\n}\n\nclass Wolf:public Creature{ ... };\nclass Bird:public Creature{ ... };\nclass Fish:public Creature{ ... };\n\nint main(){\n    Dragon dragon;\n    Wolf wolf;\n    Bird bird;\n    Fish fish;\n    dargon.Attack(& wolf); // 多态 调用 wolf.Hurted(); wolf.FightBack();\n    dargon.Attack(& bird); // 多态 调用 bird.Hurted(); bird.FightBack();\n    dargon.Attack(& fish); // 多态 调用 fish.Hurted(); fish.FightBack();\n    return 0;\n}\n\n\n多态实例-几何形体\n\n * 输入若干个几何形体的参数，输出根据每个几何形体的面积排序输出\n * 输入：\n   * 第一行输入指定几何形体的个数 N，接下来每一行由代表几何形体的字符开头，后面跟其计算面积的参数\n   * R 表示矩形，带宽高两个参数；C 表示圆带一个表示半径的参数；T 表示三角形，带三条边三个参数\n * 输出：根据每个几何形体的面积排序分别输出其类别和面积大小\n * 一个输入输出示例：\n\n#include <iostream>\n#include <stdlib.h>\n#include <math.h>\nusing namespace std;\n\nclass Shape{\n    public:\n        virtual double area() = 0; // 纯虚函数 Shape 无法计算面积 没有信息\n        virtual void printInfo() = 0;\n    \tvirtual ~Shape(){}; // 虚析构函数 delete pr/pc/pt; 析构完整\n};\n\nclass Rectangle:public Shape{\n    public:\n        int width, height;\n        virtual double area();\n        virtual void printInfo();\n};\n\nclass Circle:public Shape{\n    public:\n        int radius;\n        virtual double area();\n        virtual void printInfo();\n};\n\nclass Triangle:public Shape{\n    public:\n        int a, b, c;\n        virtual double area();\n        virtual void printInfo();\n};\n\ndouble Rectangle::area(){\n    return width*height;\n}\n\ndouble Circle::area(){\n    return 3.14*pow(radius,2);\n}\n\ndouble Triangle::area(){\n    double temp = (a+b+c)/2.0;\n    return sqrt(temp*(temp-a)*(temp-b)*(temp-c));\n}\n\nvoid Rectangle::printInfo(){\n    cout << "Rectangle:" << area() << endl;\n}\n\nvoid Circle::printInfo(){\n    cout << "Circle:" << area() << endl;\n}\n\nvoid Triangle::printInfo(){\n    cout << "Triangle:" << area() << endl;\n}\n\nShape* pShape[100];\nint compare(const void * s1, const void * s2){\n    Shape** p1;\n    Shape** p2; // p1 p2 都是指向指针的指针\n    p1 = (Shape**)s1; // 从 pShape 中取几何形体都是指向该几何形体 Shape* 类型 所以要用 * 号取值\n    p2 = (Shape**)s2;\n    double a1,a2;\n    a1 = (*p1)->area(); // p1 p2 是基类指针，被调用的 area() 取决与 p1 p2 指向的派生类， 所以此处是多态\n    a2 = (*p2)->area();\n    if(a1 < a2){\n        return -1;\n    }\n    else if (a2 < a1)\n    {\n        return 1;\n    }\n    else{\n        return 0;\n    }\n    \n} \n\nint main(){\n\n    int n;\n    cin >> n;\n    for(int index = 0; index < n; index++){\n        char c;\n        cin >> c;\n        switch (c)\n        {\n        case \'R\':\n            Rectangle* pr;\n            pr = new Rectangle();\n            cin >> pr->width >> pr->height;\n            pShape[index] = pr;\n            delete pr;\n            break;\n        case \'C\':\n            Circle* pc;\n            pc = new Circle();\n            cin >> pc->radius;\n            pShape[index]= pc;\n            delete pc;\n            break;\n        case \'T\':\n            Triangle* pt;\n            pt = new Triangle();\n            cin >> pt->a >> pt->b >> pt->c;\n            pShape[index] = pt;\n            delete pt;\n            break;\n        default:\n            break;\n        }\n    }\n\n    qsort(pShape,n,sizeof(Shape*),compare);\n    for(int i=0; i<n; i++){\n        pShape[i]->printInfo();\n    }\n\n    return 0;\n}\n/* Input:\n3\nR 3 5\nC 9\nT 3 4 5\n// Output:\nTriangle:6\nRectangle:15\nCircle:254.34\n*/\n\n\n\n# Reference\n\nC++虚函数表（多态的实现原理）',normalizedContent:'# c++ 多态\n\n\n# 虚函数和多态的概念\n\n虚函数：\n\n * 在类的定义中，有 virtual 关键字的成员函数就是虚函数，形如：\n   \n   class base{\n       public:\n       \tvirtual int get();  \n   };\n   int base::get(){} // virtual 关键字只需要在类内声明\n   \n   class derived:public base{\n       public:\n       \tvirtual int get();\n   };\n   int derived::get(){}\n   \n   int main(){\n       derived de;\n       base b;\n       base* p = & de;\n       base& r = de;\n       p->get(); // 多态 调用派生类虚函数\n       r.get();\n       p = & b;\n       p->get(); // 多态 调用ji类虚函数\n       return 0;\n   }\n   \n\n * virtual 关键字只用在类定义内的函数声明中使用，在类外写函数体时不用写 virtual 关键字。\n\n * 构造函数和静态成员函数不能是虚函数\n\n * 虚函数和普通函数的区别在于：虚函数能够参与多态，而普通函数不可以\n\n * 在非构造函数和非析构函数的成员函数中调用虚函数，就是多态。反之在构造函数和析构函数中调用虚函数，不是多态；因为在编译时就能确定被调用的虚函数是基类还是派生类的，不用等到运行才确定。**为什么构造函数中调用函数不是多态？**因为派生类调用构造函数期间会先调用基类构造函数，如果基类构造函数中存在多态并调用了派生类的虚函数，这时派生类还未调用构造函数进行初始化，这将导致错误的运行结果。\n\n * 在派生类中和基类中虚函数同名同参数表的函数，不加 virtual 关键字也自动成为虚函数\n\n#include <iostream>\nusing namespace std;\n\nclass base{\n    public:\n        void func1(){ func2(); } // void func1(){ this->func2(); }  this指针指向当前被调对象 多态\n        virtual void func2(){cout<< "base func2 called!"<<endl;}\n        virtual void hello(){cout<<"base hello"<<endl;}\n};\n\nclass derived:public base{\n    public:  \n        virtual void func2(){cout<< "derived func2 called!"<<endl;}\n        void hello(){cout<<"derived hello"<<endl;}\n        derived(){hello();} // 不是多态\n        ~derived(){hello();}\n};\n\nint main(){\n    derived d;\n    base* pb = &d;\n    pb->func1();\n    return 0;\n}\n\n\n多态的表现形式：\n\n * 通过基类指针调用基类和派生类中的同名虚函数时：\n   * 指针指向一个基类的对象，那么被调用的是基类的虚函数\n   * 指针指向一个派生类的对象，那么被调用的是派生类的虚函数\n * 通过基类引用调用基类和派生类中的同名虚函数时：\n   * 引用引用的是一个基类的对象，那么被调用的是基类的虚函数\n   * 引用引用的是一个派生类的对象，那么被调用的是派生类的虚函数\n\n多态的作用：\n\n在面向对象的程序设计中使用多态能够增强程序的可扩充性，即程序需要修改或增加功能的时候，避免大量代码的改动和增加。但是多态的机制会增加程序执行时在时间和空间上的开销，空间上是由于存在虚函数的类的每个对象在创建时都会多出 4 个字节的额外空间开销用于存放虚函数表的地址；时间上是由于在查虚函数表的过程中需要消耗一定的时间。\n\n虚析构函数：\n\n当通过基类指针销毁派生类对象时，通常只有基类的构造函数被调用，一般是先调用派生类析构函数，再调用基类构造函数，这就出现了析构不完整的情况。为此，可以将基类的析构函数声明为虚函数，即虚析构函数，派生类的析构函数就不需要进行虚函数声明，自动成为虚函数；这时，通过基类指针析构派生类对象时调用的就是派生类的析构函数，派生类的析构函数中会调用基类的析构函数。\n\n一般来说，一个类定义了虚函数，则应该将该类的析构函数声明为虚函数；另外，如果一个类要被作为基类使用，则也应该将该类的析构函数声明为虚函数。\n\n\n# 纯虚函数和抽象类\n\n纯虚函数：没有函数体的虚函数，virtual void print() = 0;\n\n抽象类：包含纯虚函数的类称为抽象类\n\n * 抽象类只能作为基类来派生新类使用，不能创建抽象类的对象\n * 抽象类的指针/引用可以用来指向/引用由抽象类派生出来的类的对象\n * 抽象类的成员函数内可以调用纯虚函数（如果能够创建抽象类的对象，而其成员函数调用了没有函数体的纯虚函数将导致程序错误），但是在其构造函数和析构函数中不能调用纯虚函数\n * 如果一个类从抽象类派生而来，那么当且仅当它实现了基类中的所有纯虚函数时，它才能成为非抽象类（类似 java 中的接口）\n\n\n# 多态的实现原理\n\n多态的关键在于通过基类指针或基类引用调用虚函数时，编译时还不确定该语句调用的是基类函数还是派生类函数，直到运行时才能确定，这种机制也称为动态联编。\n\n\n# 虚函数表\n\n每一个有虚函数的类（或有虚函数的类的派生类）都有一个虚函数表，该类的任何对象中都放着该虚函数表的指针（可以认为这是由编译器自动添加到构造函数中的指令完成的）。虚函数表中列出了该类的虚函数地址，有虚函数的类会多出 4 个字节（64 位中是 8 个字节）用于存放虚函数表的地址。虚函数表是编译器生成的，程序运行时被载入内存。\n\n#include <iostream>\nusing namespace std;\nclass a\n{\npublic:\n    int i;\n    virtual void func() {cout << "a func" <<endl;}\n    virtual void func2() {}\n};\nclass b : public a\n{\n    int j;\n    void func() {cout << "b func" <<endl;}\n};\nint main()\n{\n    cout << sizeof(a) << ", " << sizeof(b);  // a b都多出4/8个字节存虚函数表地址\n    a* pa = new b();\n    pa->func();\n    // 64位程序指针是 8 个字节与 long long * 所占空间相同\n\ta a;\n    long long * p1 = (long long *)& a; // 取对象 a 的前 8 个字节即虚函数表地址存储位置\n    long long * p2 = (long long *) pa; \n    * p2 = * p1; // 将虚函数表地址互换\n    pa->func(); // pa 的虚函数表地址变成了 a 的\n    return 0;\n}\n\n\n上述类 a 和类 b 的内存空间占用如下图所示，首部 4 个字节用于存放该类的虚函数表地址接着再存成员变量。根据虚函数表可以更好的理解多态机制，在编译过程中，存在多态的函数语句被编译成一系列依据基类指针/基类引用所指向/引用的对象中存放的虚函数表的地址，在虚函数表中查找虚函数地址，并调用虚函数的指令。例如上述代码中第一个 pa->func(); ，pa 指向 b 的对象，则依据类 b 的虚函数表地址找到虚函数表，然后在虚函数表中找到 虚函数 b::func 的地址，最后根据地址找到并调用虚函数 b:func 的指令 。\n\n多态实例-野怪\n\n * 每个野怪类都要有 attack(),fightback(),hurted() 成员函数\n * attack() 函数表现攻击动作，攻击某个野怪，并调用被攻击野怪的 hurted() 函数，以减少被攻击野怪的生命值，同时也调用被攻击野怪的 fightback() 成员函数，遭受被攻击野怪反击。\n\n// 基类 creature\nclass creature{\n    protected:\n    \tint m_nlifevalue, m_npower;\n    public:\n    \tvirtual void attack(creature* pc){}\n    \tvirtual void hurted(int npower){}\n    \tvirtual void fightback(creature* pc){}\n};\n\nclass dragon:public creature{\n    public:\n    \tvirtual void attack(creature* pc);\n    \tvirtual void hurted(int npower);\n    \tvirtual void fightback(creature* pc);    \t\n};\n\nvoid dragon::attack(creature* p){\n    p->hurted(m_npower);\n    p->fightback(this);\n}\nvoid dragon::hurted(int npower){\n    m_nlifevalue -= npower;\n}\nvoid dragon::fightback(creature* p){\n    p->hurted(m_npower/2);\n}\n\nclass wolf:public creature{ ... };\nclass bird:public creature{ ... };\nclass fish:public creature{ ... };\n\nint main(){\n    dragon dragon;\n    wolf wolf;\n    bird bird;\n    fish fish;\n    dargon.attack(& wolf); // 多态 调用 wolf.hurted(); wolf.fightback();\n    dargon.attack(& bird); // 多态 调用 bird.hurted(); bird.fightback();\n    dargon.attack(& fish); // 多态 调用 fish.hurted(); fish.fightback();\n    return 0;\n}\n\n\n多态实例-几何形体\n\n * 输入若干个几何形体的参数，输出根据每个几何形体的面积排序输出\n * 输入：\n   * 第一行输入指定几何形体的个数 n，接下来每一行由代表几何形体的字符开头，后面跟其计算面积的参数\n   * r 表示矩形，带宽高两个参数；c 表示圆带一个表示半径的参数；t 表示三角形，带三条边三个参数\n * 输出：根据每个几何形体的面积排序分别输出其类别和面积大小\n * 一个输入输出示例：\n\n#include <iostream>\n#include <stdlib.h>\n#include <math.h>\nusing namespace std;\n\nclass shape{\n    public:\n        virtual double area() = 0; // 纯虚函数 shape 无法计算面积 没有信息\n        virtual void printinfo() = 0;\n    \tvirtual ~shape(){}; // 虚析构函数 delete pr/pc/pt; 析构完整\n};\n\nclass rectangle:public shape{\n    public:\n        int width, height;\n        virtual double area();\n        virtual void printinfo();\n};\n\nclass circle:public shape{\n    public:\n        int radius;\n        virtual double area();\n        virtual void printinfo();\n};\n\nclass triangle:public shape{\n    public:\n        int a, b, c;\n        virtual double area();\n        virtual void printinfo();\n};\n\ndouble rectangle::area(){\n    return width*height;\n}\n\ndouble circle::area(){\n    return 3.14*pow(radius,2);\n}\n\ndouble triangle::area(){\n    double temp = (a+b+c)/2.0;\n    return sqrt(temp*(temp-a)*(temp-b)*(temp-c));\n}\n\nvoid rectangle::printinfo(){\n    cout << "rectangle:" << area() << endl;\n}\n\nvoid circle::printinfo(){\n    cout << "circle:" << area() << endl;\n}\n\nvoid triangle::printinfo(){\n    cout << "triangle:" << area() << endl;\n}\n\nshape* pshape[100];\nint compare(const void * s1, const void * s2){\n    shape** p1;\n    shape** p2; // p1 p2 都是指向指针的指针\n    p1 = (shape**)s1; // 从 pshape 中取几何形体都是指向该几何形体 shape* 类型 所以要用 * 号取值\n    p2 = (shape**)s2;\n    double a1,a2;\n    a1 = (*p1)->area(); // p1 p2 是基类指针，被调用的 area() 取决与 p1 p2 指向的派生类， 所以此处是多态\n    a2 = (*p2)->area();\n    if(a1 < a2){\n        return -1;\n    }\n    else if (a2 < a1)\n    {\n        return 1;\n    }\n    else{\n        return 0;\n    }\n    \n} \n\nint main(){\n\n    int n;\n    cin >> n;\n    for(int index = 0; index < n; index++){\n        char c;\n        cin >> c;\n        switch (c)\n        {\n        case \'r\':\n            rectangle* pr;\n            pr = new rectangle();\n            cin >> pr->width >> pr->height;\n            pshape[index] = pr;\n            delete pr;\n            break;\n        case \'c\':\n            circle* pc;\n            pc = new circle();\n            cin >> pc->radius;\n            pshape[index]= pc;\n            delete pc;\n            break;\n        case \'t\':\n            triangle* pt;\n            pt = new triangle();\n            cin >> pt->a >> pt->b >> pt->c;\n            pshape[index] = pt;\n            delete pt;\n            break;\n        default:\n            break;\n        }\n    }\n\n    qsort(pshape,n,sizeof(shape*),compare);\n    for(int i=0; i<n; i++){\n        pshape[i]->printinfo();\n    }\n\n    return 0;\n}\n/* input:\n3\nr 3 5\nc 9\nt 3 4 5\n// output:\ntriangle:6\nrectangle:15\ncircle:254.34\n*/\n\n\n\n# reference\n\nc++虚函数表（多态的实现原理）',charsets:{cjk:!0},lastUpdated:"2023/11/19, 12:55:48",lastUpdatedTimestamp:1700369748e3},{title:"运算符重载",frontmatter:{title:"运算符重载",date:"2023-11-18T15:46:10.000Z",permalink:"/pages/8176d2/"},regularPath:"/01.C&Cpp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/02.C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/01.C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/05.%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD.html",relativePath:"01.C&Cpp学习笔记/02.C++面向对象编程/01.C++面向对象/05.运算符重载.md",key:"v-85e7f1bc",path:"/pages/8176d2/",headers:[{level:2,title:"运算符重载的基本概念",slug:"运算符重载的基本概念",normalizedTitle:"运算符重载的基本概念",charIndex:12},{level:2,title:"赋值运算符重载",slug:"赋值运算符重载",normalizedTitle:"赋值运算符重载",charIndex:1408},{level:2,title:"流插入流提取运算符重载",slug:"流插入流提取运算符重载",normalizedTitle:"流插入流提取运算符重载",charIndex:3001},{level:2,title:"重载类型转换运算符",slug:"重载类型转换运算符",normalizedTitle:"重载类型转换运算符",charIndex:4664},{level:2,title:"自增自减运算符重载",slug:"自增自减运算符重载",normalizedTitle:"自增自减运算符重载",charIndex:5144},{level:2,title:"Reference",slug:"reference",normalizedTitle:"reference",charIndex:6156}],headersStr:"运算符重载的基本概念 赋值运算符重载 流插入流提取运算符重载 重载类型转换运算符 自增自减运算符重载 Reference",content:'# 运算符重载\n\n\n# 运算符重载的基本概念\n\n运算符重载的应用场景：运算符重载的需求是在对象运算中体现的，C++ 中希望通过对运算符的重载扩展运算符的适用范围，使对象也能通过运算符进行运算，这样可以使代码更加简洁和易理解。\n\n运算符重载的形式：\n\n// ReturnType:返回值类型; OperatorType:运算符类型; ParamList:形参表\nReturnType operator OperatorType(ParamList)\n{\n    Function Body;\n}\n\n\n * 运算符重载实际上是函数重载：\n   \n   * 重载为成员函数，参数个数为运算符目数减一（被对象调用，对象作为一个被操作数）\n   * 重载为普通函数，参数个数为运算符目数\n\n * 运算符被多次重载时根据实参的类型决定函数的调用\n\n * 对运算符的重载，应该尽可能保持运算符原始的运算特性仅仅扩展其可操作的数据对象\n   \n   运算符重载示例如下：\n\nclass Complex{\n    private:\n    \tdouble real,img;\n    public:\n    \tComplex(double r=0.0, double i=0.0):real(r),img(i){}\n    \t~Complex(){}\n    \tComplex operator-(const Complex & c);\n    \tfriend Complex operator+(const Complex & c1, const Complex & c2);\n    \tfriend Complex operator+(double r,const Complex & c);\n};\n// 运算符重载为成员函数\nComplex Complex::operator-(const Complex & c){\n    return Complex(real-c.real,img-c.img); // 返回一个无名临时对象\n}\n\n// 运算符重载为普通函数\nComplex operator+(const Complex & c1, const Complex & c2){\n    return Complex(c1.real+c2.real, c1.img+c2.img); // 返回一个无名临时对象\n}\ne\n// 被声明为友元函数，可以访问私有成员\nComplex operator+(double r,const Complex & c){\n    return Complex(real+r,img+c.img);\n}\n\n\nint main()\n{\n    Complex a(3,3),b(2,2),c,d;\n    c = a + b; // operator+(a,b)\n    cout<<c.real<<\',\'<<c.img<<endl;\n    d = 5 + a; // operator+(5,a)\n    cout<<d.real<<\',\'<<d.img<<endl;\n    cout<<(a-b).real<<\',\'<<(a-b).img<<endl; // a.operator-(b)\n    return 0;\n}\n/* output:\n5,5\n8,3\n1,1\n*/\n\n\n\n# 赋值运算符重载\n\n赋值运算符的应用场景：对赋值运算符重载实现 = 两边的类型可以不匹配，值得注意的是，赋值运算符 = 只能被重载为成员函数\n\nclass String{\n    private:\n    \tchar * str;\n    public:\n    \tString():str(new char[1]){str[0] = 0;}\n    \t~String(){delete [] str;}\n    \tconst char * c_str(){return str;}\n    \tString & operator=(const char * s);\n};\n\n// 重载赋值运算符使得 String s; s = "hello"; 能够成立\nString & String::operator=(const char * s){\n    delete [] str; // 先清空当前对象的 str\n    str = new char[strlen(s)+1]; // 申请能够存储字符串 s 的空间 \n    strcpy(str,s);\n    return * this;\n}\n\nint main(){\n    String s;\n    s = "hello, world"; // 调用 s.operator=("hello,world")\n    // String s2 = "hello"; 这里的等号是初始化不是赋值，会调用构造函数进行初始化，等价于 String s2("hello"); 如果没有定义这样的构造函数会导致程序出错\n    return 0;\n}\n\n\n赋值中的浅拷贝和深拷贝: 拷贝构造函数：深拷贝与浅拷贝\n\n看如下示例，使用默认的赋值运算符 S1 = S2;，使用类中默认的赋值运算符，会将对象中的所有位于 stack 中的域进行相应的复制操作；同时，如果对象有位于 heap 上的域，则不会为目标对象分配 heap 上的空间，而只是让目标对象指向源对象 heap 上的同一个地址如下图所示。由于源对象和目标对象都指向 heap 的同一段内容，所以在对象调用析构函数的时候，就会连续两次释放 heap 上的那一块内存区域，从而导致程序异常。\n\n另外，如果执行 S1 = "other" ，根据上面的赋值运算符重载方法 S1 会指向新 new 的空间，同时将原始空间 delete 掉，这将导致赋值后的 S2 指向了一个已经被 delete 的空间导致程序存在隐患。为此对上述赋值运算符重载方法进行改进，添加一个处理用对象赋值的成员函数，并避免s=s;语句导致出错增加判断语句。\n\nString & String::operator=(const String & s){\n    if(this == &s){\n        return * this;\n    }\n    delete [] str;\n    str = new char[strlen(s.str) + 1];\n    strcpy(str,s.str);\n    return * this;\n}\n\n\n值得注意的是，赋值运算符重载的返回值是DataType & 引用，这样可以保持赋值运算符传递的运算特点 a = b = c; 等价于 a.operator=(b.operator=(c));\n\n拷贝构造函数的需要：和类中的默认赋值运算符一样，其默认的拷贝构造函数也存在同样的浅拷贝和深拷贝问题，为了避免浅拷贝导致指向同一空间的问题，使用同样的方法自定义拷贝构造函数。\n\nString(const String & s){\n    str = new char[strlen(s.str)+1];\n    strcpy(str,s.str);\n}\n\n\n\n# 流插入流提取运算符重载\n\n流插入运算符重载：cout 是在 iostream 中定义的 ostream 类的对象，<< 能够作为流插入是在 iostream 中进行了重载，为了能够让 << 能够连续插入形如 cout << 5 << "this" 重载函数的返回值是 ostream & 类型。\n\n// << 重载可以如下形式\nostream & operator<<(int n){\n    // ... 输出代码块\n    return * this;\n}\nostream & operator<<(const char * s){\n    // ... 输出代码块\n    return * this;\n}\n\n\n当 << 的操作数是对象时，需要对其进行重载，但是又不能重载成成员函数，因为cout 已经被定义在 iostream 头文件中，所以只能重载为普通函数，示例如下：\n\nclass Student{\n    public:\n    \tint age;\n};\n\nostream & operator<<(ostream & o, const Student & s){\n    o<<s.age;\n    return o;\n}\n\nint main(){\n    Student s;\n    s.age = 5;\n    cout<<s<<"years old"<<endl;\n    return 0;\n}\n\n\n流提取运算符重载：cin 是在 iostream 中定义的 istream 类的对象，>> 能够作为流提取是在 iostream 中进行了重载，为了能够让 >> 能够连续提取内容重载函数的返回值是 istream & 类型。\n\n流插入流提取运算符重载示例：c 是 Complex复数类的对象，现在希望让 cout<<c; 能够输出 c 的a+bi 的值，让 cin>>c; 能够从接盘接受 a+bi的输入，其中 c.real = a; c.img = b;\n\nclass Complex{\n    private:\n    \tdouble real,img;\n    public:\n    \tComplex(double r=0.0, double i=0.0):real(r),img(i){}\n    \tfriend ostream & operator<<(ostream & os, const Complex & c);\n    \tfriend istream & operator>>(istream & is, const Complex & c);\n};\n\nostream & operator<<(ostream & os, const Complex & c){\n    os<<c.real<<\'+\'<<c.img<<\'i\';\n    return os;\n}\n\nistream & operator>>(istream & is, Complex & c){\n    string s;\n    is >> s; // 将"a+bi"作为字符串读入，"a+bi"中间不能有空格\n    int pos = s.find(\'+\',0);\n    string sTmp = s.substr(0,pos); // 分离出实部的字符串\n    c.real = atof(sTmp.c_str()); // atof库函数能将const char*指针指向的内容转换为float\n    sTmp = s.substr(pos+1,s.length()-pos-2);\n    c.imag = atof(sTmp.c_str());\n    return is;\n}\n\nint main(){\n    Complex c;\n    int n;\n    cin >> c >> n;\n    cout << c <<\',\'<<n;\n    return 0;\n}\n\n\n\n# 重载类型转换运算符\n\n类型转换运算符重载：将对象转换为 int float double 等类型，一旦类中定义了类型转换运算符重载，在类型转换运算符出现处的对象都会被调用类型转换运算符重载函数进行类型转换。值得注意的是，类型转换运算符重载函数和构造函数相似没有返回值类型。\n\nclass Complex{\n    private:\n    \tdouble real,img;\n    public:\n    \tComplex(double r=0.0,double i=0.0):real(r),img(i){}\n    \toperator double(){return real;}\n};\n\nint main(){\n    Complex c(1.2,3.2);\n    cout<<(double)c<<endl;\n    double n = 2 + c; // 相当于 n = 2 + c.operator double()\n    cout<<n<<endl;\n    return 0;\n}\n/* output:\n1.2\n3.2\n*/\n\n\n\n# 自增自减运算符重载\n\n前置后置运算符的区分：\n\n自增 ++ 和自减 -- 运算符有前置和后置之分，为了区分前置和后置运算符，C++ 规定：\n\n * 前置运算符作为一元运算符重载：\n   * 重载为成员函数 DataType & operator++/--();\n   * 重载为普通函数 DataType1 & operator++/--(DataType2);\n * 后置运算符作为二元运算符重载，多写一个没用的参数：\n   * 重载为成员函数 DataType operator++/--(int);\n   * 重载为普通函数 DataType1 operator++/--(DataType2,int);\n\n值得注意的是前置运算符重载函数的返回值类型是引用，而后置运算符重载函数的对象，++a = 1; 是成立的，然而 a++ = 1;是错误的后置返回的是临时对象。不用产生临时对象的前置运算符的效率在一定程度上优于后置运算符，为此在不影响结果的情况下，尽量使用前置运算符。\n\nclass Sample{\nprivate:\n    int n;\npublic:\n    Sample(int i=0):n(i){}\n    Sample & operator++();\n    Sample operator++(int);\n    friend Sample & operator--(Sample & s);\n    friend Sample operator--(Sample & s, int);\n    operator int(){return n;}\n};\n\nSample & Sample::operator++(){\n    ++n;\n    return * this;\n}\n\nSample::Sample operator++(int k){\n    Sample tmp(*this); // 记录修改前的对象\n    n++;\n    return tmp; // 返回修改后的对象\n}\n\nSample & operator--(Sample & s){\n    s.n--;\n    return s;\n}\n\nSample operator--(Sample & s, int){\n    Sample tmp(s);\n    s.n--;\n    return tmp;\n}\n\n\n\n# Reference\n\nC++类对象的赋值与复制',normalizedContent:'# 运算符重载\n\n\n# 运算符重载的基本概念\n\n运算符重载的应用场景：运算符重载的需求是在对象运算中体现的，c++ 中希望通过对运算符的重载扩展运算符的适用范围，使对象也能通过运算符进行运算，这样可以使代码更加简洁和易理解。\n\n运算符重载的形式：\n\n// returntype:返回值类型; operatortype:运算符类型; paramlist:形参表\nreturntype operator operatortype(paramlist)\n{\n    function body;\n}\n\n\n * 运算符重载实际上是函数重载：\n   \n   * 重载为成员函数，参数个数为运算符目数减一（被对象调用，对象作为一个被操作数）\n   * 重载为普通函数，参数个数为运算符目数\n\n * 运算符被多次重载时根据实参的类型决定函数的调用\n\n * 对运算符的重载，应该尽可能保持运算符原始的运算特性仅仅扩展其可操作的数据对象\n   \n   运算符重载示例如下：\n\nclass complex{\n    private:\n    \tdouble real,img;\n    public:\n    \tcomplex(double r=0.0, double i=0.0):real(r),img(i){}\n    \t~complex(){}\n    \tcomplex operator-(const complex & c);\n    \tfriend complex operator+(const complex & c1, const complex & c2);\n    \tfriend complex operator+(double r,const complex & c);\n};\n// 运算符重载为成员函数\ncomplex complex::operator-(const complex & c){\n    return complex(real-c.real,img-c.img); // 返回一个无名临时对象\n}\n\n// 运算符重载为普通函数\ncomplex operator+(const complex & c1, const complex & c2){\n    return complex(c1.real+c2.real, c1.img+c2.img); // 返回一个无名临时对象\n}\ne\n// 被声明为友元函数，可以访问私有成员\ncomplex operator+(double r,const complex & c){\n    return complex(real+r,img+c.img);\n}\n\n\nint main()\n{\n    complex a(3,3),b(2,2),c,d;\n    c = a + b; // operator+(a,b)\n    cout<<c.real<<\',\'<<c.img<<endl;\n    d = 5 + a; // operator+(5,a)\n    cout<<d.real<<\',\'<<d.img<<endl;\n    cout<<(a-b).real<<\',\'<<(a-b).img<<endl; // a.operator-(b)\n    return 0;\n}\n/* output:\n5,5\n8,3\n1,1\n*/\n\n\n\n# 赋值运算符重载\n\n赋值运算符的应用场景：对赋值运算符重载实现 = 两边的类型可以不匹配，值得注意的是，赋值运算符 = 只能被重载为成员函数\n\nclass string{\n    private:\n    \tchar * str;\n    public:\n    \tstring():str(new char[1]){str[0] = 0;}\n    \t~string(){delete [] str;}\n    \tconst char * c_str(){return str;}\n    \tstring & operator=(const char * s);\n};\n\n// 重载赋值运算符使得 string s; s = "hello"; 能够成立\nstring & string::operator=(const char * s){\n    delete [] str; // 先清空当前对象的 str\n    str = new char[strlen(s)+1]; // 申请能够存储字符串 s 的空间 \n    strcpy(str,s);\n    return * this;\n}\n\nint main(){\n    string s;\n    s = "hello, world"; // 调用 s.operator=("hello,world")\n    // string s2 = "hello"; 这里的等号是初始化不是赋值，会调用构造函数进行初始化，等价于 string s2("hello"); 如果没有定义这样的构造函数会导致程序出错\n    return 0;\n}\n\n\n赋值中的浅拷贝和深拷贝: 拷贝构造函数：深拷贝与浅拷贝\n\n看如下示例，使用默认的赋值运算符 s1 = s2;，使用类中默认的赋值运算符，会将对象中的所有位于 stack 中的域进行相应的复制操作；同时，如果对象有位于 heap 上的域，则不会为目标对象分配 heap 上的空间，而只是让目标对象指向源对象 heap 上的同一个地址如下图所示。由于源对象和目标对象都指向 heap 的同一段内容，所以在对象调用析构函数的时候，就会连续两次释放 heap 上的那一块内存区域，从而导致程序异常。\n\n另外，如果执行 s1 = "other" ，根据上面的赋值运算符重载方法 s1 会指向新 new 的空间，同时将原始空间 delete 掉，这将导致赋值后的 s2 指向了一个已经被 delete 的空间导致程序存在隐患。为此对上述赋值运算符重载方法进行改进，添加一个处理用对象赋值的成员函数，并避免s=s;语句导致出错增加判断语句。\n\nstring & string::operator=(const string & s){\n    if(this == &s){\n        return * this;\n    }\n    delete [] str;\n    str = new char[strlen(s.str) + 1];\n    strcpy(str,s.str);\n    return * this;\n}\n\n\n值得注意的是，赋值运算符重载的返回值是datatype & 引用，这样可以保持赋值运算符传递的运算特点 a = b = c; 等价于 a.operator=(b.operator=(c));\n\n拷贝构造函数的需要：和类中的默认赋值运算符一样，其默认的拷贝构造函数也存在同样的浅拷贝和深拷贝问题，为了避免浅拷贝导致指向同一空间的问题，使用同样的方法自定义拷贝构造函数。\n\nstring(const string & s){\n    str = new char[strlen(s.str)+1];\n    strcpy(str,s.str);\n}\n\n\n\n# 流插入流提取运算符重载\n\n流插入运算符重载：cout 是在 iostream 中定义的 ostream 类的对象，<< 能够作为流插入是在 iostream 中进行了重载，为了能够让 << 能够连续插入形如 cout << 5 << "this" 重载函数的返回值是 ostream & 类型。\n\n// << 重载可以如下形式\nostream & operator<<(int n){\n    // ... 输出代码块\n    return * this;\n}\nostream & operator<<(const char * s){\n    // ... 输出代码块\n    return * this;\n}\n\n\n当 << 的操作数是对象时，需要对其进行重载，但是又不能重载成成员函数，因为cout 已经被定义在 iostream 头文件中，所以只能重载为普通函数，示例如下：\n\nclass student{\n    public:\n    \tint age;\n};\n\nostream & operator<<(ostream & o, const student & s){\n    o<<s.age;\n    return o;\n}\n\nint main(){\n    student s;\n    s.age = 5;\n    cout<<s<<"years old"<<endl;\n    return 0;\n}\n\n\n流提取运算符重载：cin 是在 iostream 中定义的 istream 类的对象，>> 能够作为流提取是在 iostream 中进行了重载，为了能够让 >> 能够连续提取内容重载函数的返回值是 istream & 类型。\n\n流插入流提取运算符重载示例：c 是 complex复数类的对象，现在希望让 cout<<c; 能够输出 c 的a+bi 的值，让 cin>>c; 能够从接盘接受 a+bi的输入，其中 c.real = a; c.img = b;\n\nclass complex{\n    private:\n    \tdouble real,img;\n    public:\n    \tcomplex(double r=0.0, double i=0.0):real(r),img(i){}\n    \tfriend ostream & operator<<(ostream & os, const complex & c);\n    \tfriend istream & operator>>(istream & is, const complex & c);\n};\n\nostream & operator<<(ostream & os, const complex & c){\n    os<<c.real<<\'+\'<<c.img<<\'i\';\n    return os;\n}\n\nistream & operator>>(istream & is, complex & c){\n    string s;\n    is >> s; // 将"a+bi"作为字符串读入，"a+bi"中间不能有空格\n    int pos = s.find(\'+\',0);\n    string stmp = s.substr(0,pos); // 分离出实部的字符串\n    c.real = atof(stmp.c_str()); // atof库函数能将const char*指针指向的内容转换为float\n    stmp = s.substr(pos+1,s.length()-pos-2);\n    c.imag = atof(stmp.c_str());\n    return is;\n}\n\nint main(){\n    complex c;\n    int n;\n    cin >> c >> n;\n    cout << c <<\',\'<<n;\n    return 0;\n}\n\n\n\n# 重载类型转换运算符\n\n类型转换运算符重载：将对象转换为 int float double 等类型，一旦类中定义了类型转换运算符重载，在类型转换运算符出现处的对象都会被调用类型转换运算符重载函数进行类型转换。值得注意的是，类型转换运算符重载函数和构造函数相似没有返回值类型。\n\nclass complex{\n    private:\n    \tdouble real,img;\n    public:\n    \tcomplex(double r=0.0,double i=0.0):real(r),img(i){}\n    \toperator double(){return real;}\n};\n\nint main(){\n    complex c(1.2,3.2);\n    cout<<(double)c<<endl;\n    double n = 2 + c; // 相当于 n = 2 + c.operator double()\n    cout<<n<<endl;\n    return 0;\n}\n/* output:\n1.2\n3.2\n*/\n\n\n\n# 自增自减运算符重载\n\n前置后置运算符的区分：\n\n自增 ++ 和自减 -- 运算符有前置和后置之分，为了区分前置和后置运算符，c++ 规定：\n\n * 前置运算符作为一元运算符重载：\n   * 重载为成员函数 datatype & operator++/--();\n   * 重载为普通函数 datatype1 & operator++/--(datatype2);\n * 后置运算符作为二元运算符重载，多写一个没用的参数：\n   * 重载为成员函数 datatype operator++/--(int);\n   * 重载为普通函数 datatype1 operator++/--(datatype2,int);\n\n值得注意的是前置运算符重载函数的返回值类型是引用，而后置运算符重载函数的对象，++a = 1; 是成立的，然而 a++ = 1;是错误的后置返回的是临时对象。不用产生临时对象的前置运算符的效率在一定程度上优于后置运算符，为此在不影响结果的情况下，尽量使用前置运算符。\n\nclass sample{\nprivate:\n    int n;\npublic:\n    sample(int i=0):n(i){}\n    sample & operator++();\n    sample operator++(int);\n    friend sample & operator--(sample & s);\n    friend sample operator--(sample & s, int);\n    operator int(){return n;}\n};\n\nsample & sample::operator++(){\n    ++n;\n    return * this;\n}\n\nsample::sample operator++(int k){\n    sample tmp(*this); // 记录修改前的对象\n    n++;\n    return tmp; // 返回修改后的对象\n}\n\nsample & operator--(sample & s){\n    s.n--;\n    return s;\n}\n\nsample operator--(sample & s, int){\n    sample tmp(s);\n    s.n--;\n    return tmp;\n}\n\n\n\n# reference\n\nc++类对象的赋值与复制',charsets:{cjk:!0},lastUpdated:"2023/11/19, 12:55:48",lastUpdatedTimestamp:1700369748e3},{title:"C++ 类和对象提高",frontmatter:{title:"C++ 类和对象提高",date:"2023-11-18T15:46:10.000Z",permalink:"/pages/bbcad6/"},regularPath:"/01.C&Cpp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/02.C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/01.C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/04.C++%20%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%E6%8F%90%E9%AB%98.html",relativePath:"01.C&Cpp学习笔记/02.C++面向对象编程/01.C++面向对象/04.C++ 类和对象提高.md",key:"v-fa4616d8",path:"/pages/bbcad6/",headers:[{level:2,title:"this 指针",slug:"this-指针",normalizedTitle:"this 指针",charIndex:17},{level:2,title:"类中的静态成员",slug:"类中的静态成员",normalizedTitle:"类中的静态成员",charIndex:2256},{level:2,title:"成员对象和封闭类",slug:"成员对象和封闭类",normalizedTitle:"成员对象和封闭类",charIndex:4261},{level:2,title:"友元",slug:"友元",normalizedTitle:"友元",charIndex:5987},{level:2,title:"Reference",slug:"reference",normalizedTitle:"reference",charIndex:6624}],headersStr:"this 指针 类中的静态成员 成员对象和封闭类 友元 Reference",content:'# C++ 类和对象提高\n\n\n# this 指针\n\nthis 指针的概念：是一个隐含于每一个非静态成员函数中的特殊指针，其作用就是指向调用该成员函数的那个对象。换言之，非静态成员函数中可以直接使用 this 来代表指向该函数作用的对象的指针。\n\nclass Complex{\n    public:\n    \tdouble real, img;\n    \tPrint(){cout<<real<<" , "<<img<<endl;}\n    \tComplex(double r, double i){real = r; img = i;}\n    \tComplex addOne(){\n            // this 指针的使用\n            this->real++;\n            this->Print();\n            return * this;\n        }\n};\n\nint main(){\n    Complex c1(0,0), c2(4,4);\n    c1.Print();\n    c1 = c2.addOne(); // c2.real加一之后赋值给c1\n    return 0;\n}\n/* output:\n0 , 0\n5 , 4\n*/\n\n\nC++ 程序到 C 程序的翻译：C++ 程序的最原始的编译过程可以看作是先将 C++ 程序翻译成 C 程序，然后再使用 C 程序的编译器进行编译。下面是一个 C++ 程序翻译到 C 程序的示例：\n\nclass Car{\n    public:\n    \tint price;\n    \tvoid setPrice(int p);\n};\nvoid Car::setPrice(int p){\n    price = p;\n}\n\nint main(){\n    Car car;\n    car.setPrice(20000);\n    return 0;\n}\n\n\n上述 C++ 程序翻译成 C 程序如下：\n\nstruct Car{\n    int price;\n    // C 结构体中无法定义成员函数\n};\nvoid setPrice(struct Car* this, int p){\n    this->price = p; // 多一个参数用 this 指针指向 car 对象修改其 price 属性\n}\n\nint main(){\n    struct Car car;\n    setPrice(& car, 20000); // 传 car 对象的地址和 price 修改值\n    return 0;\n}\n\n\n更好的理解 this 指针的作用：当对一个对象调用成员函数时，编译程序先将对象的地址赋给 this 指针，然后调用成员函数，每次成员函数存取数据成员时，都隐式使用 this 指针。\n\nclass Sample{\n    private:\n    \tint x;\n    public:\n    \tvoid hello(){cout << "hello" << endl;}\n    \tvoid xHello(){cout << x << ", hello" << endl;}\n};\n\nint main(){\n    Sample* p1 = null;\n    Sample* p2 = null;\n    p1->hello(); // success\n    /*\n    p1->hello(); 能够成功运行，调用过程可以看作如下：\n    \tp1->hello(); => hello(p1); => hello(null);\n    \tvoid hello(){cout<<"hello"<<endl;} => void hello(Sample* this){cout<<"hello"<<endl;} => void hello(null){cout<<"hello"<<endl;}\n    */\n    \n    p2->xHello(); // error\n    /*\n    p2->xHello(); 运行错误\n    \tp2->xHello(); => p2->xHello(p1); => p2->xHello(null);\n    \tvoid xHello(){cout << x << ", hello" << endl;} => void xHello(Sample* this){cout << this.x << ", hello" << endl;} => void xHello(null){cout << null.x << ", hello" << endl;}\n    */\n    return 0;\n}\n\n\nthis 指针的特点：\n\n * this 并不是一个常规变量，而是个右值，所以不能取得 this 的地址（不能 &this）\n * 静态成员函数中不能使用 this 指针，因为静态成员函数是类的对象公共的，并不具体作用于某个对象；因此当静态成员函数被调用时，编译程序不会在其参数中添加 this 指针，即其真实参数个数不会改变。\n * 在一些场景中需要显示的引用 this 指针\n   * 为实现对象的链式引用\n   * 为避免对同一对象进行赋值操作\n   * 在实现一些数据结构时，例如 list\n\n\n# 类中的静态成员\n\nstatic 关键字：\n\n * 修饰普通变量，修改变量的存储区域和生命周期，使变量存储在静态区，在 main 函数运行前就分配了空间，如果有初始值就用初始值初始化它，如果没有初始值系统用默认值初始化它。\n\n * 修饰普通函数，表明函数的作用范围，仅在定义该函数的文件内才能使用。在多人开发项目时，为了防止与他人命名空间里的函数重名，可以将函数定位为 static。\n\n * 修饰类的成员变量，修饰成员变量使所有的对象都共享一个该变量，而且不需要生成对象就可以访问该成员。在类中，sizeof 运算符不会计算静态成员变量所占用的空间，例如：\n   \n   class Sample{\n       private:\n       \tint a;\n       \tstatic int b;\n   };\n   // sizeof(Sample) 的结果是 4 而不是 8\n   \n\n * 修饰类的成员函数，修饰成员函数使得不需要生成对象就可以访问该函数，但是在 static 函数内不能访问非静态成员。\n\n静态成员：普通成员变量每个对象都有各自的一份，而静态成员变量总共只有一份，所有对象共享；普通成员函数必须具体作用于某个对象，而静态成员函数并不具体作用于某个对象；静态成员不需要通过对象就能访问。静态成员有如下四种访问方式：\n\n * 类名 :: 成员名 Rectangle::PrintTotal();\n * 对象名 . 成员名 Rectangle r; r.PrintTotal(); 对象可以访问静态成员，但不具体作用于该对象\n * 指针 -> 成员名 Rectangle* p = &r; p->PrintTotal();\n * 引用 . 成员名 Rectangle& ref = r; ref.PrintTotal();\n\n静态成员变量本质上是全局变量，静态成员函数本质上也是全局函数。设置静态成员这种机制的目的在于：将和某些类紧密相关的全局变量和全局函数写到类内，这样使得这些全局变量和函数更加易于维护和理解。\n\n静态成员的一个应用示例：随时输出矩形总数和总共面积\n\nclass Rectangle{\n    private:\n    \tint width, height;\n    \tstatic int totalNumber;\n    \tstatic int totalArea;\n    public:\n    \tRectangle(int w, int h);\n    \tRectangle(const Rectangle & r); // 如果不定义拷贝构造函数，在拷贝对象的过程中没有修改 totalNumber 和 totalArea, 但是析构函数却修改了，这将导致最终总数变小\n    \t~Rectangle();\n    \tstatic void printTotal();\n};\n\nRectangle::Rectangle(int w, int h){\n    width = w;\n    height = h;\n    totalNumber++;\n    totalArea += width*height;\n}\n\nRectangle::Rectangle(const Rectangle &r){\n    width = r.width;\n    height = r.height;\n    totalNumber++;\n    totalArea += width*height;\n}\n\nRectangle::~Rectangle(){\n    totalNumber--;\n    totalArea -= width*height;\n}\n\nvoid Rectangle::printTotal(){\n    cout<< totalNumber << " , " << totalArea << endl;\n}\n\n// 必须在定义类的文件中对静态成员变量进行一次说明或初始化，否则能通过编译，但是无法链接\nint Rectangle::totalNumber = 0;\nint Rectangle::totalArea = 0;\n\nint main(){\n    Rectangle r1(1,2), r2(2,4);\n    cout << Rectangle::totalNumber << endl; // 会执行出错，因为类中定义 totalNumber是私有的\n    Rectangle::printTotal();\n    return 0;\n}\n\n\n需要注意的是，在静态成员函数中，不能访问非静态成员变量，也不能调用非静态成员函数，因为非静态成员变量是有对象所属的，而静态成员不特定属于某个对象，这将导致访问的歧义。\n\n\n# 成员对象和封闭类\n\n成员对象：一个类的成员变量如果是另一个类的对象，就称之为成员对象\n\n封闭类：有成员对象的类叫封闭类，例如：\n\nclass Tyre{\n    private:\n    \tint radius;\n    \tint width;\n    public:\n    \tTyre(int r, int w):radius(r), width(w){cout << "Tyre constructor called" <<endl;}\n    \t~Tyre(){cout<<"Tyre destructor called"<<endl;}\n};\n\nclass Engine{\n  \tpublic:\n    \tEngine(){cout<<"Engine constructor called"<<endl;}\n    \t~Engine(){cout<<"Engine destructor called"<<endl;}\n};\n\n// Car 封闭类\nclass Car{\n    private:\n    \t// 声明次序决定了初始化顺序，与初始化列表次序无关\n    \tint price;\n    \tEngine engine;\n    \tTyre tyre;\n    public:\n    \tCar(int p, int tr, int tw){}\n    \t~Car(){cout<<"Car destructor called"<<endl;}\n};\n\n// 使用初始化列表初始化封闭类：任何生成封闭类对象的语句，都要让编译器明白对象中的成员对象是如何初始化的\nCar::Car(int p, int tr, int tw):price(p), tyre(tr,tw){\n    cout<<"Car constructor called"<<endl;\n}\n\nint main(){\n    Car car(2000,125,400);\n    return 0;\n}\n/* output:\nEngine constructor called\nTyre constructor called\nCar constructor called\nCar destructor called\nTyre destructor called\nEngine destructor called\n*/\n\n\n初始化列表：\n\n当封闭类的对象生成并初始化时，它包含的成员对象也需要被初始化，这就会引发成员对象构造函数的调用。通过在定义封闭类的构造函数时，添加初始化列表的方式，让编译器明白成员对象初始化时调用的构造函数。初始化列表的写法类名::构造函数名(参数表):成员变量1(参数表), 成员变量2(参数表),.....{函数体}。\n\n初始化列表中的成员变量既可以是成员对象，也可以是基本类型的成员变量。对于成员对象，初始化列表的参数表中存放的是构造函数的参数（它指明了该成员对象如何初始化）。对于基本类型成员变量，参数表中就是一个初始值。\n\n封闭类的构造函数和析构函数的执行顺序：\n\n * 封闭类对象生成时，先执行所有对象成员的构造函数，然后才执行封闭类的构造函数。\n * 对象成员的构造函数调用次序和对象成员在类中的说明次序一致，与它们在成员初始化列表中出现的次序无关。\n * 当封闭类消亡时，先执行封闭类的析构函数，然后再执行对象的析构函数。调用次序和构造函数的调用次序相反。\n\n封闭类的拷贝构造函数：成员对象的拷贝调用该对象的拷贝构造函数\n\nclass A{\n    public:\n    \tA(){cout<<"default"<<endl;}\n    \tA(const A & a){cout<<"copy"<<endl;}\n};\nclass B{\n    private:\n    \tA a;\n};\nint mian(){\n    B b1;\n    B b2(b1);\n    return 0;\n}\n\n/* output:\ndefault\ncopy\n// b2.a使用类A的拷贝构造函数初始化的，其实参是b1.a\n*/\n\n\n\n# 友元\n\n友元函数：一个类的友元函数可以访问该类的私有成员\n\nclass A{\n    private:\n    \tint a_x;\n    public:\n    \tA(int x){a_x=x;}\n    \tfriend void addOne(A a);\n};\n\nvoid addOne(A a){\n    a.a_x++; // 友元函数可以直接访问类的私有成员\n}\n\nint main(){\n    A a(1);\n    addOne(a);\n    return 0;\n}\n\n\n友元类：友元类的成员函数都可以访问该类的私有成员\n\nclass A{\n    private:\n    \tint a_x;\n    \tfriend class B; // 友元类可以直接访问该类的私有成员\n    public:\n    \tA(int n){a_x = n;}\n};\n\nclass B{\n    public:\n    \tA a;\n    \tB(int ax):a(ax){}\n    \tvoid addOne();\n};\n\nvoid B::addOne(){\n    a.a_x++;\n}\n\nint main(){\n    B b(1);\n    b.addOne();\n    return 0;\n}\n\n\n友元的特点：\n\n * 能访问私有成员\n * 破坏封装性\n * 友元关系不可传递，不可继承\n * 友元关系的单向性\n * 友元声明的形式及数量不受限制\n\n\n# Reference\n\nC/C++\n\nC++成员对象和封闭类详解',normalizedContent:'# c++ 类和对象提高\n\n\n# this 指针\n\nthis 指针的概念：是一个隐含于每一个非静态成员函数中的特殊指针，其作用就是指向调用该成员函数的那个对象。换言之，非静态成员函数中可以直接使用 this 来代表指向该函数作用的对象的指针。\n\nclass complex{\n    public:\n    \tdouble real, img;\n    \tprint(){cout<<real<<" , "<<img<<endl;}\n    \tcomplex(double r, double i){real = r; img = i;}\n    \tcomplex addone(){\n            // this 指针的使用\n            this->real++;\n            this->print();\n            return * this;\n        }\n};\n\nint main(){\n    complex c1(0,0), c2(4,4);\n    c1.print();\n    c1 = c2.addone(); // c2.real加一之后赋值给c1\n    return 0;\n}\n/* output:\n0 , 0\n5 , 4\n*/\n\n\nc++ 程序到 c 程序的翻译：c++ 程序的最原始的编译过程可以看作是先将 c++ 程序翻译成 c 程序，然后再使用 c 程序的编译器进行编译。下面是一个 c++ 程序翻译到 c 程序的示例：\n\nclass car{\n    public:\n    \tint price;\n    \tvoid setprice(int p);\n};\nvoid car::setprice(int p){\n    price = p;\n}\n\nint main(){\n    car car;\n    car.setprice(20000);\n    return 0;\n}\n\n\n上述 c++ 程序翻译成 c 程序如下：\n\nstruct car{\n    int price;\n    // c 结构体中无法定义成员函数\n};\nvoid setprice(struct car* this, int p){\n    this->price = p; // 多一个参数用 this 指针指向 car 对象修改其 price 属性\n}\n\nint main(){\n    struct car car;\n    setprice(& car, 20000); // 传 car 对象的地址和 price 修改值\n    return 0;\n}\n\n\n更好的理解 this 指针的作用：当对一个对象调用成员函数时，编译程序先将对象的地址赋给 this 指针，然后调用成员函数，每次成员函数存取数据成员时，都隐式使用 this 指针。\n\nclass sample{\n    private:\n    \tint x;\n    public:\n    \tvoid hello(){cout << "hello" << endl;}\n    \tvoid xhello(){cout << x << ", hello" << endl;}\n};\n\nint main(){\n    sample* p1 = null;\n    sample* p2 = null;\n    p1->hello(); // success\n    /*\n    p1->hello(); 能够成功运行，调用过程可以看作如下：\n    \tp1->hello(); => hello(p1); => hello(null);\n    \tvoid hello(){cout<<"hello"<<endl;} => void hello(sample* this){cout<<"hello"<<endl;} => void hello(null){cout<<"hello"<<endl;}\n    */\n    \n    p2->xhello(); // error\n    /*\n    p2->xhello(); 运行错误\n    \tp2->xhello(); => p2->xhello(p1); => p2->xhello(null);\n    \tvoid xhello(){cout << x << ", hello" << endl;} => void xhello(sample* this){cout << this.x << ", hello" << endl;} => void xhello(null){cout << null.x << ", hello" << endl;}\n    */\n    return 0;\n}\n\n\nthis 指针的特点：\n\n * this 并不是一个常规变量，而是个右值，所以不能取得 this 的地址（不能 &this）\n * 静态成员函数中不能使用 this 指针，因为静态成员函数是类的对象公共的，并不具体作用于某个对象；因此当静态成员函数被调用时，编译程序不会在其参数中添加 this 指针，即其真实参数个数不会改变。\n * 在一些场景中需要显示的引用 this 指针\n   * 为实现对象的链式引用\n   * 为避免对同一对象进行赋值操作\n   * 在实现一些数据结构时，例如 list\n\n\n# 类中的静态成员\n\nstatic 关键字：\n\n * 修饰普通变量，修改变量的存储区域和生命周期，使变量存储在静态区，在 main 函数运行前就分配了空间，如果有初始值就用初始值初始化它，如果没有初始值系统用默认值初始化它。\n\n * 修饰普通函数，表明函数的作用范围，仅在定义该函数的文件内才能使用。在多人开发项目时，为了防止与他人命名空间里的函数重名，可以将函数定位为 static。\n\n * 修饰类的成员变量，修饰成员变量使所有的对象都共享一个该变量，而且不需要生成对象就可以访问该成员。在类中，sizeof 运算符不会计算静态成员变量所占用的空间，例如：\n   \n   class sample{\n       private:\n       \tint a;\n       \tstatic int b;\n   };\n   // sizeof(sample) 的结果是 4 而不是 8\n   \n\n * 修饰类的成员函数，修饰成员函数使得不需要生成对象就可以访问该函数，但是在 static 函数内不能访问非静态成员。\n\n静态成员：普通成员变量每个对象都有各自的一份，而静态成员变量总共只有一份，所有对象共享；普通成员函数必须具体作用于某个对象，而静态成员函数并不具体作用于某个对象；静态成员不需要通过对象就能访问。静态成员有如下四种访问方式：\n\n * 类名 :: 成员名 rectangle::printtotal();\n * 对象名 . 成员名 rectangle r; r.printtotal(); 对象可以访问静态成员，但不具体作用于该对象\n * 指针 -> 成员名 rectangle* p = &r; p->printtotal();\n * 引用 . 成员名 rectangle& ref = r; ref.printtotal();\n\n静态成员变量本质上是全局变量，静态成员函数本质上也是全局函数。设置静态成员这种机制的目的在于：将和某些类紧密相关的全局变量和全局函数写到类内，这样使得这些全局变量和函数更加易于维护和理解。\n\n静态成员的一个应用示例：随时输出矩形总数和总共面积\n\nclass rectangle{\n    private:\n    \tint width, height;\n    \tstatic int totalnumber;\n    \tstatic int totalarea;\n    public:\n    \trectangle(int w, int h);\n    \trectangle(const rectangle & r); // 如果不定义拷贝构造函数，在拷贝对象的过程中没有修改 totalnumber 和 totalarea, 但是析构函数却修改了，这将导致最终总数变小\n    \t~rectangle();\n    \tstatic void printtotal();\n};\n\nrectangle::rectangle(int w, int h){\n    width = w;\n    height = h;\n    totalnumber++;\n    totalarea += width*height;\n}\n\nrectangle::rectangle(const rectangle &r){\n    width = r.width;\n    height = r.height;\n    totalnumber++;\n    totalarea += width*height;\n}\n\nrectangle::~rectangle(){\n    totalnumber--;\n    totalarea -= width*height;\n}\n\nvoid rectangle::printtotal(){\n    cout<< totalnumber << " , " << totalarea << endl;\n}\n\n// 必须在定义类的文件中对静态成员变量进行一次说明或初始化，否则能通过编译，但是无法链接\nint rectangle::totalnumber = 0;\nint rectangle::totalarea = 0;\n\nint main(){\n    rectangle r1(1,2), r2(2,4);\n    cout << rectangle::totalnumber << endl; // 会执行出错，因为类中定义 totalnumber是私有的\n    rectangle::printtotal();\n    return 0;\n}\n\n\n需要注意的是，在静态成员函数中，不能访问非静态成员变量，也不能调用非静态成员函数，因为非静态成员变量是有对象所属的，而静态成员不特定属于某个对象，这将导致访问的歧义。\n\n\n# 成员对象和封闭类\n\n成员对象：一个类的成员变量如果是另一个类的对象，就称之为成员对象\n\n封闭类：有成员对象的类叫封闭类，例如：\n\nclass tyre{\n    private:\n    \tint radius;\n    \tint width;\n    public:\n    \ttyre(int r, int w):radius(r), width(w){cout << "tyre constructor called" <<endl;}\n    \t~tyre(){cout<<"tyre destructor called"<<endl;}\n};\n\nclass engine{\n  \tpublic:\n    \tengine(){cout<<"engine constructor called"<<endl;}\n    \t~engine(){cout<<"engine destructor called"<<endl;}\n};\n\n// car 封闭类\nclass car{\n    private:\n    \t// 声明次序决定了初始化顺序，与初始化列表次序无关\n    \tint price;\n    \tengine engine;\n    \ttyre tyre;\n    public:\n    \tcar(int p, int tr, int tw){}\n    \t~car(){cout<<"car destructor called"<<endl;}\n};\n\n// 使用初始化列表初始化封闭类：任何生成封闭类对象的语句，都要让编译器明白对象中的成员对象是如何初始化的\ncar::car(int p, int tr, int tw):price(p), tyre(tr,tw){\n    cout<<"car constructor called"<<endl;\n}\n\nint main(){\n    car car(2000,125,400);\n    return 0;\n}\n/* output:\nengine constructor called\ntyre constructor called\ncar constructor called\ncar destructor called\ntyre destructor called\nengine destructor called\n*/\n\n\n初始化列表：\n\n当封闭类的对象生成并初始化时，它包含的成员对象也需要被初始化，这就会引发成员对象构造函数的调用。通过在定义封闭类的构造函数时，添加初始化列表的方式，让编译器明白成员对象初始化时调用的构造函数。初始化列表的写法类名::构造函数名(参数表):成员变量1(参数表), 成员变量2(参数表),.....{函数体}。\n\n初始化列表中的成员变量既可以是成员对象，也可以是基本类型的成员变量。对于成员对象，初始化列表的参数表中存放的是构造函数的参数（它指明了该成员对象如何初始化）。对于基本类型成员变量，参数表中就是一个初始值。\n\n封闭类的构造函数和析构函数的执行顺序：\n\n * 封闭类对象生成时，先执行所有对象成员的构造函数，然后才执行封闭类的构造函数。\n * 对象成员的构造函数调用次序和对象成员在类中的说明次序一致，与它们在成员初始化列表中出现的次序无关。\n * 当封闭类消亡时，先执行封闭类的析构函数，然后再执行对象的析构函数。调用次序和构造函数的调用次序相反。\n\n封闭类的拷贝构造函数：成员对象的拷贝调用该对象的拷贝构造函数\n\nclass a{\n    public:\n    \ta(){cout<<"default"<<endl;}\n    \ta(const a & a){cout<<"copy"<<endl;}\n};\nclass b{\n    private:\n    \ta a;\n};\nint mian(){\n    b b1;\n    b b2(b1);\n    return 0;\n}\n\n/* output:\ndefault\ncopy\n// b2.a使用类a的拷贝构造函数初始化的，其实参是b1.a\n*/\n\n\n\n# 友元\n\n友元函数：一个类的友元函数可以访问该类的私有成员\n\nclass a{\n    private:\n    \tint a_x;\n    public:\n    \ta(int x){a_x=x;}\n    \tfriend void addone(a a);\n};\n\nvoid addone(a a){\n    a.a_x++; // 友元函数可以直接访问类的私有成员\n}\n\nint main(){\n    a a(1);\n    addone(a);\n    return 0;\n}\n\n\n友元类：友元类的成员函数都可以访问该类的私有成员\n\nclass a{\n    private:\n    \tint a_x;\n    \tfriend class b; // 友元类可以直接访问该类的私有成员\n    public:\n    \ta(int n){a_x = n;}\n};\n\nclass b{\n    public:\n    \ta a;\n    \tb(int ax):a(ax){}\n    \tvoid addone();\n};\n\nvoid b::addone(){\n    a.a_x++;\n}\n\nint main(){\n    b b(1);\n    b.addone();\n    return 0;\n}\n\n\n友元的特点：\n\n * 能访问私有成员\n * 破坏封装性\n * 友元关系不可传递，不可继承\n * 友元关系的单向性\n * 友元声明的形式及数量不受限制\n\n\n# reference\n\nc/c++\n\nc++成员对象和封闭类详解',charsets:{cjk:!0},lastUpdated:"2023/11/19, 12:55:48",lastUpdatedTimestamp:1700369748e3},{title:"C++ 输入输出流",frontmatter:{title:"C++ 输入输出流",date:"2023-11-18T15:46:10.000Z",permalink:"/pages/f0b4b2/"},regularPath:"/01.C&Cpp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/02.C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/02.C++%20STL/01.C++%20%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81.html",relativePath:"01.C&Cpp学习笔记/02.C++面向对象编程/02.C++ STL/01.C++ 输入输出流.md",key:"v-06da7966",path:"/pages/f0b4b2/",headers:[{level:2,title:"输入输出流基本概念",slug:"输入输出流基本概念",normalizedTitle:"输入输出流基本概念",charIndex:16},{level:2,title:"文件读写",slug:"文件读写",normalizedTitle:"文件读写",charIndex:1955},{level:3,title:"创建文件",slug:"创建文件",normalizedTitle:"创建文件",charIndex:1964},{level:3,title:"文件的读写指针",slug:"文件的读写指针",normalizedTitle:"文件的读写指针",charIndex:2346},{level:3,title:"二进制文件读写",slug:"二进制文件读写",normalizedTitle:"二进制文件读写",charIndex:3665}],headersStr:"输入输出流基本概念 文件读写 创建文件 文件的读写指针 二进制文件读写",content:'# C++ 输入输出流\n\n\n# 输入输出流基本概念\n\n与输入输出流操作相关的类：类的继承关系从上往下如下图所示\n\n * istream：用于输入的流类，cin 是该类的对象\n * ostream：用于输出的流类，cout cerr clog 是该类的对象\n * ifstream：用于从文件读取数据的类\n * ofstream：用于向文件写入数据的类\n * iostream：既能用于输入，又能用于输出的类\n * fstream：既能从文件读取数据，又能向文件写入数据的类\n\n标准流对象：\n\n * cin 对应于标准输入流，用于从键盘读取数据，也可以被重定向为从文件中读取数据\n\n * cout 对应于标准输出流，用于从屏幕输出数据，也可以被重定向为向文件写入数据\n\n * cerr 对应于标准错误输出流，用于向屏幕输出出错信息\n\n * clog 对应于标准错误输出流，用于向屏幕输出错误信息\n\n * cerr 和 clog 的区别在于 cerr 不使用缓冲区，直接向显示器输出出错信息；而 clog 中的信息先会被存放到缓冲区，缓冲区满或者刷新时才输出到屏幕。\n\nistream 类的成员函数：\n\n * istream & getline(char* buf, int bufSize); ：从输入流中读取 bufSize-1 个字符到缓冲区 buf 或读到碰到 \\n 为止\n * istream & getline(char* buf, int bufSize, char delim); ：从输入流中读取 bufSize-1 个字符到缓冲区 buf 或读到碰到字符 delim 为止。如果一次读入的字符个数超过了 bufSize-1 不会影响本次读入，但是之后的读入都会失败。另外，可以用 getline() 的返回值判断输入是否结束 if(!cin.getline())。\n * bool eof(); 判断输入流是否结束\n * int peek(); 返回下一个字符，但不从输入流中去掉\n * istream & putback(char c); 将字符 c 放回输入流\n * iostream & ignore(int nCount = 1, int delim = EOF); 从流中删掉最多 nCount 个字符，遇到 EOF 时结束\n\n流操纵算子控制输出格式：\n\nint main(){\n\n    // 分别以十六进制、十进制、八进制先后输出 n\n    int n = 141;\n    cout << "1) " << hex << n << " ";\n    cout << dec << n << " ";\n    cout << oct << n <<endl;\n\n    // 保留 5 位有效数字\n    double x = 1234567.89, y = 12.34567;\n    cout << "2) " << setprecision(5) << x << " " << y <<endl;\n\n    // 保留小数点后 5 位 定点输出浮点数\n    cout << "3) " << fixed << setprecision(5) << x << " " << y <<endl;\n\n    // 科学计数法输出，且保留小数点后 5 位\n    cout << "4) " << scientific << setprecision(5) << x << " " << y <<endl;\n\n    // 非负数要显示正号，输出宽度为 12 字符， 宽度不足则用 * 号填补\n    cout << "5) " << showpos << fixed << setw(12) << setfill(\'*\') << 12.1 <<endl;\n\n    // 非负数不显示正号，输出宽度为 12 字符， 左对齐 宽度不足则右边用填充字符填补\n    cout << "6) " << noshowpos << setw(12) << left << 12.1 <<endl;\n\n    // 输出宽度为 12 字符，右对齐 宽度不足则左边用填充字符填补\n    cout << "7) " << setw(12) << right << 12.1 << endl;\n\n    // 宽度不足时，符号和数值分列左右，中间用填充字符填补\n    cout << "8) " << setw(12) << internal << -12.1 <<endl;\n    cout << "9) " << 12.1 <<endl;\n\n    return 0;\n}\n\n\n\n# 文件读写\n\n\n# 创建文件\n\n调用头文件 #include <fstream> 中的函数ofstream outFile("data.txt", ios::out|ios::binary); 创建文件，其中第一个参数表示要创建的文件的名字 data.txt；ios::out 表示文件打开方式，out 表示输出内容到该文件，删除原有文件内容，app 表示输出内容到该文件，保留原有内容，从尾部追加；ios::binary 表示以二进制文件格式打开文件。\n\n除了 直接创建 ofstream 对象 outFile 也可以先创建对象，再用 open 函数打开该文件，形如 ofstream fout; fout.open("data.txt", ios::out|ios::binary) 。判断文件是否打开可以直接使用被重载的 ! 运算符，if(!fout){} 进行判断。\n\n\n# 文件的读写指针\n\n文件的读写指针并不是真正意义上的指针，它用来表示文件操作的当前位置，该指针在那里，读写操作就在哪里进行。对于输入文件，有一个读指针；对于输出文件，有一个写指针；对于输入输出文件，有一个读写指针。\n\n输出文件，写指针：tellp()/seekp()\n\nofstream fout("test.out", ios::app); \nlong location = fout.tellp(); // 获取写指针的位置\nlocation = 10;  // location 可以为负值\nfout.seekp(location); // 将写指针移动到第10个字节处\nfout.seekp(location, ios::beg); // 从文件头开始移动location个字节\nfout.seekp(location, ios::cur); // 从当前位置开始移动location个字节\nfout.seekp(location, ios::end); // 从文件尾开始移动location个字节\n\n\n输入文件，读指针：tellg()/seekg()\n\nifstream fin("test.in", ios::ate); // 打开文件并将读指针定位到文件末尾 \nlong location = fin.tellg(); // 获取写指针的位置\nlocation = 10;  // location 可以为负值\nfin.seekg(location); // 将读指针移动到第10个字节处\nfin.seekg(location, ios::beg); // 从文件头开始移动location个字节\nfin.seekg(location, ios::cur); // 从当前位置开始移动location个字节\nfin.seekg(location, ios::end); // 从文件尾开始移动location个字节\n\n\n字符文件读写：实践示例 将文件 in.txt 里面的整数排序后，输出到 out.txt\n\n#include <iostream>\n#include <fstream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint main(){\n\n    vector<int> v;\n    ifstream srcFile("in.txt", ios::in);\n    ofstream destFile("out.txt", ios::out);\n    int x;\n    while (srcFile >> x)\n    {\n        v.push_back(x);\n    }\n    sort(v.begin(), v.end());\n    for(int i=0; i< v.size(); i++){\n        destFile << v[i] << " ";\n    }\n   destFile.close();\n   srcFile.close();\n\n    return 0;\n}\n\n\n\n# 二进制文件读写\n\n二进制读文件：\n\n二进制读文件可以使用 ifstream 和 fstream 的成员函数 istream& read(char* s, long n);，read 函数的作用是将文件读指针指向的地方的 n 个字节内容，读入到内存地址 s，然后将文件读指针向后移动 n 个字节；如果文件使用 ios::in 的方式打开文件，文件的读指针开始指向文件开头。\n\n二进制写文件：\n\n二进制写文件可以使用 ofstream 和 fstream 的成员函数 istream& write(const char* s, long n);，write 函数的作用是将内存地址 s 处的 n 个字节内容，写入到文件中写指针指向的位置，然后将文件写指针向后移动 n 个字节；如果文件使用 ios::out 的方式打开文件，文件的写指针开始指向文件开头；ios::app 方式打开文件时，文件写指针最开始指向文件尾部。\n\n#include<iostream>\n#include<fstream>\nint main(){\n    ofstream fout("data.dat", ios::out|ios::binary);\n    int x=120;\n    fout.write((const char *)(&x), sizeof(int));\n    fout.close();\n    ifstream fin("data.dat", ios::in|ios::binary);\n    int y;\n    fin.read((char *)(&y), sizeof(int));\n    fin.close();\n    cout << y << endl;\n    return 0;\n}\n\n\n文件读写实例-文件拷贝：将 ori.dat 拷贝到 dest.dat ，如果目标文件存在就将其原始文件覆盖。\n\n#include <iostream>\n#include <fstream>\nusing namespace std;\nint main(int argc, char* argv[]){\n\tif(argc != 3){\n        cout << "file name missing1" << endl;\n        return 0;\n    }\n    // 读取二进制文件\n    ifstream inFile(argv[1], ios::binary|ios::in);\n    if(!inFile){\n        cout << "Source file open error." << endl;\n        return 0;\n    }\n\t// 写入二进制文件\n    ofstream outFile(argv[2], ios::binary|ios::out);\n    if(!outFile){\n        cout << "New file open error." << endl;\n        inFile.close();\n        return 0;\n    }\n    // 拷贝文件\n    char c;\n    while(inFile.get(c)){ // 每次从源文件读取一个字符\n        outFile.put(c); // 每次写入一个字符到目标文件\n    }\n    outFile.close();\n    inFile.close();\n    return 0;\n}\n',normalizedContent:'# c++ 输入输出流\n\n\n# 输入输出流基本概念\n\n与输入输出流操作相关的类：类的继承关系从上往下如下图所示\n\n * istream：用于输入的流类，cin 是该类的对象\n * ostream：用于输出的流类，cout cerr clog 是该类的对象\n * ifstream：用于从文件读取数据的类\n * ofstream：用于向文件写入数据的类\n * iostream：既能用于输入，又能用于输出的类\n * fstream：既能从文件读取数据，又能向文件写入数据的类\n\n标准流对象：\n\n * cin 对应于标准输入流，用于从键盘读取数据，也可以被重定向为从文件中读取数据\n\n * cout 对应于标准输出流，用于从屏幕输出数据，也可以被重定向为向文件写入数据\n\n * cerr 对应于标准错误输出流，用于向屏幕输出出错信息\n\n * clog 对应于标准错误输出流，用于向屏幕输出错误信息\n\n * cerr 和 clog 的区别在于 cerr 不使用缓冲区，直接向显示器输出出错信息；而 clog 中的信息先会被存放到缓冲区，缓冲区满或者刷新时才输出到屏幕。\n\nistream 类的成员函数：\n\n * istream & getline(char* buf, int bufsize); ：从输入流中读取 bufsize-1 个字符到缓冲区 buf 或读到碰到 \\n 为止\n * istream & getline(char* buf, int bufsize, char delim); ：从输入流中读取 bufsize-1 个字符到缓冲区 buf 或读到碰到字符 delim 为止。如果一次读入的字符个数超过了 bufsize-1 不会影响本次读入，但是之后的读入都会失败。另外，可以用 getline() 的返回值判断输入是否结束 if(!cin.getline())。\n * bool eof(); 判断输入流是否结束\n * int peek(); 返回下一个字符，但不从输入流中去掉\n * istream & putback(char c); 将字符 c 放回输入流\n * iostream & ignore(int ncount = 1, int delim = eof); 从流中删掉最多 ncount 个字符，遇到 eof 时结束\n\n流操纵算子控制输出格式：\n\nint main(){\n\n    // 分别以十六进制、十进制、八进制先后输出 n\n    int n = 141;\n    cout << "1) " << hex << n << " ";\n    cout << dec << n << " ";\n    cout << oct << n <<endl;\n\n    // 保留 5 位有效数字\n    double x = 1234567.89, y = 12.34567;\n    cout << "2) " << setprecision(5) << x << " " << y <<endl;\n\n    // 保留小数点后 5 位 定点输出浮点数\n    cout << "3) " << fixed << setprecision(5) << x << " " << y <<endl;\n\n    // 科学计数法输出，且保留小数点后 5 位\n    cout << "4) " << scientific << setprecision(5) << x << " " << y <<endl;\n\n    // 非负数要显示正号，输出宽度为 12 字符， 宽度不足则用 * 号填补\n    cout << "5) " << showpos << fixed << setw(12) << setfill(\'*\') << 12.1 <<endl;\n\n    // 非负数不显示正号，输出宽度为 12 字符， 左对齐 宽度不足则右边用填充字符填补\n    cout << "6) " << noshowpos << setw(12) << left << 12.1 <<endl;\n\n    // 输出宽度为 12 字符，右对齐 宽度不足则左边用填充字符填补\n    cout << "7) " << setw(12) << right << 12.1 << endl;\n\n    // 宽度不足时，符号和数值分列左右，中间用填充字符填补\n    cout << "8) " << setw(12) << internal << -12.1 <<endl;\n    cout << "9) " << 12.1 <<endl;\n\n    return 0;\n}\n\n\n\n# 文件读写\n\n\n# 创建文件\n\n调用头文件 #include <fstream> 中的函数ofstream outfile("data.txt", ios::out|ios::binary); 创建文件，其中第一个参数表示要创建的文件的名字 data.txt；ios::out 表示文件打开方式，out 表示输出内容到该文件，删除原有文件内容，app 表示输出内容到该文件，保留原有内容，从尾部追加；ios::binary 表示以二进制文件格式打开文件。\n\n除了 直接创建 ofstream 对象 outfile 也可以先创建对象，再用 open 函数打开该文件，形如 ofstream fout; fout.open("data.txt", ios::out|ios::binary) 。判断文件是否打开可以直接使用被重载的 ! 运算符，if(!fout){} 进行判断。\n\n\n# 文件的读写指针\n\n文件的读写指针并不是真正意义上的指针，它用来表示文件操作的当前位置，该指针在那里，读写操作就在哪里进行。对于输入文件，有一个读指针；对于输出文件，有一个写指针；对于输入输出文件，有一个读写指针。\n\n输出文件，写指针：tellp()/seekp()\n\nofstream fout("test.out", ios::app); \nlong location = fout.tellp(); // 获取写指针的位置\nlocation = 10;  // location 可以为负值\nfout.seekp(location); // 将写指针移动到第10个字节处\nfout.seekp(location, ios::beg); // 从文件头开始移动location个字节\nfout.seekp(location, ios::cur); // 从当前位置开始移动location个字节\nfout.seekp(location, ios::end); // 从文件尾开始移动location个字节\n\n\n输入文件，读指针：tellg()/seekg()\n\nifstream fin("test.in", ios::ate); // 打开文件并将读指针定位到文件末尾 \nlong location = fin.tellg(); // 获取写指针的位置\nlocation = 10;  // location 可以为负值\nfin.seekg(location); // 将读指针移动到第10个字节处\nfin.seekg(location, ios::beg); // 从文件头开始移动location个字节\nfin.seekg(location, ios::cur); // 从当前位置开始移动location个字节\nfin.seekg(location, ios::end); // 从文件尾开始移动location个字节\n\n\n字符文件读写：实践示例 将文件 in.txt 里面的整数排序后，输出到 out.txt\n\n#include <iostream>\n#include <fstream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint main(){\n\n    vector<int> v;\n    ifstream srcfile("in.txt", ios::in);\n    ofstream destfile("out.txt", ios::out);\n    int x;\n    while (srcfile >> x)\n    {\n        v.push_back(x);\n    }\n    sort(v.begin(), v.end());\n    for(int i=0; i< v.size(); i++){\n        destfile << v[i] << " ";\n    }\n   destfile.close();\n   srcfile.close();\n\n    return 0;\n}\n\n\n\n# 二进制文件读写\n\n二进制读文件：\n\n二进制读文件可以使用 ifstream 和 fstream 的成员函数 istream& read(char* s, long n);，read 函数的作用是将文件读指针指向的地方的 n 个字节内容，读入到内存地址 s，然后将文件读指针向后移动 n 个字节；如果文件使用 ios::in 的方式打开文件，文件的读指针开始指向文件开头。\n\n二进制写文件：\n\n二进制写文件可以使用 ofstream 和 fstream 的成员函数 istream& write(const char* s, long n);，write 函数的作用是将内存地址 s 处的 n 个字节内容，写入到文件中写指针指向的位置，然后将文件写指针向后移动 n 个字节；如果文件使用 ios::out 的方式打开文件，文件的写指针开始指向文件开头；ios::app 方式打开文件时，文件写指针最开始指向文件尾部。\n\n#include<iostream>\n#include<fstream>\nint main(){\n    ofstream fout("data.dat", ios::out|ios::binary);\n    int x=120;\n    fout.write((const char *)(&x), sizeof(int));\n    fout.close();\n    ifstream fin("data.dat", ios::in|ios::binary);\n    int y;\n    fin.read((char *)(&y), sizeof(int));\n    fin.close();\n    cout << y << endl;\n    return 0;\n}\n\n\n文件读写实例-文件拷贝：将 ori.dat 拷贝到 dest.dat ，如果目标文件存在就将其原始文件覆盖。\n\n#include <iostream>\n#include <fstream>\nusing namespace std;\nint main(int argc, char* argv[]){\n\tif(argc != 3){\n        cout << "file name missing1" << endl;\n        return 0;\n    }\n    // 读取二进制文件\n    ifstream infile(argv[1], ios::binary|ios::in);\n    if(!infile){\n        cout << "source file open error." << endl;\n        return 0;\n    }\n\t// 写入二进制文件\n    ofstream outfile(argv[2], ios::binary|ios::out);\n    if(!outfile){\n        cout << "new file open error." << endl;\n        infile.close();\n        return 0;\n    }\n    // 拷贝文件\n    char c;\n    while(infile.get(c)){ // 每次从源文件读取一个字符\n        outfile.put(c); // 每次写入一个字符到目标文件\n    }\n    outfile.close();\n    infile.close();\n    return 0;\n}\n',charsets:{cjk:!0},lastUpdated:"2023/11/19, 12:55:48",lastUpdatedTimestamp:1700369748e3},{title:"C++ 泛型编程",frontmatter:{title:"C++ 泛型编程",date:"2023-11-18T15:46:10.000Z",permalink:"/pages/b3a5d5/"},regularPath:"/01.C&Cpp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/02.C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/02.C++%20STL/02.C++%20%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B.html",relativePath:"01.C&Cpp学习笔记/02.C++面向对象编程/02.C++ STL/02.C++ 泛型编程.md",key:"v-57adafc4",path:"/pages/b3a5d5/",headers:[{level:2,title:"函数模板",slug:"函数模板",normalizedTitle:"函数模板",charIndex:15},{level:2,title:"类模板",slug:"类模板",normalizedTitle:"类模板",charIndex:2453},{level:2,title:"类模板与继承",slug:"类模板与继承",normalizedTitle:"类模板与继承",charIndex:4040},{level:3,title:"类模板与派生",slug:"类模板与派生",normalizedTitle:"类模板与派生",charIndex:4051},{level:3,title:"类模板与友元",slug:"类模板与友元",normalizedTitle:"类模板与友元",charIndex:5111},{level:3,title:"类模板与静态成员变量",slug:"类模板与静态成员变量",normalizedTitle:"类模板与静态成员变量",charIndex:6542},{level:2,title:"Reference",slug:"reference",normalizedTitle:"reference",charIndex:7017}],headersStr:"函数模板 类模板 类模板与继承 类模板与派生 类模板与友元 类模板与静态成员变量 Reference",content:'# C++ 泛型编程\n\n\n# 函数模板\n\n函数模板的概念：\n\n是一种特殊的函数，可以使用不同的类型进行调用，对于功能相同的函数，不需要重复编写代码，实现代码复用，并且函数模板与普通函数看起来很类似，区别就是类型可以被参数化。所谓模板就是可以以此为基础批量生成相似的事物，函数模板就是可以用它来自动生成很多相似的函数，更高级的函数重载。函数模板通过 template 与 typename/class 关键字来定义，另外，函数模板中可以有不只一种类型的参数。\n\ntemplate <class Type1, class Type2, ...>\n返回值类型 模板名(Type1 arg1, Type2 arg2, ...)\n{\n    /* function body */\n}\n\n\n函数模板的调用：\n\n函数模板在被调用是，可以隐示地进行自动类型推导调用 maxElement(arr1, 5);，也可以使用具体类型显示调用 maxElement<double>(arr2, 5); 如下实例是求数组最大元素的maxElement 函数模板：\n\ntemplate <class T>\nT maxElement(T a[], int size){\n    T tempMax = a[0];\n    for(int i=1; i<size; ++i){\n        if(tempMax < a[i]){\n            tempMax = a[i];\n        }\n    }\n    return tempMax;\n}\n\nint main(){\n    int arr1 = {1,2,3,4,5};\n    double arr2 = {1.1,2.2,3.3,4.4,5.5};\n    cout << maxElement(arr1, 5);\n    cout << maxElement<double>(arr2, 5);\n    return 0;\n}\n\n\n函数模板的重载：\n\n和普通函数一样，函数模板也可以被重载，只要它们的形参表或类型参数表不同即可。\n\ntemplate <typename T>\nvoid print(T arg1, T arg2)\n{\n    cout << "void print(T arg1, T arg2)" << endl;\n}\n \ntemplate <typename T1, typename T2> // 类型参数表不一致\nvoid print(T1 arg1, T1 arg2)\n{\n    cout << "void print(T1 arg1, T1 arg2)" << endl;\n}\n\ntemplate <typename T1, typename T2>\nvoid print(T1 arg1, T2 arg2) // 形参表不一致\n{\n    cout << "void print(T1 arg1, T2 arg2)" << endl;\n}\n\n\n函数模板除了可以重载之外，普通函数的名字也可以和函数模板相同，在这种情况下编译器处理函数调用语句的原则是：\n\n * 优先找参数完全匹配的普通函数，而非由模板实例化而得到的函数\n * 第二选择是寻找参数完全匹配的模板函数\n * 最后的选择是寻找实参可以通过自动类型转换能够匹配的普通函数，值得注意的是在匹配模板函数时，不会对实参进行类型自动转换。\n\n函数模板重要实例 Map 底层实现：Map 函数的作用是根据提供的函数对指定的序列做映射，实例如下：\n\ntemplate<class T, class Pred>\nvoid map(T s, T e, T x, Pred op){\n    for( ; s != e; ++s, ++x){\n        *x = op(*s);\n    }\n}\n\nint cube(int x){\n    return x*x*x;\n}\ndouble square(double x){\n    return x*x;\n}\n\nint main(){\n    int a[5] = {1,2,3,4,5}, b[5];\n    double c[5] = {1.1,2.2,3.3,4.4,5.5}, d[5];\n\n    map(a,a+5,b,cube);\n    for(int i=0; i<5; ++i){\n        cout << b[i] << \' \';\n    }\n    cout << endl;\n\n    map(a,a+5,b,square);\n    for(int i=0; i<5; ++i){\n        cout << b[i] << \' \';\n    }\n    cout << endl;\n    \n    map(c,c+5,d,square);\n    for(int i=0; i<5; ++i){\n        cout << d[i] << \' \';\n    }\n    cout << endl;\n\n    return 0;\n}\n\n\n在下面的实现中，map 函数模板的形参表 T s, T e, T x, Pred op 分别表示指定序列的起始位置 s 、结束位置 e 、新序列的起始位置 x 和提供的映射函数 op。在 main 函数中调用模板函数时，函数模板被实例化为对应的函数，例如调用语句 map(a, a+5, b, square) 被实例化为如下函数：\n\nvoid map(int *s, int *e, int *x, double(*op)(double)){\n     for( ; s != e; ++s, ++x){\n        *x = op(*s); // 以*s作为参数去调用op所指向的函数，并把函数执行结果赋值给*x\n    }\n}\n\n\n\n# 类模板\n\n类模板的基本概念：\n\n为了多快好省地定义出一批相似的类，可以定义类模板，然后由类模板生成不同的类。将模板的思想应用于类，只考虑类的功能实现，不需要关注具体数据元素的类型，这种思想非常适用于编写数据结构相关的代码，比如数组类、线性表、栈和堆等，只需要实现他们的逻辑功能，不必关注具体的数据类型。\n\n和函数模板一样，类模板也通过 template 与 typename/class 关键字来定义，类模板里的成员函数的定义也需要添加类型参数表，使用类模板定义对象时需要添加实际类型参数表，如下所示：\n\n// 类模板的定义\ntemplate <class Type1, class Type2, ...>\nclass 类模板名\n{\n    /* class body: 成员变量和成员函数 */\n};\n\n// 类模板成员函数的定义\ntemplate <class Type1, class Type2, ...>\n返回值类型 类模板名<类型参数名列表>::成员函数名(形参表)\n{\n    /* function body */\n}\n\n// 用类模板定义对象\n类模板名<真实类型参数表> 对象名(构造函数实参表);\n\n\n类模板的定义中类型参数表可以包含非类型参数，如下实例中的 size 参数：\n\ntemplate <class T, int size>\nclass myArray{\n    T array[size];\n};\n\n\n类模板实例 Pair 类模板：\n\ntemplate <class T1, class T2>\nclass Pair{\npublic:\n    T1 key;\n    T2 value;\n    Pair(T1 k, T2 v):key(k), value(v){};\n    bool operator < (const Pair<T1, T2> &p) const; // const Pair<T1, T2> & p 是Pair类模板对象的引用\n};\n\n// Pair类模板的成员函数 operator <\ntemplate<class T1, class T2>\nbool Pair<T1, T2>::operator < (const Pair<T1, T2> &p) const{\n    return key < p.key;\n}\n\nint main(){\n    Pair<string, int> student("Tom",19); // 实例化一个类\n    cout << student.key << " " << student.value << endl;\n    return 0;\n}\n\n\n编译器由类模板生成类的过程叫类模板的实例化，由类模板实例化得到的类，叫模板类。值得注意的是，同一个类模板的两个模板类是不兼容的，例如 Pair<string, int> * p; Pair<string, double> a; p = &a; 是非法的赋值。\n\n函数模板作为类模板的成员函数：\n\n#include <iostream>\nusing namespace std;\ntemplate <class T>\nclass A{\npublic:\n    // 函数模板作为类模板的成员函数\n    template <class T2>\n    void Func(T2 t){cout << t;} \n};\nint main(){\n    A<int> a;\n    a.Func(\'K\'); // 成员函数模板 Func 被实例化为形参为 char 类型\n    a.Func(\'hello\'); // 成员函数模板 Func 被实例化为形参为 string 类型\n    return 0;\n}\n\n\n\n# 类模板与继承\n\n\n# 类模板与派生\n\n类模板与继承关系，自上而下有以下四种情况：类模板从类模板派生、类模板从模板类派生、类模板从普通类派生、普通类从模板类派生。\n\n类模板从类模板派生：多片森林\n\n// 模板从模板派生\ntemplate <class T1, class T2>\nclass A{\n    T1 v1; T2 v2;\n};\n\ntemplate <class T1, class T2>\nclass B:public A<T2, T1>{\n    T1 v3; T2 v4;\n};\n\nint main(){\n    B<int, double> obj;\n    return 0;\n}\n\n/* 第13行类模板生成对象 obj 时实例化了两个模板类 */\nclass B<int, double>:public A<double, int>{\n\tint v3; double v4;  \n};\nclass A<double, int>{\n    double v1; int v2;\n};\n\n\n类模板从模板类派生：一片森林\n\ntemplate <class T1, class T2>\nclass A{\n    T1 v1; T2 v2;\n};\n\ntemplate <class T>\nclass B:public A<int, double>{\n    T v3;\n};\n\nint main(){\n    B<int> obj;\n    return 0;\n}\n\n/* 第12行类模板生成对象 obj 时实例化了两个模板类 */\nclass B<int>:public A<int, double>{\n\tint v3; \n};\nclass A<int, double>{\n    int v1; double v2;\n};\n\n\n类模板从普通类派生：一棵树\n\nclass A{\n    int v1;\n};\n\ntemplate <class T>\nclass B:public A{ // 所有从类模板B实例化得到的类，都是A的派生类\n    T v2;\n};\n\nint main(){\n    B<int> obj;\n    return 0;\n}\n\n\n普通类从模板类派生：\n\ntemplate <class T>\nclass A{\n    T v1;\n};\n\nclass B:public A<int>{\n    int v2;\n};\n\nint main(){\n    B obj;\n    return 0;\n}\n\n\n\n# 类模板与友元\n\n类模板的友元可以是普通函数、函数模板、普通类、普通类的成员函数、类模板；函数模板也可以作为普通类的友元。\n\nvoid Func1(){} // 普通函数\nclass A{}; // 普通类\nclass B{\npublic:\n    void FuncB(){} // 普通类的成员函数\n};\n\ntemplate <class T>\nclass FriTmp{\n    friend void Func1();\n    friend class A;\n    friend void B::FuncB();\n};\n\n\n函数模板作为类模板的友元 STL 实例 Pair：任意从函数模板生成的函数都是任意Pair模板类的友元\n\n#include <iostream>\n#include <string>\nusing namespace std;\ntemplate <class T1, class T2>\nclass Pair{\nprivate:\n    T1 key;\n    T2 value;\npublic:\n    Pair(T1 k, T2 v):key(k),value(v){}\n    bool operator < (const Pair<T1, T2> & p) const;\n    // 函数模板作为类模板友元，任意从函数模板生成的函数都是任意Pair模板类的友元\n    template <class T3, class T4>\n    friend ostream & operator<< (ostream& o, const Pair<T3, T4>& p);\n};\n\ntemplate <class T1, class T2>\nbool operator< (const Pair<T1,T2>& p) const{\n    return key < p.key;\n}\ntemplate <class T3, class T4>\nostream& operator<< (ostream& o, const Pair<T3,T4>& p){\n    o << "(" << p.key << "," << p.value << ")";\n    return o;\n}\n\nint main(){\n    Pair<string, int> student("Tom",14);\n    Pair<int, double> obj(12, 4.32);\n    cout << student << " " << obj;\n    return 0;\n}\n\n\n类模板作为类模板的友元：从被声明为友元的类模板实例化出来的类，都是任何包含友元类模板的类模板实例化出来的类的友元。\n\ntemplate <class T>\nclass B{\n    T v;\npublic:\n    B(T n):v(n){}\n    // 声明其他类模板作为类模板的友元\n    template <class T2>\n    friend class A;\n};\n\ntemplate <class T>\nclass A{\npublic:\n    // A 类模板作为友元，其成员函数可以直接访问 B 类模板的成员变量\n    void Func(){B<int> b(10); cout << b.v << endl;}\n};\n\n\n\n# 类模板与静态成员变量\n\n类模板中可以定义静态成员 (static) ，那么从该类模板实例化得到的所有类都包含同样的静态成员。\n\ntemplate <class T>\nclass A{\nprivate:\n    static int count;\n    T v;\npublic:\n    A(T n):v(n){count++;}\n    ~A(){count--;}\n    A(A& a){count++;}\n    static void PrintCount(){cout << count << endl;}\n};\n\n// 和普通类一样，类模板的静态成员变量也需要在类外单独声明\ntemplate<> int A<int>::count = 0;\ntemplate<> int A<double>::count = 0;\n\nint main(){\n    A<int> ia;\n    A<double> da;\n    ia.PrintCount();\n    da.PrintCount();\n    return 0;\n}\n\n\n\n# Reference\n\nC++中的函数模板',normalizedContent:'# c++ 泛型编程\n\n\n# 函数模板\n\n函数模板的概念：\n\n是一种特殊的函数，可以使用不同的类型进行调用，对于功能相同的函数，不需要重复编写代码，实现代码复用，并且函数模板与普通函数看起来很类似，区别就是类型可以被参数化。所谓模板就是可以以此为基础批量生成相似的事物，函数模板就是可以用它来自动生成很多相似的函数，更高级的函数重载。函数模板通过 template 与 typename/class 关键字来定义，另外，函数模板中可以有不只一种类型的参数。\n\ntemplate <class type1, class type2, ...>\n返回值类型 模板名(type1 arg1, type2 arg2, ...)\n{\n    /* function body */\n}\n\n\n函数模板的调用：\n\n函数模板在被调用是，可以隐示地进行自动类型推导调用 maxelement(arr1, 5);，也可以使用具体类型显示调用 maxelement<double>(arr2, 5); 如下实例是求数组最大元素的maxelement 函数模板：\n\ntemplate <class t>\nt maxelement(t a[], int size){\n    t tempmax = a[0];\n    for(int i=1; i<size; ++i){\n        if(tempmax < a[i]){\n            tempmax = a[i];\n        }\n    }\n    return tempmax;\n}\n\nint main(){\n    int arr1 = {1,2,3,4,5};\n    double arr2 = {1.1,2.2,3.3,4.4,5.5};\n    cout << maxelement(arr1, 5);\n    cout << maxelement<double>(arr2, 5);\n    return 0;\n}\n\n\n函数模板的重载：\n\n和普通函数一样，函数模板也可以被重载，只要它们的形参表或类型参数表不同即可。\n\ntemplate <typename t>\nvoid print(t arg1, t arg2)\n{\n    cout << "void print(t arg1, t arg2)" << endl;\n}\n \ntemplate <typename t1, typename t2> // 类型参数表不一致\nvoid print(t1 arg1, t1 arg2)\n{\n    cout << "void print(t1 arg1, t1 arg2)" << endl;\n}\n\ntemplate <typename t1, typename t2>\nvoid print(t1 arg1, t2 arg2) // 形参表不一致\n{\n    cout << "void print(t1 arg1, t2 arg2)" << endl;\n}\n\n\n函数模板除了可以重载之外，普通函数的名字也可以和函数模板相同，在这种情况下编译器处理函数调用语句的原则是：\n\n * 优先找参数完全匹配的普通函数，而非由模板实例化而得到的函数\n * 第二选择是寻找参数完全匹配的模板函数\n * 最后的选择是寻找实参可以通过自动类型转换能够匹配的普通函数，值得注意的是在匹配模板函数时，不会对实参进行类型自动转换。\n\n函数模板重要实例 map 底层实现：map 函数的作用是根据提供的函数对指定的序列做映射，实例如下：\n\ntemplate<class t, class pred>\nvoid map(t s, t e, t x, pred op){\n    for( ; s != e; ++s, ++x){\n        *x = op(*s);\n    }\n}\n\nint cube(int x){\n    return x*x*x;\n}\ndouble square(double x){\n    return x*x;\n}\n\nint main(){\n    int a[5] = {1,2,3,4,5}, b[5];\n    double c[5] = {1.1,2.2,3.3,4.4,5.5}, d[5];\n\n    map(a,a+5,b,cube);\n    for(int i=0; i<5; ++i){\n        cout << b[i] << \' \';\n    }\n    cout << endl;\n\n    map(a,a+5,b,square);\n    for(int i=0; i<5; ++i){\n        cout << b[i] << \' \';\n    }\n    cout << endl;\n    \n    map(c,c+5,d,square);\n    for(int i=0; i<5; ++i){\n        cout << d[i] << \' \';\n    }\n    cout << endl;\n\n    return 0;\n}\n\n\n在下面的实现中，map 函数模板的形参表 t s, t e, t x, pred op 分别表示指定序列的起始位置 s 、结束位置 e 、新序列的起始位置 x 和提供的映射函数 op。在 main 函数中调用模板函数时，函数模板被实例化为对应的函数，例如调用语句 map(a, a+5, b, square) 被实例化为如下函数：\n\nvoid map(int *s, int *e, int *x, double(*op)(double)){\n     for( ; s != e; ++s, ++x){\n        *x = op(*s); // 以*s作为参数去调用op所指向的函数，并把函数执行结果赋值给*x\n    }\n}\n\n\n\n# 类模板\n\n类模板的基本概念：\n\n为了多快好省地定义出一批相似的类，可以定义类模板，然后由类模板生成不同的类。将模板的思想应用于类，只考虑类的功能实现，不需要关注具体数据元素的类型，这种思想非常适用于编写数据结构相关的代码，比如数组类、线性表、栈和堆等，只需要实现他们的逻辑功能，不必关注具体的数据类型。\n\n和函数模板一样，类模板也通过 template 与 typename/class 关键字来定义，类模板里的成员函数的定义也需要添加类型参数表，使用类模板定义对象时需要添加实际类型参数表，如下所示：\n\n// 类模板的定义\ntemplate <class type1, class type2, ...>\nclass 类模板名\n{\n    /* class body: 成员变量和成员函数 */\n};\n\n// 类模板成员函数的定义\ntemplate <class type1, class type2, ...>\n返回值类型 类模板名<类型参数名列表>::成员函数名(形参表)\n{\n    /* function body */\n}\n\n// 用类模板定义对象\n类模板名<真实类型参数表> 对象名(构造函数实参表);\n\n\n类模板的定义中类型参数表可以包含非类型参数，如下实例中的 size 参数：\n\ntemplate <class t, int size>\nclass myarray{\n    t array[size];\n};\n\n\n类模板实例 pair 类模板：\n\ntemplate <class t1, class t2>\nclass pair{\npublic:\n    t1 key;\n    t2 value;\n    pair(t1 k, t2 v):key(k), value(v){};\n    bool operator < (const pair<t1, t2> &p) const; // const pair<t1, t2> & p 是pair类模板对象的引用\n};\n\n// pair类模板的成员函数 operator <\ntemplate<class t1, class t2>\nbool pair<t1, t2>::operator < (const pair<t1, t2> &p) const{\n    return key < p.key;\n}\n\nint main(){\n    pair<string, int> student("tom",19); // 实例化一个类\n    cout << student.key << " " << student.value << endl;\n    return 0;\n}\n\n\n编译器由类模板生成类的过程叫类模板的实例化，由类模板实例化得到的类，叫模板类。值得注意的是，同一个类模板的两个模板类是不兼容的，例如 pair<string, int> * p; pair<string, double> a; p = &a; 是非法的赋值。\n\n函数模板作为类模板的成员函数：\n\n#include <iostream>\nusing namespace std;\ntemplate <class t>\nclass a{\npublic:\n    // 函数模板作为类模板的成员函数\n    template <class t2>\n    void func(t2 t){cout << t;} \n};\nint main(){\n    a<int> a;\n    a.func(\'k\'); // 成员函数模板 func 被实例化为形参为 char 类型\n    a.func(\'hello\'); // 成员函数模板 func 被实例化为形参为 string 类型\n    return 0;\n}\n\n\n\n# 类模板与继承\n\n\n# 类模板与派生\n\n类模板与继承关系，自上而下有以下四种情况：类模板从类模板派生、类模板从模板类派生、类模板从普通类派生、普通类从模板类派生。\n\n类模板从类模板派生：多片森林\n\n// 模板从模板派生\ntemplate <class t1, class t2>\nclass a{\n    t1 v1; t2 v2;\n};\n\ntemplate <class t1, class t2>\nclass b:public a<t2, t1>{\n    t1 v3; t2 v4;\n};\n\nint main(){\n    b<int, double> obj;\n    return 0;\n}\n\n/* 第13行类模板生成对象 obj 时实例化了两个模板类 */\nclass b<int, double>:public a<double, int>{\n\tint v3; double v4;  \n};\nclass a<double, int>{\n    double v1; int v2;\n};\n\n\n类模板从模板类派生：一片森林\n\ntemplate <class t1, class t2>\nclass a{\n    t1 v1; t2 v2;\n};\n\ntemplate <class t>\nclass b:public a<int, double>{\n    t v3;\n};\n\nint main(){\n    b<int> obj;\n    return 0;\n}\n\n/* 第12行类模板生成对象 obj 时实例化了两个模板类 */\nclass b<int>:public a<int, double>{\n\tint v3; \n};\nclass a<int, double>{\n    int v1; double v2;\n};\n\n\n类模板从普通类派生：一棵树\n\nclass a{\n    int v1;\n};\n\ntemplate <class t>\nclass b:public a{ // 所有从类模板b实例化得到的类，都是a的派生类\n    t v2;\n};\n\nint main(){\n    b<int> obj;\n    return 0;\n}\n\n\n普通类从模板类派生：\n\ntemplate <class t>\nclass a{\n    t v1;\n};\n\nclass b:public a<int>{\n    int v2;\n};\n\nint main(){\n    b obj;\n    return 0;\n}\n\n\n\n# 类模板与友元\n\n类模板的友元可以是普通函数、函数模板、普通类、普通类的成员函数、类模板；函数模板也可以作为普通类的友元。\n\nvoid func1(){} // 普通函数\nclass a{}; // 普通类\nclass b{\npublic:\n    void funcb(){} // 普通类的成员函数\n};\n\ntemplate <class t>\nclass fritmp{\n    friend void func1();\n    friend class a;\n    friend void b::funcb();\n};\n\n\n函数模板作为类模板的友元 stl 实例 pair：任意从函数模板生成的函数都是任意pair模板类的友元\n\n#include <iostream>\n#include <string>\nusing namespace std;\ntemplate <class t1, class t2>\nclass pair{\nprivate:\n    t1 key;\n    t2 value;\npublic:\n    pair(t1 k, t2 v):key(k),value(v){}\n    bool operator < (const pair<t1, t2> & p) const;\n    // 函数模板作为类模板友元，任意从函数模板生成的函数都是任意pair模板类的友元\n    template <class t3, class t4>\n    friend ostream & operator<< (ostream& o, const pair<t3, t4>& p);\n};\n\ntemplate <class t1, class t2>\nbool operator< (const pair<t1,t2>& p) const{\n    return key < p.key;\n}\ntemplate <class t3, class t4>\nostream& operator<< (ostream& o, const pair<t3,t4>& p){\n    o << "(" << p.key << "," << p.value << ")";\n    return o;\n}\n\nint main(){\n    pair<string, int> student("tom",14);\n    pair<int, double> obj(12, 4.32);\n    cout << student << " " << obj;\n    return 0;\n}\n\n\n类模板作为类模板的友元：从被声明为友元的类模板实例化出来的类，都是任何包含友元类模板的类模板实例化出来的类的友元。\n\ntemplate <class t>\nclass b{\n    t v;\npublic:\n    b(t n):v(n){}\n    // 声明其他类模板作为类模板的友元\n    template <class t2>\n    friend class a;\n};\n\ntemplate <class t>\nclass a{\npublic:\n    // a 类模板作为友元，其成员函数可以直接访问 b 类模板的成员变量\n    void func(){b<int> b(10); cout << b.v << endl;}\n};\n\n\n\n# 类模板与静态成员变量\n\n类模板中可以定义静态成员 (static) ，那么从该类模板实例化得到的所有类都包含同样的静态成员。\n\ntemplate <class t>\nclass a{\nprivate:\n    static int count;\n    t v;\npublic:\n    a(t n):v(n){count++;}\n    ~a(){count--;}\n    a(a& a){count++;}\n    static void printcount(){cout << count << endl;}\n};\n\n// 和普通类一样，类模板的静态成员变量也需要在类外单独声明\ntemplate<> int a<int>::count = 0;\ntemplate<> int a<double>::count = 0;\n\nint main(){\n    a<int> ia;\n    a<double> da;\n    ia.printcount();\n    da.printcount();\n    return 0;\n}\n\n\n\n# reference\n\nc++中的函数模板',charsets:{cjk:!0},lastUpdated:"2023/11/19, 12:55:48",lastUpdatedTimestamp:1700369748e3},{title:"C++ string类",frontmatter:{title:"C++ string类",date:"2023-11-18T15:46:10.000Z",permalink:"/pages/9b802c/"},regularPath:"/01.C&Cpp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/02.C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/02.C++%20STL/03.C++%20string%E7%B1%BB.html",relativePath:"01.C&Cpp学习笔记/02.C++面向对象编程/02.C++ STL/03.C++ string类.md",key:"v-4477712c",path:"/pages/9b802c/",headers:[{level:2,title:"string 的初始化",slug:"string-的初始化",normalizedTitle:"string 的初始化",charIndex:18},{level:2,title:"string 的基础操作",slug:"string-的基础操作",normalizedTitle:"string 的基础操作",charIndex:414},{level:2,title:"string 的比较操作",slug:"string-的比较操作",normalizedTitle:"string 的比较操作",charIndex:2058},{level:2,title:"string 的查找操作",slug:"string-的查找操作",normalizedTitle:"string 的查找操作",charIndex:2513},{level:2,title:"string 的C语言转换",slug:"string-的c语言转换",normalizedTitle:"string 的c语言转换",charIndex:3099},{level:2,title:"字符串流处理",slug:"字符串流处理",normalizedTitle:"字符串流处理",charIndex:3440},{level:2,title:"Reference",slug:"reference",normalizedTitle:"reference",charIndex:4081}],headersStr:"string 的初始化 string 的基础操作 string 的比较操作 string 的查找操作 string 的C语言转换 字符串流处理 Reference",content:'# C++ string类\n\n\n# string 的初始化\n\n使用 string 类要导入头文件 #include <string>，string 类是模板类 typedef basic_string<char> string; 从 basic_string 类模板实例化生成的。string 类有多种构造函数，string 对象的几种初始化方式如下\n\nstring s1("Hello");\nstring month = "March";\nstring s2(8,\'x\'); // 生成具有8个x字符的字符串\n// string 对象不能用字符(char)进行初始化，但是可以用字符对string 对象进行赋值\nstring error1 = \'c\';\nstring error2(\'c\');\n// string 对象不能用数值进行初始化\nstring error1 = 22;\nstring error2(8);\n\n\n\n# string 的基础操作\n\n获取长度 length()：\n\nstring 对象的长度用成员函数 length() 读取，string s("hello"); cout << s.length();\n\n流读取 getline()：\n\nstring 类支持流读取运算符，string str; cin >> str;。同时支持 getline() 函数，从流读取中读取一整行到指定的 string 对象，getline(cin, str);\n\n赋值 =：\n\nstring 类支持 = 运算符进行赋值，string s1("cat"), s2;\n\n复制 assign()：\n\nstring 对象使用 assign() 成员函数进行复制，string s1("cat"), s3; s3.assign(s1);，使用 assign() 函数除了可以完整复制，也可以指定起始位置和子串长度进行部分复制，s3.assign(s1,1,3); 从 s1 中下标为1的字符开始复制3个字符的子串给 s3。除此之外也可以对单个字符进行复制 s2[5] = s1[3] = \'a\';\n\n随机访问 at()：\n\nstring 对象可以使用 at() 成员函数逐个访问对象中的字符，也可以使用下标运算符 [] 进行随机访问，区别在于 at() 成员函数会做范围检查，如果超出范围会抛出 out_of_range 异常，而下标运算符不做范围检查。string str("Hello"); sout<< str.at(1) << str[2];\n\n连接 append()：\n\nstring 对象的连接可以使用 append() 成员函数连接字符串，string s1("hello"), s2("world"); s1.append(s2);；和 assign() 函数类似 append() 函数也可以通过指定起始位置和长度进行部分连接，s2.append(s1,3,s1.size()); 从 s1 中下标为3开始将s1.size() 个字符连接到 s2 字符串，如果字符串内没有足够字符，则复制到字符串最后一个字符。除了 append() 函数也可以使用连接运算符 + 连接字符串，s1 += s2;。\n\n取子串 substr()：\n\nstring 对象使用 substr() 成员函数取子串，string s1("hello"), s2; s2 = s1.substr(0,4); 返回 s1 从下标0开始的4个字符组成的子串给 s2。\n\n交换 swap()：\n\nstring 对象使用 swap() 成员函数交换两个 string 对象的值，string s1("hello"), s2("world"); s1.swap(s2);\n\n替换 replace()：\n\nstring 对象使用 replace() 成员函数替换字符串，string s1("hello"); s1.replace(2,3,"1234"); 将 s1 中从下标 2 开始的3个字符串用 "1234" 替换；也可以使用· s1.replace(2,3,"1234",1,2); 指定用于替换字符串的子串，即用 "1234" 下标 1 开始的两个字符进行替换。\n\n插入 insert()：\n\nstring 对象使用 insert() 成员函数插入其他字符串，string s1("hello"), s2("world"); s1.insert(4,s2); 将 s2 插入到 s1 下标为4的位置；s1.insert(2,s2,0,3); 将 s2 从下标0开始的3个字符插入到 s1 下标为2的位置；\n\n删除子串 erase()：\n\nstring 对象使用 erase() 成员函数删除子串，string s1("hello"); s1.erase(2); 将 s1 中从下标 2 开始（包含下标2的字符）之后的字符删除。\n\n\n# string 的比较操作\n\n关系运算符比大小：string 对象可以关系运算符比较大小 ==, >, >=, <, <=, != 返回值都是 bool 类型，成立返回 true，否则返回 false\n\nstring s1("hello"),s2("hello"),s3("hell");\nbool b = (s1 == s2);\ncout << b << endl;\nb = (s1 == s3);\ncout << b << endl;\nb = (s1 > s3);\ncout << b << endl;\n\n\ncompare()函数比大小：string 对象也可以compare() 成员函数比较大小 ，大于返回值为 1，等于返回值为 0，小于返回值为 -1；和 assign(), append()函数类似，compare()函数也可以指定起始位置和长度进行部分比较，s1.compare(1,2,s3,0,3); s1 从以开始的2个字符构成的子串和 s3 从0开始的3个字符构成的子串进行比较。\n\n\n# string 的查找操作\n\n示例 string s1("hello, world");\n\n * find()：s1.find("lo"); 在 s1 中从前向后查找 "lo" 第一次出现的地方，如果找到返回对应的位置即 l 的位置下标；如果没有找到则返回一个静态常量 string::npos 。除此之外，find() 成员函数也可以指定查找的起始位置，s1.find("ll",3);表示从 s1 下标为3的位置开始从前向后查找。\n\n * rfind()：s1.rfind("lo"); 在 s1 中从后向前查找 "lo" 第一次出现的地方，如果找到返回对应的位置即 l 的位置下标；如果没有找到则返回一个静态常量 string::npos\n\n * find_first_of()：s1.find_first_of("abcd"); 在 s1 中从前向后查找 "abdc" 中任何一个字符第一次出现的地方，如果找到返回被找到字母的位置；如果没有找到则返回一个静态常量 string::npos\n\n * find_last_not_of()：s1.find_last_not_of("abcd"); 在 s1 中从后向前查找不在 "abdc" 中任何一个字符第一次出现的地方，如果找到返回被找到字母的位置；如果没有找到则返回一个静态常量 string::npos\n\n\n# string 的C语言转换\n\nC++ 是兼容 C 语言的，但是 C 语言中没有 string 类，所以要使用一些方法将 string 对象转换为 C 语言支持的 char * 字符串。\n\n * c_str()：返回一个以 \\0 结尾的 C 字符串，即 c_str() 函数返回一个指向正规 C 字符串的指针, 内容与原始string串相同。例如 string s1("hello world"); s1.c_str(); ，s1.c_str(); 返回传统的 const char * 类型字符串，且该字符串以 \\0 结尾。\n * data()：与 c_str() 方法类似，但是返回的是 char * 类型字符串，而非 const 类型，在修改时会导致原始字符转被更改。\n\n\n# 字符串流处理\n\n除了标准流和文件流输入输出外，还可以从 string 进行输入输出。类似 istream 和 ostream 进行标准流输入输出，也可以用 istringstream 和 ostringstream 进行字符串上的输入输出，也称为内存输入输出。使用字符串流处理需要导入以下头文件 <string> <iostream> <sstream>。\n\n// 使用 istringstream 进行字符串输入\nstring input("Input test 123 4.7 A");\nistringstream inputString(input); // 声明istringstream对象\nint i; double d; char c;\ninputString >> str1 >> str2 >> i >> d >> c; // 使用istringstream对象进行字符串输入\ncout << str1 << str2 << endl;\ncout << i << \' \' << d << \' \' << c << endl;\n\n// 使用 ostringstream 进行字符串输出\nostringstream outputString;\nint a = 10;\noutputString << "This" << a << "ok" << endl;\ncout << outputString.str(); // 取出ostringstream的字符串\n\n\n\n# Reference\n\nC++string类总结',normalizedContent:'# c++ string类\n\n\n# string 的初始化\n\n使用 string 类要导入头文件 #include <string>，string 类是模板类 typedef basic_string<char> string; 从 basic_string 类模板实例化生成的。string 类有多种构造函数，string 对象的几种初始化方式如下\n\nstring s1("hello");\nstring month = "march";\nstring s2(8,\'x\'); // 生成具有8个x字符的字符串\n// string 对象不能用字符(char)进行初始化，但是可以用字符对string 对象进行赋值\nstring error1 = \'c\';\nstring error2(\'c\');\n// string 对象不能用数值进行初始化\nstring error1 = 22;\nstring error2(8);\n\n\n\n# string 的基础操作\n\n获取长度 length()：\n\nstring 对象的长度用成员函数 length() 读取，string s("hello"); cout << s.length();\n\n流读取 getline()：\n\nstring 类支持流读取运算符，string str; cin >> str;。同时支持 getline() 函数，从流读取中读取一整行到指定的 string 对象，getline(cin, str);\n\n赋值 =：\n\nstring 类支持 = 运算符进行赋值，string s1("cat"), s2;\n\n复制 assign()：\n\nstring 对象使用 assign() 成员函数进行复制，string s1("cat"), s3; s3.assign(s1);，使用 assign() 函数除了可以完整复制，也可以指定起始位置和子串长度进行部分复制，s3.assign(s1,1,3); 从 s1 中下标为1的字符开始复制3个字符的子串给 s3。除此之外也可以对单个字符进行复制 s2[5] = s1[3] = \'a\';\n\n随机访问 at()：\n\nstring 对象可以使用 at() 成员函数逐个访问对象中的字符，也可以使用下标运算符 [] 进行随机访问，区别在于 at() 成员函数会做范围检查，如果超出范围会抛出 out_of_range 异常，而下标运算符不做范围检查。string str("hello"); sout<< str.at(1) << str[2];\n\n连接 append()：\n\nstring 对象的连接可以使用 append() 成员函数连接字符串，string s1("hello"), s2("world"); s1.append(s2);；和 assign() 函数类似 append() 函数也可以通过指定起始位置和长度进行部分连接，s2.append(s1,3,s1.size()); 从 s1 中下标为3开始将s1.size() 个字符连接到 s2 字符串，如果字符串内没有足够字符，则复制到字符串最后一个字符。除了 append() 函数也可以使用连接运算符 + 连接字符串，s1 += s2;。\n\n取子串 substr()：\n\nstring 对象使用 substr() 成员函数取子串，string s1("hello"), s2; s2 = s1.substr(0,4); 返回 s1 从下标0开始的4个字符组成的子串给 s2。\n\n交换 swap()：\n\nstring 对象使用 swap() 成员函数交换两个 string 对象的值，string s1("hello"), s2("world"); s1.swap(s2);\n\n替换 replace()：\n\nstring 对象使用 replace() 成员函数替换字符串，string s1("hello"); s1.replace(2,3,"1234"); 将 s1 中从下标 2 开始的3个字符串用 "1234" 替换；也可以使用· s1.replace(2,3,"1234",1,2); 指定用于替换字符串的子串，即用 "1234" 下标 1 开始的两个字符进行替换。\n\n插入 insert()：\n\nstring 对象使用 insert() 成员函数插入其他字符串，string s1("hello"), s2("world"); s1.insert(4,s2); 将 s2 插入到 s1 下标为4的位置；s1.insert(2,s2,0,3); 将 s2 从下标0开始的3个字符插入到 s1 下标为2的位置；\n\n删除子串 erase()：\n\nstring 对象使用 erase() 成员函数删除子串，string s1("hello"); s1.erase(2); 将 s1 中从下标 2 开始（包含下标2的字符）之后的字符删除。\n\n\n# string 的比较操作\n\n关系运算符比大小：string 对象可以关系运算符比较大小 ==, >, >=, <, <=, != 返回值都是 bool 类型，成立返回 true，否则返回 false\n\nstring s1("hello"),s2("hello"),s3("hell");\nbool b = (s1 == s2);\ncout << b << endl;\nb = (s1 == s3);\ncout << b << endl;\nb = (s1 > s3);\ncout << b << endl;\n\n\ncompare()函数比大小：string 对象也可以compare() 成员函数比较大小 ，大于返回值为 1，等于返回值为 0，小于返回值为 -1；和 assign(), append()函数类似，compare()函数也可以指定起始位置和长度进行部分比较，s1.compare(1,2,s3,0,3); s1 从以开始的2个字符构成的子串和 s3 从0开始的3个字符构成的子串进行比较。\n\n\n# string 的查找操作\n\n示例 string s1("hello, world");\n\n * find()：s1.find("lo"); 在 s1 中从前向后查找 "lo" 第一次出现的地方，如果找到返回对应的位置即 l 的位置下标；如果没有找到则返回一个静态常量 string::npos 。除此之外，find() 成员函数也可以指定查找的起始位置，s1.find("ll",3);表示从 s1 下标为3的位置开始从前向后查找。\n\n * rfind()：s1.rfind("lo"); 在 s1 中从后向前查找 "lo" 第一次出现的地方，如果找到返回对应的位置即 l 的位置下标；如果没有找到则返回一个静态常量 string::npos\n\n * find_first_of()：s1.find_first_of("abcd"); 在 s1 中从前向后查找 "abdc" 中任何一个字符第一次出现的地方，如果找到返回被找到字母的位置；如果没有找到则返回一个静态常量 string::npos\n\n * find_last_not_of()：s1.find_last_not_of("abcd"); 在 s1 中从后向前查找不在 "abdc" 中任何一个字符第一次出现的地方，如果找到返回被找到字母的位置；如果没有找到则返回一个静态常量 string::npos\n\n\n# string 的c语言转换\n\nc++ 是兼容 c 语言的，但是 c 语言中没有 string 类，所以要使用一些方法将 string 对象转换为 c 语言支持的 char * 字符串。\n\n * c_str()：返回一个以 \\0 结尾的 c 字符串，即 c_str() 函数返回一个指向正规 c 字符串的指针, 内容与原始string串相同。例如 string s1("hello world"); s1.c_str(); ，s1.c_str(); 返回传统的 const char * 类型字符串，且该字符串以 \\0 结尾。\n * data()：与 c_str() 方法类似，但是返回的是 char * 类型字符串，而非 const 类型，在修改时会导致原始字符转被更改。\n\n\n# 字符串流处理\n\n除了标准流和文件流输入输出外，还可以从 string 进行输入输出。类似 istream 和 ostream 进行标准流输入输出，也可以用 istringstream 和 ostringstream 进行字符串上的输入输出，也称为内存输入输出。使用字符串流处理需要导入以下头文件 <string> <iostream> <sstream>。\n\n// 使用 istringstream 进行字符串输入\nstring input("input test 123 4.7 a");\nistringstream inputstring(input); // 声明istringstream对象\nint i; double d; char c;\ninputstring >> str1 >> str2 >> i >> d >> c; // 使用istringstream对象进行字符串输入\ncout << str1 << str2 << endl;\ncout << i << \' \' << d << \' \' << c << endl;\n\n// 使用 ostringstream 进行字符串输出\nostringstream outputstring;\nint a = 10;\noutputstring << "this" << a << "ok" << endl;\ncout << outputstring.str(); // 取出ostringstream的字符串\n\n\n\n# reference\n\nc++string类总结',charsets:{cjk:!0},lastUpdated:"2023/11/19, 12:55:48",lastUpdatedTimestamp:1700369748e3},{title:"C++ 标准模板库 STL 函数对象",frontmatter:{title:"C++ 标准模板库 STL 函数对象",date:"2023-11-18T15:46:10.000Z",permalink:"/pages/2fa612/"},regularPath:"/01.C&Cpp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/02.C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/02.C++%20STL/06.C++%20%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93%20STL%20%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1.html",relativePath:"01.C&Cpp学习笔记/02.C++面向对象编程/02.C++ STL/06.C++ 标准模板库 STL 函数对象.md",key:"v-74760cb8",path:"/pages/2fa612/",headers:[{level:2,title:"函数对象的基本概念",slug:"函数对象的基本概念",normalizedTitle:"函数对象的基本概念",charIndex:11},{level:2,title:"函数对象的实际应用",slug:"函数对象的实际应用",normalizedTitle:"函数对象的实际应用",charIndex:353},{level:2,title:"函数对象的应用示例",slug:"函数对象的应用示例",normalizedTitle:"函数对象的应用示例",charIndex:849},{level:2,title:"STL 中的函数对象类模板",slug:"stl-中的函数对象类模板",normalizedTitle:"stl 中的函数对象类模板",charIndex:2603},{level:4,title:"Greater 函数对象类模板",slug:"greater-函数对象类模板",normalizedTitle:"greater 函数对象类模板",charIndex:2703},{level:4,title:"STL 中的大小关系",slug:"stl-中的大小关系",normalizedTitle:"stl 中的大小关系",charIndex:3875}],headersStr:"函数对象的基本概念 函数对象的实际应用 函数对象的应用示例 STL 中的函数对象类模板 Greater 函数对象类模板 STL 中的大小关系",content:'# 函数对象\n\n\n# 函数对象的基本概念\n\n函数对象：如果一个类重载了运算符()，及重载了括号运算符的类，其产生的对象都将成为函数对象。函数对象是个对象，但是用起来看上去像函数调用，实际上也执行了函数调用。\n\n// 函数对象类\nclass CMyAverage{\npublic:\n    double operator() (int a, int b, int c){\n        return (double)(a+b+c)/3;\n    }\n};\n\nint main(){\n    CMyAverage average; // 函数对象\n    cout<<average(3,2,3); // 等价与 average.operator()(3,2,3)\n    return 0;\n}\n\n\n\n# 函数对象的实际应用\n\n例如C++中的accumulate的实现源码如下：\n\ntemplate<typename _InputIterator, typename _Tp, typename _BinaryOperation>\n_Tp accumulate(_InputIterator _first, _InputIterator _last, _Tp init, _BinaryOperation _binary_op){\n    for(;_first != _last; ++_first){\n        _init = _binary_op(_init, *_first); // 传入的实参可以是函数或者函数对象\n    }\n    return _init;\n}\n\n\n在调用accumulate时，和_binary_op形参对应的实参可以是函数或者函数对象\n\n值得注意的是在定义模板template时，使用关键字typename, class并没有什么不同，但是他们又有细微的差别，具体请参考template关键字typename和class的区别,以及模板默认参数\n\n\n# 函数对象的应用示例\n\n//累加平方值\nint sumSquares(int total, int value){\n    return total + value*value;\n}\n// 输出区间[first,last)中的所有元素\ntemplate <typename T>\nvoid printInterval(T first, T last){\n    for(;first!=last;++first){\n        cout << *first<<" ";\n    }\n    cout << endl;\n}\n// 类模板，计算power次方并累加\ntemplate <typename T>\nclass SumPowers{\nprivate:\n    int power;\npublic:\n    SumPowers(int p):power(p){}\n    const T operator()(const T& total, const T& value){\n        T v = value;\n        for(int i=0;i<power-1;++i){\n            v = v*value;\n        }\n        return total+v;\n    }\n};\n// 调用示例\nint main(){\n    vector<int> v{1,2,3,4,5,6,7,8,9,10};\n    cout<<"1)";printInterval(v.begin(),v.end()); // 输出v的所有元素\n    int result = accumulate(v.begin(),v.end(),0,sumSquares); // 使用sumSquares求平方和\n    cout<<"2)"<<result<<endl;\n    result = accumulate(v.begin(),v.end(),0,SumPowers<int>(3)); // SumPowers<int> 是由类模板构造的整型模板类，该模板类由实例化了函数对象SumPowers<int>(3)，来求立方和\n    cout<<"3)"<<result<<endl;\n    result = accumulate(v.begin(),v.end(),0,SumPowers<int>(4));\n    cout<<"4)"<<result<<endl;\n    return 0;\n}\n\n\n上述示例中的函数调用实例化过程：\n\n 1. 求平方和实例化：可以使用函数指针指向函数\n\nint result = accumulate(v.begin(),v.end(),0,sumSquares); // 使用sumSquares求平方和\n// 实例化出\nint accumulate(vector<int>::iterator first,vector<int>::iterator last,int init,int ( * op)( int,int)) // 用函数指针指向函数\n{\n    for ( ; first != last; ++first){\n    \tinit = op(init, *first);\n    }\n    return init;\n}\n\n\n 2. 求立方和实例化：直接使用函数对象指向函数，这样使用面向对象的思想，不用重复编写求次方和的函数\n\nresult = accumulate(v.begin(),v.end(),0,SumPowers<int>(3));\n// 实例化出\nint accumulate(vector<int>::iterator first, vector<int>::iterator last, int init, SumPowers<int> op) // 实例化为函数对象\n{\n    for ( ; first != last; ++first)\n    {\n        init = op(init, *first);\n    }\n    return init;\n}\n\n\n\n# STL 中的函数对象类模板\n\nSTL 中由很多类模板可以用来生成函数对象，例如：euqal_to, greater, less等，他们都包含在#include<functional>头文件中。\n\n# Greater 函数对象类模板\n\ngreater函数对象类模板源码\n\ntemplate<class T>\nstruct greater : public binary_function<T, T, bool> {\n\tbool operator()(const T& x, const T& y) const {\n\t\treturn x > y; //数值大的元素反而小\n\t}\n};\n\n\ngreater函数对象的一个典型应用是在双向队列list的sort成员函数，因为list元素顺序的特殊性不能直接使用 STL 算法提供的sort函数\n\n * 不带参数的sort函数 void sort()：将 list 中的元素按 < 运算符规定的比较方法升序排列\n\n * 带函数对象参数的sort函数\n   \n   > template <typename T>\n   > void sort(T op);\n   > \n   > \n   > 将 list 中的元素按 op 规定的比较方法升序排列，即要比较 x,y 的大小时，看 op(x,y)的返回值，如果返回值为 true 则认为 x小于y，所以 x 应该排在前面\n\n#include <list>\n#include <iostream>\n#include <iterator>\nusing namespace std;\nclass myLess {\npublic:\n    bool operator()(const int & c1, const int & c2){\n    \treturn (c1 % 10) < (c2 % 10); // 个位数较小的元素整体较小\n    }\n};\n\ntemplate <typename T>\nvoid myPrint(T first, T last){\n    for(;first!=last;++first){\n        cout<<*first<<",";\n    }\n}\n\nint main()\n{\n    const int SIZE = 5;\n    int a[SIZE] = {5,21,14,2,3};\n    list<int> lst(a,a+SIZE);\n    lst.sort(myLess()); // 使用函数对象myLess进行排序\n    myPrint(lst.begin(),lst.end());\n    lst.sort(greater<int>()); // 使用greater<int>()函数对象进行排序 数值大的元素反而小\n    //本句进行降序排序\n    myPrint(lst.begin(),lst.end());\n    cout<<endl;\n    return 0;\n}\n\n\n# STL 中的大小关系\n\n关联容器和STL中许多算法，都是可以自定义比较器的; 在自定义了比较器op的情况下，以下三种说法是等价的：\n\n * x 小于 y\n * op(x,y) 返回值为 true\n * y 大于 x\n\n自定义大小关系示例如下：\n\n// 函数对象类\nclass myLess {\npublic:\n    bool operator()(const int & c1, const int & c2){\n    \treturn (c1 % 10) < (c2 % 10); // 个位数较小的元素整体较小\n    }\n};\n\n// 函数调用\nbool myCompare(const int & c1, const int & c2){\n    \treturn (c1 % 10) > (c2 % 10); // 个位数较小的元素整体较小\n}\n\n// 模板类\ntemplate <class T, class Pred>\nT MyMax( T* p, int n, Pred op)\n{\n    T tmpmax = p[0];\n    for( int i = 1;i < n;i ++ ){\n        if(op(tmpmax,p[i]))\n        \ttmpmax = p[i];\n    } \n    return tmpmax;\n};\n\nint main()\n{\n    int a[] = {35,7,13,19,12};\n    cout << MyMax(a,5,MyLess()) << endl; // 自定义函数对象大小比较\n    cout << MyMax(a,5,MyCompare) << endl; // 自定义函数大小比较\n    return 0;\n}\n',normalizedContent:'# 函数对象\n\n\n# 函数对象的基本概念\n\n函数对象：如果一个类重载了运算符()，及重载了括号运算符的类，其产生的对象都将成为函数对象。函数对象是个对象，但是用起来看上去像函数调用，实际上也执行了函数调用。\n\n// 函数对象类\nclass cmyaverage{\npublic:\n    double operator() (int a, int b, int c){\n        return (double)(a+b+c)/3;\n    }\n};\n\nint main(){\n    cmyaverage average; // 函数对象\n    cout<<average(3,2,3); // 等价与 average.operator()(3,2,3)\n    return 0;\n}\n\n\n\n# 函数对象的实际应用\n\n例如c++中的accumulate的实现源码如下：\n\ntemplate<typename _inputiterator, typename _tp, typename _binaryoperation>\n_tp accumulate(_inputiterator _first, _inputiterator _last, _tp init, _binaryoperation _binary_op){\n    for(;_first != _last; ++_first){\n        _init = _binary_op(_init, *_first); // 传入的实参可以是函数或者函数对象\n    }\n    return _init;\n}\n\n\n在调用accumulate时，和_binary_op形参对应的实参可以是函数或者函数对象\n\n值得注意的是在定义模板template时，使用关键字typename, class并没有什么不同，但是他们又有细微的差别，具体请参考template关键字typename和class的区别,以及模板默认参数\n\n\n# 函数对象的应用示例\n\n//累加平方值\nint sumsquares(int total, int value){\n    return total + value*value;\n}\n// 输出区间[first,last)中的所有元素\ntemplate <typename t>\nvoid printinterval(t first, t last){\n    for(;first!=last;++first){\n        cout << *first<<" ";\n    }\n    cout << endl;\n}\n// 类模板，计算power次方并累加\ntemplate <typename t>\nclass sumpowers{\nprivate:\n    int power;\npublic:\n    sumpowers(int p):power(p){}\n    const t operator()(const t& total, const t& value){\n        t v = value;\n        for(int i=0;i<power-1;++i){\n            v = v*value;\n        }\n        return total+v;\n    }\n};\n// 调用示例\nint main(){\n    vector<int> v{1,2,3,4,5,6,7,8,9,10};\n    cout<<"1)";printinterval(v.begin(),v.end()); // 输出v的所有元素\n    int result = accumulate(v.begin(),v.end(),0,sumsquares); // 使用sumsquares求平方和\n    cout<<"2)"<<result<<endl;\n    result = accumulate(v.begin(),v.end(),0,sumpowers<int>(3)); // sumpowers<int> 是由类模板构造的整型模板类，该模板类由实例化了函数对象sumpowers<int>(3)，来求立方和\n    cout<<"3)"<<result<<endl;\n    result = accumulate(v.begin(),v.end(),0,sumpowers<int>(4));\n    cout<<"4)"<<result<<endl;\n    return 0;\n}\n\n\n上述示例中的函数调用实例化过程：\n\n 1. 求平方和实例化：可以使用函数指针指向函数\n\nint result = accumulate(v.begin(),v.end(),0,sumsquares); // 使用sumsquares求平方和\n// 实例化出\nint accumulate(vector<int>::iterator first,vector<int>::iterator last,int init,int ( * op)( int,int)) // 用函数指针指向函数\n{\n    for ( ; first != last; ++first){\n    \tinit = op(init, *first);\n    }\n    return init;\n}\n\n\n 2. 求立方和实例化：直接使用函数对象指向函数，这样使用面向对象的思想，不用重复编写求次方和的函数\n\nresult = accumulate(v.begin(),v.end(),0,sumpowers<int>(3));\n// 实例化出\nint accumulate(vector<int>::iterator first, vector<int>::iterator last, int init, sumpowers<int> op) // 实例化为函数对象\n{\n    for ( ; first != last; ++first)\n    {\n        init = op(init, *first);\n    }\n    return init;\n}\n\n\n\n# stl 中的函数对象类模板\n\nstl 中由很多类模板可以用来生成函数对象，例如：euqal_to, greater, less等，他们都包含在#include<functional>头文件中。\n\n# greater 函数对象类模板\n\ngreater函数对象类模板源码\n\ntemplate<class t>\nstruct greater : public binary_function<t, t, bool> {\n\tbool operator()(const t& x, const t& y) const {\n\t\treturn x > y; //数值大的元素反而小\n\t}\n};\n\n\ngreater函数对象的一个典型应用是在双向队列list的sort成员函数，因为list元素顺序的特殊性不能直接使用 stl 算法提供的sort函数\n\n * 不带参数的sort函数 void sort()：将 list 中的元素按 < 运算符规定的比较方法升序排列\n\n * 带函数对象参数的sort函数\n   \n   > template <typename t>\n   > void sort(t op);\n   > \n   > \n   > 将 list 中的元素按 op 规定的比较方法升序排列，即要比较 x,y 的大小时，看 op(x,y)的返回值，如果返回值为 true 则认为 x小于y，所以 x 应该排在前面\n\n#include <list>\n#include <iostream>\n#include <iterator>\nusing namespace std;\nclass myless {\npublic:\n    bool operator()(const int & c1, const int & c2){\n    \treturn (c1 % 10) < (c2 % 10); // 个位数较小的元素整体较小\n    }\n};\n\ntemplate <typename t>\nvoid myprint(t first, t last){\n    for(;first!=last;++first){\n        cout<<*first<<",";\n    }\n}\n\nint main()\n{\n    const int size = 5;\n    int a[size] = {5,21,14,2,3};\n    list<int> lst(a,a+size);\n    lst.sort(myless()); // 使用函数对象myless进行排序\n    myprint(lst.begin(),lst.end());\n    lst.sort(greater<int>()); // 使用greater<int>()函数对象进行排序 数值大的元素反而小\n    //本句进行降序排序\n    myprint(lst.begin(),lst.end());\n    cout<<endl;\n    return 0;\n}\n\n\n# stl 中的大小关系\n\n关联容器和stl中许多算法，都是可以自定义比较器的; 在自定义了比较器op的情况下，以下三种说法是等价的：\n\n * x 小于 y\n * op(x,y) 返回值为 true\n * y 大于 x\n\n自定义大小关系示例如下：\n\n// 函数对象类\nclass myless {\npublic:\n    bool operator()(const int & c1, const int & c2){\n    \treturn (c1 % 10) < (c2 % 10); // 个位数较小的元素整体较小\n    }\n};\n\n// 函数调用\nbool mycompare(const int & c1, const int & c2){\n    \treturn (c1 % 10) > (c2 % 10); // 个位数较小的元素整体较小\n}\n\n// 模板类\ntemplate <class t, class pred>\nt mymax( t* p, int n, pred op)\n{\n    t tmpmax = p[0];\n    for( int i = 1;i < n;i ++ ){\n        if(op(tmpmax,p[i]))\n        \ttmpmax = p[i];\n    } \n    return tmpmax;\n};\n\nint main()\n{\n    int a[] = {35,7,13,19,12};\n    cout << mymax(a,5,myless()) << endl; // 自定义函数对象大小比较\n    cout << mymax(a,5,mycompare) << endl; // 自定义函数大小比较\n    return 0;\n}\n',charsets:{cjk:!0},lastUpdated:"2023/11/19, 12:55:48",lastUpdatedTimestamp:1700369748e3},{title:"C++ 标准模板库 STL 顺序容器",frontmatter:{title:"C++ 标准模板库 STL 顺序容器",date:"2023-11-18T15:46:10.000Z",permalink:"/pages/6cbf31/"},regularPath:"/01.C&Cpp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/02.C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/02.C++%20STL/05.C++%20%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93%20STL%20%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8.html",relativePath:"01.C&Cpp学习笔记/02.C++面向对象编程/02.C++ STL/05.C++ 标准模板库 STL 顺序容器.md",key:"v-0a5e0a62",path:"/pages/6cbf31/",headers:[{level:2,title:"动态数组 vector",slug:"动态数组-vector",normalizedTitle:"动态数组 vector",charIndex:166},{level:4,title:"构造函数",slug:"构造函数",normalizedTitle:"构造函数",charIndex:1146},{level:4,title:"容量管理函数",slug:"容量管理函数",normalizedTitle:"容量管理函数",charIndex:1399},{level:4,title:"增删函数",slug:"增删函数",normalizedTitle:"增删函数",charIndex:1697},{level:4,title:"索引函数",slug:"索引函数",normalizedTitle:"索引函数",charIndex:2128},{level:4,title:"迭代器函数",slug:"迭代器函数",normalizedTitle:"迭代器函数",charIndex:2311},{level:4,title:"用 vector 实现二维数组",slug:"用-vector-实现二维数组",normalizedTitle:"用 vector 实现二维数组",charIndex:2680},{level:2,title:"双向队列 deque",slug:"双向队列-deque",normalizedTitle:"双向队列 deque",charIndex:3122},{level:2,title:"双向链表 list",slug:"双向链表-list",normalizedTitle:"双向链表 list",charIndex:3574}],headersStr:"动态数组 vector 构造函数 容量管理函数 增删函数 索引函数 迭代器函数 用 vector 实现二维数组 双向队列 deque 双向链表 list",content:'# C++ 标准模板库 STL 顺序容器\n\n容器       数据结构   顺序性   重复性   支持迭代器\nvector   动态数组   无序    可重复   随机访问迭代器\ndeque    双向队列   无序    可重复   随机访问迭代器\nlist     双向链表   无序    可重复   双向迭代器\n\n\n# 动态数组 vector\n\nvector #include <vector> 动态数组：其元素在内存中是连续存放的，随机存取任何元素都可以在常数时间内完成，在该容器的尾部增删元素也几乎能够在常数时间内完成具有较好的性能。\n\n一个 vector 常用函数使用实例如下：\n\n#include <iostream>\n#include <vector>\nusing namespace std;\ntemplate<class T>\nvoid printVector(T s, T e){\n    for(;s != e; ++s){\n        cout << *s << \' \';\n    }\n    cout << endl;\n}\n\nint main(){\n    int a[5] = {1,2,3,4,5};\n    vector<int> v(a,a+5);\n    cout << "1)" << v.end() - v.begin() << endl;\n    cout << "2)";\n    printVector(v.begin(), v.end());\n    v.insert(v.begin()+3, 100); // insert()函数插入元素\n    cout << "3)";\n    printVector(v.begin(), v.end());\n\n    vector<int> v2(5,0);\n    v2.insert(v2.begin()+2,v.begin(),v.end()); // insert() 函数数据块插入  \n    cout << "4)";\n    printVector(v2.begin(), v2.end());   \n    v.erase(v.begin()+3); // erase() 函数删除元素 \n    cout << "5)";\n    printVector(v.begin(), v.end());\n    v.erase(v.begin()+2,v.begin()+4); // erase() 函数删除数据块\n    cout << "6)";\n    printVector(v.begin(), v.end());\n \n    return 0;\n}\n\n\n# 构造函数\n\n函数                      函数描述\nvector                  构造函数创建一个 vector，可以设定大小 nSize\nvector(const vector&)   拷贝构造函数，可以对区间内另一个数组的元素进行拷贝\noperator=               将新内容分配给容器，替换其当前内容，并相应地修改其大小\nassign                  将新内容分配给 vector，替换其当前内容，并相应地修改其 size\n\n# 容量管理函数\n\n函数              函数描述\nsize            返回容器中元素的数量\nmax_size        返回容器可容纳的最大元素数\nresize          调整容器的大小，使其包含 n（参数）个元素\ncapacity        返回当前为 vector 分配的存储空间（容量）的大小\nempty           返回 vector 是否为空\nreserve         请求 vector 容量至少足以包含 n（参数）个元素\nshrink_to_fit   要求容器减小其 capacity（容量）以适应其 size（元素数量）\n\n# 增删函数\n\n函数             函数描述\npush_back      在容器的最后一个元素之后添加一个新元素\npop_back       删除容器中的最后一个元素，有效地将容器 size 减少一个\ninsert         通过在指定位置的元素之前插入新元素来扩展该容器，通过插入元素的数量有效地增加容器大小\nerase          从 vector\n               中删除单个元素（position）或一系列元素（[first，last)），这有效地减少了被去除的元素的数量，从而破坏了容器的大小\nclear          从 vector 中删除所有的元素（被销毁），留下 size 为 0 的容器\nemplace        通过在 position（参数）位置处插入新元素 args（参数）来扩展容器\nemplace_back   在 vector 的末尾插入一个新的元素，紧跟在当前的最后一个元素之后\n\n# 索引函数\n\n函数           函数描述\noperator[]   返回容器中第 n（参数）个位置的元素的引用\nat           返回容器中第 n（参数）个位置的元素的引用\nfront        返回对容器中第一个元素的引用\nback         返回对容器中最后一个元素的引用\ndata         返回指向容器中第一个元素的指针\n\n# 迭代器函数\n\n函数        函数描述\nbegin     返回指向容器中第一个元素的迭代器\nend       返回指向容器中最后一个元素之后的理论元素的迭代器\nrbegin    返回指向容器中最后一个元素的反向迭代器\nrend      返回一个反向迭代器，指向中第一个元素之前的理论元素\ncbegin    返回指向容器中第一个元素的常量迭代器（const_iterator）\ncend      返回指向容器中最后一个元素之后的理论元素的常量迭代器（const_iterator）\ncrbegin   返回指向容器中最后一个元素的常量反向迭代器（const_reverse_iterator）\ncrend     返回指向容器中第一个元素之前的理论元素的常量反向迭代器（const_reverse_iterator）\n\n# 用 vector 实现二维数组\n\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main(){\n    vector<vector<int>> arr(3); // arr中有 3 个元素，每个元素都是 vector<int> 容器\n    for(int i=0; i<arr.size(); ++i){\n        for(int j=0; j<3; ++j){\n            arr[i].push_back(j);\n        }\n    }\n    for(int i=0; i<arr.size(); ++i){\n        for(int j=0; j<3; ++j){\n            cout << arr[i][j] << \' \';\n        }\n        cout << endl;\n    }\n    return 0;\n}\n\n\n\n# 双向队列 deque\n\ndeque #include <deque> 双向队列：其元素在内存中是连续存放的，随机存取任何元素都可以在常数时间内完成，在该容器的两端增删元素也几乎能够在常数时间内完成具有较好的性能。\n\n所有适用于 vector 的操作都适用于 deque，除此之外，deque 还有 push_front / pop_front 在最前端插入或删除元素的操作，复杂的都是 $O(1)$ 。\n\n函数              函数描述\ndeque           构造函数\npush_back       在容器的末尾添加一个新元素\npush_front      在容器的开头插入一个新元素\npop_back        删除容器中的最后一个元素，同时将容器大小减少一个\npop_front       删除容器中的第一个元素，同时将容器大小减少一个\nemplace_front   在容器的开头插入一个新的元素\nemplace_back    在容器的末尾插入一个新的元素\n\n\n# 双向链表 list\n\nlist #include <list> 双向链表：其元素在内存中是不连续存放的，不支持随机存取，在该容器的任何位置增删元素几乎都能够在常数时间内完成具有较好的性能。\n\nlist 除了具有所有顺序容器都有的成员函数之外，还支持以下8个成员函数：\n\n函数           函数描述\npush_front   在容器的开头插入一个新元素\npop_front    删除容器中的第一个元素\nsort         元素排序，值得注意的是 list 不支持 STL 算法中的 sort\nremove       删除和指定值相等的所有元素\nunique       删除所有和前一个元素相同的元素，使得元素不重复，使用之前需要sort\nmerge        合并两个链表，并清空被合并的那个链表\nreverse      颠倒链表内容\nsplice       在指定位置前面插入另一链表中的一个或多个元素，并在该链表中删除这些元素\n\n一个 list 的成员函数使用实例如下：\n\n#include <iostream>\n#include <list>\n#include <algorithm>\nusing namespace std;\n\nclass A{\n    private:\n        int n;\n    public:\n        A(int n_){n = n_;}\n        friend bool operator<(const A & a1, const A & a2);\n        friend bool operator==(const A & a1, const A & a2);\n        friend ostream& operator<<(ostream & o, const A & a2);\n};\n\nbool operator<(const A & a1, const A & a2){\n    return a1.n < a2.n;\n}\n\nbool operator==(const A & a1, const A & a2){\n    return a1.n == a2.n;\n}\n\nostream& operator<<(ostream & o, const A & a2){\n    o << a2.n;\n    return o;\n}\n\ntemplate <class T>\nvoid printList(T start, T end){\n    for(;start != end; ++start){\n        cout << *start << \',\';\n    }\n    cout << endl;\n}\n\nint main(){\n    list<A> lst1, lst2;\n    lst1.push_back(1); lst1.push_back(3);\n    lst1.push_back(2); lst1.push_back(4);\n    lst1.push_back(2);\n    lst2.push_back(10); lst2.push_back(50);\n    lst2.push_back(30); lst2.push_back(30);  \n    lst2.push_back(40); lst2.push_back(40); \n    lst2.push_back(30); lst2.push_back(20);\n    cout << "1) ";\n    printList(lst1.begin(),lst1.end());\n    cout << "2) ";\n    printList(lst2.begin(),lst2.end());\n    lst2.sort(); // 调用 sort 成员函数进行 lst2 排序\n    cout << "3) ";\n    printList(lst2.begin(),lst2.end());\n    lst2.unique(); // 删除 lst2 中所有和前一个元素相等的元素\n    cout << "4) ";\n    printList(lst2.begin(),lst2.end());\n    lst2.pop_front(); // 将 lst2 的第一个元素删除\n    cout << "5) ";\n    printList(lst2.begin(),lst2.end());\n    lst1.remove(2); // 删除 lst1 中所有值为 2 的元素\n    cout << "6) ";\n    printList(lst1.begin(),lst1.end());\n    lst2.merge(lst1); // 将 lst1 中的元素合并到 lst2 并将 lst1 清空\n    cout << "7) ";\n    printList(lst2.begin(),lst2.end());\n    lst2.reverse(); // 颠倒 lst2\n    cout << "8) ";\n    printList(lst2.begin(),lst2.end());\n    \n    lst1.push_back(100); lst1.push_back(200); \n    lst1.push_back(300); lst1.push_back(400);\n    cout<<"9) ";\n    printList(lst1.begin(),lst1.end());\n    // 找到列表中的指定元素\n    list<A>::iterator p1,p2,p3;\n    p1 = find(lst2.begin(),lst2.end(),4);\n    p2 = find(lst1.begin(),lst1.end(),200);\n    p3 = find(lst1.begin(),lst1.end(),400);\n    lst2.splice(p1,lst1,p2,p3); // 将 lst1 中 [p2,p3) 区间内的元素插入到 lst2 中 p1 位置之前，并将这些元素从 lst1 中删除\n    cout<<"10) ";\n    printList(lst1.begin(),lst1.end());\n    cout<<"11) ";\n    printList(lst2.begin(),lst2.end());\n    \n    return 0;\n}\n',normalizedContent:'# c++ 标准模板库 stl 顺序容器\n\n容器       数据结构   顺序性   重复性   支持迭代器\nvector   动态数组   无序    可重复   随机访问迭代器\ndeque    双向队列   无序    可重复   随机访问迭代器\nlist     双向链表   无序    可重复   双向迭代器\n\n\n# 动态数组 vector\n\nvector #include <vector> 动态数组：其元素在内存中是连续存放的，随机存取任何元素都可以在常数时间内完成，在该容器的尾部增删元素也几乎能够在常数时间内完成具有较好的性能。\n\n一个 vector 常用函数使用实例如下：\n\n#include <iostream>\n#include <vector>\nusing namespace std;\ntemplate<class t>\nvoid printvector(t s, t e){\n    for(;s != e; ++s){\n        cout << *s << \' \';\n    }\n    cout << endl;\n}\n\nint main(){\n    int a[5] = {1,2,3,4,5};\n    vector<int> v(a,a+5);\n    cout << "1)" << v.end() - v.begin() << endl;\n    cout << "2)";\n    printvector(v.begin(), v.end());\n    v.insert(v.begin()+3, 100); // insert()函数插入元素\n    cout << "3)";\n    printvector(v.begin(), v.end());\n\n    vector<int> v2(5,0);\n    v2.insert(v2.begin()+2,v.begin(),v.end()); // insert() 函数数据块插入  \n    cout << "4)";\n    printvector(v2.begin(), v2.end());   \n    v.erase(v.begin()+3); // erase() 函数删除元素 \n    cout << "5)";\n    printvector(v.begin(), v.end());\n    v.erase(v.begin()+2,v.begin()+4); // erase() 函数删除数据块\n    cout << "6)";\n    printvector(v.begin(), v.end());\n \n    return 0;\n}\n\n\n# 构造函数\n\n函数                      函数描述\nvector                  构造函数创建一个 vector，可以设定大小 nsize\nvector(const vector&)   拷贝构造函数，可以对区间内另一个数组的元素进行拷贝\noperator=               将新内容分配给容器，替换其当前内容，并相应地修改其大小\nassign                  将新内容分配给 vector，替换其当前内容，并相应地修改其 size\n\n# 容量管理函数\n\n函数              函数描述\nsize            返回容器中元素的数量\nmax_size        返回容器可容纳的最大元素数\nresize          调整容器的大小，使其包含 n（参数）个元素\ncapacity        返回当前为 vector 分配的存储空间（容量）的大小\nempty           返回 vector 是否为空\nreserve         请求 vector 容量至少足以包含 n（参数）个元素\nshrink_to_fit   要求容器减小其 capacity（容量）以适应其 size（元素数量）\n\n# 增删函数\n\n函数             函数描述\npush_back      在容器的最后一个元素之后添加一个新元素\npop_back       删除容器中的最后一个元素，有效地将容器 size 减少一个\ninsert         通过在指定位置的元素之前插入新元素来扩展该容器，通过插入元素的数量有效地增加容器大小\nerase          从 vector\n               中删除单个元素（position）或一系列元素（[first，last)），这有效地减少了被去除的元素的数量，从而破坏了容器的大小\nclear          从 vector 中删除所有的元素（被销毁），留下 size 为 0 的容器\nemplace        通过在 position（参数）位置处插入新元素 args（参数）来扩展容器\nemplace_back   在 vector 的末尾插入一个新的元素，紧跟在当前的最后一个元素之后\n\n# 索引函数\n\n函数           函数描述\noperator[]   返回容器中第 n（参数）个位置的元素的引用\nat           返回容器中第 n（参数）个位置的元素的引用\nfront        返回对容器中第一个元素的引用\nback         返回对容器中最后一个元素的引用\ndata         返回指向容器中第一个元素的指针\n\n# 迭代器函数\n\n函数        函数描述\nbegin     返回指向容器中第一个元素的迭代器\nend       返回指向容器中最后一个元素之后的理论元素的迭代器\nrbegin    返回指向容器中最后一个元素的反向迭代器\nrend      返回一个反向迭代器，指向中第一个元素之前的理论元素\ncbegin    返回指向容器中第一个元素的常量迭代器（const_iterator）\ncend      返回指向容器中最后一个元素之后的理论元素的常量迭代器（const_iterator）\ncrbegin   返回指向容器中最后一个元素的常量反向迭代器（const_reverse_iterator）\ncrend     返回指向容器中第一个元素之前的理论元素的常量反向迭代器（const_reverse_iterator）\n\n# 用 vector 实现二维数组\n\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main(){\n    vector<vector<int>> arr(3); // arr中有 3 个元素，每个元素都是 vector<int> 容器\n    for(int i=0; i<arr.size(); ++i){\n        for(int j=0; j<3; ++j){\n            arr[i].push_back(j);\n        }\n    }\n    for(int i=0; i<arr.size(); ++i){\n        for(int j=0; j<3; ++j){\n            cout << arr[i][j] << \' \';\n        }\n        cout << endl;\n    }\n    return 0;\n}\n\n\n\n# 双向队列 deque\n\ndeque #include <deque> 双向队列：其元素在内存中是连续存放的，随机存取任何元素都可以在常数时间内完成，在该容器的两端增删元素也几乎能够在常数时间内完成具有较好的性能。\n\n所有适用于 vector 的操作都适用于 deque，除此之外，deque 还有 push_front / pop_front 在最前端插入或删除元素的操作，复杂的都是 $o(1)$ 。\n\n函数              函数描述\ndeque           构造函数\npush_back       在容器的末尾添加一个新元素\npush_front      在容器的开头插入一个新元素\npop_back        删除容器中的最后一个元素，同时将容器大小减少一个\npop_front       删除容器中的第一个元素，同时将容器大小减少一个\nemplace_front   在容器的开头插入一个新的元素\nemplace_back    在容器的末尾插入一个新的元素\n\n\n# 双向链表 list\n\nlist #include <list> 双向链表：其元素在内存中是不连续存放的，不支持随机存取，在该容器的任何位置增删元素几乎都能够在常数时间内完成具有较好的性能。\n\nlist 除了具有所有顺序容器都有的成员函数之外，还支持以下8个成员函数：\n\n函数           函数描述\npush_front   在容器的开头插入一个新元素\npop_front    删除容器中的第一个元素\nsort         元素排序，值得注意的是 list 不支持 stl 算法中的 sort\nremove       删除和指定值相等的所有元素\nunique       删除所有和前一个元素相同的元素，使得元素不重复，使用之前需要sort\nmerge        合并两个链表，并清空被合并的那个链表\nreverse      颠倒链表内容\nsplice       在指定位置前面插入另一链表中的一个或多个元素，并在该链表中删除这些元素\n\n一个 list 的成员函数使用实例如下：\n\n#include <iostream>\n#include <list>\n#include <algorithm>\nusing namespace std;\n\nclass a{\n    private:\n        int n;\n    public:\n        a(int n_){n = n_;}\n        friend bool operator<(const a & a1, const a & a2);\n        friend bool operator==(const a & a1, const a & a2);\n        friend ostream& operator<<(ostream & o, const a & a2);\n};\n\nbool operator<(const a & a1, const a & a2){\n    return a1.n < a2.n;\n}\n\nbool operator==(const a & a1, const a & a2){\n    return a1.n == a2.n;\n}\n\nostream& operator<<(ostream & o, const a & a2){\n    o << a2.n;\n    return o;\n}\n\ntemplate <class t>\nvoid printlist(t start, t end){\n    for(;start != end; ++start){\n        cout << *start << \',\';\n    }\n    cout << endl;\n}\n\nint main(){\n    list<a> lst1, lst2;\n    lst1.push_back(1); lst1.push_back(3);\n    lst1.push_back(2); lst1.push_back(4);\n    lst1.push_back(2);\n    lst2.push_back(10); lst2.push_back(50);\n    lst2.push_back(30); lst2.push_back(30);  \n    lst2.push_back(40); lst2.push_back(40); \n    lst2.push_back(30); lst2.push_back(20);\n    cout << "1) ";\n    printlist(lst1.begin(),lst1.end());\n    cout << "2) ";\n    printlist(lst2.begin(),lst2.end());\n    lst2.sort(); // 调用 sort 成员函数进行 lst2 排序\n    cout << "3) ";\n    printlist(lst2.begin(),lst2.end());\n    lst2.unique(); // 删除 lst2 中所有和前一个元素相等的元素\n    cout << "4) ";\n    printlist(lst2.begin(),lst2.end());\n    lst2.pop_front(); // 将 lst2 的第一个元素删除\n    cout << "5) ";\n    printlist(lst2.begin(),lst2.end());\n    lst1.remove(2); // 删除 lst1 中所有值为 2 的元素\n    cout << "6) ";\n    printlist(lst1.begin(),lst1.end());\n    lst2.merge(lst1); // 将 lst1 中的元素合并到 lst2 并将 lst1 清空\n    cout << "7) ";\n    printlist(lst2.begin(),lst2.end());\n    lst2.reverse(); // 颠倒 lst2\n    cout << "8) ";\n    printlist(lst2.begin(),lst2.end());\n    \n    lst1.push_back(100); lst1.push_back(200); \n    lst1.push_back(300); lst1.push_back(400);\n    cout<<"9) ";\n    printlist(lst1.begin(),lst1.end());\n    // 找到列表中的指定元素\n    list<a>::iterator p1,p2,p3;\n    p1 = find(lst2.begin(),lst2.end(),4);\n    p2 = find(lst1.begin(),lst1.end(),200);\n    p3 = find(lst1.begin(),lst1.end(),400);\n    lst2.splice(p1,lst1,p2,p3); // 将 lst1 中 [p2,p3) 区间内的元素插入到 lst2 中 p1 位置之前，并将这些元素从 lst1 中删除\n    cout<<"10) ";\n    printlist(lst1.begin(),lst1.end());\n    cout<<"11) ";\n    printlist(lst2.begin(),lst2.end());\n    \n    return 0;\n}\n',charsets:{cjk:!0},lastUpdated:"2023/11/19, 12:55:48",lastUpdatedTimestamp:1700369748e3},{title:"C++ 标准模板库 STL 容器适配器",frontmatter:{title:"C++ 标准模板库 STL 容器适配器",date:"2023-11-18T15:46:10.000Z",permalink:"/pages/c24021/"},regularPath:"/01.C&Cpp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/02.C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/02.C++%20STL/08.C++%20%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93%20STL%20%E5%AE%B9%E5%99%A8%E9%80%82%E9%85%8D%E5%99%A8.html",relativePath:"01.C&Cpp学习笔记/02.C++面向对象编程/02.C++ STL/08.C++ 标准模板库 STL 容器适配器.md",key:"v-032fbe38",path:"/pages/c24021/",headers:[{level:2,title:"栈 stack",slug:"栈-stack",normalizedTitle:"栈 stack",charIndex:335},{level:2,title:"队列 queue",slug:"队列-queue",normalizedTitle:"队列 queue",charIndex:730},{level:2,title:"优先队列 priority_queue",slug:"优先队列-priority-queue",normalizedTitle:"优先队列 priority_queue",charIndex:1165}],headersStr:"栈 stack 队列 queue 优先队列 priority_queue",content:'# C++ 标准模板库 STL 容器适配器\n\n容器               数据结构                时间复杂度            顺序性   重复性\nstack            deque / list        顶部插入、顶部删除 O(1)   无序    可重复\nqueue            deque / list        尾部插入、头部删除 O(1)   无序    可重复\npriority_queue   vector + max-heap   插入、删除 O(log2n)   有序    可重复\n\n容器适配器和容器的主要差别在于，容器适配器没有迭代器，所以STL中的算法无法直接在容器适配器中使用。\n\n\n# 栈 stack\n\nstack 类模板定义中有2个模板参数如下：\n\ntemplate <typename T, typename Container = deque<T> >\nclass stack { …… };\n\n\n两个参数分别表示栈中元素类型和实现栈的数据结构Container，栈可用 vector, list, deque 来实现，缺省情况下用deque实现；一般情况下推荐使用deque实现，因为用 vector 实现存在是容量大小有限制和扩容耗时的缺陷；而使用list实现则会导致整体性能较差。\n\nstack 是后进先出的数据结构，只能插入，删除，访问栈顶的元素。所以，stack上主要可以进行如下操作：\n\n * push：插入元素\n * pop：弹出元素\n * top：返回栈顶元素的引用\n * empty：判断容器适配器是否为空\n * size：回适配器中元素个数\n\n\n# 队列 queue\n\nqueue 和 stack 基本相似，其类模板定义中也有相同的2个模板参数如下：\n\ntemplate <typename T, typename Container = deque<T> >\nclass queue { …… };\n\n\n两个参数分别表示栈中元素类型和实现栈的数据结构Container，栈可用 vector, list, deque 来实现，缺省情况下用deque实现；一般情况下推荐使用deque实现，因为用 vector 实现存在是容量大小有限制和扩容耗时的缺陷；而使用list实现则会导致整体性能较差。\n\nqueue 是先进先出的数据结构，可以在队头和队尾操作元素。所以，queue 上主要可以进行如下操作：\n\n * push：从队尾插入元素\n * pop：弹出队头元素\n * top：返回队头元素的引用\n * back：返回队尾元素的引用\n * empty：判断容器适配器是否为空\n * size：回适配器中元素个数\n\n\n# 优先队列 priority_queue\n\npriority_queue 类模板定义中有3个模板参数如下：\n\ntemplate <typename T, typename Container = vector<T>, typename Compare = less<T> >\nclass priority_queue { …… };\n\n\npriority_queue 通常使用 vector 实现，其内部元素处理规则通常用堆排序（heap）技术实现，保证最大的元素总是在最前面。即执行pop操作时，删除的是最大的元素；执行top操作时，返回的是最大元素的常引用。默认的元素比较器是使用<运算符进行比较的 less<T>。\n\n和 queue 相似 priority_queue 可以进行如下操作：\n\n * push：从队尾插入元素\n * pop：弹出队头元素\n * top：返回队头元素的引用\n * empty：判断容器适配器是否为空\n * size：回适配器中元素个数\n\n一个 priority_queue 使用示例如下：\n\ninclude <queue>\n#include <iostream>\nusing namespace std;\nint main()\n{\n    priority_queue<double> pq1;\n    pq1.push(3.2); pq1.push(9.8); pq1.push(9.8); pq1.push(5.4);\n    while( !pq1.empty() ) {\n    \tcout << pq1.top() << " ";\n    \tpq1.pop();\n    } \n    cout << endl;\n    \n    priority_queue<double,vector<double>,greater<double> > pq2;\n    pq2.push(3.2); pq2.push(9.8); pq2.push(9.8); pq2.push(5.4);\n    while( !pq2.empty() ) {\n        cout << pq2.top() << " ";\n        pq2.pop();\n    }\n    return 0;\n}\n',normalizedContent:'# c++ 标准模板库 stl 容器适配器\n\n容器               数据结构                时间复杂度            顺序性   重复性\nstack            deque / list        顶部插入、顶部删除 o(1)   无序    可重复\nqueue            deque / list        尾部插入、头部删除 o(1)   无序    可重复\npriority_queue   vector + max-heap   插入、删除 o(log2n)   有序    可重复\n\n容器适配器和容器的主要差别在于，容器适配器没有迭代器，所以stl中的算法无法直接在容器适配器中使用。\n\n\n# 栈 stack\n\nstack 类模板定义中有2个模板参数如下：\n\ntemplate <typename t, typename container = deque<t> >\nclass stack { …… };\n\n\n两个参数分别表示栈中元素类型和实现栈的数据结构container，栈可用 vector, list, deque 来实现，缺省情况下用deque实现；一般情况下推荐使用deque实现，因为用 vector 实现存在是容量大小有限制和扩容耗时的缺陷；而使用list实现则会导致整体性能较差。\n\nstack 是后进先出的数据结构，只能插入，删除，访问栈顶的元素。所以，stack上主要可以进行如下操作：\n\n * push：插入元素\n * pop：弹出元素\n * top：返回栈顶元素的引用\n * empty：判断容器适配器是否为空\n * size：回适配器中元素个数\n\n\n# 队列 queue\n\nqueue 和 stack 基本相似，其类模板定义中也有相同的2个模板参数如下：\n\ntemplate <typename t, typename container = deque<t> >\nclass queue { …… };\n\n\n两个参数分别表示栈中元素类型和实现栈的数据结构container，栈可用 vector, list, deque 来实现，缺省情况下用deque实现；一般情况下推荐使用deque实现，因为用 vector 实现存在是容量大小有限制和扩容耗时的缺陷；而使用list实现则会导致整体性能较差。\n\nqueue 是先进先出的数据结构，可以在队头和队尾操作元素。所以，queue 上主要可以进行如下操作：\n\n * push：从队尾插入元素\n * pop：弹出队头元素\n * top：返回队头元素的引用\n * back：返回队尾元素的引用\n * empty：判断容器适配器是否为空\n * size：回适配器中元素个数\n\n\n# 优先队列 priority_queue\n\npriority_queue 类模板定义中有3个模板参数如下：\n\ntemplate <typename t, typename container = vector<t>, typename compare = less<t> >\nclass priority_queue { …… };\n\n\npriority_queue 通常使用 vector 实现，其内部元素处理规则通常用堆排序（heap）技术实现，保证最大的元素总是在最前面。即执行pop操作时，删除的是最大的元素；执行top操作时，返回的是最大元素的常引用。默认的元素比较器是使用<运算符进行比较的 less<t>。\n\n和 queue 相似 priority_queue 可以进行如下操作：\n\n * push：从队尾插入元素\n * pop：弹出队头元素\n * top：返回队头元素的引用\n * empty：判断容器适配器是否为空\n * size：回适配器中元素个数\n\n一个 priority_queue 使用示例如下：\n\ninclude <queue>\n#include <iostream>\nusing namespace std;\nint main()\n{\n    priority_queue<double> pq1;\n    pq1.push(3.2); pq1.push(9.8); pq1.push(9.8); pq1.push(5.4);\n    while( !pq1.empty() ) {\n    \tcout << pq1.top() << " ";\n    \tpq1.pop();\n    } \n    cout << endl;\n    \n    priority_queue<double,vector<double>,greater<double> > pq2;\n    pq2.push(3.2); pq2.push(9.8); pq2.push(9.8); pq2.push(5.4);\n    while( !pq2.empty() ) {\n        cout << pq2.top() << " ";\n        pq2.pop();\n    }\n    return 0;\n}\n',charsets:{cjk:!0},lastUpdated:"2023/11/19, 12:55:48",lastUpdatedTimestamp:1700369748e3},{title:"C++ 标准模板库 STL 概述",frontmatter:{title:"C++ 标准模板库 STL 概述",date:"2023-11-18T15:46:10.000Z",permalink:"/pages/79b686/"},regularPath:"/01.C&Cpp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/02.C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/02.C++%20STL/04.C++%20%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93%20STL%20%E6%A6%82%E8%BF%B0.html",relativePath:"01.C&Cpp学习笔记/02.C++面向对象编程/02.C++ STL/04.C++ 标准模板库 STL 概述.md",key:"v-2002d43c",path:"/pages/79b686/",headers:[{level:2,title:"泛型程序设计",slug:"泛型程序设计",normalizedTitle:"泛型程序设计",charIndex:23},{level:2,title:"STL 中的基本概念",slug:"stl-中的基本概念",normalizedTitle:"stl 中的基本概念",charIndex:392},{level:2,title:"容器",slug:"容器",normalizedTitle:"容器",charIndex:404},{level:2,title:"迭代器",slug:"迭代器",normalizedTitle:"迭代器",charIndex:432},{level:2,title:"算法",slug:"算法",normalizedTitle:"算法",charIndex:204}],headersStr:"泛型程序设计 STL 中的基本概念 容器 迭代器 算法",content:'# C++ 标准模板库 STL 概述\n\n\n# 泛型程序设计\n\nC++ 的特点：\n\nC++ 的核心优势之一就是便于软件重用，而软件的重用在 C++ 中主要体现在以下两个方面：\n\n * 面向对象的思想：继承、多态和标准类库\n * 泛型程序设计的思想：模板机制和标准模板库 STL\n\n泛型程序设计：\n\n泛型程序设计通俗地讲就是使用模板的程序设计方法。泛型程序设计中将一些常用的数据结构（例如链表、数组和二叉树等）和算法（例如排序和查找等）写成模板，这样在后续的使用中不管数据结构中存放的是什么数据对象，算法应用于什么类型的数据对象，都不需要重新实现数据结构和算法，极大的提高了代码重用性。\n\n标准模板库 (Standard Template Library) 就是最为常用的数据结构和算法的模板集合，使用 STL 可以直接重用大多的标准数据结构和算法，而且能够获得相对较高的性能。\n\n\n# STL 中的基本概念\n\n容器：可容纳各种数据类型的通用数据结构，都是类模板：\n\n迭代器：可用于依次存取容器中的元素，类似指针\n\n算法：用来操作容器中元素的函数模板，例如可以使用 sort() 来对一个 vector 中的数据进行排序，使用 find() 来搜索一个 list 中的对象。算法的实现和它操作的数据对象无关，所以可以将算法应用于几乎任何数据结构。\n\nint array[100]; // 容器\nint* parr = array; // 使用 int* 类型的指针变量作为迭代器\nsort(parr, parr+70); // 使用 sort() 算法作用于该容器\n\n\n\n# 容器\n\n容器是可容纳各种数据类型（基本数据类型、对象等）的通用数据结构，都是类模板，分为三种类型：\n\n * 顺序容器：vector, deque, list\n * 关联容器：set, multiset, map, multimap\n * 容器适配器：stack, queue, priority_queue\n\n使用容器时需要注意两点：\n\n * 对象被插入容器中时，被插入的是对象的一个复制品\n\n * 有些容器本身是存在顺序关系的即是已排序的，所以放入容器的对象所属的类一般需要重载 == 和 < 运算符。STL 中相等 == 和大小 < 的概念是可以自定义的，不局限于数值大小，示例如下：\n   \n   #include <iostream>\n   #include <algorithm>\n   #include <vector>\n   using namespace std;\n   \n   class A{\n       int v;\n   public:\n       A(int n):v(n){};\n       bool operator<(const A& a2) const{\n           cout << v << "<" << a2.v << "?" << endl;\n           return false;\n       }\n       bool operator==(const A& a2) const{\n           cout << v << "==" << a2.v << "?" <<endl;\n           return v == a2.v;\n       }\n   };\n   \n   int main(){\n       A a[] = {A(1),A(2),A(3),A(4),A(5)};\n       cout << binary_search(a,a+4,A(9)); // 折半查找\n       return 0;\n   }\n   /*output: 说明 binary_search()方法没有使用 == 运算符只使用了<\n   3<9?\n   2<9?\n   1<9?\n   9<1?\n   1\n   */\n   \n\n顺序容器：\n\n顺序容器是非排序的，而且其元素的插入位置与元素自身的值无关，数组便于查找，链表便于操作。\n\n * vector #include <vector> 一维动态数组：其元素在内存中是连续存放的，随机存取任何元素都可以在常数时间内完成，在该容器的尾部增删元素也几乎能够在常熟时间内完成具有较好的性能。\n * deque #include <deque> 双向队列：其元素在内存中是连续存放的，随机存取任何元素都可以在常数时间内完成，在该容器的两端增删元素也几乎能够在常熟时间内完成具有较好的性能。\n * list #include <list> 双向链表：其元素在内存中是不连续存放的，不支持随机存取，在该容器的任何位置增删元素几乎都能够在常熟时间内完成具有较好的性能。\n\n关联容器：\n\n关联容器的元素是排序的，插入元素需要根据相应的排序规则来确定插入位置的，在查找时具有较好的性能。关联容器通常使用平衡二叉树实现，其插入和检索的时间都是 $O(log(N))$ 。\n\n * set/multiset #include <set> 集合：set 集合中不允许存在相同的元素，multiset 集合中允许存在相同的元素。\n * map/multimap #include <map> 键值对集合：map 和 set 的不同在于前者存放的元素有且仅有两个成员变量 (first,second)，一个名为 first，另一个名为 second ，first 的值用来对整体元素进行从小到大的排序，并可以通过 first 快速检索元素。和 multiset 类似 multimap 和 map 的区别中允许存在相同 first 值的元素。\n\n容器适配器：\n\n * stack #include <stack> 栈：栈是项都有限序列，并满足序列中被删除、检索和修改的项都只能是最近插入序列的项，即栈顶的项。满足后进先出规则\n * queue #include <queue> 队列：（入队）插入只允许在尾部进行，（出队）删除、检索和修改只允许在头部进行。满足先进先出规则\n * priority_queue #include <queue> 优先级队列：优先级最高的元素总是第一个出队列\n\n顺序容器和关联容器的成员函数：\n\n成员函数       函数作用\nbegin()    返回指向容器中第一个元素位置的迭代器\nend()      返回指向容器中最后一个元素后面的位置的迭代器\nrbegin()   返回指向容器中最后一个元素位置的迭代器\nrend()     返回指向容器中第一个元素前面的位置的迭代器\nerase()    从容器中删除一个或几个元素\nclear()    从容器中删除所有元素\n\n顺序容器的常用成员函数：\n\n成员函数          函数作用\nfront()       返回容器中第一个元素的引用\nback()        返回容器中最后一个元素的引用\npush_back()   在容器末尾增加新元素\npop_back()    删除容器末尾的元素\nerase()       删除迭代器指向的元素，或删除一个区间，返回被删除元素后面的那个元素的迭代器\n\n\n# 迭代器\n\n迭代器的用法和指针类似，用于指向顺序容器和关联容器中的元素。迭代器分为 const 和非 const 两种，通过迭代器可以读取它指向的元素，通过非 const 迭代器可以修改其指向的元素。\n\n容器类的迭代器的定义方式如下，并使用 * 运算符访问迭代器所指向的元素：\n\n容器类名::iterator 变量名; // 非const迭代器\n容器类名::const_iterator 变量名; // const迭代器\n* 迭代器变量名;\n\n\n迭代器上可以执行 ++ 操作来移动迭代器，使其指向容器中的下一个元素。如果迭代器到达了容器中的最后一个元素的后面，此时在使用该迭代器就会出错，类似于使用了未被初始化的指针。\n\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main(){\n    vector<int> v; // 空数组\n    v.push_back(1); v.push_back(2); v.push_back(3); v.push_back(4);\n    vector<int>::const_iterator cit; // const 迭代器\n    for(cit = v.begin(); cit != v.end(); ++cit){\n        cout << *cit << \',\';\n    }\n    cout << endl;\n\n    vector<int>::reverse_iterator rit; // 反向迭代器\n    for(rit = v.rbegin(); rit != v.rend(); ++rit){\n        cout << *rit << \',\';\n    }\n    cout << endl;\n\n    vector<int>::iterator it; // 非 const 迭代器\n    for(it = v.begin(); it != v.end(); ++it){\n        *it += 1;\n        cout << *it << \',\';\n    }\n    cout << endl;\n    return 0;\n}\n\n\n双向迭代器：\n\n可以使用 ++/-- 运算符使迭代器指向容器中的下一个元素或上一个元素，同样也使用 * 运算符取迭代器所指向的元素。除此之外，双向迭代器可以用其他双向迭代器进行赋值 =，和与其他双向迭代器进行相等判定 ==/!=\n\n随机访问迭代器：\n\n除了具备双向迭代器的所有操作，随机访问迭代器还可以指定步长随机移动，例如 p +=/-= i 表示将该迭代器向后或向前移动 i 个元素；p +/- i 表示指向该迭代器之后或之前的第 i 个元素的迭代器；p[i] 表示该迭代器之后的第 i 个元素的引用。除了双向迭代器的相等判定之外，随机访问迭代器可以进行大小判定 <, <=, >, >=。\n\n容器和迭代器：\n\n容器               容器上的迭代器类别\nvector           随机访问迭代器\ndeque            随机访问迭代器\nlist             双向迭代器\nset/multiset     双向迭代器\nmap/multimap     双向迭代器\nstack            不支持迭代器\nqueue            不支持迭代器\npriority_queue   不支持迭代器\n\n容器支持的迭代器也直接限制其支持的算法，有的算法需要使用随机访问迭代器访问容器中的元素，例如 sort(), binary_search() 算法，那么 list 以及关联容器就不支持该算法。\n\n\n# 算法\n\nSTL 中提供了能在各种容器中通用的算法，算法就是函数模板集合，大多数算法都定义在头文件 <algorithm> 中，算法不仅仅只可以对容器进行操作，也可以处理普通数组。\n\n算法通过迭代器来操作容器中的元素，一些算法不仅可以操作整个容器中的元素，也可以只操作容器中的一个局部区间，例如排序和查找算法，所以这类算法一般会带有两个参数，即起始元素的迭代器和终止元素的后一个元素的迭代器。有的算法的返回值是一个迭代器，例如 find() 算法的作用就是在容器中查找一个元素，并返回指向该元素的迭代器。\n\ntemplate <class Inlt, class T>\nInlt find(Inlt first, Inlt last, const T& val); // 查找区间左闭右开 [first, last)，在该区间中找到等于 val 的元素并返回指向该元素的迭代器 \n\n\n#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint main(){\n    int array[10] = {10,20,30,40};\n    vector<int> v;\n    v.push_back(1); v.push_back(2); v.push_back(3); v.push_back(4);\n    vector<int>::iterator it;\n    it = find(v.begin(), v.end(), 3);\n    if(it != v.end()){\n        cout << *it << endl;\n    }\n    // find() 没有找到元素时，返回容器末尾迭代器\n    it = find(v.begin(), v.end(), 9);\n    if(it == v.end()){\n        cout << "not found" << endl;\n    }\n    it = find(v.begin()+1,v.end()-2,2); // 完整容器:[1,2,3,4]，查找的局部区间:[2,3)\n    if(it != v.end()){\n        cout << *it << endl;\n    }\n    // 算法操作普通数组\n    int *parr = find(array,array+4,20);\n    cout<< *parr << endl;\n    return 0;\n}\n',normalizedContent:'# c++ 标准模板库 stl 概述\n\n\n# 泛型程序设计\n\nc++ 的特点：\n\nc++ 的核心优势之一就是便于软件重用，而软件的重用在 c++ 中主要体现在以下两个方面：\n\n * 面向对象的思想：继承、多态和标准类库\n * 泛型程序设计的思想：模板机制和标准模板库 stl\n\n泛型程序设计：\n\n泛型程序设计通俗地讲就是使用模板的程序设计方法。泛型程序设计中将一些常用的数据结构（例如链表、数组和二叉树等）和算法（例如排序和查找等）写成模板，这样在后续的使用中不管数据结构中存放的是什么数据对象，算法应用于什么类型的数据对象，都不需要重新实现数据结构和算法，极大的提高了代码重用性。\n\n标准模板库 (standard template library) 就是最为常用的数据结构和算法的模板集合，使用 stl 可以直接重用大多的标准数据结构和算法，而且能够获得相对较高的性能。\n\n\n# stl 中的基本概念\n\n容器：可容纳各种数据类型的通用数据结构，都是类模板：\n\n迭代器：可用于依次存取容器中的元素，类似指针\n\n算法：用来操作容器中元素的函数模板，例如可以使用 sort() 来对一个 vector 中的数据进行排序，使用 find() 来搜索一个 list 中的对象。算法的实现和它操作的数据对象无关，所以可以将算法应用于几乎任何数据结构。\n\nint array[100]; // 容器\nint* parr = array; // 使用 int* 类型的指针变量作为迭代器\nsort(parr, parr+70); // 使用 sort() 算法作用于该容器\n\n\n\n# 容器\n\n容器是可容纳各种数据类型（基本数据类型、对象等）的通用数据结构，都是类模板，分为三种类型：\n\n * 顺序容器：vector, deque, list\n * 关联容器：set, multiset, map, multimap\n * 容器适配器：stack, queue, priority_queue\n\n使用容器时需要注意两点：\n\n * 对象被插入容器中时，被插入的是对象的一个复制品\n\n * 有些容器本身是存在顺序关系的即是已排序的，所以放入容器的对象所属的类一般需要重载 == 和 < 运算符。stl 中相等 == 和大小 < 的概念是可以自定义的，不局限于数值大小，示例如下：\n   \n   #include <iostream>\n   #include <algorithm>\n   #include <vector>\n   using namespace std;\n   \n   class a{\n       int v;\n   public:\n       a(int n):v(n){};\n       bool operator<(const a& a2) const{\n           cout << v << "<" << a2.v << "?" << endl;\n           return false;\n       }\n       bool operator==(const a& a2) const{\n           cout << v << "==" << a2.v << "?" <<endl;\n           return v == a2.v;\n       }\n   };\n   \n   int main(){\n       a a[] = {a(1),a(2),a(3),a(4),a(5)};\n       cout << binary_search(a,a+4,a(9)); // 折半查找\n       return 0;\n   }\n   /*output: 说明 binary_search()方法没有使用 == 运算符只使用了<\n   3<9?\n   2<9?\n   1<9?\n   9<1?\n   1\n   */\n   \n\n顺序容器：\n\n顺序容器是非排序的，而且其元素的插入位置与元素自身的值无关，数组便于查找，链表便于操作。\n\n * vector #include <vector> 一维动态数组：其元素在内存中是连续存放的，随机存取任何元素都可以在常数时间内完成，在该容器的尾部增删元素也几乎能够在常熟时间内完成具有较好的性能。\n * deque #include <deque> 双向队列：其元素在内存中是连续存放的，随机存取任何元素都可以在常数时间内完成，在该容器的两端增删元素也几乎能够在常熟时间内完成具有较好的性能。\n * list #include <list> 双向链表：其元素在内存中是不连续存放的，不支持随机存取，在该容器的任何位置增删元素几乎都能够在常熟时间内完成具有较好的性能。\n\n关联容器：\n\n关联容器的元素是排序的，插入元素需要根据相应的排序规则来确定插入位置的，在查找时具有较好的性能。关联容器通常使用平衡二叉树实现，其插入和检索的时间都是 $o(log(n))$ 。\n\n * set/multiset #include <set> 集合：set 集合中不允许存在相同的元素，multiset 集合中允许存在相同的元素。\n * map/multimap #include <map> 键值对集合：map 和 set 的不同在于前者存放的元素有且仅有两个成员变量 (first,second)，一个名为 first，另一个名为 second ，first 的值用来对整体元素进行从小到大的排序，并可以通过 first 快速检索元素。和 multiset 类似 multimap 和 map 的区别中允许存在相同 first 值的元素。\n\n容器适配器：\n\n * stack #include <stack> 栈：栈是项都有限序列，并满足序列中被删除、检索和修改的项都只能是最近插入序列的项，即栈顶的项。满足后进先出规则\n * queue #include <queue> 队列：（入队）插入只允许在尾部进行，（出队）删除、检索和修改只允许在头部进行。满足先进先出规则\n * priority_queue #include <queue> 优先级队列：优先级最高的元素总是第一个出队列\n\n顺序容器和关联容器的成员函数：\n\n成员函数       函数作用\nbegin()    返回指向容器中第一个元素位置的迭代器\nend()      返回指向容器中最后一个元素后面的位置的迭代器\nrbegin()   返回指向容器中最后一个元素位置的迭代器\nrend()     返回指向容器中第一个元素前面的位置的迭代器\nerase()    从容器中删除一个或几个元素\nclear()    从容器中删除所有元素\n\n顺序容器的常用成员函数：\n\n成员函数          函数作用\nfront()       返回容器中第一个元素的引用\nback()        返回容器中最后一个元素的引用\npush_back()   在容器末尾增加新元素\npop_back()    删除容器末尾的元素\nerase()       删除迭代器指向的元素，或删除一个区间，返回被删除元素后面的那个元素的迭代器\n\n\n# 迭代器\n\n迭代器的用法和指针类似，用于指向顺序容器和关联容器中的元素。迭代器分为 const 和非 const 两种，通过迭代器可以读取它指向的元素，通过非 const 迭代器可以修改其指向的元素。\n\n容器类的迭代器的定义方式如下，并使用 * 运算符访问迭代器所指向的元素：\n\n容器类名::iterator 变量名; // 非const迭代器\n容器类名::const_iterator 变量名; // const迭代器\n* 迭代器变量名;\n\n\n迭代器上可以执行 ++ 操作来移动迭代器，使其指向容器中的下一个元素。如果迭代器到达了容器中的最后一个元素的后面，此时在使用该迭代器就会出错，类似于使用了未被初始化的指针。\n\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main(){\n    vector<int> v; // 空数组\n    v.push_back(1); v.push_back(2); v.push_back(3); v.push_back(4);\n    vector<int>::const_iterator cit; // const 迭代器\n    for(cit = v.begin(); cit != v.end(); ++cit){\n        cout << *cit << \',\';\n    }\n    cout << endl;\n\n    vector<int>::reverse_iterator rit; // 反向迭代器\n    for(rit = v.rbegin(); rit != v.rend(); ++rit){\n        cout << *rit << \',\';\n    }\n    cout << endl;\n\n    vector<int>::iterator it; // 非 const 迭代器\n    for(it = v.begin(); it != v.end(); ++it){\n        *it += 1;\n        cout << *it << \',\';\n    }\n    cout << endl;\n    return 0;\n}\n\n\n双向迭代器：\n\n可以使用 ++/-- 运算符使迭代器指向容器中的下一个元素或上一个元素，同样也使用 * 运算符取迭代器所指向的元素。除此之外，双向迭代器可以用其他双向迭代器进行赋值 =，和与其他双向迭代器进行相等判定 ==/!=\n\n随机访问迭代器：\n\n除了具备双向迭代器的所有操作，随机访问迭代器还可以指定步长随机移动，例如 p +=/-= i 表示将该迭代器向后或向前移动 i 个元素；p +/- i 表示指向该迭代器之后或之前的第 i 个元素的迭代器；p[i] 表示该迭代器之后的第 i 个元素的引用。除了双向迭代器的相等判定之外，随机访问迭代器可以进行大小判定 <, <=, >, >=。\n\n容器和迭代器：\n\n容器               容器上的迭代器类别\nvector           随机访问迭代器\ndeque            随机访问迭代器\nlist             双向迭代器\nset/multiset     双向迭代器\nmap/multimap     双向迭代器\nstack            不支持迭代器\nqueue            不支持迭代器\npriority_queue   不支持迭代器\n\n容器支持的迭代器也直接限制其支持的算法，有的算法需要使用随机访问迭代器访问容器中的元素，例如 sort(), binary_search() 算法，那么 list 以及关联容器就不支持该算法。\n\n\n# 算法\n\nstl 中提供了能在各种容器中通用的算法，算法就是函数模板集合，大多数算法都定义在头文件 <algorithm> 中，算法不仅仅只可以对容器进行操作，也可以处理普通数组。\n\n算法通过迭代器来操作容器中的元素，一些算法不仅可以操作整个容器中的元素，也可以只操作容器中的一个局部区间，例如排序和查找算法，所以这类算法一般会带有两个参数，即起始元素的迭代器和终止元素的后一个元素的迭代器。有的算法的返回值是一个迭代器，例如 find() 算法的作用就是在容器中查找一个元素，并返回指向该元素的迭代器。\n\ntemplate <class inlt, class t>\ninlt find(inlt first, inlt last, const t& val); // 查找区间左闭右开 [first, last)，在该区间中找到等于 val 的元素并返回指向该元素的迭代器 \n\n\n#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint main(){\n    int array[10] = {10,20,30,40};\n    vector<int> v;\n    v.push_back(1); v.push_back(2); v.push_back(3); v.push_back(4);\n    vector<int>::iterator it;\n    it = find(v.begin(), v.end(), 3);\n    if(it != v.end()){\n        cout << *it << endl;\n    }\n    // find() 没有找到元素时，返回容器末尾迭代器\n    it = find(v.begin(), v.end(), 9);\n    if(it == v.end()){\n        cout << "not found" << endl;\n    }\n    it = find(v.begin()+1,v.end()-2,2); // 完整容器:[1,2,3,4]，查找的局部区间:[2,3)\n    if(it != v.end()){\n        cout << *it << endl;\n    }\n    // 算法操作普通数组\n    int *parr = find(array,array+4,20);\n    cout<< *parr << endl;\n    return 0;\n}\n',charsets:{cjk:!0},lastUpdated:"2023/11/19, 12:55:48",lastUpdatedTimestamp:1700369748e3},{title:"C++11 新特性",frontmatter:{title:"C++11 新特性",date:"2023-11-18T15:46:10.000Z",permalink:"/pages/dc0db4/"},regularPath:"/01.C&Cpp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/02.C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/03.C++%20%E6%96%B0%E7%89%B9%E6%80%A7/01.C++11%20%E6%96%B0%E7%89%B9%E6%80%A7.html",relativePath:"01.C&Cpp学习笔记/02.C++面向对象编程/03.C++ 新特性/01.C++11 新特性.md",key:"v-10b51f52",path:"/pages/dc0db4/",headers:[{level:2,title:"统一的初始化方法",slug:"统一的初始化方法",normalizedTitle:"统一的初始化方法",charIndex:16},{level:2,title:"auto关键字",slug:"auto关键字",normalizedTitle:"auto关键字",charIndex:857},{level:2,title:"decltype关键字",slug:"decltype关键字",normalizedTitle:"decltype关键字",charIndex:1799},{level:2,title:"返回类型后置",slug:"返回类型后置",normalizedTitle:"返回类型后置",charIndex:2792},{level:2,title:"右值引用与移动构造函数",slug:"右值引用与移动构造函数",normalizedTitle:"右值引用与移动构造函数",charIndex:3362},{level:3,title:"左值和右值的基本概念",slug:"左值和右值的基本概念",normalizedTitle:"左值和右值的基本概念",charIndex:3378},{level:3,title:"右值引用",slug:"右值引用",normalizedTitle:"右值引用",charIndex:3362},{level:3,title:"移动构造函数",slug:"移动构造函数",normalizedTitle:"移动构造函数",charIndex:3367},{level:3,title:"move函数",slug:"move函数",normalizedTitle:"move函数",charIndex:4439},{level:2,title:"智能指针 shared_ptr",slug:"智能指针-shared-ptr",normalizedTitle:"智能指针 shared_ptr",charIndex:6504},{level:2,title:"空指针 nullptr",slug:"空指针-nullptr",normalizedTitle:"空指针 nullptr",charIndex:8649},{level:2,title:"基于范围的 for 循环",slug:"基于范围的-for-循环",normalizedTitle:"基于范围的 for 循环",charIndex:9506},{level:2,title:"无序容器",slug:"无序容器",normalizedTitle:"无序容器",charIndex:10435},{level:2,title:"Lambda 表达式",slug:"lambda-表达式",normalizedTitle:"lambda 表达式",charIndex:11610}],headersStr:"统一的初始化方法 auto关键字 decltype关键字 返回类型后置 右值引用与移动构造函数 左值和右值的基本概念 右值引用 移动构造函数 move函数 智能指针 shared_ptr 空指针 nullptr 基于范围的 for 循环 无序容器 Lambda 表达式",content:'# C++11 新特性\n\n\n# 统一的初始化方法\n\n在C++11中可以直接在变量名后加上初始化列表来对对象进行初始化。\n\n在此之前，C++中的初始化方式很多，有初始化列表、拷贝初始化和直接初始化等，例如：\n\nclass A{\npublic:\n    int a; int b;\n    A(int _a, int_b):a(_a), b(_b){}\n    A(const A& obja){\n        a = obja.a; b = obja.b;\n    }\n};\n\nint main(){\n\tint arr[3] = {1,2,3}; // 初始化列表\n    A a(1,2); // 直接初始化\n    A a2(a); // 拷贝初始化\n    return 0;\n}\n\n\n这些不同的初始化方法，都有各自的适用范围和作用。最关键的是，这些种类繁多的初始化方法，没有一种可以通用所有情况。为了统一初始化方式，并且让初始化行为具有确定的效果，C++11 中提出了初始化列表（List-initialization）的概念。\n\n这种方式扩大了原先的初始化列表的初始化方式的适用范围，在C++11中任何类型的对象都可以采用这种初始化方式，例如：\n\nint main(){\n    int arr[3]{1, 2, 3};\n    vector<int> iv{1, 2, 3};\n    map<int, string> mp{{1, "a"}, {2, "b"}};\n    string str{"Hello World"};\n    int* p = new int[20]{1,2,3}; // 动态数组使用初始化列表\n    \n    A a{1,2};\n    A* a1 = new A{1,2}; // new一个临时对象，然后荣过拷贝构造函数初始化a1\n}\n\n// 初始化列表作为函数返回值\nA func(int m, int n){\n    return {m,n};\n}\n\n\n\n# auto关键字\n\nC++11 中 auto 关键字被用来做自动类型变量推导。也就是说，使用了 auto 关键字以后，编译器会在编译期间自动推导出变量的类型，不再需要手动指明变量的数据类型，值得注意的是：auto的自动类型推导是根据变量的右值推到出变量的类型的，所以使用auto关键字时需要对变量进行初始化。简单使用示例如下：\n\nauto i = 100;     // i 是 int\nauto p = new A(); // p 是 A *\nauto k = 34343LL; // k 是 long long\nauto *p = &i, j=100; // 连续定义多个变量,但是auto在推导的时候不能有二义性，即i和j的类型应该保持一致\n\n\n使用auto定义STL迭代器\n\nauto 的一个典型应用场景是用来定义 STL 的迭代器，使用迭代器遍历容器时，需要编写复杂冗长的容器类型，而使用auto关键字可以大大简化这一场景：\n\nvoid printMap(map<string,int,greater<string> > mp){\n    for( auto i = mp.begin(); i != mp.end(); ++i){\n        cout << i->first << "," << i->second ;\n    }\n}\n\n\n在上述例子中如果不使用auto关键字定义迭代器auto i = mp.begin();，那么就需要写全该迭代器类型map<string,int,greater<string> >::iterator i = mp.begin();。而是用auto就可以直接通过mp.begin()的返回值类型来推导出迭代器i的类型。\n\nauto用于泛型编程\n\n在泛型编程中，往往不清楚变量的具体类型，有些情况下需要不具体指明变量的类型到达更加灵活编程的目的，而auto关键字就为这种需求提供了可能，例如：\n\nclass A { };\nA operator + ( int n,const A & a){ // 重载+运算符,用具计算 int+A 的情况\n\treturn a;\n}\n\n//模板函数 实现两对象相加 函数的返回值类型auto推到 而decltype关键字用于推到出表达式的类型\ntemplate <typename T1, typename T2>\nauto add(T1 x, T2 y) -> decltype(x + y){ \n\treturn x+y;\n}\n\nint main(){\n    auto ans1 = add(100,1.5); // ans1 double类型\n    auto ans2 = add(100,A()); // ans2 A类型\n}\n\n\n上述例子中 ans1是 double 类型因为其值为101.5；而 ans2 是A类型，模板函数 add 的函数体内是x+y，+运算符又被重载过，通过计算返回值是A()创建的A类型的临时对象。\n\n\n# decltype关键字\n\ndecltype(declare type) 声明类型，和auto关键字一样，decltype 关键字也被用来自动类型推导。和 auto 关键字 根据=右边的初始值 value 推导出变量的类型不同，decltype 关键字根据表达式推导出变量的类型，该表达式可以是任意复杂的形式，但是必须保证表达式的结果是有类型的，不可以是void。decltype 使用示例如下：\n\nint main(){\n    int i;\n    double t;\n    struct A { double x; };\n    const A* a = new A();\n    decltype(a) x1; // x1 is A *\n    decltype(i) x2; // x2 is int\n    decltype(a->x) x3; // x3 is double\n    decltype((a->x)) x4 = t; // x4 is double&\n}\n\n\ndecltype 自动推导类型主要按照一下三条规则：\n\n * 如上例中的x1, x2, x3，如果decltype声明的表达式是普通变量、一般表达式或者是类成员访问表达式，其推导结果与表达式类型一致\n * 如auto关键字中的模板函数示例中，如果decltype用于声明函数调用类型，则其推导结果与函数返回值的类型一致\n * 如上例中的x4，如果decltype声明的表达式是一个左值，或者被()括号括起，那么其推导结果为该表达式类型的引用\n\n\n# 返回类型后置\n\n返回类型后置语法是将 decltype 和 auto 结合起来完成返回值类型的推导。这种语法的提出是为了解决数返回值类型依赖于参数而导致难以确定返回值类型的问题，例如 auto 关键字中的add模板函数示例：\n\ntemplate <typename T1, typename T2>\nauto add(T1 x, T2 y) -> decltype(x + y){ \n\treturn x+y;\n}\n\n\nauto func() -> decltype(exp) 就是返回类型后置语法，如果不采用这种语法，该函数的实现就会变得很复杂：\n\ntemplate <typename T1, typename T2>\ndecltype(x + y) add(T1 x, T2 y){ // 这种写法是明显错误的，因为decltype(x + y)中的x,y还未定义\n\treturn x+y;\n}\n\ntemplate <typename T1, typename T2>\ndecltype(T1() + T2()) add(T1 x, T2 y){ // 这种写法的前提是T1,T2类均有无参构造函数\n\treturn x+y;\n}\n\n\n总的来说，使用返回类型后置语法在一些特殊场景中，能够更简洁明了的描述出函数返回值的类型推导。\n\n\n# 右值引用与移动构造函数\n\n\n# 左值和右值的基本概念\n\n左值和右值：左值是指那些在表达式执行结束后依然存在的数据，也就是持久性的数据；右值是指那些在表达式执行结束后不再存在的数据，也就是临时性的数据。有一种很简单的方法来区分左值和右值，对表达式取地址，如果编译器不报错就为左值，否则为右值。简而言之：有名称的、可以获取到存储地址的表达式即为左值；反之则是右值。例如：\n\nint a = 5;\nint b = a; // a,b均为左值\n5 = a;    // 错误，5是右值\n\n\n\n# 右值引用\n\n在之前的C++引用中通常指的是左值引用，即允许使用常量左值引用操作右值，但不支持为右值建立非常量左值引用，例如：\n\nclass A{};\nint main(){\n    A a = A();\n    A& b = a; // 左值引用\n    A& c = A(); // 错误，A()是无名变量，是右值\n    A&& c = A(); // 右值引用\n}\n\n\n为此，C++11中提出了右值引用使用&&表示，和声明左值引用一样，右值引用也必须立即进行初始化操作，且只能使用右值进行初始化。提出右值引用的主要目的是提高程序运行的效率，减少需要进行深拷贝的对象进行深拷贝的次数。\n\n\n# 移动构造函数\n\nC++通常使用拷贝构造函数初始化一个同类新对象，而当类中拥有指针类型的成员变量时，拷贝构造函数中需要以深拷贝（而非浅拷贝）的方式复制该指针成员，这将导致严重的深拷贝效率问题\n\n为此C++11中采用右值引用提出了移动构造函数，指的就是以移动而非深拷贝的方式初始化含有指针成员的类对象。通俗的讲，移动构造函数就是将其他对象（通常是临时对象）拥有的内存资源移为已用。对于程序执行过程中产生的临时对象，往往只用于传递数据（没有其它的用处），并且会很快会被销毁。因此在使用临时对象初始化新对象时，我们可以将其包含的指针成员指向的内存资源直接移给新对象所有，无需再新拷贝一份，这大大提高了初始化的执行效率。\n\n当类中同时包含拷贝构造函数和移动构造函数时，如果使用临时对象初始化当前类的对象，编译器会优先调用移动构造函数来完成此操作。只有当类中没有合适的移动构造函数时，编译器才会退而求其次，调用拷贝构造函数。所以，通常在类中自定义移动构造函数的同时，会再为其自定义一个适当的拷贝构造函数，由此当用户利用右值初始化类对象时，会调用移动构造函数；使用左值（非右值）初始化类对象时，会调用拷贝构造函数。\n\n移动构造函数的调用时机是：用同类的右值对象初始化新对象\n\n\n# move函数\n\n默认情况下，左值初始化同类对象只能通过拷贝构造函数完成，如果想调用移动构造函数，则必须使用右值进行初始化。为了能够使用左值初始化同类对象时也通过移动构造函数完成，C++11提出了move函数：它可以将左值强制转换成对应的右值，由此便可以使用移动构造函数。\n\nmove函数语法为move(a)，其中 a 表示指定的左值对象，该函数会返回 a 对象的右值形式。\n\n一个移动构造函数使用示例：\n\n#include <iostream>\n#include <string>\n#include <cstring>\nusing namespace std;\n\nclass String\n{\npublic:\n    char * str;\n    // 构造函数\n    String():str(new char[1]) { str[0] = 0;}\n    String(const char * s) {\n        str = new char[strlen(s)+1];\n        strcpy(str,s);\n    }\n    // 拷贝构造函数\n    String(const String & s) {\n        cout << "copy constructor called" << endl;\n        str = new char[strlen(s.str)+1];\n        strcpy(str,s.str);\n    }\n    // 重载赋值运算符拷贝构造函数\n    String & operator=(const String & s) {\n\t\tcout << "copy operator= called" << endl;\n        if( str != s.str) {\n            delete [] str;\n            str = new char[strlen(s.str)+1];\n            strcpy(str,s.str);\n        }\n        return * this;\n\t}\n    // 移动构造函数\n    String(String && s):str(s.str) { // String && s 右值引用\n        cout << "move constructor called"<<endl;\n        s.str = new char[1];\n        s.str[0] = 0;\n\t}\n    // 重载赋值运算符移动构造函数\n    String & operator = (String &&s) {\n\t\tcout << "move operator= called"<<endl;\n        if (str!= s.str) {\n            delete [] str;\n            str = s.str;\n            s.str = new char[1];\n            s.str[0] = 0;\n        }\n        return *this;\n\t}\n    // 析构函数\n    ~String() { delete [] str; }\n};\n\ntemplate <typename T>\nvoid moveSwap(T& a, T& b){\n    T tmp(move(a)); // 直接构造 std::move(a) 为右值，move constructor called\n    a = move(b);    // 赋值号拷贝构造 move(b) 为右值，move operator= called\n    b = move(tmp);\t// 赋值号拷贝构造 move(tmp) 为右值，move operator= called\n}\n\nint main(){\n    String s;\n    s = String("ok"); // String("ok")是右值\n    String && r = String("this"); // r 为String("this")右值引用\n    cout << r.str << endl;\n    String s1 = "hello",s2 = "world";\n    moveSwap(s1,s2);\n    cout << s1.str << \',\' << s2.str << endl;\n    return 0;\n}\n/* Output:\nmove operator= called\nthis\nmove constructor called\nmove operator= called\nmove operator= called\nworld,hello\n*/\n\n\n\n# 智能指针 shared_ptr\n\n大部分面向对象的程序语言中都有垃圾回收机制，而 C++ 中一直缺乏这种友好的内存管理机制。这也带来了很多内存资源管理不当的问题，例如：\n\n * 野指针-指向了内存资源已经被释放的空间并被继续使用；\n * 重复释放内存-内存资源在已经被释放的情况下，被试图再次释放导致程序崩溃；\n * 内存泄漏-没有及时释放不再使用的内存资源，致使程序运行过程中占用的内存资源不断累加，最终导致程序崩溃。\n\nC++11中提出了 shared_ptr, unique_ptr, weak_ptr三种智能指针用于实现堆内存的自动回收，这种智能指针和普通指针的用法是相似的，不同之处在于，智能指针可以在适当时机自动释放分配的内存，而这种机制将有效避免内存泄漏的问题。\n\n> C++ 智能指针底层是采用引用计数的方式实现的。简单的理解，智能指针在申请堆内存空间的同时，会为其配备一个整形值（初始值为 1），每当有新对象使用此堆内存时，该整形值 +1；反之，每当使用此堆内存的对象被释放时，该整形值减 1。当堆空间对应的整形值为 0 时，即表明不再有对象使用它，该堆空间就会被释放掉。\n\n此处介绍相对较为常用的shared_ptr指针，和其他智能指针一样，shared_ptr也是以类模板的方式定义在<memory>头文件中的，并位于 std 命名空间中。\n\n通过shared_ptr的构造函数，可以让shared_ptr对象托管一个new运算符返回的指针，写法如下：\n\nshared_ptr<T> ptr(new T); // T 表示指针指向的具体数据类型\n\n\n声明智能指针ptr后，该指针就可以像普通T*类型的指针一样来使用，即可以使用*ptr取new动态分配的那个对象，同时也不必操心使用完后需要主动delete释放内存。\n\n值得注意的是，多个shared_ptr对象可以同时托管一个指针，系统会维护一个引用计数，如果有shared_ptr对象不再托管该指针，则将引用计数减 1，通过这种方式达到不影响其他指向同一指针 shared_ptr 对象的目的。只有引用计数为 0 时，即没有任何shared_ptr对象托管该指针时，delete该指针，其对应的堆内存才会被自动释放。\n\n一个智能指针的使用示例：\n\n#include <memory>\n#include <iostream>\nusing namespace std;\nstruct A {\n    int n;\n    A(int v = 0):n(v){ }\n    ~A() { cout << n << " destructor" << endl;\n};\n    \nint main()\n{\n    shared_ptr<A> sp1(new A(2)); //sp1托管A(2)\n    shared_ptr<A> sp2(sp1); //sp2与sp1共同托管A(2)\n    cout << sp1->n << "," << sp2->n << endl;\n    A* p = sp1.get(); //p 指向 A(2)\n    cout <<  p->n << endl;\n    shared_ptr<A> sp3;\n    sp3 = sp1; //sp3也托管 A(2)\n\tcout << (*sp3).n << endl; // 使用.号运算符取对象成员\n    \n    // 使用reset()函数重置shared_ptr托管的指针\n    sp1.reset(); //sp1放弃托管 A(2)\n\tif( !sp1 )\n\t\tcout << "sp1 is null" << endl;\n    A * q = new A(3);\n\tsp1.reset(q); // sp1托管q\n    cout << sp1->n << endl;\n\t\n    // 使用shared_ptr的一种常见错误\n    shared_ptr<A> sp4;\n    sp4.reset(q); // 这中托管方式并不会增加对指针q的引用计数，在程序结束时由于sp1和sp4的共同指向导致多次尝试释放q所指向的内存空间\n    \n    // 验证引用指针计数为0时，shared_ptr托管的指针指向的空间被自动释放\n    shared_ptr<A> sp5(sp1); // sp5也托管q A(3)\n    sp1.reset(); //sp1放弃托管 q\n    cout << "before end main" << endl;\n    sp5.reset(); //sp5放弃托管 q，A(3)的引用计数为0，被自动释放，调用析构函数\n    cout << "end main" << endl;\n    return 0; //程序结束，会delete掉 A(2) 调用析构函数\n    /* 验证引用指针计数部分的输出为\n    before end main\n    3 destructor\n    end main\n    2 destructor\n    */\n}\n\n\n\n# 空指针 nullptr\n\n野指针往往没有明确的指向，这将极有可能导致程序发生异常。而避免产生野指针最为有效的方法就是在定义指针的同时完成初始化操作，而对于那些指向尚未明确的指针，就需要将其初始化为空指针。\n\n通常情况下都使用NULL对指针进行初始化，而该关键字在C++中其实就是一个事先定义号的宏#define NULL 0，可以看出NULL被定义为一个字面常量0，在一些特殊情况下，这将带来一定的缺陷导致程序运行错误。\n\n为了进一步完善对指针的初始化，C++11中提出了nullptr空指针关键字，nullptr 是 nullptr_t 类型的右值常量，专用于初始化空类型指针。nullptr_t 被称为指针空值类型，而 nullptr 则是该类型的一个实例，nullptr 可以被隐式转换成任意的指针类型，但是它无法隐式转换为整型，即语句int i = nullptr;将导致错误。\n\n总的来说，使用 nullptr 初始化空指针可以让程序更加健壮，但是仍然兼容 NULL 关键字。\n\n一个空指针 nullptr的使用示例：\n\n#include <memory>\n#include <iostream>\nusing namespace std;\nint main()\n{\n    int* p1 = NULL;\n    int* p2 = nullptr;\n    shared_ptr<double> p3 = nullptr;\n    if( p1 == p2)\n    \tcout << "equal 1" <<endl;\n    if( p3 == nullptr)\n        cout << "equal 2" <<endl;\n    if( p3 == NULL)\n        cout << "equal 3" <<endl;\n    bool b = nullptr; // nullptr 可以被隐式转换为bool类型 b = false\n    return 0;\n}\n\n\n\n# 基于范围的 for 循环\n\n为了更加便捷地遍历 STL 容器，C++11中为 for 循环添加了一种全新的语法格式-基于范围的for循环：\n\nfor (declaration : expression){\n    //循环体\n}\n\n\n * declaration：表示此处要定义一个变量，该变量的类型为要遍历序列中存储元素的类型。需要注意的是，C++ 11 标准中，declaration 参数处定义的变量类型可以用 auto 关键字表示，使用该关键字让编译器自行推导出变量的数据类型。\n * expression：表示要遍历的序列，常见的有普通数组或者 STL 容器等，还可以是用 {}大括号初始化的序列。\n\n与传统的 for 循环语法规则相比较，可以看出基于范围的 for 循环语法没有明确限定遍历范围，而只会逐个遍历 序列中的每个元素，直到全部遍历完成结束。\n\n在使用基于范围的 for 循环时，值得注意的是：\n\n * 可以使用 auto关键字声明变量，自动推导数据类型\n * 可以使用 引用形式的变量，在遍历序列的过程中修改器内部元素的值\n\n一个基于范围的 for 循环使用示例如下：\n\n#include <iostream>\n#include <vector>\nusing namespace std;\nstruct A {\n\tint n; \n    A(int i):n(i) {}\n};\n\nint main() {\n    // 遍历普通数组\n\tint ary[] = {1,2,3,4,5}; \n    for(int e : ary)\n    \tcout << e << ",";\n    cout << endl;\n    \n    // 遍历并修改数组元素\n    for(int & e: ary)\n        e*= 10;\n    \n    // 遍历STL容器\n\tvector<A> st(ary,ary+5);\n\tfor( auto & it: st) // 使用auto关键字\n\t\tit.n *= 10;\n\tfor( A it: st)\n\t\tcout << it.n << ",";\n\treturn 0;\n}\n\n\n\n# 无序容器\n\n和关联容器一样，无序容器也使用键值对（pair 类型）的方式存储数据，但是他们在底层实现上有着本质上的不同：关联容器是采用红黑树结构实现的，而无序容器则是采用哈希表的存储结构实现的。\n\n基于哈希表实现的无序容器，相较于关联容器有如下两个主要特点：\n\n * 无序容器内部存储的键值对是无序的，各键值对的存储位置取决于该键值对中的键\n * 由于采用哈希表的存储结构，无序容器在通过指定键查找对应的值的效率能够达到常数级别；而在遍历容器的使用场景下，无序容器的执行效率明显差于关联容器\n\nC++11标准的 STL 中，在已经提供关联容器set/multiset, map/multimap的情况下，又采用哈希表的存储结构对应新增了无序容器unordered_set/unordered_multiset, unordered_map/unordered_multimap，提高了元素插入与查找的效率。\n\n总的来说，无序容器和关联容器的使用方法一致，区别在于无序容器的无序型，以及其在查找应用场景中提供的高效率查找。\n\n一个使用无序容器 unordered_map 的示例如下：\n\n#include <iostream>\n#include <string>\n#include <unordered_map>\nusing namespace std;\nint main()\n{\n    unordered_map<string,int> turingWinner; \n    // 使用 insert() 成员函数插入pair对象\n    turingWinner.insert(make_pair("Dijkstra",1972));\n    turingWinner.insert(make_pair("Scott",1976));\n    turingWinner.insert(make_pair("Wilkes",1967));\n    turingWinner.insert(make_pair("Hamming",1968));\n    // 使用 重载[]运算符的成员函数插入元素\n    turingWinner["Ritchie"] = 1983;\n    \n    string name;\n\tcin >> name;\n    // 使用 find() 成员函数查找指定元素\n    unordered_map<string,int>::iterator p = turingWinner.find(name);\n\tif( p != turingWinner.end())\n\t\tcout << p->second;\n\telse\n\t\tcout << "Not Found" << endl;\n\treturn 0;\n}\n\n\n\n# Lambda 表达式\n\n就向一些临时变量一样，也存在临时函数的情况。有些简单函数或函数对象在整个程序中可能只需要被调用或使用一次。这样一次性的函数，如果为其单独声明函数或者编写一个类，可能降低程序的可读性。而C++11中提供的 Lambda 表达式提供了避免这一问题的方法，使用 Lambda 表达式构建匿名函数。\n\nLambda 表达式的简单语法格式如下，他和普通函数的唯一区别在于其没有名称用[外部变量]代替其名称，即普通函数是func_name (parm_list) -> return_type{fucntion_body;} 而 Lambda表达式声明的匿名函数没有函数名称[extra_parm] (parm_list) -> return_type{fucntion_body;}\n\n[外部变量访问方式说明符](参数表) -> 返回值类型\n{\n\t语句组;\n}\n\n\n * 外部变量：[]方括号用于向编译器表明当前是一个 lambda 表达式，类似于声明一个 lambda 表达式的关键字。在方括号内部，可以注明当前 lambda 函数的函数体中可以使用哪些外部变量，而外部变量指的是和当前 lambda 表达式位于同一作用域内的所有局部变量。外部变量的使用受以值还是以引用方式传递影响，[外部变量]的几种常用定义方式如下\n   \n   > 外部变量格式      说明\n   > []          不使用任何外部变量\n   > [=]         只有一个 = 等号，表示以传值的形式使用所有外部变量\n   > [&]         只有一个 & 符号，表示以引用形式使用所有外部变量\n   > [x, &y]     x 以传值形式使用，y 以引用形式使用\n   > [=,&x,&y]   x,y 以引用形式使用，其余变量以传值形式使用\n   > [&,x,y]     x,y 以传值的形式使用，其余变量以引用形式使用\n\n * 参数表：和普通函数的定义一样，lambda 匿名函数也可以接收外部传递的多个参数。和普通函数不同的是，如果不需要传递参数，可以连同 ()小括号一起省略\n\n * 返回值类型：在编写 lambda 表达式时，可以省略返回值类型，没有指定返回值类型则编译器自动推断其返回值类型\n\n * 语句组（函数体）：和普通函数一样，lambda 匿名函数包含的内部代码都放置在函数体中。该函数体内除了可以使用指定传递进来的参数之外，还可以使用指定的外部变量以及全局范围内的所有全局变量。需要注意的是，外部变量会受到以值传递还是以引用传递方式引入的影响，而全局变量则不会。换句话说，在 lambda 表达式内可以使用任意一个全局变量，必要时还可以直接修改它们的值\n\n一个 Lambda 表达式的使用示例如下：\n\n#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\nint main()\n{\n    int x = 100,y=200,z=300;\n    // 不使用任何外部变量\n    cout << [ ](double a,double b) { return a + b; }(1.2,2.5) << endl;\n    // y,z以传引用的方式使用，x以传值方式使用\n    auto ff = [=,&y,&z](int n) {\n    \tcout << x << endl;\n        y++; z++;\n        return n*n;\n    };\n    cout << ff(15) << endl;\n    cout << y << "," << z << endl;\n    \n    // 结合STL算法使用 Lambda 表达式，构造匿名函数对象\n    int a[4] = { 4,2,11,33};\n    sort(a,a+4,[ ](int x,int y) ->bool {\n        return x%10 < y%10; \n    });\n    \n    // 结合STL容器和算法使用 Lambda 表达式\n    vector<int> a { 1,2,3,4};\n    int total = 0;\n    for_each(a.begin(),a.end(),[&](int & x){\n        total += x; x*=2;\n    });\n    cout << total << endl; \n    for_each(a.begin(),a.end(),[](int x){ \n        cout << x << " ";\n    });\n    return 0;\n}\n',normalizedContent:'# c++11 新特性\n\n\n# 统一的初始化方法\n\n在c++11中可以直接在变量名后加上初始化列表来对对象进行初始化。\n\n在此之前，c++中的初始化方式很多，有初始化列表、拷贝初始化和直接初始化等，例如：\n\nclass a{\npublic:\n    int a; int b;\n    a(int _a, int_b):a(_a), b(_b){}\n    a(const a& obja){\n        a = obja.a; b = obja.b;\n    }\n};\n\nint main(){\n\tint arr[3] = {1,2,3}; // 初始化列表\n    a a(1,2); // 直接初始化\n    a a2(a); // 拷贝初始化\n    return 0;\n}\n\n\n这些不同的初始化方法，都有各自的适用范围和作用。最关键的是，这些种类繁多的初始化方法，没有一种可以通用所有情况。为了统一初始化方式，并且让初始化行为具有确定的效果，c++11 中提出了初始化列表（list-initialization）的概念。\n\n这种方式扩大了原先的初始化列表的初始化方式的适用范围，在c++11中任何类型的对象都可以采用这种初始化方式，例如：\n\nint main(){\n    int arr[3]{1, 2, 3};\n    vector<int> iv{1, 2, 3};\n    map<int, string> mp{{1, "a"}, {2, "b"}};\n    string str{"hello world"};\n    int* p = new int[20]{1,2,3}; // 动态数组使用初始化列表\n    \n    a a{1,2};\n    a* a1 = new a{1,2}; // new一个临时对象，然后荣过拷贝构造函数初始化a1\n}\n\n// 初始化列表作为函数返回值\na func(int m, int n){\n    return {m,n};\n}\n\n\n\n# auto关键字\n\nc++11 中 auto 关键字被用来做自动类型变量推导。也就是说，使用了 auto 关键字以后，编译器会在编译期间自动推导出变量的类型，不再需要手动指明变量的数据类型，值得注意的是：auto的自动类型推导是根据变量的右值推到出变量的类型的，所以使用auto关键字时需要对变量进行初始化。简单使用示例如下：\n\nauto i = 100;     // i 是 int\nauto p = new a(); // p 是 a *\nauto k = 34343ll; // k 是 long long\nauto *p = &i, j=100; // 连续定义多个变量,但是auto在推导的时候不能有二义性，即i和j的类型应该保持一致\n\n\n使用auto定义stl迭代器\n\nauto 的一个典型应用场景是用来定义 stl 的迭代器，使用迭代器遍历容器时，需要编写复杂冗长的容器类型，而使用auto关键字可以大大简化这一场景：\n\nvoid printmap(map<string,int,greater<string> > mp){\n    for( auto i = mp.begin(); i != mp.end(); ++i){\n        cout << i->first << "," << i->second ;\n    }\n}\n\n\n在上述例子中如果不使用auto关键字定义迭代器auto i = mp.begin();，那么就需要写全该迭代器类型map<string,int,greater<string> >::iterator i = mp.begin();。而是用auto就可以直接通过mp.begin()的返回值类型来推导出迭代器i的类型。\n\nauto用于泛型编程\n\n在泛型编程中，往往不清楚变量的具体类型，有些情况下需要不具体指明变量的类型到达更加灵活编程的目的，而auto关键字就为这种需求提供了可能，例如：\n\nclass a { };\na operator + ( int n,const a & a){ // 重载+运算符,用具计算 int+a 的情况\n\treturn a;\n}\n\n//模板函数 实现两对象相加 函数的返回值类型auto推到 而decltype关键字用于推到出表达式的类型\ntemplate <typename t1, typename t2>\nauto add(t1 x, t2 y) -> decltype(x + y){ \n\treturn x+y;\n}\n\nint main(){\n    auto ans1 = add(100,1.5); // ans1 double类型\n    auto ans2 = add(100,a()); // ans2 a类型\n}\n\n\n上述例子中 ans1是 double 类型因为其值为101.5；而 ans2 是a类型，模板函数 add 的函数体内是x+y，+运算符又被重载过，通过计算返回值是a()创建的a类型的临时对象。\n\n\n# decltype关键字\n\ndecltype(declare type) 声明类型，和auto关键字一样，decltype 关键字也被用来自动类型推导。和 auto 关键字 根据=右边的初始值 value 推导出变量的类型不同，decltype 关键字根据表达式推导出变量的类型，该表达式可以是任意复杂的形式，但是必须保证表达式的结果是有类型的，不可以是void。decltype 使用示例如下：\n\nint main(){\n    int i;\n    double t;\n    struct a { double x; };\n    const a* a = new a();\n    decltype(a) x1; // x1 is a *\n    decltype(i) x2; // x2 is int\n    decltype(a->x) x3; // x3 is double\n    decltype((a->x)) x4 = t; // x4 is double&\n}\n\n\ndecltype 自动推导类型主要按照一下三条规则：\n\n * 如上例中的x1, x2, x3，如果decltype声明的表达式是普通变量、一般表达式或者是类成员访问表达式，其推导结果与表达式类型一致\n * 如auto关键字中的模板函数示例中，如果decltype用于声明函数调用类型，则其推导结果与函数返回值的类型一致\n * 如上例中的x4，如果decltype声明的表达式是一个左值，或者被()括号括起，那么其推导结果为该表达式类型的引用\n\n\n# 返回类型后置\n\n返回类型后置语法是将 decltype 和 auto 结合起来完成返回值类型的推导。这种语法的提出是为了解决数返回值类型依赖于参数而导致难以确定返回值类型的问题，例如 auto 关键字中的add模板函数示例：\n\ntemplate <typename t1, typename t2>\nauto add(t1 x, t2 y) -> decltype(x + y){ \n\treturn x+y;\n}\n\n\nauto func() -> decltype(exp) 就是返回类型后置语法，如果不采用这种语法，该函数的实现就会变得很复杂：\n\ntemplate <typename t1, typename t2>\ndecltype(x + y) add(t1 x, t2 y){ // 这种写法是明显错误的，因为decltype(x + y)中的x,y还未定义\n\treturn x+y;\n}\n\ntemplate <typename t1, typename t2>\ndecltype(t1() + t2()) add(t1 x, t2 y){ // 这种写法的前提是t1,t2类均有无参构造函数\n\treturn x+y;\n}\n\n\n总的来说，使用返回类型后置语法在一些特殊场景中，能够更简洁明了的描述出函数返回值的类型推导。\n\n\n# 右值引用与移动构造函数\n\n\n# 左值和右值的基本概念\n\n左值和右值：左值是指那些在表达式执行结束后依然存在的数据，也就是持久性的数据；右值是指那些在表达式执行结束后不再存在的数据，也就是临时性的数据。有一种很简单的方法来区分左值和右值，对表达式取地址，如果编译器不报错就为左值，否则为右值。简而言之：有名称的、可以获取到存储地址的表达式即为左值；反之则是右值。例如：\n\nint a = 5;\nint b = a; // a,b均为左值\n5 = a;    // 错误，5是右值\n\n\n\n# 右值引用\n\n在之前的c++引用中通常指的是左值引用，即允许使用常量左值引用操作右值，但不支持为右值建立非常量左值引用，例如：\n\nclass a{};\nint main(){\n    a a = a();\n    a& b = a; // 左值引用\n    a& c = a(); // 错误，a()是无名变量，是右值\n    a&& c = a(); // 右值引用\n}\n\n\n为此，c++11中提出了右值引用使用&&表示，和声明左值引用一样，右值引用也必须立即进行初始化操作，且只能使用右值进行初始化。提出右值引用的主要目的是提高程序运行的效率，减少需要进行深拷贝的对象进行深拷贝的次数。\n\n\n# 移动构造函数\n\nc++通常使用拷贝构造函数初始化一个同类新对象，而当类中拥有指针类型的成员变量时，拷贝构造函数中需要以深拷贝（而非浅拷贝）的方式复制该指针成员，这将导致严重的深拷贝效率问题\n\n为此c++11中采用右值引用提出了移动构造函数，指的就是以移动而非深拷贝的方式初始化含有指针成员的类对象。通俗的讲，移动构造函数就是将其他对象（通常是临时对象）拥有的内存资源移为已用。对于程序执行过程中产生的临时对象，往往只用于传递数据（没有其它的用处），并且会很快会被销毁。因此在使用临时对象初始化新对象时，我们可以将其包含的指针成员指向的内存资源直接移给新对象所有，无需再新拷贝一份，这大大提高了初始化的执行效率。\n\n当类中同时包含拷贝构造函数和移动构造函数时，如果使用临时对象初始化当前类的对象，编译器会优先调用移动构造函数来完成此操作。只有当类中没有合适的移动构造函数时，编译器才会退而求其次，调用拷贝构造函数。所以，通常在类中自定义移动构造函数的同时，会再为其自定义一个适当的拷贝构造函数，由此当用户利用右值初始化类对象时，会调用移动构造函数；使用左值（非右值）初始化类对象时，会调用拷贝构造函数。\n\n移动构造函数的调用时机是：用同类的右值对象初始化新对象\n\n\n# move函数\n\n默认情况下，左值初始化同类对象只能通过拷贝构造函数完成，如果想调用移动构造函数，则必须使用右值进行初始化。为了能够使用左值初始化同类对象时也通过移动构造函数完成，c++11提出了move函数：它可以将左值强制转换成对应的右值，由此便可以使用移动构造函数。\n\nmove函数语法为move(a)，其中 a 表示指定的左值对象，该函数会返回 a 对象的右值形式。\n\n一个移动构造函数使用示例：\n\n#include <iostream>\n#include <string>\n#include <cstring>\nusing namespace std;\n\nclass string\n{\npublic:\n    char * str;\n    // 构造函数\n    string():str(new char[1]) { str[0] = 0;}\n    string(const char * s) {\n        str = new char[strlen(s)+1];\n        strcpy(str,s);\n    }\n    // 拷贝构造函数\n    string(const string & s) {\n        cout << "copy constructor called" << endl;\n        str = new char[strlen(s.str)+1];\n        strcpy(str,s.str);\n    }\n    // 重载赋值运算符拷贝构造函数\n    string & operator=(const string & s) {\n\t\tcout << "copy operator= called" << endl;\n        if( str != s.str) {\n            delete [] str;\n            str = new char[strlen(s.str)+1];\n            strcpy(str,s.str);\n        }\n        return * this;\n\t}\n    // 移动构造函数\n    string(string && s):str(s.str) { // string && s 右值引用\n        cout << "move constructor called"<<endl;\n        s.str = new char[1];\n        s.str[0] = 0;\n\t}\n    // 重载赋值运算符移动构造函数\n    string & operator = (string &&s) {\n\t\tcout << "move operator= called"<<endl;\n        if (str!= s.str) {\n            delete [] str;\n            str = s.str;\n            s.str = new char[1];\n            s.str[0] = 0;\n        }\n        return *this;\n\t}\n    // 析构函数\n    ~string() { delete [] str; }\n};\n\ntemplate <typename t>\nvoid moveswap(t& a, t& b){\n    t tmp(move(a)); // 直接构造 std::move(a) 为右值，move constructor called\n    a = move(b);    // 赋值号拷贝构造 move(b) 为右值，move operator= called\n    b = move(tmp);\t// 赋值号拷贝构造 move(tmp) 为右值，move operator= called\n}\n\nint main(){\n    string s;\n    s = string("ok"); // string("ok")是右值\n    string && r = string("this"); // r 为string("this")右值引用\n    cout << r.str << endl;\n    string s1 = "hello",s2 = "world";\n    moveswap(s1,s2);\n    cout << s1.str << \',\' << s2.str << endl;\n    return 0;\n}\n/* output:\nmove operator= called\nthis\nmove constructor called\nmove operator= called\nmove operator= called\nworld,hello\n*/\n\n\n\n# 智能指针 shared_ptr\n\n大部分面向对象的程序语言中都有垃圾回收机制，而 c++ 中一直缺乏这种友好的内存管理机制。这也带来了很多内存资源管理不当的问题，例如：\n\n * 野指针-指向了内存资源已经被释放的空间并被继续使用；\n * 重复释放内存-内存资源在已经被释放的情况下，被试图再次释放导致程序崩溃；\n * 内存泄漏-没有及时释放不再使用的内存资源，致使程序运行过程中占用的内存资源不断累加，最终导致程序崩溃。\n\nc++11中提出了 shared_ptr, unique_ptr, weak_ptr三种智能指针用于实现堆内存的自动回收，这种智能指针和普通指针的用法是相似的，不同之处在于，智能指针可以在适当时机自动释放分配的内存，而这种机制将有效避免内存泄漏的问题。\n\n> c++ 智能指针底层是采用引用计数的方式实现的。简单的理解，智能指针在申请堆内存空间的同时，会为其配备一个整形值（初始值为 1），每当有新对象使用此堆内存时，该整形值 +1；反之，每当使用此堆内存的对象被释放时，该整形值减 1。当堆空间对应的整形值为 0 时，即表明不再有对象使用它，该堆空间就会被释放掉。\n\n此处介绍相对较为常用的shared_ptr指针，和其他智能指针一样，shared_ptr也是以类模板的方式定义在<memory>头文件中的，并位于 std 命名空间中。\n\n通过shared_ptr的构造函数，可以让shared_ptr对象托管一个new运算符返回的指针，写法如下：\n\nshared_ptr<t> ptr(new t); // t 表示指针指向的具体数据类型\n\n\n声明智能指针ptr后，该指针就可以像普通t*类型的指针一样来使用，即可以使用*ptr取new动态分配的那个对象，同时也不必操心使用完后需要主动delete释放内存。\n\n值得注意的是，多个shared_ptr对象可以同时托管一个指针，系统会维护一个引用计数，如果有shared_ptr对象不再托管该指针，则将引用计数减 1，通过这种方式达到不影响其他指向同一指针 shared_ptr 对象的目的。只有引用计数为 0 时，即没有任何shared_ptr对象托管该指针时，delete该指针，其对应的堆内存才会被自动释放。\n\n一个智能指针的使用示例：\n\n#include <memory>\n#include <iostream>\nusing namespace std;\nstruct a {\n    int n;\n    a(int v = 0):n(v){ }\n    ~a() { cout << n << " destructor" << endl;\n};\n    \nint main()\n{\n    shared_ptr<a> sp1(new a(2)); //sp1托管a(2)\n    shared_ptr<a> sp2(sp1); //sp2与sp1共同托管a(2)\n    cout << sp1->n << "," << sp2->n << endl;\n    a* p = sp1.get(); //p 指向 a(2)\n    cout <<  p->n << endl;\n    shared_ptr<a> sp3;\n    sp3 = sp1; //sp3也托管 a(2)\n\tcout << (*sp3).n << endl; // 使用.号运算符取对象成员\n    \n    // 使用reset()函数重置shared_ptr托管的指针\n    sp1.reset(); //sp1放弃托管 a(2)\n\tif( !sp1 )\n\t\tcout << "sp1 is null" << endl;\n    a * q = new a(3);\n\tsp1.reset(q); // sp1托管q\n    cout << sp1->n << endl;\n\t\n    // 使用shared_ptr的一种常见错误\n    shared_ptr<a> sp4;\n    sp4.reset(q); // 这中托管方式并不会增加对指针q的引用计数，在程序结束时由于sp1和sp4的共同指向导致多次尝试释放q所指向的内存空间\n    \n    // 验证引用指针计数为0时，shared_ptr托管的指针指向的空间被自动释放\n    shared_ptr<a> sp5(sp1); // sp5也托管q a(3)\n    sp1.reset(); //sp1放弃托管 q\n    cout << "before end main" << endl;\n    sp5.reset(); //sp5放弃托管 q，a(3)的引用计数为0，被自动释放，调用析构函数\n    cout << "end main" << endl;\n    return 0; //程序结束，会delete掉 a(2) 调用析构函数\n    /* 验证引用指针计数部分的输出为\n    before end main\n    3 destructor\n    end main\n    2 destructor\n    */\n}\n\n\n\n# 空指针 nullptr\n\n野指针往往没有明确的指向，这将极有可能导致程序发生异常。而避免产生野指针最为有效的方法就是在定义指针的同时完成初始化操作，而对于那些指向尚未明确的指针，就需要将其初始化为空指针。\n\n通常情况下都使用null对指针进行初始化，而该关键字在c++中其实就是一个事先定义号的宏#define null 0，可以看出null被定义为一个字面常量0，在一些特殊情况下，这将带来一定的缺陷导致程序运行错误。\n\n为了进一步完善对指针的初始化，c++11中提出了nullptr空指针关键字，nullptr 是 nullptr_t 类型的右值常量，专用于初始化空类型指针。nullptr_t 被称为指针空值类型，而 nullptr 则是该类型的一个实例，nullptr 可以被隐式转换成任意的指针类型，但是它无法隐式转换为整型，即语句int i = nullptr;将导致错误。\n\n总的来说，使用 nullptr 初始化空指针可以让程序更加健壮，但是仍然兼容 null 关键字。\n\n一个空指针 nullptr的使用示例：\n\n#include <memory>\n#include <iostream>\nusing namespace std;\nint main()\n{\n    int* p1 = null;\n    int* p2 = nullptr;\n    shared_ptr<double> p3 = nullptr;\n    if( p1 == p2)\n    \tcout << "equal 1" <<endl;\n    if( p3 == nullptr)\n        cout << "equal 2" <<endl;\n    if( p3 == null)\n        cout << "equal 3" <<endl;\n    bool b = nullptr; // nullptr 可以被隐式转换为bool类型 b = false\n    return 0;\n}\n\n\n\n# 基于范围的 for 循环\n\n为了更加便捷地遍历 stl 容器，c++11中为 for 循环添加了一种全新的语法格式-基于范围的for循环：\n\nfor (declaration : expression){\n    //循环体\n}\n\n\n * declaration：表示此处要定义一个变量，该变量的类型为要遍历序列中存储元素的类型。需要注意的是，c++ 11 标准中，declaration 参数处定义的变量类型可以用 auto 关键字表示，使用该关键字让编译器自行推导出变量的数据类型。\n * expression：表示要遍历的序列，常见的有普通数组或者 stl 容器等，还可以是用 {}大括号初始化的序列。\n\n与传统的 for 循环语法规则相比较，可以看出基于范围的 for 循环语法没有明确限定遍历范围，而只会逐个遍历 序列中的每个元素，直到全部遍历完成结束。\n\n在使用基于范围的 for 循环时，值得注意的是：\n\n * 可以使用 auto关键字声明变量，自动推导数据类型\n * 可以使用 引用形式的变量，在遍历序列的过程中修改器内部元素的值\n\n一个基于范围的 for 循环使用示例如下：\n\n#include <iostream>\n#include <vector>\nusing namespace std;\nstruct a {\n\tint n; \n    a(int i):n(i) {}\n};\n\nint main() {\n    // 遍历普通数组\n\tint ary[] = {1,2,3,4,5}; \n    for(int e : ary)\n    \tcout << e << ",";\n    cout << endl;\n    \n    // 遍历并修改数组元素\n    for(int & e: ary)\n        e*= 10;\n    \n    // 遍历stl容器\n\tvector<a> st(ary,ary+5);\n\tfor( auto & it: st) // 使用auto关键字\n\t\tit.n *= 10;\n\tfor( a it: st)\n\t\tcout << it.n << ",";\n\treturn 0;\n}\n\n\n\n# 无序容器\n\n和关联容器一样，无序容器也使用键值对（pair 类型）的方式存储数据，但是他们在底层实现上有着本质上的不同：关联容器是采用红黑树结构实现的，而无序容器则是采用哈希表的存储结构实现的。\n\n基于哈希表实现的无序容器，相较于关联容器有如下两个主要特点：\n\n * 无序容器内部存储的键值对是无序的，各键值对的存储位置取决于该键值对中的键\n * 由于采用哈希表的存储结构，无序容器在通过指定键查找对应的值的效率能够达到常数级别；而在遍历容器的使用场景下，无序容器的执行效率明显差于关联容器\n\nc++11标准的 stl 中，在已经提供关联容器set/multiset, map/multimap的情况下，又采用哈希表的存储结构对应新增了无序容器unordered_set/unordered_multiset, unordered_map/unordered_multimap，提高了元素插入与查找的效率。\n\n总的来说，无序容器和关联容器的使用方法一致，区别在于无序容器的无序型，以及其在查找应用场景中提供的高效率查找。\n\n一个使用无序容器 unordered_map 的示例如下：\n\n#include <iostream>\n#include <string>\n#include <unordered_map>\nusing namespace std;\nint main()\n{\n    unordered_map<string,int> turingwinner; \n    // 使用 insert() 成员函数插入pair对象\n    turingwinner.insert(make_pair("dijkstra",1972));\n    turingwinner.insert(make_pair("scott",1976));\n    turingwinner.insert(make_pair("wilkes",1967));\n    turingwinner.insert(make_pair("hamming",1968));\n    // 使用 重载[]运算符的成员函数插入元素\n    turingwinner["ritchie"] = 1983;\n    \n    string name;\n\tcin >> name;\n    // 使用 find() 成员函数查找指定元素\n    unordered_map<string,int>::iterator p = turingwinner.find(name);\n\tif( p != turingwinner.end())\n\t\tcout << p->second;\n\telse\n\t\tcout << "not found" << endl;\n\treturn 0;\n}\n\n\n\n# lambda 表达式\n\n就向一些临时变量一样，也存在临时函数的情况。有些简单函数或函数对象在整个程序中可能只需要被调用或使用一次。这样一次性的函数，如果为其单独声明函数或者编写一个类，可能降低程序的可读性。而c++11中提供的 lambda 表达式提供了避免这一问题的方法，使用 lambda 表达式构建匿名函数。\n\nlambda 表达式的简单语法格式如下，他和普通函数的唯一区别在于其没有名称用[外部变量]代替其名称，即普通函数是func_name (parm_list) -> return_type{fucntion_body;} 而 lambda表达式声明的匿名函数没有函数名称[extra_parm] (parm_list) -> return_type{fucntion_body;}\n\n[外部变量访问方式说明符](参数表) -> 返回值类型\n{\n\t语句组;\n}\n\n\n * 外部变量：[]方括号用于向编译器表明当前是一个 lambda 表达式，类似于声明一个 lambda 表达式的关键字。在方括号内部，可以注明当前 lambda 函数的函数体中可以使用哪些外部变量，而外部变量指的是和当前 lambda 表达式位于同一作用域内的所有局部变量。外部变量的使用受以值还是以引用方式传递影响，[外部变量]的几种常用定义方式如下\n   \n   > 外部变量格式      说明\n   > []          不使用任何外部变量\n   > [=]         只有一个 = 等号，表示以传值的形式使用所有外部变量\n   > [&]         只有一个 & 符号，表示以引用形式使用所有外部变量\n   > [x, &y]     x 以传值形式使用，y 以引用形式使用\n   > [=,&x,&y]   x,y 以引用形式使用，其余变量以传值形式使用\n   > [&,x,y]     x,y 以传值的形式使用，其余变量以引用形式使用\n\n * 参数表：和普通函数的定义一样，lambda 匿名函数也可以接收外部传递的多个参数。和普通函数不同的是，如果不需要传递参数，可以连同 ()小括号一起省略\n\n * 返回值类型：在编写 lambda 表达式时，可以省略返回值类型，没有指定返回值类型则编译器自动推断其返回值类型\n\n * 语句组（函数体）：和普通函数一样，lambda 匿名函数包含的内部代码都放置在函数体中。该函数体内除了可以使用指定传递进来的参数之外，还可以使用指定的外部变量以及全局范围内的所有全局变量。需要注意的是，外部变量会受到以值传递还是以引用传递方式引入的影响，而全局变量则不会。换句话说，在 lambda 表达式内可以使用任意一个全局变量，必要时还可以直接修改它们的值\n\n一个 lambda 表达式的使用示例如下：\n\n#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\nint main()\n{\n    int x = 100,y=200,z=300;\n    // 不使用任何外部变量\n    cout << [ ](double a,double b) { return a + b; }(1.2,2.5) << endl;\n    // y,z以传引用的方式使用，x以传值方式使用\n    auto ff = [=,&y,&z](int n) {\n    \tcout << x << endl;\n        y++; z++;\n        return n*n;\n    };\n    cout << ff(15) << endl;\n    cout << y << "," << z << endl;\n    \n    // 结合stl算法使用 lambda 表达式，构造匿名函数对象\n    int a[4] = { 4,2,11,33};\n    sort(a,a+4,[ ](int x,int y) ->bool {\n        return x%10 < y%10; \n    });\n    \n    // 结合stl容器和算法使用 lambda 表达式\n    vector<int> a { 1,2,3,4};\n    int total = 0;\n    for_each(a.begin(),a.end(),[&](int & x){\n        total += x; x*=2;\n    });\n    cout << total << endl; \n    for_each(a.begin(),a.end(),[](int x){ \n        cout << x << " ";\n    });\n    return 0;\n}\n',charsets:{cjk:!0},lastUpdated:"2023/11/19, 12:55:48",lastUpdatedTimestamp:1700369748e3},{title:"变量与常量",frontmatter:{title:"变量与常量",date:"2023-03-24T16:48:20.000Z",permalink:"/pages/4b9df2/"},regularPath:"/02.Golang%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/01.Golang%E5%9F%BA%E7%A1%80/01.%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/01.%E5%8F%98%E9%87%8F%E4%B8%8E%E5%B8%B8%E9%87%8F.html",relativePath:"02.Golang学习笔记/01.Golang基础/01.数据类型/01.变量与常量.md",key:"v-42065d9a",path:"/pages/4b9df2/",headers:[{level:2,title:"01 变量声明",slug:"_01-变量声明",normalizedTitle:"01 变量声明",charIndex:12},{level:2,title:"02 常量声明",slug:"_02-常量声明",normalizedTitle:"02 常量声明",charIndex:826},{level:2,title:"03 初始化",slug:"_03-初始化",normalizedTitle:"03 初始化",charIndex:1098},{level:3,title:"3.1 变量初始化",slug:"_3-1-变量初始化",normalizedTitle:"3.1 变量初始化",charIndex:1109},{level:3,title:"3.2 常量初始化",slug:"_3-2-常量初始化",normalizedTitle:"3.2 常量初始化",charIndex:1784},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:2946}],headersStr:"01 变量声明 02 常量声明 03 初始化 3.1 变量初始化 3.2 常量初始化 参考资料",content:'# 变量与常量\n\n\n# 01 变量声明\n\n变量就是内存堆栈区的一块地址空间用于存储数据，Go语言在使用变量时需要先声明变量，常用的声明方式有两种：\n\n 1. 使用var关键字声明\n\n> 使用关键字var声明变量的格式如下所示，以关键字var开头，被声明的变量放在数据类型之前（与其他语言形式上有较大区别）。（这种声明方式通常用于全局变量的声明）\n> \n> var 变量名称 数据类型\n> \n> // example:\n> var age int\n> var score float32\n> var qualified bool\n> var name string\n\n> 当你需要一口气声明多个变量时，Go也提供了简洁的声明方式，仅使用一个var关键字，将多个变量名称及其数据类型放在该关键字后的括号中。\n> \n> var (\n>    变量名称 数据类型\n>    ...\n> )\n> \n> // example:\n> var (\n>     age int\n>     score float32\n>     qualified bool\n>     name string\n> )\n\n 2. 使用:=符号声明短变量\n\n> 短变量声明也是Go语言中一种特殊的变量声明方式，类似于=赋值运算符的使用方式，使用:=连接变量名称和变量值两个部分声明用于函数体内的变量。（这种声明方式通常用于函数内局部变量的声明）\n> \n> 变量名称 := 变量值\n> \n> // example:\n> func (){\n>     name := "Jack"\n>     age := 10\n>     score := 99.6\n> }\n\n=和:=的区别：前者是赋值运算符，仅将右值赋给左侧变量；后者用于短变量声明，完成变量声明和变量初始化赋值两个任务，要注意的是变量仅能被声明一次，不能在同一作用域内使用:=多次声明同名短变量，但是可以用=多次赋值短变量。\n\n\n# 02 常量声明\n\n常量是一种恒定不变的数值或者数据项。常量多用于定义程序运行期间不随时间变化的某些量和信息，也可以是表示某一数值的字符或字符串，常被用来标识、测量和比较。\n\n常量的声明使用const关键字声明，在常量声明时必须被赋值初始化且在整个程序运行期间都不能再改变。\n\nconst 常量名称 = 常量值\n\n// example-1:\nconst pi = 3.1415926\nconst e = 2.7182\n\n// example-2:\nconst (\n    pi = 3.1415926\n    e = 2.7182\n)\n\n\n\n# 03 初始化\n\n\n# 3.1 变量初始化\n\nGo语言编译器在声明变量时，如果没有显式地初始化，则会根据变量的数据类型用默认值对其进行初始化。显示表达式初始化变量的格式如下所示：\n\nvar 变量名称 数据类型 = 表达式\n\n// example:\nvar name string = "Jack"\nvar age int = 18\n\n\n类型自动推导：在显示初始化变量时，可以省略变量的数据类型，编译器自动根据赋值运算符右值来自动推导出变量的数据类型完成初始化。\n\n多变量初始化：Go语言中可以用一个赋值运算符一次性初始化多个变量，这是Go语言赋值运算符的一大特点。\n\nvar 变量名称 = 表达式\n\n\n// example-1:\nvar name = "Jack"\nvar age = 18\n\n// example-2:\nvar (\n    name = "Jack"\n    age = 18\n)\n\n// example-3:\nvar name, age = "Jack", 18\n\n\n匿名变量：在多重赋值时，用下划线_占位，表示忽略值，这也是Go语言的一语法特点，匿名变量不占用命名空间，不会分配内存，所以也不存在重复声明。\n\n// example:\nfunc foo() (string, int){\n\treturn "Jack", 18\n}\n\nfunc main(){\n\tname, _ := foo()\n\t_, age := foo()\n\tfmt.Println("name: ", name)\n\tfmt.Println("age: ", age)\n}\n\n\n\n# 3.2 常量初始化\n\n常量在定义时必须被初始化，变量的初始化方式都适用于常量，将var关键字替换成const即可。\n\n同值多常量省略初始化：但在声明多个常量时，可以通过省略值的方式初始化值相同的常量，如果省略了值则表示该常量的值与其上一行的常量值相同，这是变量中无法实现的初始化方式。\n\n// example: num1,num2,num3三个常量的值都被初始化\nconst (\n\tnum1 = 100\n\tnum2 \n\tnum3\n)\n\n\niota常量计数器实现枚举：iota智能用于常量表达式中，在const关键字出现是被置为0，每新增一行常量声明将被iota计数一次。\n\n// example-1: 一般情况\nconst (\n    num1 = iota // 0\n    num2        // 1\n    num3        // 2\n)\n\n// example-2: 中间插队恢复\nconst (\n    num1 = iota // 0\n    other = 100 \n    num2 = iota // 2\n    num3        // 3\n)\n\n// example-3: 插队导致 iota 失效\nconst (\n    num1 = iota // 0\n    other = 100 \n    num2        // 100\n    num3        // 100\n)\n\n\niota的使用技巧：iota可以被用于表达式中，也可以将多个iota定义在一行枚举多个变量\n\n 1. iota用于表达式\n\n> iota结合表达式构成更加赋值的枚举\n> \n> // example:\n> const (\n> \t_  = iota\n> \tKB = 1 << (10 * iota)\n> \tMB = 1 << (10 * iota)\n> \tGB = 1 << (10 * iota)\n> \tTB = 1 << (10 * iota)\n> \tPB = 1 << (10 * iota)\n> )\n> \n> \n> 定义数量级 （这里的<<表示左移操作，1<<10表示将1的二进制表示向左移10位，也就是由1变成了10000000000，也就是十进制的1024。同理2<<2表示将2的二进制表示向左移2位，也就是由10变成了1000，也就是十进制的8。）\n\n 2. 多个iota\n\n> 将多个iota定义在一行枚举多个变量\n> \n> // example:\n> const (\n> \tc, d = iota, 2*iota // 0 0\n> \te, f                // 1 2\n> \t_, _\n> \tg, h                // 3 6\n> )\n\n\n# 参考资料\n\n变量和常量 · Go语言中文文档',normalizedContent:'# 变量与常量\n\n\n# 01 变量声明\n\n变量就是内存堆栈区的一块地址空间用于存储数据，go语言在使用变量时需要先声明变量，常用的声明方式有两种：\n\n 1. 使用var关键字声明\n\n> 使用关键字var声明变量的格式如下所示，以关键字var开头，被声明的变量放在数据类型之前（与其他语言形式上有较大区别）。（这种声明方式通常用于全局变量的声明）\n> \n> var 变量名称 数据类型\n> \n> // example:\n> var age int\n> var score float32\n> var qualified bool\n> var name string\n\n> 当你需要一口气声明多个变量时，go也提供了简洁的声明方式，仅使用一个var关键字，将多个变量名称及其数据类型放在该关键字后的括号中。\n> \n> var (\n>    变量名称 数据类型\n>    ...\n> )\n> \n> // example:\n> var (\n>     age int\n>     score float32\n>     qualified bool\n>     name string\n> )\n\n 2. 使用:=符号声明短变量\n\n> 短变量声明也是go语言中一种特殊的变量声明方式，类似于=赋值运算符的使用方式，使用:=连接变量名称和变量值两个部分声明用于函数体内的变量。（这种声明方式通常用于函数内局部变量的声明）\n> \n> 变量名称 := 变量值\n> \n> // example:\n> func (){\n>     name := "jack"\n>     age := 10\n>     score := 99.6\n> }\n\n=和:=的区别：前者是赋值运算符，仅将右值赋给左侧变量；后者用于短变量声明，完成变量声明和变量初始化赋值两个任务，要注意的是变量仅能被声明一次，不能在同一作用域内使用:=多次声明同名短变量，但是可以用=多次赋值短变量。\n\n\n# 02 常量声明\n\n常量是一种恒定不变的数值或者数据项。常量多用于定义程序运行期间不随时间变化的某些量和信息，也可以是表示某一数值的字符或字符串，常被用来标识、测量和比较。\n\n常量的声明使用const关键字声明，在常量声明时必须被赋值初始化且在整个程序运行期间都不能再改变。\n\nconst 常量名称 = 常量值\n\n// example-1:\nconst pi = 3.1415926\nconst e = 2.7182\n\n// example-2:\nconst (\n    pi = 3.1415926\n    e = 2.7182\n)\n\n\n\n# 03 初始化\n\n\n# 3.1 变量初始化\n\ngo语言编译器在声明变量时，如果没有显式地初始化，则会根据变量的数据类型用默认值对其进行初始化。显示表达式初始化变量的格式如下所示：\n\nvar 变量名称 数据类型 = 表达式\n\n// example:\nvar name string = "jack"\nvar age int = 18\n\n\n类型自动推导：在显示初始化变量时，可以省略变量的数据类型，编译器自动根据赋值运算符右值来自动推导出变量的数据类型完成初始化。\n\n多变量初始化：go语言中可以用一个赋值运算符一次性初始化多个变量，这是go语言赋值运算符的一大特点。\n\nvar 变量名称 = 表达式\n\n\n// example-1:\nvar name = "jack"\nvar age = 18\n\n// example-2:\nvar (\n    name = "jack"\n    age = 18\n)\n\n// example-3:\nvar name, age = "jack", 18\n\n\n匿名变量：在多重赋值时，用下划线_占位，表示忽略值，这也是go语言的一语法特点，匿名变量不占用命名空间，不会分配内存，所以也不存在重复声明。\n\n// example:\nfunc foo() (string, int){\n\treturn "jack", 18\n}\n\nfunc main(){\n\tname, _ := foo()\n\t_, age := foo()\n\tfmt.println("name: ", name)\n\tfmt.println("age: ", age)\n}\n\n\n\n# 3.2 常量初始化\n\n常量在定义时必须被初始化，变量的初始化方式都适用于常量，将var关键字替换成const即可。\n\n同值多常量省略初始化：但在声明多个常量时，可以通过省略值的方式初始化值相同的常量，如果省略了值则表示该常量的值与其上一行的常量值相同，这是变量中无法实现的初始化方式。\n\n// example: num1,num2,num3三个常量的值都被初始化\nconst (\n\tnum1 = 100\n\tnum2 \n\tnum3\n)\n\n\niota常量计数器实现枚举：iota智能用于常量表达式中，在const关键字出现是被置为0，每新增一行常量声明将被iota计数一次。\n\n// example-1: 一般情况\nconst (\n    num1 = iota // 0\n    num2        // 1\n    num3        // 2\n)\n\n// example-2: 中间插队恢复\nconst (\n    num1 = iota // 0\n    other = 100 \n    num2 = iota // 2\n    num3        // 3\n)\n\n// example-3: 插队导致 iota 失效\nconst (\n    num1 = iota // 0\n    other = 100 \n    num2        // 100\n    num3        // 100\n)\n\n\niota的使用技巧：iota可以被用于表达式中，也可以将多个iota定义在一行枚举多个变量\n\n 1. iota用于表达式\n\n> iota结合表达式构成更加赋值的枚举\n> \n> // example:\n> const (\n> \t_  = iota\n> \tkb = 1 << (10 * iota)\n> \tmb = 1 << (10 * iota)\n> \tgb = 1 << (10 * iota)\n> \ttb = 1 << (10 * iota)\n> \tpb = 1 << (10 * iota)\n> )\n> \n> \n> 定义数量级 （这里的<<表示左移操作，1<<10表示将1的二进制表示向左移10位，也就是由1变成了10000000000，也就是十进制的1024。同理2<<2表示将2的二进制表示向左移2位，也就是由10变成了1000，也就是十进制的8。）\n\n 2. 多个iota\n\n> 将多个iota定义在一行枚举多个变量\n> \n> // example:\n> const (\n> \tc, d = iota, 2*iota // 0 0\n> \te, f                // 1 2\n> \t_, _\n> \tg, h                // 3 6\n> )\n\n\n# 参考资料\n\n变量和常量 · go语言中文文档',charsets:{cjk:!0},lastUpdated:"2023/11/19, 12:55:48",lastUpdatedTimestamp:1700369748e3},{title:"基础数据类型之值类型",frontmatter:{title:"基础数据类型之值类型",date:"2023-03-24T16:48:20.000Z",permalink:"/pages/97e5f5/"},regularPath:"/02.Golang%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/01.Golang%E5%9F%BA%E7%A1%80/01.%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/02.%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B9%8B%E5%80%BC%E7%B1%BB%E5%9E%8B.html",relativePath:"02.Golang学习笔记/01.Golang基础/01.数据类型/02.基础数据类型之值类型.md",key:"v-270b393e",path:"/pages/97e5f5/",headers:[{level:2,title:"01 布尔类型",slug:"_01-布尔类型",normalizedTitle:"01 布尔类型",charIndex:764},{level:2,title:"02 字符类型",slug:"_02-字符类型",normalizedTitle:"02 字符类型",charIndex:1e3},{level:2,title:"03 整型",slug:"_03-整型",normalizedTitle:"03 整型",charIndex:1471},{level:2,title:"04 浮点类型",slug:"_04-浮点类型",normalizedTitle:"04 浮点类型",charIndex:2061},{level:2,title:"05 复数类型",slug:"_05-复数类型",normalizedTitle:"05 复数类型",charIndex:2244},{level:2,title:"06 字符串类型",slug:"_06-字符串类型",normalizedTitle:"06 字符串类型",charIndex:2517},{level:3,title:"6.1 定义字符串",slug:"_6-1-定义字符串",normalizedTitle:"6.1 定义字符串",charIndex:2597},{level:3,title:"6.2 字符串操作",slug:"_6-2-字符串操作",normalizedTitle:"6.2 字符串操作",charIndex:3105},{level:2,title:"07  定长数组",slug:"_07-定长数组",normalizedTitle:"07  定长数组",charIndex:null},{level:3,title:"7.1 定义数组",slug:"_7-1-定义数组",normalizedTitle:"7.1 定义数组",charIndex:7494},{level:3,title:"7.2 定义多维数组",slug:"_7-2-定义多维数组",normalizedTitle:"7.2 定义多维数组",charIndex:8297},{level:3,title:"7.3 遍历数组",slug:"_7-3-遍历数组",normalizedTitle:"7.3 遍历数组",charIndex:8753},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:9455}],headersStr:"01 布尔类型 02 字符类型 03 整型 04 浮点类型 05 复数类型 06 字符串类型 6.1 定义字符串 6.2 字符串操作 07  定长数组 7.1 定义数组 7.2 定义多维数组 7.3 遍历数组 参考资料",content:'# 基础数据类型 值类型\n\n值类型通常是存储在内存栈空间中的键值对，将变量的实际值存储在栈中随取随用，但在赋值或拷贝时产生的是独立的键值对副本，修改新数据旧值不受影响。\n\n类型              长度/BYTE   默认值     说明\nbool            1         false   \nbyte            1         0       uint8\nrune            4         0       Unicode Code Point, int32\nint, uint       4/8       0       32 或 64 位\nint8, uint8     1         0       -128 ~ 127, 0 ~ 255，byte是uint8 的别名\nint16, uint16   2         0       -32768 ~ 32767, 0 ~ 65535\nint32, uint32   4         0       -21亿~ 21亿, 0 ~ 42亿，rune是int32 的别名\nint64, uint64   8         0       \nfloat32         4         0.0     \nfloat64         8         0.0     \ncomplex64       8                 \ncomplex128      16                \nstring                            UTF-8 字符串\narray                             固定长度的数组\n\n\n# 01 布尔类型\n\n和C++一样，Golang中也使用bool保留字声明布尔类型的数据，这种数据只有true和false两种值，分别表示“真”和“假”。\n\n布尔类型有如下特点：\n\n * 布尔类型的默认值是false\n\n * 布尔类型无法参与任何形式数值运算\n\n * 布尔类型无法与其他任何类型进行转换\n\nfunc BoolExp() {\n\tvar flag bool\n\tif !flag {\n\t\tfmt.Println("flag is false")\n\t}\n}\n\n\n\n# 02 字符类型\n\n组成每个字符串的元素叫做“字符”，在C/C++这种类型被称为字符类型用保留字char表示，在Golang中用两种方式声明字符类型：\n\n * byte 类型：和C/C++中的char相似只能表示 ASCII 码表中的字符，是 uint8 的别名类型\n\n * rune类型：则是Golang中特有的字符类型能够表示 UTF-8 中的任一字符， 是 int32 的别名类型\n\nbyte 类型虽然表示范围较小但在处理字符串性能上更优；而 rune 类型则在处理中文、日文等其他Unicode复合字符串时更加方便。Golang通过这两种字符类型让其在处理字符串时性能和扩展性都有照顾。\n\nfunc CharExp() {\n\tvar a byte = \'A\'\n\tvar b rune = \'A\'\n\n\tfmt.Printf("sizeof a is %d bytes\\n", unsafe.Sizeof(a))\n\tfmt.Printf("sizeof b is %d bytes\\n", unsafe.Sizeof(b))\n}\n\n\n\n# 03 整型\n\nGolang中对数据类型进行更明确的命名，其中国整型分为以下两个大类：\n\n * 有符号整型：int8、int16、int32、int64\n\n * 无符号整型：uint8、uint16、uint32、uint64\n\n其中uint8是byte类型及C/C++中的char类型；int16对应C/C++中的short类型；int32对应C/C++中的int类型；int64 对应C/C++中的long类型。\n\nfunc IntExp() {\n\tvar a int8 = 1\n\tvar b int16 = 1\n\tvar c int32 = 1\n\tvar d int64 = 1\n\tvar e int = 1\n\n\tfmt.Printf("size of a is %d bytes", unsafe.Sizeof(a))\n\tfmt.Printf("size of b is %d bytes", unsafe.Sizeof(b))\n\tfmt.Printf("size of c is %d bytes", unsafe.Sizeof(c))\n\tfmt.Printf("size of d is %d bytes", unsafe.Sizeof(d))\n\tfmt.Printf("size of e is %d bytes", unsafe.Sizeof(e))\n}\n\n\n\n# 04 浮点类型\n\nGolang支持两种浮点型数：float32和float64分别对应C/C++中的float和double两种浮点类型。\n\nfloat32 的浮点数的最大范围约为3.4e38，可以使用常量定义：math.MaxFloat32。 float64 的浮点数的最大范围约为 1.8e308，可以使用一个常量定义：math.MaxFloat64。\n\n\n# 05 复数类型\n\nGolang中增加了对复数表示的支持，针对复数实部和虚部float32和float64两种不同的精度提供了两种复数类型：complex64和complex128。\n\n复数类型可以通过real和 imag两个内置函数分别获取complex的实部和虚部\n\nvar a complex128 = complex(1, 2) \nvar b complex128 = complex(3, 4) \n\nfmt.Println(a*b) \nfmt.Println(real(a*b))\nfmt.Println(imag(a*b))\n\n\n\n# 06 字符串类型\n\n不同于C/C++中字符串以第三方库出现，Golang中将字符串作为原生数据类型，并实现基于UTF-8编码，极大简化了字符串的处理。\n\n\n# 6.1 定义字符串\n\n字符串类型的保留字是string，可以直接使用双引号""来定义字符串。\n\nfunc StringExp() {\n\tvar str1 string = "hello, world"\n\tvar str2 = "golang \\\\"\n\tstr3 := "go"\n\n\tfmt.Println(str1, "printed by", str2, str3)\n}\n\n\n上面的例子中 str2 的定义中使用到反斜杠的转义符\\\\，除此之外字符串中常见的转义符包含回车、换行、单双引号、制表符等。\n\n转义   含义\n\\r   回车符（返回行首）\n\\n   换行符（直接跳到下一行的同列位置）\n\\t   制表符（tab键）\n\'    单引号\n"    双引号\n\\    反斜杠\n\n定义多行字符串：Golang中可以使用反引号定义一个多行字符串，但反引号间换行将被作为字符串中的换行，但是所有的转义字符均无效，文本将会原样输出。\n\nfunc MultiRows() {\n\tvar rows = `hello \\n\n\t\tworld!\n\t\t\\t golang\n\t`\n\n\tfmt.Println(rows)\n}\n\n\n\n# 6.2 字符串操作\n\n方法                                    介绍\nlen(str)                              求长度\n+ 或 fmt.Sprintf                       拼接字符串\nstrings.Split                         分割\nstrings.Contains                      判断是否包含\nstrings.HasPrefix,strings.HasSuffix   前缀/后缀判断\nstrings.Index(),strings.LastIndex()   子串出现的位置\nstrings.Join(a[]string, sep string)   join操作\n\n（1）获取字符串长度\n\nGolang可以使用内置函数len()来获取字符串的长度，也可以使用RuneCountInString()来获取 Unicode 编码的字符串长度。\n\nlen()获取的是字符串的 ASCII 字符个数或者整个字符串所占空间的字节长度，如下例子中，str1是纯ASCII字符串其字符个数为12，则len(str1)的返回值是12；str2则是Unicode编码的字符串，"你好"字符串以 UTF-8 格式保存，每个中文字符占用 3 个字节，因此len(str2)的返回值是 6。\n\nfunc StringLen() {\n\tvar str1 string = "hello, world"\n\tstr2 := "你好"\n\n\tfmt.Printf("the length of str1 is %d, str2 is %d\\n", len(str1), len(str2))\n\tfmt.Printf("the length of str1 is %d, str2 is %d\\n", len(str1), utf8.RuneCountInString(str2))\n}\n\n\n如果想要获取 Unicode 字符串的字符个数，则需要使用 UTF-8 包中的 RuneCountInString() 方法，统计字符个数，及一般意义上的字符串长度。\n\n（2）遍历字符串\n\nGolang中遍历字符串可以通过标准索引法来获取，即用方括号运算符[]找到对应索引位置的字符，字符串索引从 0 开始计数。\n\nfunc StringTraversal() {\n\tstr1 := "hello, world"\n\tstr2 := "hello, 世界"\n\tfor i := 0; i < len(str1); i++ {\n\t\tfmt.Printf(" %c:%d", str1[i], str1[i])\n\t}\n\tfmt.Println()\n\tfor i := 0; i < len(str2); i++ {\n\t\tfmt.Printf(" %c:%d", str2[i], str2[i])\n\t}\n\tfmt.Println()\n\tfor _, ch := range str2 {\n\t\tfmt.Printf(" %c:%d", ch, ch)\n\t}\n\tfmt.Println()\n}\n\n\n比较str1和str2的标准索引遍历方式，后者中Unicode编码字符出现乱码情况，可以得出该方式仅适用于纯 ASCII 码字符串 。Unicode 字符串遍历使用 for range。\n\n字符串底层原理：这是由于字符串底层是一个byte数组，所以可以和[]byte类型相互转换。字符串是由byte字节组成，所以字符串的长度是byte字节的长度。 rune类型用来表示utf8字符，一个rune字符由一个或多个byte组成，一个中文汉字由3~4个字节组成，所以不能简单的按照字节去遍历一个包含中文的字符串，否则就会出现乱码情况。\n\n（3）截取子字符串\n\nGolang字符串的截取可以使用标准索引法，使用索引[m:n]表示截取索引大于等于m小于n的子串即str[m,n)，如果字符串是 Unicode 编码则需要把包含复杂字符的字节数全都包含在截取区间内否则会出现乱码情况。\n\nfunc StringSubStr() {\n\tstr := "hello, 世界"\n\tfmt.Printf("str[0:5]:%s\\n", str[0:5])\n\tfmt.Printf("str[0:8]:%s\\n", str[0:8])\n\tfmt.Printf("str[0:10]:%s\\n", str[0:10])\n\tfmt.Printf("str[7:]:%s\\n", str[7:])\n}\n\n\n（4）拼接字符串\n\nGolang中字符串的拼接同样可以直接使用加号运算发+将其右侧字符串拼接到其左侧字符串末尾生成一个新的字符串。也可以使用+=运算符在当前字符串后直接添加一个字符串。\n\nfunc StringAppend() {\n    str1 := "hello, "\n    str2 := "world!"\n    str := str1 + str2\n    fmt.Printf("%s + %s = %s\\n", str1, str2, str)\n    str += "你好，世界！"\n    fmt.Printf("new string: %s\\n", str)\n}\n\n\n（5）修改字符串\n\nGolang中要修改字符串，需要先将其转换成[]rune或[]byte，完成后再转换为string。无论哪种转换，都会重新分配内存，并复制字节数组。\n\nfunc StringChange() {\n\tstr1 := "hello, world"\n\tbyteStr1 := []byte(str1)\n\tbyteStr1[1] = \'E\'\n\tfmt.Println("change str1: ", string(byteStr1))\n\n\tstr2 := "hello, 世界"\n\truneStr2 := []rune(str2)\n\truneStr2[7] = \'国\'\n\tfmt.Println("change str2: ", string(runeStr2))\n}\n\n\n更多字符串操作参考标准库stringsstrings package - strings - Go Packages\n\n//判断两个字符串是否相同，忽略大小写。\nfunc EqualFold(s, t string) bool\n//判断字符串p的前缀是否为prefix\nfunc HasPrefix(s, prefix string) bool\n//判断字符串的结尾是否为suffix\nfunc HasSuffix(s, suffix string) bool\n//判断字符串s是否包含substr\nfunc Contains(s, substr string) bool\n//判断字符串中是否包括rune字符\nfunc ContainsRune(s string, r rune) bool\n//字符串s中是否包含chars任何一个字符\nfunc ContainsAny(s, chars string) bool\n//统计s中有多少sep个字符串\nfunc Count(s, sep string) int\n//返回在s中sep的首字母位置\nfunc Index(s, sep string) int\n//返回字符c在s中的位置\nfunc IndexByte(s string, c byte) int\n//返回字符r在s中的位置\nfunc IndexRune(s string, r rune) int\n//返回字符串chars中在s中出现最早的位置\nfunc IndexAny(s, chars string) int\n//返回符合函数规范的索引\nfunc IndexFunc(s string, f func(rune) bool) int\n//任意的字符chars在s中最后一个字符的索引\nfunc LastIndexAny(s, chars string) int\n//转换成小写字母\nfunc ToLower(s string) string\n//转换成大写字母\nfunc ToUpper(s string) string\n//字符串中的指定字符，最后一个参数为替换的个数，如果为-1，则全部替换\nfunc Replace(s, old, new string, n int) string\n//将所有包含sutset的开头和结尾的字符全部删除\nfunc Trim(s string, cutset string) string\n//删除全部空白\nfunc TrimSpace(s string) string\n//删除根据函数进行字符串开头和结尾的删除\nfunc TrimFunc(s string, f func(rune) bool) string\n//将字符串左侧的指定字符删除\nfunc TrimLeft(s string, cutset string) string\n//将字符串左侧符合函数的字符进行删除\nfunc TrimLeftFunc(s string, f func(rune) bool) string\n//将字符串左侧的prefix进行删除\nfunc TrimPrefix(s, prefix string) string\n//按字符串之间的空白进行分割，返回数组\nfunc Fields(s string) []string\n//按字符串中符合函数的字符进行分割\nfunc FieldsFunc(s string, f func(rune) bool) []string\n//将字符串中的sep作为分割符，进行分割，返回数组\nfunc Split(s, sep string) []string\n//按照sep进行分割，并且可以指定分割的次数\nfunc SplitN(s, sep string, n int) []string\n//前些个分割字符串是将分割符进行删除，此函数，将在分割符后进行分割。\nfunc SplitAfter(s, sep string) []string\n//不删除分割符，并指定分割次数\nfunc SplitAfterN(s, sep string, n int) []string\n//将字符串型数组，按照指定连接符进行连接\nfunc Join(a []string, sep string) string\n\n\n\n# 07 定长数组\n\n\n# 7.1 定义数组\n\nGolang中数组 Array 是同一种数据类型的固定长度的序列，所以定义数组时必须指定存放元素的类型和容量，其格式如下所示：\n\nvar 变量名称 [数组容量]数据类型\n\n// example:\nvar arr0 [5]int\nvar arr1 [3]bool\n\n\n如果在定义数组时不对其进行初始化，则使用默认值填充，整型默认值是0、浮点型默认值是0.0、布尔类型默认值是false、字符串默认值则是空串。\n\n使用大括号初始化数组：即在大括号中定义好和数组指定的数据类型与数组容量一致的值\n\nvar arr0 = [5]int{1, 2, 3, 4, 5}\nvar arr1 [3]bool\nfmt.Println("arr0:", arr0, "\\narr1:", arr1)\n\n\n局部初始化：初始化元素个数小于指明的容量时，数组在初始化过程中会用默认值填充补齐；如果数组声明时未指明容量或者使用...设置数组容量，则数组在初始化过程中会根据初始值自动判断数组的容量。\n\nvar arr2 = [7]int{1, 2, 3, 4, 5, 6, 7}\nvar arr3 = [7]int{1, 2, 3}\nvar arr4 = []int{1, 2, 3}\nvar arr5 = [...]int{1, 2, 3}\nfmt.Println("arr2:", arr2, "\\narr3:", arr3, "\\narr4:", arr4, "\\narr5:", arr5)\n\n\n通过指定索引对应的值初始化数组：在大括号中指定索引对应的值，未指定索引的值会用默认值填充。\n\narr6 := [5]int{0: 1, 3: 4}\narr7 := []int{0: 1, 4: 5, 8: 9}\nfmt.Println("arr6:", arr6, "\\narr7:", arr7)\n\n\n\n# 7.2 定义多维数组\n\nGolang中可以通过增加容量维度来定义多维数组，声明语法格式如下所示：\n\nvar 变量名称 [一维容量][二维容量]...[N维容量]数据类型\n\n// example:\nvar arr8 [3][3]int\nvar arr9 [3][3][3]bool\n\n\n多维数组的初始化与一维一致，满足嵌套结构\n\narr8 := [3][3]int{\n\t\t{1, 2, 3},\n\t\t{4, 5, 6},\n\t\t{0: 7, 2: 9},\n\t}\nfmt.Println("arr8:", arr8)\n\n\n多维数组容量声明时仅能省略第一维度，其他维度不可省略\n\narr10 := [...][3]int{\n\t\t{1, 2, 3},\n\t\t{4, 5, 6},\n\t\t{0: 7, 2: 9},\n\t}\narr11 := [][3]int{\n\t\t{1, 2, 3},\n\t\t{0: 7, 2: 9},\n\t}\nfmt.Println("arr10:", arr10, "\\narr11:", arr11)\n\n\n\n# 7.3 遍历数组\n\n使用标准索引法遍历数组：这种方式需要使用len()内置函数获取数组长度，然后使用[]中括号运算符获取索引元素。\n\nfunc ArrayTraversal() {\n\tvar arr0 = [5]int{1, 2, 3, 4, 5}\n\tfor i := 0; i < len(arr0); i++ {\n\t\tfmt.Printf("%d:%d ", i, arr0[i])\n\t}\n\n\tarr8 := [3][3]int{\n\t\t{1, 2, 3},\n\t\t{4, 5, 6},\n\t\t{0: 7, 2: 9},\n\t}\n\tfor i := 0; i < len(arr8); i++ {\n\t\tfor j := 0; j < len(arr8[0]); j++ {\n\t\t\tfmt.Printf("(%d,%d):%d ", i, j, arr8[i][j])\n\t\t}\n\t}\n}\n\n\n使用for range遍历数组：\n\nfunc ArrayTraversal() {\n\tvar arr0 = [5]int{1, 2, 3, 4, 5}\n\tfor _, e := range arr0 {\n\t\tfmt.Printf("%d", e)\n\t}\n\n\tarr8 := [3][3]int{\n\t\t{1, 2, 3},\n\t\t{4, 5, 6},\n\t\t{0: 7, 2: 9},\n\t}\n\tfor k1, row := range arr8 {\n\t\tfor k2, elem := range row {\n\t\t\tfmt.Printf("(%d,%d):%d ", k1, k2, elem)\n\t\t}\n\t}\n}\n\n\n\n# 参考资料\n\n基本类型 · Go语言中文文档\n\n变量类型之值类型与引用类型\n\nGo语言字符串\n\n数组Array · Go语言中文文档',normalizedContent:'# 基础数据类型 值类型\n\n值类型通常是存储在内存栈空间中的键值对，将变量的实际值存储在栈中随取随用，但在赋值或拷贝时产生的是独立的键值对副本，修改新数据旧值不受影响。\n\n类型              长度/byte   默认值     说明\nbool            1         false   \nbyte            1         0       uint8\nrune            4         0       unicode code point, int32\nint, uint       4/8       0       32 或 64 位\nint8, uint8     1         0       -128 ~ 127, 0 ~ 255，byte是uint8 的别名\nint16, uint16   2         0       -32768 ~ 32767, 0 ~ 65535\nint32, uint32   4         0       -21亿~ 21亿, 0 ~ 42亿，rune是int32 的别名\nint64, uint64   8         0       \nfloat32         4         0.0     \nfloat64         8         0.0     \ncomplex64       8                 \ncomplex128      16                \nstring                            utf-8 字符串\narray                             固定长度的数组\n\n\n# 01 布尔类型\n\n和c++一样，golang中也使用bool保留字声明布尔类型的数据，这种数据只有true和false两种值，分别表示“真”和“假”。\n\n布尔类型有如下特点：\n\n * 布尔类型的默认值是false\n\n * 布尔类型无法参与任何形式数值运算\n\n * 布尔类型无法与其他任何类型进行转换\n\nfunc boolexp() {\n\tvar flag bool\n\tif !flag {\n\t\tfmt.println("flag is false")\n\t}\n}\n\n\n\n# 02 字符类型\n\n组成每个字符串的元素叫做“字符”，在c/c++这种类型被称为字符类型用保留字char表示，在golang中用两种方式声明字符类型：\n\n * byte 类型：和c/c++中的char相似只能表示 ascii 码表中的字符，是 uint8 的别名类型\n\n * rune类型：则是golang中特有的字符类型能够表示 utf-8 中的任一字符， 是 int32 的别名类型\n\nbyte 类型虽然表示范围较小但在处理字符串性能上更优；而 rune 类型则在处理中文、日文等其他unicode复合字符串时更加方便。golang通过这两种字符类型让其在处理字符串时性能和扩展性都有照顾。\n\nfunc charexp() {\n\tvar a byte = \'a\'\n\tvar b rune = \'a\'\n\n\tfmt.printf("sizeof a is %d bytes\\n", unsafe.sizeof(a))\n\tfmt.printf("sizeof b is %d bytes\\n", unsafe.sizeof(b))\n}\n\n\n\n# 03 整型\n\ngolang中对数据类型进行更明确的命名，其中国整型分为以下两个大类：\n\n * 有符号整型：int8、int16、int32、int64\n\n * 无符号整型：uint8、uint16、uint32、uint64\n\n其中uint8是byte类型及c/c++中的char类型；int16对应c/c++中的short类型；int32对应c/c++中的int类型；int64 对应c/c++中的long类型。\n\nfunc intexp() {\n\tvar a int8 = 1\n\tvar b int16 = 1\n\tvar c int32 = 1\n\tvar d int64 = 1\n\tvar e int = 1\n\n\tfmt.printf("size of a is %d bytes", unsafe.sizeof(a))\n\tfmt.printf("size of b is %d bytes", unsafe.sizeof(b))\n\tfmt.printf("size of c is %d bytes", unsafe.sizeof(c))\n\tfmt.printf("size of d is %d bytes", unsafe.sizeof(d))\n\tfmt.printf("size of e is %d bytes", unsafe.sizeof(e))\n}\n\n\n\n# 04 浮点类型\n\ngolang支持两种浮点型数：float32和float64分别对应c/c++中的float和double两种浮点类型。\n\nfloat32 的浮点数的最大范围约为3.4e38，可以使用常量定义：math.maxfloat32。 float64 的浮点数的最大范围约为 1.8e308，可以使用一个常量定义：math.maxfloat64。\n\n\n# 05 复数类型\n\ngolang中增加了对复数表示的支持，针对复数实部和虚部float32和float64两种不同的精度提供了两种复数类型：complex64和complex128。\n\n复数类型可以通过real和 imag两个内置函数分别获取complex的实部和虚部\n\nvar a complex128 = complex(1, 2) \nvar b complex128 = complex(3, 4) \n\nfmt.println(a*b) \nfmt.println(real(a*b))\nfmt.println(imag(a*b))\n\n\n\n# 06 字符串类型\n\n不同于c/c++中字符串以第三方库出现，golang中将字符串作为原生数据类型，并实现基于utf-8编码，极大简化了字符串的处理。\n\n\n# 6.1 定义字符串\n\n字符串类型的保留字是string，可以直接使用双引号""来定义字符串。\n\nfunc stringexp() {\n\tvar str1 string = "hello, world"\n\tvar str2 = "golang \\\\"\n\tstr3 := "go"\n\n\tfmt.println(str1, "printed by", str2, str3)\n}\n\n\n上面的例子中 str2 的定义中使用到反斜杠的转义符\\\\，除此之外字符串中常见的转义符包含回车、换行、单双引号、制表符等。\n\n转义   含义\n\\r   回车符（返回行首）\n\\n   换行符（直接跳到下一行的同列位置）\n\\t   制表符（tab键）\n\'    单引号\n"    双引号\n\\    反斜杠\n\n定义多行字符串：golang中可以使用反引号定义一个多行字符串，但反引号间换行将被作为字符串中的换行，但是所有的转义字符均无效，文本将会原样输出。\n\nfunc multirows() {\n\tvar rows = `hello \\n\n\t\tworld!\n\t\t\\t golang\n\t`\n\n\tfmt.println(rows)\n}\n\n\n\n# 6.2 字符串操作\n\n方法                                    介绍\nlen(str)                              求长度\n+ 或 fmt.sprintf                       拼接字符串\nstrings.split                         分割\nstrings.contains                      判断是否包含\nstrings.hasprefix,strings.hassuffix   前缀/后缀判断\nstrings.index(),strings.lastindex()   子串出现的位置\nstrings.join(a[]string, sep string)   join操作\n\n（1）获取字符串长度\n\ngolang可以使用内置函数len()来获取字符串的长度，也可以使用runecountinstring()来获取 unicode 编码的字符串长度。\n\nlen()获取的是字符串的 ascii 字符个数或者整个字符串所占空间的字节长度，如下例子中，str1是纯ascii字符串其字符个数为12，则len(str1)的返回值是12；str2则是unicode编码的字符串，"你好"字符串以 utf-8 格式保存，每个中文字符占用 3 个字节，因此len(str2)的返回值是 6。\n\nfunc stringlen() {\n\tvar str1 string = "hello, world"\n\tstr2 := "你好"\n\n\tfmt.printf("the length of str1 is %d, str2 is %d\\n", len(str1), len(str2))\n\tfmt.printf("the length of str1 is %d, str2 is %d\\n", len(str1), utf8.runecountinstring(str2))\n}\n\n\n如果想要获取 unicode 字符串的字符个数，则需要使用 utf-8 包中的 runecountinstring() 方法，统计字符个数，及一般意义上的字符串长度。\n\n（2）遍历字符串\n\ngolang中遍历字符串可以通过标准索引法来获取，即用方括号运算符[]找到对应索引位置的字符，字符串索引从 0 开始计数。\n\nfunc stringtraversal() {\n\tstr1 := "hello, world"\n\tstr2 := "hello, 世界"\n\tfor i := 0; i < len(str1); i++ {\n\t\tfmt.printf(" %c:%d", str1[i], str1[i])\n\t}\n\tfmt.println()\n\tfor i := 0; i < len(str2); i++ {\n\t\tfmt.printf(" %c:%d", str2[i], str2[i])\n\t}\n\tfmt.println()\n\tfor _, ch := range str2 {\n\t\tfmt.printf(" %c:%d", ch, ch)\n\t}\n\tfmt.println()\n}\n\n\n比较str1和str2的标准索引遍历方式，后者中unicode编码字符出现乱码情况，可以得出该方式仅适用于纯 ascii 码字符串 。unicode 字符串遍历使用 for range。\n\n字符串底层原理：这是由于字符串底层是一个byte数组，所以可以和[]byte类型相互转换。字符串是由byte字节组成，所以字符串的长度是byte字节的长度。 rune类型用来表示utf8字符，一个rune字符由一个或多个byte组成，一个中文汉字由3~4个字节组成，所以不能简单的按照字节去遍历一个包含中文的字符串，否则就会出现乱码情况。\n\n（3）截取子字符串\n\ngolang字符串的截取可以使用标准索引法，使用索引[m:n]表示截取索引大于等于m小于n的子串即str[m,n)，如果字符串是 unicode 编码则需要把包含复杂字符的字节数全都包含在截取区间内否则会出现乱码情况。\n\nfunc stringsubstr() {\n\tstr := "hello, 世界"\n\tfmt.printf("str[0:5]:%s\\n", str[0:5])\n\tfmt.printf("str[0:8]:%s\\n", str[0:8])\n\tfmt.printf("str[0:10]:%s\\n", str[0:10])\n\tfmt.printf("str[7:]:%s\\n", str[7:])\n}\n\n\n（4）拼接字符串\n\ngolang中字符串的拼接同样可以直接使用加号运算发+将其右侧字符串拼接到其左侧字符串末尾生成一个新的字符串。也可以使用+=运算符在当前字符串后直接添加一个字符串。\n\nfunc stringappend() {\n    str1 := "hello, "\n    str2 := "world!"\n    str := str1 + str2\n    fmt.printf("%s + %s = %s\\n", str1, str2, str)\n    str += "你好，世界！"\n    fmt.printf("new string: %s\\n", str)\n}\n\n\n（5）修改字符串\n\ngolang中要修改字符串，需要先将其转换成[]rune或[]byte，完成后再转换为string。无论哪种转换，都会重新分配内存，并复制字节数组。\n\nfunc stringchange() {\n\tstr1 := "hello, world"\n\tbytestr1 := []byte(str1)\n\tbytestr1[1] = \'e\'\n\tfmt.println("change str1: ", string(bytestr1))\n\n\tstr2 := "hello, 世界"\n\trunestr2 := []rune(str2)\n\trunestr2[7] = \'国\'\n\tfmt.println("change str2: ", string(runestr2))\n}\n\n\n更多字符串操作参考标准库stringsstrings package - strings - go packages\n\n//判断两个字符串是否相同，忽略大小写。\nfunc equalfold(s, t string) bool\n//判断字符串p的前缀是否为prefix\nfunc hasprefix(s, prefix string) bool\n//判断字符串的结尾是否为suffix\nfunc hassuffix(s, suffix string) bool\n//判断字符串s是否包含substr\nfunc contains(s, substr string) bool\n//判断字符串中是否包括rune字符\nfunc containsrune(s string, r rune) bool\n//字符串s中是否包含chars任何一个字符\nfunc containsany(s, chars string) bool\n//统计s中有多少sep个字符串\nfunc count(s, sep string) int\n//返回在s中sep的首字母位置\nfunc index(s, sep string) int\n//返回字符c在s中的位置\nfunc indexbyte(s string, c byte) int\n//返回字符r在s中的位置\nfunc indexrune(s string, r rune) int\n//返回字符串chars中在s中出现最早的位置\nfunc indexany(s, chars string) int\n//返回符合函数规范的索引\nfunc indexfunc(s string, f func(rune) bool) int\n//任意的字符chars在s中最后一个字符的索引\nfunc lastindexany(s, chars string) int\n//转换成小写字母\nfunc tolower(s string) string\n//转换成大写字母\nfunc toupper(s string) string\n//字符串中的指定字符，最后一个参数为替换的个数，如果为-1，则全部替换\nfunc replace(s, old, new string, n int) string\n//将所有包含sutset的开头和结尾的字符全部删除\nfunc trim(s string, cutset string) string\n//删除全部空白\nfunc trimspace(s string) string\n//删除根据函数进行字符串开头和结尾的删除\nfunc trimfunc(s string, f func(rune) bool) string\n//将字符串左侧的指定字符删除\nfunc trimleft(s string, cutset string) string\n//将字符串左侧符合函数的字符进行删除\nfunc trimleftfunc(s string, f func(rune) bool) string\n//将字符串左侧的prefix进行删除\nfunc trimprefix(s, prefix string) string\n//按字符串之间的空白进行分割，返回数组\nfunc fields(s string) []string\n//按字符串中符合函数的字符进行分割\nfunc fieldsfunc(s string, f func(rune) bool) []string\n//将字符串中的sep作为分割符，进行分割，返回数组\nfunc split(s, sep string) []string\n//按照sep进行分割，并且可以指定分割的次数\nfunc splitn(s, sep string, n int) []string\n//前些个分割字符串是将分割符进行删除，此函数，将在分割符后进行分割。\nfunc splitafter(s, sep string) []string\n//不删除分割符，并指定分割次数\nfunc splitaftern(s, sep string, n int) []string\n//将字符串型数组，按照指定连接符进行连接\nfunc join(a []string, sep string) string\n\n\n\n# 07 定长数组\n\n\n# 7.1 定义数组\n\ngolang中数组 array 是同一种数据类型的固定长度的序列，所以定义数组时必须指定存放元素的类型和容量，其格式如下所示：\n\nvar 变量名称 [数组容量]数据类型\n\n// example:\nvar arr0 [5]int\nvar arr1 [3]bool\n\n\n如果在定义数组时不对其进行初始化，则使用默认值填充，整型默认值是0、浮点型默认值是0.0、布尔类型默认值是false、字符串默认值则是空串。\n\n使用大括号初始化数组：即在大括号中定义好和数组指定的数据类型与数组容量一致的值\n\nvar arr0 = [5]int{1, 2, 3, 4, 5}\nvar arr1 [3]bool\nfmt.println("arr0:", arr0, "\\narr1:", arr1)\n\n\n局部初始化：初始化元素个数小于指明的容量时，数组在初始化过程中会用默认值填充补齐；如果数组声明时未指明容量或者使用...设置数组容量，则数组在初始化过程中会根据初始值自动判断数组的容量。\n\nvar arr2 = [7]int{1, 2, 3, 4, 5, 6, 7}\nvar arr3 = [7]int{1, 2, 3}\nvar arr4 = []int{1, 2, 3}\nvar arr5 = [...]int{1, 2, 3}\nfmt.println("arr2:", arr2, "\\narr3:", arr3, "\\narr4:", arr4, "\\narr5:", arr5)\n\n\n通过指定索引对应的值初始化数组：在大括号中指定索引对应的值，未指定索引的值会用默认值填充。\n\narr6 := [5]int{0: 1, 3: 4}\narr7 := []int{0: 1, 4: 5, 8: 9}\nfmt.println("arr6:", arr6, "\\narr7:", arr7)\n\n\n\n# 7.2 定义多维数组\n\ngolang中可以通过增加容量维度来定义多维数组，声明语法格式如下所示：\n\nvar 变量名称 [一维容量][二维容量]...[n维容量]数据类型\n\n// example:\nvar arr8 [3][3]int\nvar arr9 [3][3][3]bool\n\n\n多维数组的初始化与一维一致，满足嵌套结构\n\narr8 := [3][3]int{\n\t\t{1, 2, 3},\n\t\t{4, 5, 6},\n\t\t{0: 7, 2: 9},\n\t}\nfmt.println("arr8:", arr8)\n\n\n多维数组容量声明时仅能省略第一维度，其他维度不可省略\n\narr10 := [...][3]int{\n\t\t{1, 2, 3},\n\t\t{4, 5, 6},\n\t\t{0: 7, 2: 9},\n\t}\narr11 := [][3]int{\n\t\t{1, 2, 3},\n\t\t{0: 7, 2: 9},\n\t}\nfmt.println("arr10:", arr10, "\\narr11:", arr11)\n\n\n\n# 7.3 遍历数组\n\n使用标准索引法遍历数组：这种方式需要使用len()内置函数获取数组长度，然后使用[]中括号运算符获取索引元素。\n\nfunc arraytraversal() {\n\tvar arr0 = [5]int{1, 2, 3, 4, 5}\n\tfor i := 0; i < len(arr0); i++ {\n\t\tfmt.printf("%d:%d ", i, arr0[i])\n\t}\n\n\tarr8 := [3][3]int{\n\t\t{1, 2, 3},\n\t\t{4, 5, 6},\n\t\t{0: 7, 2: 9},\n\t}\n\tfor i := 0; i < len(arr8); i++ {\n\t\tfor j := 0; j < len(arr8[0]); j++ {\n\t\t\tfmt.printf("(%d,%d):%d ", i, j, arr8[i][j])\n\t\t}\n\t}\n}\n\n\n使用for range遍历数组：\n\nfunc arraytraversal() {\n\tvar arr0 = [5]int{1, 2, 3, 4, 5}\n\tfor _, e := range arr0 {\n\t\tfmt.printf("%d", e)\n\t}\n\n\tarr8 := [3][3]int{\n\t\t{1, 2, 3},\n\t\t{4, 5, 6},\n\t\t{0: 7, 2: 9},\n\t}\n\tfor k1, row := range arr8 {\n\t\tfor k2, elem := range row {\n\t\t\tfmt.printf("(%d,%d):%d ", k1, k2, elem)\n\t\t}\n\t}\n}\n\n\n\n# 参考资料\n\n基本类型 · go语言中文文档\n\n变量类型之值类型与引用类型\n\ngo语言字符串\n\n数组array · go语言中文文档',charsets:{cjk:!0},lastUpdated:"2023/11/19, 12:55:48",lastUpdatedTimestamp:1700369748e3},{title:"基础数据类型之引用类型",frontmatter:{title:"基础数据类型之引用类型",date:"2023-03-24T16:48:20.000Z",permalink:"/pages/410fb6/"},regularPath:"/02.Golang%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/01.Golang%E5%9F%BA%E7%A1%80/01.%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/03.%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B9%8B%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B.html",relativePath:"02.Golang学习笔记/01.Golang基础/01.数据类型/03.基础数据类型之引用类型.md",key:"v-1d4eb24c",path:"/pages/410fb6/",headers:[{level:2,title:"01 Slice 切片",slug:"_01-slice-切片",normalizedTitle:"01 slice 切片",charIndex:218},{level:3,title:"1.1 创建切片",slug:"_1-1-创建切片",normalizedTitle:"1.1 创建切片",charIndex:680},{level:3,title:"1.2 操作切片",slug:"_1-2-操作切片",normalizedTitle:"1.2 操作切片",charIndex:2884},{level:4,title:"1.2.1 切片追加",slug:"_1-2-1-切片追加",normalizedTitle:"1.2.1 切片追加",charIndex:2896},{level:4,title:"1.2.2 拷贝切片",slug:"_1-2-2-拷贝切片",normalizedTitle:"1.2.2 拷贝切片",charIndex:4276},{level:4,title:"1.2.3 遍历切片",slug:"_1-2-3-遍历切片",normalizedTitle:"1.2.3 遍历切片",charIndex:6649},{level:4,title:"1.2.4 切片删除",slug:"_1-2-4-切片删除",normalizedTitle:"1.2.4 切片删除",charIndex:7323},{level:3,title:"1.3 切片扩容",slug:"_1-3-切片扩容",normalizedTitle:"1.3 切片扩容",charIndex:7859},{level:2,title:"02 Map 键值对",slug:"_02-map-键值对",normalizedTitle:"02 map 键值对",charIndex:10073},{level:3,title:"2.1 创建 Map",slug:"_2-1-创建-map",normalizedTitle:"2.1 创建 map",charIndex:10330},{level:3,title:"2.2 操作 Map",slug:"_2-2-操作-map",normalizedTitle:"2.2 操作 map",charIndex:11054},{level:4,title:"2.2.1 Map 取值",slug:"_2-2-1-map-取值",normalizedTitle:"2.2.1 map 取值",charIndex:11068},{level:4,title:"2.2.2 遍历 Map",slug:"_2-2-2-遍历-map",normalizedTitle:"2.2.2 遍历 map",charIndex:11759},{level:4,title:"2.2.3 Map 删除",slug:"_2-2-3-map-删除",normalizedTitle:"2.2.3 map 删除",charIndex:13223},{level:3,title:"2.3 Map 实现原理",slug:"_2-3-map-实现原理",normalizedTitle:"2.3 map 实现原理",charIndex:13666},{level:2,title:"03 Channel 通道",slug:"_03-channel-通道",normalizedTitle:"03 channel 通道",charIndex:13704},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:13738}],headersStr:"01 Slice 切片 1.1 创建切片 1.2 操作切片 1.2.1 切片追加 1.2.2 拷贝切片 1.2.3 遍历切片 1.2.4 切片删除 1.3 切片扩容 02 Map 键值对 2.1 创建 Map 2.2 操作 Map 2.2.1 Map 取值 2.2.2 遍历 Map 2.2.3 Map 删除 2.3 Map 实现原理 03 Channel 通道 参考资料",content:'# 基础数据类型 引用类型\n\n引用类型的在内存栈空间中存储的是保存变量名和指向堆空间中的变量地址，地址指向的堆空间中保存着实际的值。在赋值或拷贝变量时，栈空间中保存的地址也被拷贝指向相同的堆空间中保存的值，所以在修改其中一个变量的值时，其他的变量会一起被修改。\n\n类型        默认值   说明\nslice     nil   引用类型\nmap       nil   引用类型\nchannel   nil   引用类型\n\n\n# 01 Slice 切片\n\n切片（slice）是对数组一个连续片段的引用，所以切片是一个引用类型，类似于 C/C++ 中的数组类型，而Golang 中的数组是值类型，赋值和函数传参操作都会复制整个数组数据。\n\n相较于 Golang 数组拷贝过程中的巨大内存开销，采用切片的方式进行赋值或者传参不需要使用额外的内存并且比使用数组更有效率。\n\n切片的实现原理类似 C++ STL 中的 vector，但是切片本身并不是动态数组或者数组指针。它内部实现的数据结构通过指针引用底层数组，设定相关属性将数据读写操作限定在指定的区域内。切片本身是一个只读对象，其工作机制类似数组指针的一种封装。\n\ntype slice struct {\n    array unsafe.Pointer // 保存指向堆空间的地址\n    len   int            // 包含元素的个数（实际被使用容量）长度\n    cap   int            // 切片的实际容量（使用部分+未使用部分）通常大于等于len\n}\n\n\n\n# 1.1 创建切片\n\n声明切片的方式与数组声明类似，但是不在[]中指明长度，数组是固定长度的，而切片的长度可变的。\n\n// 数组声明\nvar arr1 [3]int\nvar arr2 [...]int{1,2,3}\narr3 := [3]int{1,2,3} // 短变量声明\n// 切片声明\nvar s1 []int // 空切片\ns1 := []int{1,2,3} // 短变量声明\n\n\nmake函数初始化切片：Golang 的 make 内置函数用于分配内存空间，返回引用类型本身。make 函数有三个入参分别是：数据类型(*_type)，长度(len)和容量(cap)，如果容量被省略则与长度同值。\n\n// 声明形式\nvar slice []type = make([]type, len)\nslice  := make([]type, len)\nslice  := make([]type, len, cap)\n\n// example:\nfunc SliceCreate() {\n    var s1 []int = make([]int, 3, 5)\n    fmt.Println("s1:", s1, " len / cap:", len(s1), "/", cap(s1))\n    var s2 []int = make([]int, 3)\n    fmt.Println("s2:", s2, " len / cap:", len(s2), "/", cap(s2))\n}\n\n/* output:\ns1: [0 0 0]  len / cap: 3 / 5\ns2: [0 0 0]  len / cap: 3 / 3\n*/\n\n\n空切片初始化：nil切片表示该切片结构体的指针指向nil，表示切片不存在，常用于函数异常返回值。空切片的指针指向具体地址但该地址没有存放任何元素，空切片一般会用来表示一个空的集合。\n\nfunc SliceCreate() {\n    var s3 []int // nil切片\n    if s3 == nil {\n        fmt.Println("s3 is empty")\n    }\n    s3 = []int{1, 2, 3}\n    fmt.Println("s3:", s3, " len / cap:", len(s3), "/", cap(s3))\n    // 空切片\n    s4 := make([]int, 0)\n    fmt.Println("s4:", s4, " len / cap:", len(s4), "/", cap(s4))\n    s4 = []int{}\n    fmt.Println("s4:", s4, " len / cap:", len(s4), "/", cap(s4))\n    s4 = []int{1, 2, 3, 4}\n    fmt.Println("s4:", s4, " len / cap:", len(s4), "/", cap(s4))\n}\n\n/* output:\ns3 is empty\ns3: [1 2 3]  len / cap: 3 / 3\ns4: []  len / cap: 0 / 0\ns4: []  len / cap: 0 / 0\ns4: [1 2 3 4]  len / cap: 4 / 4\n*/\n\n\n使用字面量从数组中切片：使用切片引用数组连续的全部或部分数据，使用字面量（索引号）获取数组的部分数据，字面量操作含义如下表所示\n\n操作                  含义\narr[n]              索引号为n的单个元素\narr[:]              从索引位置0到len(arr)-1中所获得的切片即数组的所有元素\narr[low:]           从索引位置low到len(arr)-1中所获得的切片，长度为len(arr)-low，容量为len(arr)\narr[:high]          从索引位置0到high-1中所获得的切片，长度为high，容量为len(arr)\narr[low:high]       从索引位置low到high-1中所获得的切片，长度为high-low，容量为len(arr)\narr[low:high:max]   从索引位置low到high-1中所获得的切片，长度为high-low，容量为max-low\n\nfunc SliceCreate() {\n    var arr = [...]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 0}\n    s5 := arr[1:5:6]\n    fmt.Println("s5:", s5, " len / cap:", len(s5), "/", cap(s5))\n    s6 := arr[1:5]\n    fmt.Println("s6:", s6, " len / cap:", len(s6), "/", cap(s6))\n}\n\n/* output:\ns5: [2 3 4 5]  len / cap: 4 / 5\ns6: [2 3 4 5]  len / cap: 4 / 9\n*/ \n\n\n\n# 1.2 操作切片\n\n# 1.2.1 切片追加\n\nappend()内置函数添加元素：切片使用append()内置函数向该切片末尾追加元素，并返回新的切片。\n\nfunc SliceAppend() {\n    s1 := make([]int, 1)\n    fmt.Println("s1:", s1, " len / cap:", len(s1), "/", cap(s1))\n    s2 := append(s1, 1)\n    fmt.Println("s2:", s2, " len / cap:", len(s2), "/", cap(s2))\n    fmt.Printf("pos s1: %p; pos s2: %p\\n", &s1, &s2)\n}\n\n/* output:\ns1: [0]  len / cap: 1 / 1\ns2: [0 1]  len / cap: 2 / 2\npos s1: 0xc0000040d8; pos s2: 0xc000004108\n*/\n\n\n向切片中追加多个元素：\n\n 1. 切片追加多个元素，可以通过多次调用append()，也可以添加多个入参\n\nfunc SliceAppend() {\n    s3 := []int{1, 2, 3}\n    fmt.Println("s3:", s3, " len / cap:", len(s3), "/", cap(s3))\n    s3 = append(s3, 4)\n    s3 = append(s3, 5)\n    fmt.Println("s3:", s3, " len / cap:", len(s3), "/", cap(s3))\n    s3 = append(s3, 6, 7, 8)\n    fmt.Println("s3:", s3, " len / cap:", len(s3), "/", cap(s3))\n}\n\n/* output:\ns3: [1 2 3]  len / cap: 3 / 3\ns3: [1 2 3 4 5]  len / cap: 5 / 6\ns3: [1 2 3 4 5 6 7 8]  len / cap: 8 / 12\n*/\n\n\n 2. 使用append()将切片作为追加元素，使用...运算符将切片值拆分成单个追加元素\n\nfunc SliceAppend() {\n    s4 := []int{1, 2, 3}\n    fmt.Println("s4:", s4, " len / cap:", len(s4), "/", cap(s4))\n    s5 := []int{4, 5}\n    fmt.Println("s5:", s5, " len / cap:", len(s5), "/", cap(s5))\n    s6 := append(s4, s5...)\n    fmt.Println("s6:", s6, " len / cap:", len(s6), "/", cap(s6))\n}\n\n/* output:\ns4: [1 2 3]  len / cap: 3 / 3\ns5: [4 5]  len / cap: 2 / 2\ns6: [1 2 3 4 5]  len / cap: 5 / 6\n*/\n\n\n# 1.2.2 拷贝切片\n\ncopy()内置函数拷贝切片：使用 copy 内置函数拷贝切片时，是将切片的数据拷贝到另外新开辟的内存空间中；copy 内置函数的参数和返回值为copy( dest Slice, src Slice []T) int，其中第一个参数为拷贝的目标切片，第二个参数是拷贝的对象即数据源，返回值表示的是根据两个切片长度len的较小值实际成功拷贝的元素个数。\n\nfunc SliceCopy() {\n    s1 := make([]int, 3, 5)\n    fmt.Println("s1:", s1, " len / cap:", len(s1), "/", cap(s1))\n    s2 := []int{1, 2}\n    fmt.Println("s2:", s2, " len / cap:", len(s2), "/", cap(s2))\n    copy(s1, s2)\n    fmt.Println("copy s1:", s1, " len / cap:", len(s1), "/", cap(s1))\n    fmt.Println("copy s2:", s2, " len / cap:", len(s2), "/", cap(s2))\n    s3 := []int{3}\n    fmt.Println("s3:", s3, " len / cap:", len(s3), "/", cap(s3))\n    s1 = append(s1, s3...)\n    fmt.Println("append s1:", s1, " len / cap:", len(s1), "/", cap(s1))\n    copy(s3, s2)\n    fmt.Println("copy s3:", s3, " len / cap:", len(s3), "/", cap(s3))\n    fmt.Println("copy s2:", s2, " len / cap:", len(s2), "/", cap(s2))\n}\n\n/* output:\ns1: [0 0 0]  len / cap: 3 / 5\ns2: [1 2]  len / cap: 2 / 2\ncopy s1: [1 2 0]  len / cap: 3 / 5\ncopy s2: [1 2]  len / cap: 2 / 2\ns3: [3]  len / cap: 1 / 1\nappend s1: [1 2 0 3]  len / cap: 4 / 5\ncopy s3: [1]  len / cap: 1 / 1\ncopy s2: [1 2]  len / cap: 2 / 2\n*/\n\n\n=赋值运算符浅拷贝：Golang 中有了 Array 数组还提出 Slice 切片的一个重要动机就是当数组保存数据规模过大时，避免全部重新复制一遍数组元素，而使用指向存储实际数据空间的指针高效利用内存。使用=拷贝切片时，两者引用同一个内存空间，当修改其中一个时，两者同时被修改。\n\nfunc SliceCopy() {\n    s4 := []int{1, 2, 3}\n    s5 := []int{}\n    s6 := make([]int, 3)\n    fmt.Println("s4:", s4, " len / cap:", len(s4), "/", cap(s4))\n    fmt.Println("s5:", s5, " len / cap:", len(s5), "/", cap(s5))\n    fmt.Println("s6:", s6, " len / cap:", len(s6), "/", cap(s6))\n    s5 = s4\n    copy(s6, s4)\n    fmt.Println("copy s4:", s4, " len / cap:", len(s4), "/", cap(s4))\n    fmt.Println("copy s5:", s5, " len / cap:", len(s5), "/", cap(s5))\n    fmt.Println("copy s6:", s6, " len / cap:", len(s6), "/", cap(s6))\n    s4[0] = 9\n    fmt.Println("modify s4:", s4, " len / cap:", len(s4), "/", cap(s4))\n    fmt.Println("modify s5:", s5, " len / cap:", len(s5), "/", cap(s5))\n    fmt.Println("modify s6:", s6, " len / cap:", len(s6), "/", cap(s6))\n}\n\n/* output:\ns4: [1 2 3]  len / cap: 3 / 3\ns5: []  len / cap: 0 / 0\ns6: [0 0 0]  len / cap: 3 / 3\ncopy s4: [1 2 3]  len / cap: 3 / 3\ncopy s5: [1 2 3]  len / cap: 3 / 3\ncopy s6: [1 2 3]  len / cap: 3 / 3\nmodify s4: [9 2 3]  len / cap: 3 / 3\nmodify s5: [9 2 3]  len / cap: 3 / 3\nmodify s6: [1 2 3]  len / cap: 3 / 3\n*/\n\n\n# 1.2.3 遍历切片\n\nfor i/for range遍历切片：和遍历数组一样可以使用标准索引法遍历切片，使用len()内置函数获取数组长度，然后使用[]中括号运算符获取索引元素；也可以使用for range这种更加便捷的遍历方式遍历引用。\n\nfunc SliceTraversal() {\n    s1 := []int{6, 5, 4, 3, 2, 1}\n    for i := 0; i < len(s1); i++ {\n        fmt.Printf("index: %d, value: %d\\n", i, s1[i])\n    }\n    fmt.Println("--------------")\n    for index, value := range s1 {\n        fmt.Printf("index: %d, value: %d\\n", index, value)\n    }\n}\n\n/* output:\nindex: 0, value: 6\nindex: 1, value: 5\nindex: 2, value: 4\nindex: 3, value: 3\nindex: 4, value: 2\nindex: 5, value: 1\n--------------\nindex: 0, value: 6\nindex: 1, value: 5\nindex: 2, value: 4\nindex: 3, value: 3\nindex: 4, value: 2\nindex: 5, value: 1\n*/\n\n\n# 1.2.4 切片删除\n\nGolang 中切片元素的删除过程并没有提供任何的语法糖或者方法封装，删除元素需要以被删除元素为分界点，将前后两个部分的内存重新连接起来。但这种方法在切片数据规模较大时非常低效。\n\nfunc SliceDelete() {\n    s1 := []int{0, 1, 2, 3, 4, 5}\n    index := 3\n    fmt.Println("s1:", s1, " len / cap:", len(s1), "/", cap(s1))\n    fmt.Println("before: ", s1[:index], "after: ", s1[index+1:])\n    s1 = append(s1[:index], s1[index+1:]...)\n    fmt.Println("s1:", s1, " len / cap:", len(s1), "/", cap(s1))\n}\n\n/* output:\ns1: [0 1 2 3 4 5]  len / cap: 6 / 6\nbefore:  [0 1 2] after:  [4 5]\ns1: [0 1 2 4 5]  len / cap: 5 / 6\n*/\n\n\n\n# 1.3 切片扩容\n\n前面介绍到 Golang 切片的实现原理类似 C++ STL 中的 vector，切片中也有类似于 vector 中动态扩容的智能动作。\n\n当切片使用append()内置函数追加元素时，如果当前切片容量cap被使用完时，就需要重新开辟一块新的内存空间，然后把原数据拷贝到该新空间中，并把指向原地址空间的切片指针重定向到新空间，最后释放掉原存储数据的空间。\n\nGo 中切片扩容的策略：按照 2 倍或者 1.5 倍扩大原切片的容量cap (注意不是长度len)。\n\n * 如果切片的容量小于 1024 个元素，于是扩容的时候就翻倍增加容量，即每次增加原来容量的一倍\n\n * 一旦元素个数超过 1024 个元素，那么增长因子就变成 1.5 ，即每次增加原来容量的四分之一\n\nfunc SliceExpend() {\n    s1 := make([]int, 3, 5)\n    fmt.Println("s1:", s1, " len / cap:", len(s1), "/", cap(s1))\n    s1 = append(s1, 4, 5, 6)\n    fmt.Println("s1:", s1, " len / cap:", len(s1), "/", cap(s1))\n    s2 := make([]int, 1023, 1024)\n    fmt.Println("ori s2:", " len / cap:", len(s2), "/", cap(s2))\n    s2 = append(s2, 1024, 1025)\n    fmt.Println("exp s2:", " len / cap:", len(s2), "/", cap(s2))\n}\n\n/* output:\ns1: [0 0 0]  len / cap: 3 / 5\ns1: [0 0 0 4 5 6]  len / cap: 6 / 10\nori s2:  len / cap: 1023 / 1024\nexp s2:  len / cap: 1025 / 1536\n*/\n\n\n不触发切片自动扩容的情况：Golang 切片扩容机制中要注意如果切片创建是通过字面量对 Array 数组的截取，要注意明确第三个参数 cap 值，当 cap 并不等于指向数组的总容量时且切片长度小于容量时，不会触发自动扩容，导致切片指针指向的就是原 Array 数组，当数组元素发生改变时也会影响切片。\n\n所以用字面量创建切片的时候，cap 的值一定要明确，避免共享原数组导致的 bug。\n\nfunc SliceExpend() {\n    arr := [5]int{1, 2, 3, 4, 5}\n    s3 := arr[:3]\n    fmt.Println("s3:", s3, " len / cap:", len(s3), "/", cap(s3))\n    s3 = append(s3, 4)\n    fmt.Println("s3:", s3, " len / cap:", len(s3), "/", cap(s3))\n    arr[0] = 9\n    fmt.Println("s3:", s3, " len / cap:", len(s3), "/", cap(s3))\n}\n\n/* output:\ns3: [1 2 3]  len / cap: 3 / 5\ns3: [1 2 3 4]  len / cap: 4 / 5\ns3: [9 2 3 4]  len / cap: 4 / 5 \n*/\n\n\n切片扩容导致的索引失效：当切片作为函数参数时，如果在函数内部发生了扩容，这时再修改切片中的值不会生效，因为修改发生在新开辟的内存空间中，对原先的数据没有任何影响。\n\nfunc SliceExpend() {\n    s4 := make([]int, 3, 4)\n    fmt.Println("s4:", s4, " len / cap:", len(s4), "/", cap(s4))\n    appendToExpend(s4)\n    fmt.Println("append s4:", s4, " len / cap:", len(s4), "/", cap(s4))\n    s5 := []int{1, 2, 3}\n    fmt.Println("s5:", s5, " len / cap:", len(s5), "/", cap(s5))\n    appendToExpend(s5)\n    fmt.Println("append s5:", s5, " len / cap:", len(s5), "/", cap(s5))\n}\n\nfunc appendToExpend(s []int) {\n    s = append(s, 4)\n    s[0] = 9\n}\n\n/* output:\ns4: [0 0 0]  len / cap: 3 / 4\nappend s4: [9 0 0]  len / cap: 3 / 4\ns5: [1 2 3]  len / cap: 3 / 3\nappend s5: [1 2 3]  len / cap: 3 / 3\n*/\n\n\n\n# 02 Map 键值对\n\n键值对（Map）是 Golang 中提供映射关系容器，底层使用哈希表（散列表）实现。\n\n不同于 C++ 标准模板库 STL 关联容器 提供了基于红黑树实现的有序键值对集合 Map 和基于哈希表实现的无序键值对集合 unordered_map 两种关联容器，Goalng 中提供了无序的 Map。\n\n键值对 Map 就是通过 键（Key）获取值（Value）的一种蕴含映射关系的数据结构，其底层最为简单的存储方式就是线性表，用Hash函数计算存储位置即索引，然后将数据值存入该位置。\n\n\n# 2.1 创建 Map\n\n不同于切片使用不带长度的[]元素类型的方式声明，Golang为键值对保留了关键字map用于声明键值对集合 Map，其声明格式为var mapName map[KeyType]ValueType，其中 mapName是键值对集合的名称，KeyType为键类型；ValueType是键对应的值类型。\n\nMap和切片一样，也是引用类型，声明之后未进行初始化时指向nil，所以在使用Map时声明后需要初始化，可以使用make内置函数初始化，也可以不是用make函数在声明是就填充元素完成初始化。\n\nfunc MapCreate() {\n    var m1 map[string]int\n    if m1 == nil {\n        fmt.Println("m1 is empty!")\n    }\n    var m2 = make(map[string]int)\n    m2["one"] = 1\n    m2["two"] = 2\n    fmt.Println("m2: ", m2, " len: ", len(m2))\n    m3 := map[string]int{\n        "one":   1,\n        "two":   2,\n        "three": 3,\n    }\n    fmt.Println("m3: ", m3, " len: ", len(m3))\n}\n\n/* output:\nm1 is empty!\nm2:  map[one:1 two:2]  len:  2\nm3:  map[one:1 three:3 two:2]  len:  3\n*/\n\n\n\n# 2.2 操作 Map\n\n# 2.2.1 Map 取值\n\nmap 可以直接根据键进行取值mapName[key]，如果查询的键值对不存也不会报错，返回结果是空值。\n\nfunc MapGet() {\n    m1 := map[string]int{\n        "one": 1,\n        "two": 2,\n    }\n    fmt.Println("exist: ", m1["one"], " don\'t exist: ", m1["three"])\n}\n\n/* output:\nexist:  1  don\'t exist:  0\n*/\n\n\n取值判断：Golang 中也提供了判断某个键是否存在的机制，使用比较特殊的写法value, ok := mapName[key]，在默认获取键值的基础上，多取了一个变量ok，可以判断键是否存在于map中。\n\nfunc MapGet() {\n    m1 := map[string]int{\n        "one": 1,\n        "two": 2,\n    }\n    fmt.Println("m1: ", m1, " len: ", len(m1))\n    val, ok := m1["one"]\n    if ok {\n        fmt.Println("exist: ", val)\n    } else {\n        fmt.Println("don\'t exist")\n    }\n}\n\n/* output:\nm1:  map[one:1 two:2]  len:  2\nexist:  1\n*/\n\n\n# 2.2.2 遍历 Map\n\n一般使用  for range 遍历 Map，遍历map时的元素顺序与添加键值对的顺序无关。\n\nfunc MapTraversal() {\n    m1 := map[string]int{\n        "one":   1,\n        "two":   2,\n        "three": 3,\n    }\n    fmt.Println("m1: ", m1, " len: ", len(m1))\n    for k, v := range m1 {\n        fmt.Println("key: ", k, " val: ", v)\n    }\n}\n\n/* output:\nm1:  map[one:1 three:3 two:2]  len:  3\nkey:  one  val:  1\nkey:  two  val:  2\nkey:  three  val:  3\n*/\n\n\n如果仅遍历Map的键或者值，在for range参数中省略或者用匿名遍历忽略其中一个即可。\n\nfunc MapTraversal() {\n    m1 := map[string]int{\n        "one":   1,\n        "two":   2,\n        "three": 3,\n    }\n    fmt.Println("m1: ", m1, " len: ", len(m1))\n    // 只取键\n    for k := range m1 {\n        fmt.Println("key: ", k)\n    }\n    // 只取\n    for _, v := range m1 {\n        fmt.Println(" val: ", v)\n    }\n}\n\n\n/* output:\nm1:  map[one:1 three:3 two:2]  len:  3\nkey:  one  val:  1\nkey:  two  val:  2\nkey:  three  val:  3\nkey:  one\nkey:  two\nkey:  three\n val:  1\n val:  2\n val:  3\n*/\n\n\n按指定顺序遍历Map：由于 Golang 中 Map 底层实现是 Hash 表，所以通常遍历结果是无序的，如果要按照指定顺序遍历 Map，则需要额外进行排序等操作实现。\n\nfunc MapTraversal() {\n    m2 := map[string]int{\n        "stu-2": 99,\n        "stu-4": 79,\n        "stu-3": 93,\n        "stu-1": 63,\n    }\n    keys := make([]string, 0, 4)\n    for k := range m2 {\n        keys = append(keys, k)\n    }\n    sort.Strings(keys)\n    fmt.Println("sort print:")\n    for _, key := range keys {\n        fmt.Println(key, m2[key])\n    }\n}\n\n/* output:\nsort print:\nstu-1 63\nstu-2 99\nstu-3 93\nstu-4 79\n*/\n\n\n# 2.2.3 Map 删除\n\nMap 中如果需要删除某个键值对可以直接使用内置函数delete()进行操作，使用格式为delete(mapName,key)，其中 mapName 是要删除的 map 实例名称，key 则为要删除的 map 键值对中的键。\n\nfunc MapDelete() {\n    m1 := map[string]int{\n        "one": 1,\n        "xyz": 100,\n        "two": 2,\n    }\n    fmt.Println("m1: ", m1, " len: ", len(m1))\n    delete(m1, "xyz")\n    fmt.Println("m1: ", m1, " len: ", len(m1))\n}\n\n/* output:\nm1:  map[one:1 two:2 xyz:100]  len:  3\nm1:  map[one:1 two:2]  len:  2\n*/\n\n\n\n# 2.3 Map 实现原理\n\nGolang Map实现原理 - 简书\n\n\n# 03 Channel 通道\n\n待并发编程更新.......\n\n\n# 参考资料\n\n切片Slice · Go语言中文文档\n\nGo slice切片详解和实战 - 掘金\n\ngolang基础-深入理解 slice - 掘金\n\nMap · Go语言中文文档\n\nGo map详解和实战 - 掘金\n\nGolang Map实现原理 - 简书\n\ngolang 系列：channel 全面解析',normalizedContent:'# 基础数据类型 引用类型\n\n引用类型的在内存栈空间中存储的是保存变量名和指向堆空间中的变量地址，地址指向的堆空间中保存着实际的值。在赋值或拷贝变量时，栈空间中保存的地址也被拷贝指向相同的堆空间中保存的值，所以在修改其中一个变量的值时，其他的变量会一起被修改。\n\n类型        默认值   说明\nslice     nil   引用类型\nmap       nil   引用类型\nchannel   nil   引用类型\n\n\n# 01 slice 切片\n\n切片（slice）是对数组一个连续片段的引用，所以切片是一个引用类型，类似于 c/c++ 中的数组类型，而golang 中的数组是值类型，赋值和函数传参操作都会复制整个数组数据。\n\n相较于 golang 数组拷贝过程中的巨大内存开销，采用切片的方式进行赋值或者传参不需要使用额外的内存并且比使用数组更有效率。\n\n切片的实现原理类似 c++ stl 中的 vector，但是切片本身并不是动态数组或者数组指针。它内部实现的数据结构通过指针引用底层数组，设定相关属性将数据读写操作限定在指定的区域内。切片本身是一个只读对象，其工作机制类似数组指针的一种封装。\n\ntype slice struct {\n    array unsafe.pointer // 保存指向堆空间的地址\n    len   int            // 包含元素的个数（实际被使用容量）长度\n    cap   int            // 切片的实际容量（使用部分+未使用部分）通常大于等于len\n}\n\n\n\n# 1.1 创建切片\n\n声明切片的方式与数组声明类似，但是不在[]中指明长度，数组是固定长度的，而切片的长度可变的。\n\n// 数组声明\nvar arr1 [3]int\nvar arr2 [...]int{1,2,3}\narr3 := [3]int{1,2,3} // 短变量声明\n// 切片声明\nvar s1 []int // 空切片\ns1 := []int{1,2,3} // 短变量声明\n\n\nmake函数初始化切片：golang 的 make 内置函数用于分配内存空间，返回引用类型本身。make 函数有三个入参分别是：数据类型(*_type)，长度(len)和容量(cap)，如果容量被省略则与长度同值。\n\n// 声明形式\nvar slice []type = make([]type, len)\nslice  := make([]type, len)\nslice  := make([]type, len, cap)\n\n// example:\nfunc slicecreate() {\n    var s1 []int = make([]int, 3, 5)\n    fmt.println("s1:", s1, " len / cap:", len(s1), "/", cap(s1))\n    var s2 []int = make([]int, 3)\n    fmt.println("s2:", s2, " len / cap:", len(s2), "/", cap(s2))\n}\n\n/* output:\ns1: [0 0 0]  len / cap: 3 / 5\ns2: [0 0 0]  len / cap: 3 / 3\n*/\n\n\n空切片初始化：nil切片表示该切片结构体的指针指向nil，表示切片不存在，常用于函数异常返回值。空切片的指针指向具体地址但该地址没有存放任何元素，空切片一般会用来表示一个空的集合。\n\nfunc slicecreate() {\n    var s3 []int // nil切片\n    if s3 == nil {\n        fmt.println("s3 is empty")\n    }\n    s3 = []int{1, 2, 3}\n    fmt.println("s3:", s3, " len / cap:", len(s3), "/", cap(s3))\n    // 空切片\n    s4 := make([]int, 0)\n    fmt.println("s4:", s4, " len / cap:", len(s4), "/", cap(s4))\n    s4 = []int{}\n    fmt.println("s4:", s4, " len / cap:", len(s4), "/", cap(s4))\n    s4 = []int{1, 2, 3, 4}\n    fmt.println("s4:", s4, " len / cap:", len(s4), "/", cap(s4))\n}\n\n/* output:\ns3 is empty\ns3: [1 2 3]  len / cap: 3 / 3\ns4: []  len / cap: 0 / 0\ns4: []  len / cap: 0 / 0\ns4: [1 2 3 4]  len / cap: 4 / 4\n*/\n\n\n使用字面量从数组中切片：使用切片引用数组连续的全部或部分数据，使用字面量（索引号）获取数组的部分数据，字面量操作含义如下表所示\n\n操作                  含义\narr[n]              索引号为n的单个元素\narr[:]              从索引位置0到len(arr)-1中所获得的切片即数组的所有元素\narr[low:]           从索引位置low到len(arr)-1中所获得的切片，长度为len(arr)-low，容量为len(arr)\narr[:high]          从索引位置0到high-1中所获得的切片，长度为high，容量为len(arr)\narr[low:high]       从索引位置low到high-1中所获得的切片，长度为high-low，容量为len(arr)\narr[low:high:max]   从索引位置low到high-1中所获得的切片，长度为high-low，容量为max-low\n\nfunc slicecreate() {\n    var arr = [...]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 0}\n    s5 := arr[1:5:6]\n    fmt.println("s5:", s5, " len / cap:", len(s5), "/", cap(s5))\n    s6 := arr[1:5]\n    fmt.println("s6:", s6, " len / cap:", len(s6), "/", cap(s6))\n}\n\n/* output:\ns5: [2 3 4 5]  len / cap: 4 / 5\ns6: [2 3 4 5]  len / cap: 4 / 9\n*/ \n\n\n\n# 1.2 操作切片\n\n# 1.2.1 切片追加\n\nappend()内置函数添加元素：切片使用append()内置函数向该切片末尾追加元素，并返回新的切片。\n\nfunc sliceappend() {\n    s1 := make([]int, 1)\n    fmt.println("s1:", s1, " len / cap:", len(s1), "/", cap(s1))\n    s2 := append(s1, 1)\n    fmt.println("s2:", s2, " len / cap:", len(s2), "/", cap(s2))\n    fmt.printf("pos s1: %p; pos s2: %p\\n", &s1, &s2)\n}\n\n/* output:\ns1: [0]  len / cap: 1 / 1\ns2: [0 1]  len / cap: 2 / 2\npos s1: 0xc0000040d8; pos s2: 0xc000004108\n*/\n\n\n向切片中追加多个元素：\n\n 1. 切片追加多个元素，可以通过多次调用append()，也可以添加多个入参\n\nfunc sliceappend() {\n    s3 := []int{1, 2, 3}\n    fmt.println("s3:", s3, " len / cap:", len(s3), "/", cap(s3))\n    s3 = append(s3, 4)\n    s3 = append(s3, 5)\n    fmt.println("s3:", s3, " len / cap:", len(s3), "/", cap(s3))\n    s3 = append(s3, 6, 7, 8)\n    fmt.println("s3:", s3, " len / cap:", len(s3), "/", cap(s3))\n}\n\n/* output:\ns3: [1 2 3]  len / cap: 3 / 3\ns3: [1 2 3 4 5]  len / cap: 5 / 6\ns3: [1 2 3 4 5 6 7 8]  len / cap: 8 / 12\n*/\n\n\n 2. 使用append()将切片作为追加元素，使用...运算符将切片值拆分成单个追加元素\n\nfunc sliceappend() {\n    s4 := []int{1, 2, 3}\n    fmt.println("s4:", s4, " len / cap:", len(s4), "/", cap(s4))\n    s5 := []int{4, 5}\n    fmt.println("s5:", s5, " len / cap:", len(s5), "/", cap(s5))\n    s6 := append(s4, s5...)\n    fmt.println("s6:", s6, " len / cap:", len(s6), "/", cap(s6))\n}\n\n/* output:\ns4: [1 2 3]  len / cap: 3 / 3\ns5: [4 5]  len / cap: 2 / 2\ns6: [1 2 3 4 5]  len / cap: 5 / 6\n*/\n\n\n# 1.2.2 拷贝切片\n\ncopy()内置函数拷贝切片：使用 copy 内置函数拷贝切片时，是将切片的数据拷贝到另外新开辟的内存空间中；copy 内置函数的参数和返回值为copy( dest slice, src slice []t) int，其中第一个参数为拷贝的目标切片，第二个参数是拷贝的对象即数据源，返回值表示的是根据两个切片长度len的较小值实际成功拷贝的元素个数。\n\nfunc slicecopy() {\n    s1 := make([]int, 3, 5)\n    fmt.println("s1:", s1, " len / cap:", len(s1), "/", cap(s1))\n    s2 := []int{1, 2}\n    fmt.println("s2:", s2, " len / cap:", len(s2), "/", cap(s2))\n    copy(s1, s2)\n    fmt.println("copy s1:", s1, " len / cap:", len(s1), "/", cap(s1))\n    fmt.println("copy s2:", s2, " len / cap:", len(s2), "/", cap(s2))\n    s3 := []int{3}\n    fmt.println("s3:", s3, " len / cap:", len(s3), "/", cap(s3))\n    s1 = append(s1, s3...)\n    fmt.println("append s1:", s1, " len / cap:", len(s1), "/", cap(s1))\n    copy(s3, s2)\n    fmt.println("copy s3:", s3, " len / cap:", len(s3), "/", cap(s3))\n    fmt.println("copy s2:", s2, " len / cap:", len(s2), "/", cap(s2))\n}\n\n/* output:\ns1: [0 0 0]  len / cap: 3 / 5\ns2: [1 2]  len / cap: 2 / 2\ncopy s1: [1 2 0]  len / cap: 3 / 5\ncopy s2: [1 2]  len / cap: 2 / 2\ns3: [3]  len / cap: 1 / 1\nappend s1: [1 2 0 3]  len / cap: 4 / 5\ncopy s3: [1]  len / cap: 1 / 1\ncopy s2: [1 2]  len / cap: 2 / 2\n*/\n\n\n=赋值运算符浅拷贝：golang 中有了 array 数组还提出 slice 切片的一个重要动机就是当数组保存数据规模过大时，避免全部重新复制一遍数组元素，而使用指向存储实际数据空间的指针高效利用内存。使用=拷贝切片时，两者引用同一个内存空间，当修改其中一个时，两者同时被修改。\n\nfunc slicecopy() {\n    s4 := []int{1, 2, 3}\n    s5 := []int{}\n    s6 := make([]int, 3)\n    fmt.println("s4:", s4, " len / cap:", len(s4), "/", cap(s4))\n    fmt.println("s5:", s5, " len / cap:", len(s5), "/", cap(s5))\n    fmt.println("s6:", s6, " len / cap:", len(s6), "/", cap(s6))\n    s5 = s4\n    copy(s6, s4)\n    fmt.println("copy s4:", s4, " len / cap:", len(s4), "/", cap(s4))\n    fmt.println("copy s5:", s5, " len / cap:", len(s5), "/", cap(s5))\n    fmt.println("copy s6:", s6, " len / cap:", len(s6), "/", cap(s6))\n    s4[0] = 9\n    fmt.println("modify s4:", s4, " len / cap:", len(s4), "/", cap(s4))\n    fmt.println("modify s5:", s5, " len / cap:", len(s5), "/", cap(s5))\n    fmt.println("modify s6:", s6, " len / cap:", len(s6), "/", cap(s6))\n}\n\n/* output:\ns4: [1 2 3]  len / cap: 3 / 3\ns5: []  len / cap: 0 / 0\ns6: [0 0 0]  len / cap: 3 / 3\ncopy s4: [1 2 3]  len / cap: 3 / 3\ncopy s5: [1 2 3]  len / cap: 3 / 3\ncopy s6: [1 2 3]  len / cap: 3 / 3\nmodify s4: [9 2 3]  len / cap: 3 / 3\nmodify s5: [9 2 3]  len / cap: 3 / 3\nmodify s6: [1 2 3]  len / cap: 3 / 3\n*/\n\n\n# 1.2.3 遍历切片\n\nfor i/for range遍历切片：和遍历数组一样可以使用标准索引法遍历切片，使用len()内置函数获取数组长度，然后使用[]中括号运算符获取索引元素；也可以使用for range这种更加便捷的遍历方式遍历引用。\n\nfunc slicetraversal() {\n    s1 := []int{6, 5, 4, 3, 2, 1}\n    for i := 0; i < len(s1); i++ {\n        fmt.printf("index: %d, value: %d\\n", i, s1[i])\n    }\n    fmt.println("--------------")\n    for index, value := range s1 {\n        fmt.printf("index: %d, value: %d\\n", index, value)\n    }\n}\n\n/* output:\nindex: 0, value: 6\nindex: 1, value: 5\nindex: 2, value: 4\nindex: 3, value: 3\nindex: 4, value: 2\nindex: 5, value: 1\n--------------\nindex: 0, value: 6\nindex: 1, value: 5\nindex: 2, value: 4\nindex: 3, value: 3\nindex: 4, value: 2\nindex: 5, value: 1\n*/\n\n\n# 1.2.4 切片删除\n\ngolang 中切片元素的删除过程并没有提供任何的语法糖或者方法封装，删除元素需要以被删除元素为分界点，将前后两个部分的内存重新连接起来。但这种方法在切片数据规模较大时非常低效。\n\nfunc slicedelete() {\n    s1 := []int{0, 1, 2, 3, 4, 5}\n    index := 3\n    fmt.println("s1:", s1, " len / cap:", len(s1), "/", cap(s1))\n    fmt.println("before: ", s1[:index], "after: ", s1[index+1:])\n    s1 = append(s1[:index], s1[index+1:]...)\n    fmt.println("s1:", s1, " len / cap:", len(s1), "/", cap(s1))\n}\n\n/* output:\ns1: [0 1 2 3 4 5]  len / cap: 6 / 6\nbefore:  [0 1 2] after:  [4 5]\ns1: [0 1 2 4 5]  len / cap: 5 / 6\n*/\n\n\n\n# 1.3 切片扩容\n\n前面介绍到 golang 切片的实现原理类似 c++ stl 中的 vector，切片中也有类似于 vector 中动态扩容的智能动作。\n\n当切片使用append()内置函数追加元素时，如果当前切片容量cap被使用完时，就需要重新开辟一块新的内存空间，然后把原数据拷贝到该新空间中，并把指向原地址空间的切片指针重定向到新空间，最后释放掉原存储数据的空间。\n\ngo 中切片扩容的策略：按照 2 倍或者 1.5 倍扩大原切片的容量cap (注意不是长度len)。\n\n * 如果切片的容量小于 1024 个元素，于是扩容的时候就翻倍增加容量，即每次增加原来容量的一倍\n\n * 一旦元素个数超过 1024 个元素，那么增长因子就变成 1.5 ，即每次增加原来容量的四分之一\n\nfunc sliceexpend() {\n    s1 := make([]int, 3, 5)\n    fmt.println("s1:", s1, " len / cap:", len(s1), "/", cap(s1))\n    s1 = append(s1, 4, 5, 6)\n    fmt.println("s1:", s1, " len / cap:", len(s1), "/", cap(s1))\n    s2 := make([]int, 1023, 1024)\n    fmt.println("ori s2:", " len / cap:", len(s2), "/", cap(s2))\n    s2 = append(s2, 1024, 1025)\n    fmt.println("exp s2:", " len / cap:", len(s2), "/", cap(s2))\n}\n\n/* output:\ns1: [0 0 0]  len / cap: 3 / 5\ns1: [0 0 0 4 5 6]  len / cap: 6 / 10\nori s2:  len / cap: 1023 / 1024\nexp s2:  len / cap: 1025 / 1536\n*/\n\n\n不触发切片自动扩容的情况：golang 切片扩容机制中要注意如果切片创建是通过字面量对 array 数组的截取，要注意明确第三个参数 cap 值，当 cap 并不等于指向数组的总容量时且切片长度小于容量时，不会触发自动扩容，导致切片指针指向的就是原 array 数组，当数组元素发生改变时也会影响切片。\n\n所以用字面量创建切片的时候，cap 的值一定要明确，避免共享原数组导致的 bug。\n\nfunc sliceexpend() {\n    arr := [5]int{1, 2, 3, 4, 5}\n    s3 := arr[:3]\n    fmt.println("s3:", s3, " len / cap:", len(s3), "/", cap(s3))\n    s3 = append(s3, 4)\n    fmt.println("s3:", s3, " len / cap:", len(s3), "/", cap(s3))\n    arr[0] = 9\n    fmt.println("s3:", s3, " len / cap:", len(s3), "/", cap(s3))\n}\n\n/* output:\ns3: [1 2 3]  len / cap: 3 / 5\ns3: [1 2 3 4]  len / cap: 4 / 5\ns3: [9 2 3 4]  len / cap: 4 / 5 \n*/\n\n\n切片扩容导致的索引失效：当切片作为函数参数时，如果在函数内部发生了扩容，这时再修改切片中的值不会生效，因为修改发生在新开辟的内存空间中，对原先的数据没有任何影响。\n\nfunc sliceexpend() {\n    s4 := make([]int, 3, 4)\n    fmt.println("s4:", s4, " len / cap:", len(s4), "/", cap(s4))\n    appendtoexpend(s4)\n    fmt.println("append s4:", s4, " len / cap:", len(s4), "/", cap(s4))\n    s5 := []int{1, 2, 3}\n    fmt.println("s5:", s5, " len / cap:", len(s5), "/", cap(s5))\n    appendtoexpend(s5)\n    fmt.println("append s5:", s5, " len / cap:", len(s5), "/", cap(s5))\n}\n\nfunc appendtoexpend(s []int) {\n    s = append(s, 4)\n    s[0] = 9\n}\n\n/* output:\ns4: [0 0 0]  len / cap: 3 / 4\nappend s4: [9 0 0]  len / cap: 3 / 4\ns5: [1 2 3]  len / cap: 3 / 3\nappend s5: [1 2 3]  len / cap: 3 / 3\n*/\n\n\n\n# 02 map 键值对\n\n键值对（map）是 golang 中提供映射关系容器，底层使用哈希表（散列表）实现。\n\n不同于 c++ 标准模板库 stl 关联容器 提供了基于红黑树实现的有序键值对集合 map 和基于哈希表实现的无序键值对集合 unordered_map 两种关联容器，goalng 中提供了无序的 map。\n\n键值对 map 就是通过 键（key）获取值（value）的一种蕴含映射关系的数据结构，其底层最为简单的存储方式就是线性表，用hash函数计算存储位置即索引，然后将数据值存入该位置。\n\n\n# 2.1 创建 map\n\n不同于切片使用不带长度的[]元素类型的方式声明，golang为键值对保留了关键字map用于声明键值对集合 map，其声明格式为var mapname map[keytype]valuetype，其中 mapname是键值对集合的名称，keytype为键类型；valuetype是键对应的值类型。\n\nmap和切片一样，也是引用类型，声明之后未进行初始化时指向nil，所以在使用map时声明后需要初始化，可以使用make内置函数初始化，也可以不是用make函数在声明是就填充元素完成初始化。\n\nfunc mapcreate() {\n    var m1 map[string]int\n    if m1 == nil {\n        fmt.println("m1 is empty!")\n    }\n    var m2 = make(map[string]int)\n    m2["one"] = 1\n    m2["two"] = 2\n    fmt.println("m2: ", m2, " len: ", len(m2))\n    m3 := map[string]int{\n        "one":   1,\n        "two":   2,\n        "three": 3,\n    }\n    fmt.println("m3: ", m3, " len: ", len(m3))\n}\n\n/* output:\nm1 is empty!\nm2:  map[one:1 two:2]  len:  2\nm3:  map[one:1 three:3 two:2]  len:  3\n*/\n\n\n\n# 2.2 操作 map\n\n# 2.2.1 map 取值\n\nmap 可以直接根据键进行取值mapname[key]，如果查询的键值对不存也不会报错，返回结果是空值。\n\nfunc mapget() {\n    m1 := map[string]int{\n        "one": 1,\n        "two": 2,\n    }\n    fmt.println("exist: ", m1["one"], " don\'t exist: ", m1["three"])\n}\n\n/* output:\nexist:  1  don\'t exist:  0\n*/\n\n\n取值判断：golang 中也提供了判断某个键是否存在的机制，使用比较特殊的写法value, ok := mapname[key]，在默认获取键值的基础上，多取了一个变量ok，可以判断键是否存在于map中。\n\nfunc mapget() {\n    m1 := map[string]int{\n        "one": 1,\n        "two": 2,\n    }\n    fmt.println("m1: ", m1, " len: ", len(m1))\n    val, ok := m1["one"]\n    if ok {\n        fmt.println("exist: ", val)\n    } else {\n        fmt.println("don\'t exist")\n    }\n}\n\n/* output:\nm1:  map[one:1 two:2]  len:  2\nexist:  1\n*/\n\n\n# 2.2.2 遍历 map\n\n一般使用  for range 遍历 map，遍历map时的元素顺序与添加键值对的顺序无关。\n\nfunc maptraversal() {\n    m1 := map[string]int{\n        "one":   1,\n        "two":   2,\n        "three": 3,\n    }\n    fmt.println("m1: ", m1, " len: ", len(m1))\n    for k, v := range m1 {\n        fmt.println("key: ", k, " val: ", v)\n    }\n}\n\n/* output:\nm1:  map[one:1 three:3 two:2]  len:  3\nkey:  one  val:  1\nkey:  two  val:  2\nkey:  three  val:  3\n*/\n\n\n如果仅遍历map的键或者值，在for range参数中省略或者用匿名遍历忽略其中一个即可。\n\nfunc maptraversal() {\n    m1 := map[string]int{\n        "one":   1,\n        "two":   2,\n        "three": 3,\n    }\n    fmt.println("m1: ", m1, " len: ", len(m1))\n    // 只取键\n    for k := range m1 {\n        fmt.println("key: ", k)\n    }\n    // 只取\n    for _, v := range m1 {\n        fmt.println(" val: ", v)\n    }\n}\n\n\n/* output:\nm1:  map[one:1 three:3 two:2]  len:  3\nkey:  one  val:  1\nkey:  two  val:  2\nkey:  three  val:  3\nkey:  one\nkey:  two\nkey:  three\n val:  1\n val:  2\n val:  3\n*/\n\n\n按指定顺序遍历map：由于 golang 中 map 底层实现是 hash 表，所以通常遍历结果是无序的，如果要按照指定顺序遍历 map，则需要额外进行排序等操作实现。\n\nfunc maptraversal() {\n    m2 := map[string]int{\n        "stu-2": 99,\n        "stu-4": 79,\n        "stu-3": 93,\n        "stu-1": 63,\n    }\n    keys := make([]string, 0, 4)\n    for k := range m2 {\n        keys = append(keys, k)\n    }\n    sort.strings(keys)\n    fmt.println("sort print:")\n    for _, key := range keys {\n        fmt.println(key, m2[key])\n    }\n}\n\n/* output:\nsort print:\nstu-1 63\nstu-2 99\nstu-3 93\nstu-4 79\n*/\n\n\n# 2.2.3 map 删除\n\nmap 中如果需要删除某个键值对可以直接使用内置函数delete()进行操作，使用格式为delete(mapname,key)，其中 mapname 是要删除的 map 实例名称，key 则为要删除的 map 键值对中的键。\n\nfunc mapdelete() {\n    m1 := map[string]int{\n        "one": 1,\n        "xyz": 100,\n        "two": 2,\n    }\n    fmt.println("m1: ", m1, " len: ", len(m1))\n    delete(m1, "xyz")\n    fmt.println("m1: ", m1, " len: ", len(m1))\n}\n\n/* output:\nm1:  map[one:1 two:2 xyz:100]  len:  3\nm1:  map[one:1 two:2]  len:  2\n*/\n\n\n\n# 2.3 map 实现原理\n\ngolang map实现原理 - 简书\n\n\n# 03 channel 通道\n\n待并发编程更新.......\n\n\n# 参考资料\n\n切片slice · go语言中文文档\n\ngo slice切片详解和实战 - 掘金\n\ngolang基础-深入理解 slice - 掘金\n\nmap · go语言中文文档\n\ngo map详解和实战 - 掘金\n\ngolang map实现原理 - 简书\n\ngolang 系列：channel 全面解析',charsets:{cjk:!0},lastUpdated:"2023/11/19, 12:55:48",lastUpdatedTimestamp:1700369748e3},{title:"条件判断",frontmatter:{title:"条件判断",date:"2023-03-24T19:09:52.000Z",permalink:"/pages/d8dd95/"},regularPath:"/02.Golang%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/01.Golang%E5%9F%BA%E7%A1%80/02.%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/01.%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD.html",relativePath:"02.Golang学习笔记/01.Golang基础/02.流程控制/01.条件判断.md",key:"v-3f0ce116",path:"/pages/d8dd95/",headers:[{level:2,title:"01 条件判断 if",slug:"_01-条件判断-if",normalizedTitle:"01 条件判断 if",charIndex:81},{level:2,title:"02 分支选择 switch",slug:"_02-分支选择-switch",normalizedTitle:"02 分支选择 switch",charIndex:1491},{level:2,title:"03 异步处理 select",slug:"_03-异步处理-select",normalizedTitle:"03 异步处理 select",charIndex:3108},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:3143}],headersStr:"01 条件判断 if 02 分支选择 switch 03 异步处理 select 参考资料",content:'# 条件判断\n\n条件语句一般指定一个或多个条件，并通过测试条件是否为 true 来决定是否执行指定语句，并在条件为 false 的情况在执行另外的语句。\n\n\n# 01 条件判断 if\n\nGolang 中 if 条件语句通过 if 关键字声明，声明条件可以省略条件表达式的括号，但是条件语句的代码块左大括号 { 必须在条件表达式的末尾，否则会触发编译错误。\n\n// 声明语法\nif 条件表达式 {\n    /* 在条件表达式为 true 时执行 */\n}\n\n// example:\nfunc IfExp() {\n    var x int = 10\n    // if x > 10  // 编译出错\n    // {\n    //     fmt.Println("con\'t print here")\n    // }\n    if x >= 10 {\n        fmt.Println("x 大于等于 10")\n    }\n}\n\n\nelse 关键字和 if 对应在条件表达式为 false 时执行其代码块； else if 是 if 的延伸，与多个 if 判断不同的是 else if 与其关联的 if 互斥执行，而前者是相互独立执行的。\n\nfunc IfExp() {\n    var x int = 10\n\n    if x != 10 {\n        fmt.Println("x 不等于 10")\n    } else {\n        fmt.Println("x 等于 10")\n    }\n\n    y := 20\n\n    if x == 10 {\n        fmt.Println("x 等于 10")\n    } else if y == 20 {\n        fmt.Println("y 等于 20")\n    } else {\n        fmt.Println("x 不等于 10")\n    }\n\n    if x == 10 {\n        fmt.Println("x 等于 10")\n    }\n    if y == 20 {\n        fmt.Println("y 等于 20")\n    }\n}\n\n\nGolang 中可以在 if 条件表达式之前添加执行语句，再根据执行语句的变量值进行判断。这种特殊写法引出了变量作用域的问题，上述执行语句中的变量仅在 if 局部代码块内生效，不影响外部的变量。\n\n> 在编程中，变量在其实现了变量的功能后，作用范围越小，所造成的问题可能性越小，每一个变量代表一个状态，有状态的地方，状态就会被修改，函数的局部变量只会影响一个函数的执行，但全局变量可能会影响所有代码的执行状态，因此限制变量的作用范围对代码的稳定性有很大的帮助。\n\nfunc IfExp() {\n    var x int = 10\n    if x := subFunc(); x == 1 {\n        fmt.Println("x 等于 1")\n        x -= 1\n        fmt.Println("inner x:", x)\n    } else {\n        fmt.Println("x 等于 10")\n    }\n    fmt.Println("global x:", x)\n}\n\nfunc subFunc() int {\n    return 1\n}\n\n/* output:\nx 等于 1\ninner x: 0\nglobal x: 10\n*/\n\n\n\n# 02 分支选择 switch\n\nswitch 分支选择可以理解为一种批量的 if 语句，根据不同的条件执行不同的代码块，使用switch语句可方便地对大量的值进行判断。\n\n区别于 C/C++ 中 switch 语句只能进行常量判断，Golang 中 switch 的分支表达式可以是任意类型，且在每个唯一的 case 分支代码块相互独立，可以省略 break 跳出操作，默认自动终止。\n\nfunc SwitchExp() {\n    var num int = 1\n    switch num {\n    case 0:\n        fmt.Println("case 0")\n    case 1:\n        fmt.Println("case 1")\n    case 2:\n        fmt.Println("case 2")\n    }\n}\n\n\n同分支合并：如果多个不同 case 的代码执行任务一致，可以将它们放在一起，不同的case表达式使用逗号分隔。\n\nfunc SwitchExp() {\n    str := "hello"\n    switch str {\n    case "hello", "world":\n        fmt.Println("Hello,World!")\n    case "你好", "世界":\n        fmt.Println("你好，世界！")\n    }\n}\n\n\n分支表达式：switch 的 case 中不仅可以是值类型的常量判断，还可以是表达式等任意类型。这种方式类似于 else if 机制，一旦一个 case 表达式满足，后续 case 不再被判断而跳出整个 switch；但是可以使用 fallthrough 关键字强制执行后面的 case 代码块。\n\nfunc SwitchExp() {\n    n := 10\n    switch {\n    case n > 9 && n < 20:\n        fmt.Println("9 < n < 20")\n        fallthrough\n    case n == 10:\n        fmt.Println("n == 10")\n    }\n}\n\n\n用于类型判断：switch 分支选择常被用来判断 Golang 中表示任意类型或空接口的 any/interface{} 变量中实际存储的变量类型。\n\nfunc SwitchExp() {\n    var a interface{}\n    dataType(a)\n    var i int = 1\n    dataType(i)\n    var s string = "hello"\n    dataType(s)\n}\n\nfunc dataType(a any) {\n    switch t := a.(type) {\n    case nil:\n        fmt.Printf("变量的类型 :%T\\r\\n", t)\n    case int:\n        fmt.Println("变量是 int 型")\n    case float64:\n        fmt.Println("变量是 float64 型")\n    case func(int) float64:\n        fmt.Println("变量是 func(int) 型")\n    case bool, string:\n        fmt.Println("变量是 bool 或 string 型")\n    default:\n        fmt.Println("未知型")\n    }\n}\n\n/* output:\n变量的类型 :<nil>\n变量是 int 型\n变量是 bool 或 string 型\n*/\n\n\n\n# 03 异步处理 select\n\n待并发编程更新.......\n\n\n# 参考资料\n\n条件语句if · Go语言中文文档\n\n条件语句switch · Go语言中文文档\n\nGo语言 if判断和for循环实战 goto使用的那些坑 - 掘金',normalizedContent:'# 条件判断\n\n条件语句一般指定一个或多个条件，并通过测试条件是否为 true 来决定是否执行指定语句，并在条件为 false 的情况在执行另外的语句。\n\n\n# 01 条件判断 if\n\ngolang 中 if 条件语句通过 if 关键字声明，声明条件可以省略条件表达式的括号，但是条件语句的代码块左大括号 { 必须在条件表达式的末尾，否则会触发编译错误。\n\n// 声明语法\nif 条件表达式 {\n    /* 在条件表达式为 true 时执行 */\n}\n\n// example:\nfunc ifexp() {\n    var x int = 10\n    // if x > 10  // 编译出错\n    // {\n    //     fmt.println("con\'t print here")\n    // }\n    if x >= 10 {\n        fmt.println("x 大于等于 10")\n    }\n}\n\n\nelse 关键字和 if 对应在条件表达式为 false 时执行其代码块； else if 是 if 的延伸，与多个 if 判断不同的是 else if 与其关联的 if 互斥执行，而前者是相互独立执行的。\n\nfunc ifexp() {\n    var x int = 10\n\n    if x != 10 {\n        fmt.println("x 不等于 10")\n    } else {\n        fmt.println("x 等于 10")\n    }\n\n    y := 20\n\n    if x == 10 {\n        fmt.println("x 等于 10")\n    } else if y == 20 {\n        fmt.println("y 等于 20")\n    } else {\n        fmt.println("x 不等于 10")\n    }\n\n    if x == 10 {\n        fmt.println("x 等于 10")\n    }\n    if y == 20 {\n        fmt.println("y 等于 20")\n    }\n}\n\n\ngolang 中可以在 if 条件表达式之前添加执行语句，再根据执行语句的变量值进行判断。这种特殊写法引出了变量作用域的问题，上述执行语句中的变量仅在 if 局部代码块内生效，不影响外部的变量。\n\n> 在编程中，变量在其实现了变量的功能后，作用范围越小，所造成的问题可能性越小，每一个变量代表一个状态，有状态的地方，状态就会被修改，函数的局部变量只会影响一个函数的执行，但全局变量可能会影响所有代码的执行状态，因此限制变量的作用范围对代码的稳定性有很大的帮助。\n\nfunc ifexp() {\n    var x int = 10\n    if x := subfunc(); x == 1 {\n        fmt.println("x 等于 1")\n        x -= 1\n        fmt.println("inner x:", x)\n    } else {\n        fmt.println("x 等于 10")\n    }\n    fmt.println("global x:", x)\n}\n\nfunc subfunc() int {\n    return 1\n}\n\n/* output:\nx 等于 1\ninner x: 0\nglobal x: 10\n*/\n\n\n\n# 02 分支选择 switch\n\nswitch 分支选择可以理解为一种批量的 if 语句，根据不同的条件执行不同的代码块，使用switch语句可方便地对大量的值进行判断。\n\n区别于 c/c++ 中 switch 语句只能进行常量判断，golang 中 switch 的分支表达式可以是任意类型，且在每个唯一的 case 分支代码块相互独立，可以省略 break 跳出操作，默认自动终止。\n\nfunc switchexp() {\n    var num int = 1\n    switch num {\n    case 0:\n        fmt.println("case 0")\n    case 1:\n        fmt.println("case 1")\n    case 2:\n        fmt.println("case 2")\n    }\n}\n\n\n同分支合并：如果多个不同 case 的代码执行任务一致，可以将它们放在一起，不同的case表达式使用逗号分隔。\n\nfunc switchexp() {\n    str := "hello"\n    switch str {\n    case "hello", "world":\n        fmt.println("hello,world!")\n    case "你好", "世界":\n        fmt.println("你好，世界！")\n    }\n}\n\n\n分支表达式：switch 的 case 中不仅可以是值类型的常量判断，还可以是表达式等任意类型。这种方式类似于 else if 机制，一旦一个 case 表达式满足，后续 case 不再被判断而跳出整个 switch；但是可以使用 fallthrough 关键字强制执行后面的 case 代码块。\n\nfunc switchexp() {\n    n := 10\n    switch {\n    case n > 9 && n < 20:\n        fmt.println("9 < n < 20")\n        fallthrough\n    case n == 10:\n        fmt.println("n == 10")\n    }\n}\n\n\n用于类型判断：switch 分支选择常被用来判断 golang 中表示任意类型或空接口的 any/interface{} 变量中实际存储的变量类型。\n\nfunc switchexp() {\n    var a interface{}\n    datatype(a)\n    var i int = 1\n    datatype(i)\n    var s string = "hello"\n    datatype(s)\n}\n\nfunc datatype(a any) {\n    switch t := a.(type) {\n    case nil:\n        fmt.printf("变量的类型 :%t\\r\\n", t)\n    case int:\n        fmt.println("变量是 int 型")\n    case float64:\n        fmt.println("变量是 float64 型")\n    case func(int) float64:\n        fmt.println("变量是 func(int) 型")\n    case bool, string:\n        fmt.println("变量是 bool 或 string 型")\n    default:\n        fmt.println("未知型")\n    }\n}\n\n/* output:\n变量的类型 :<nil>\n变量是 int 型\n变量是 bool 或 string 型\n*/\n\n\n\n# 03 异步处理 select\n\n待并发编程更新.......\n\n\n# 参考资料\n\n条件语句if · go语言中文文档\n\n条件语句switch · go语言中文文档\n\ngo语言 if判断和for循环实战 goto使用的那些坑 - 掘金',charsets:{cjk:!0},lastUpdated:"2023/11/19, 12:55:48",lastUpdatedTimestamp:1700369748e3},{title:"循环控制",frontmatter:{title:"循环控制",date:"2023-03-24T19:09:52.000Z",permalink:"/pages/3a35c4/"},regularPath:"/02.Golang%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/01.Golang%E5%9F%BA%E7%A1%80/02.%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/02.%E5%BE%AA%E7%8E%AF%E6%8E%A7%E5%88%B6.html",relativePath:"02.Golang学习笔记/01.Golang基础/02.流程控制/02.循环控制.md",key:"v-96f454f6",path:"/pages/3a35c4/",headers:[{level:2,title:"01 基础循环 for",slug:"_01-基础循环-for",normalizedTitle:"01 基础循环 for",charIndex:65},{level:2,title:"02 键值循环 for range",slug:"_02-键值循环-for-range",normalizedTitle:"02 键值循环 for range",charIndex:1801},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:4111}],headersStr:"01 基础循环 for 02 键值循环 for range 参考资料",content:'# 循环控制\n\n循环控制通常用于程序中需要重复执行的逻辑模块，循环结构通常由循环变量、循环终止条件和循环体三个部分构成。\n\n\n# 01 基础循环 for\n\nGolang 中所有的循环控制都使用 for 关键定义。基础 for 循环控制结构，可以执行指定次数的循环，一般形式是 for init; condition; post { body }，其中：\n\n * init：一般为赋值表达式，给控制变量赋初值；\n * condition： 关系表达式或逻辑表达式，循环控制条件；\n * post： 一般为赋值表达式，给控制变量增量或减量\n * body：是需要重复执行的循环体代码\n\ninit 的循环变量同样存在作用域问题，在 for 循环中声明的变量仅在该循环体内有效，对外部变量没有影响；如果引用了外部声明的变量，则该循环变量具有更大的作用域。\n\nfunc ForExp() {\n    var i int = 10\n    for i := 0; i < 9; i++ {\n        fmt.Printf("%d ", i)\n    }\n    fmt.Printf(" global i: %d\\n", i)\n}\n\n/* output:\n0 1 2 3 4 5 6 7 8  global i: 10\n*/\n\n\nwhile 循环：Golang 中并没有 while 关键字，可以使用只有一个循环条件的 for 循环语句实现类似的功能，在循环体外部声明循环遍历，满足循环条件时循环执行循环体。\n\nfunc ForExp() {\n    var i int = 10\n    for i > 0 {\n        i--\n        fmt.Printf("%d ", i)\n    }\n    fmt.Printf(" global i: %d\\n", i)\n}\n\n/* output:\n9 8 7 6 5 4 3 2 1 0  global i: 0\n*/\n\n\n无限循环：其他语言中无限循环大多使用 while(true) 实现，在 Golang 中使用不带循环变量和循环条件的 for{} 实现。无限循环在需要时可以使用 break 跳出循环。\n\nfunc ForExp() {\n    var i int = 10\n    for {\n        i--\n        fmt.Printf("%d ", i)\n        if i == 0 {\n            break\n        }\n    }\n    fmt.Printf(" global i: %d\\n", i)\n}\n\n/* output:\n9 8 7 6 5 4 3 2 1 0  global i: 0\n*/\n\n\n循环嵌套：在 for 循环中嵌套一个或多个 for 循环实现更复杂的循环执行逻辑。\n\n循环嵌套中常常使用 goto、break、continue 三种循环控制关键字结合代码标签进行循环跳出或程序执行位置的调整\n\n * goto 语句通过标签进行代码间的无条件跳转，可以在快速跳出循环、避免重复退出上有一定的帮助。\n * break 语句可以结束 for、switch 和 select 的代码块；还可以在语句后面添加标签，表示退出某个标签对应的代码块，标签要求必须定义在对应的for、switch和select的代码块上。\n * continue 语句可以结束当前循环，开始下一次的循环迭代过程，仅限在for循环内使用；在continue语句后添加标签时，表示开始标签对应的循环。\n\nfunc ForExp() {\nPrime: // 外层循环标签\n    for i := 2; i < 100; i++ {\n        j := 2\n        for ; j <= (i / j); j++ {\n            if i%j == 0 {\n                break Prime // 退出循环到 Prime 之外\n            }\n        }\n        if j > (i / j) {\n            fmt.Printf("%d  是质数\\n", i)\n        }\n    }\n}\n\n\n\n# 02 键值循环 for range\n\nGolang 中提供 for range 遍历数组、切片、字符串、键值对（map）和通道（channel）等容器，不同容器的返回值也有所不同；对于仅需获得一个返回值的应用场景可以直接使用匿名变量 _接收不需要的返回值。\n\n                     第一个返回值    第二个返回值\narray/slice/string   index     s[index]\nmap                  key       m[key]\nchannel              element   \n\n * 数组、切片、字符串返回索引和元素值\n * 键值对（map）返回键和值\n * 通道（channel）只返回通道内的值\n\n遍历数组、切片和字符串：for range 遍历数组、切片、字符串时，index 和 value 分别代表索引和索引值\n\nfunc RangeExp() {\n    var a = [5]int{1, 2, 3, 4, 5}\n    var s []float32 = make([]float32, 3, 5)\n    s = []float32{1.0, 2.0, 3.0}\n    var str string = "hello,world!"\n    fmt.Println("----------Array----------")\n    for index, value := range a {\n        fmt.Printf("index:%d, value:%d\\n", index, value)\n    }\n    fmt.Println("----------Slice----------")\n    for index, value := range s {\n        fmt.Printf("index:%d, value:%f\\n", index, value)\n    }\n    fmt.Println("----------String----------")\n    for index, value := range str {\n        fmt.Printf("index:%d, value:%c\\n", index, value)\n    }\n}\n\n/* output:\n----------Array----------\nindex:0, value:1\nindex:1, value:2\nindex:2, value:3\nindex:3, value:4\nindex:4, value:5\n----------Slice----------\nindex:0, value:1.000000\nindex:1, value:2.000000\nindex:2, value:3.000000\n----------String----------\nindex:0, value:h\nindex:1, value:e\nindex:2, value:l\nindex:3, value:l\nindex:4, value:o\nindex:5, value:,\nindex:6, value:w\nindex:7, value:o\nindex:8, value:r\nindex:9, value:l\nindex:10, value:d\nindex:11, value:!\n*/\n\n\n遍历键值对 map：for range 遍历键值对 Map 时，key 和 value 分别代表 map 的索引键 key 和索引对应的值 value。值得注意的是对 map 遍历时，遍历输出的键值是无序的，如果需要有序的键值对输出，需要对结果进行排序。\n\nfunc RangeExp() {\n    hash := map[int]string{\n        1: "one",\n        2: "two",\n        3: "three",\n    }\n    fmt.Println("----------Map----------")\n    for key, value := range hash {\n        fmt.Printf("key:%d, value:%s\\n", key, value)\n    }\n}\n\n/* output:\n----------Map----------\nkey:1, value:one\nkey:2, value:two\nkey:3, value:three\n*/\n\n\n遍历通道 channel：for range 遍历通道 channel 时，返回值只有一个，即管道内的类型对应的数据。\n\nfunc RangeExp() {\n    c := make(chan int)\n    go func() {\n        c <- 1\n        c <- 2\n        c <- 3\n        close(c)\n    }()\n    fmt.Println("----------Channel----------")\n    for value := range c {\n        fmt.Printf("value:%d\\n", value)\n    }\n}\n\n/* output:\n----------Channel----------\nvalue:1\nvalue:2\nvalue:3\n*/\n\n\n\n# 参考资料\n\n循环语句for · Go语言中文文档\n\n循环语句range · Go语言中文文档\n\nGo语言 if判断和for循环实战 goto使用的那些坑 - 掘金',normalizedContent:'# 循环控制\n\n循环控制通常用于程序中需要重复执行的逻辑模块，循环结构通常由循环变量、循环终止条件和循环体三个部分构成。\n\n\n# 01 基础循环 for\n\ngolang 中所有的循环控制都使用 for 关键定义。基础 for 循环控制结构，可以执行指定次数的循环，一般形式是 for init; condition; post { body }，其中：\n\n * init：一般为赋值表达式，给控制变量赋初值；\n * condition： 关系表达式或逻辑表达式，循环控制条件；\n * post： 一般为赋值表达式，给控制变量增量或减量\n * body：是需要重复执行的循环体代码\n\ninit 的循环变量同样存在作用域问题，在 for 循环中声明的变量仅在该循环体内有效，对外部变量没有影响；如果引用了外部声明的变量，则该循环变量具有更大的作用域。\n\nfunc forexp() {\n    var i int = 10\n    for i := 0; i < 9; i++ {\n        fmt.printf("%d ", i)\n    }\n    fmt.printf(" global i: %d\\n", i)\n}\n\n/* output:\n0 1 2 3 4 5 6 7 8  global i: 10\n*/\n\n\nwhile 循环：golang 中并没有 while 关键字，可以使用只有一个循环条件的 for 循环语句实现类似的功能，在循环体外部声明循环遍历，满足循环条件时循环执行循环体。\n\nfunc forexp() {\n    var i int = 10\n    for i > 0 {\n        i--\n        fmt.printf("%d ", i)\n    }\n    fmt.printf(" global i: %d\\n", i)\n}\n\n/* output:\n9 8 7 6 5 4 3 2 1 0  global i: 0\n*/\n\n\n无限循环：其他语言中无限循环大多使用 while(true) 实现，在 golang 中使用不带循环变量和循环条件的 for{} 实现。无限循环在需要时可以使用 break 跳出循环。\n\nfunc forexp() {\n    var i int = 10\n    for {\n        i--\n        fmt.printf("%d ", i)\n        if i == 0 {\n            break\n        }\n    }\n    fmt.printf(" global i: %d\\n", i)\n}\n\n/* output:\n9 8 7 6 5 4 3 2 1 0  global i: 0\n*/\n\n\n循环嵌套：在 for 循环中嵌套一个或多个 for 循环实现更复杂的循环执行逻辑。\n\n循环嵌套中常常使用 goto、break、continue 三种循环控制关键字结合代码标签进行循环跳出或程序执行位置的调整\n\n * goto 语句通过标签进行代码间的无条件跳转，可以在快速跳出循环、避免重复退出上有一定的帮助。\n * break 语句可以结束 for、switch 和 select 的代码块；还可以在语句后面添加标签，表示退出某个标签对应的代码块，标签要求必须定义在对应的for、switch和select的代码块上。\n * continue 语句可以结束当前循环，开始下一次的循环迭代过程，仅限在for循环内使用；在continue语句后添加标签时，表示开始标签对应的循环。\n\nfunc forexp() {\nprime: // 外层循环标签\n    for i := 2; i < 100; i++ {\n        j := 2\n        for ; j <= (i / j); j++ {\n            if i%j == 0 {\n                break prime // 退出循环到 prime 之外\n            }\n        }\n        if j > (i / j) {\n            fmt.printf("%d  是质数\\n", i)\n        }\n    }\n}\n\n\n\n# 02 键值循环 for range\n\ngolang 中提供 for range 遍历数组、切片、字符串、键值对（map）和通道（channel）等容器，不同容器的返回值也有所不同；对于仅需获得一个返回值的应用场景可以直接使用匿名变量 _接收不需要的返回值。\n\n                     第一个返回值    第二个返回值\narray/slice/string   index     s[index]\nmap                  key       m[key]\nchannel              element   \n\n * 数组、切片、字符串返回索引和元素值\n * 键值对（map）返回键和值\n * 通道（channel）只返回通道内的值\n\n遍历数组、切片和字符串：for range 遍历数组、切片、字符串时，index 和 value 分别代表索引和索引值\n\nfunc rangeexp() {\n    var a = [5]int{1, 2, 3, 4, 5}\n    var s []float32 = make([]float32, 3, 5)\n    s = []float32{1.0, 2.0, 3.0}\n    var str string = "hello,world!"\n    fmt.println("----------array----------")\n    for index, value := range a {\n        fmt.printf("index:%d, value:%d\\n", index, value)\n    }\n    fmt.println("----------slice----------")\n    for index, value := range s {\n        fmt.printf("index:%d, value:%f\\n", index, value)\n    }\n    fmt.println("----------string----------")\n    for index, value := range str {\n        fmt.printf("index:%d, value:%c\\n", index, value)\n    }\n}\n\n/* output:\n----------array----------\nindex:0, value:1\nindex:1, value:2\nindex:2, value:3\nindex:3, value:4\nindex:4, value:5\n----------slice----------\nindex:0, value:1.000000\nindex:1, value:2.000000\nindex:2, value:3.000000\n----------string----------\nindex:0, value:h\nindex:1, value:e\nindex:2, value:l\nindex:3, value:l\nindex:4, value:o\nindex:5, value:,\nindex:6, value:w\nindex:7, value:o\nindex:8, value:r\nindex:9, value:l\nindex:10, value:d\nindex:11, value:!\n*/\n\n\n遍历键值对 map：for range 遍历键值对 map 时，key 和 value 分别代表 map 的索引键 key 和索引对应的值 value。值得注意的是对 map 遍历时，遍历输出的键值是无序的，如果需要有序的键值对输出，需要对结果进行排序。\n\nfunc rangeexp() {\n    hash := map[int]string{\n        1: "one",\n        2: "two",\n        3: "three",\n    }\n    fmt.println("----------map----------")\n    for key, value := range hash {\n        fmt.printf("key:%d, value:%s\\n", key, value)\n    }\n}\n\n/* output:\n----------map----------\nkey:1, value:one\nkey:2, value:two\nkey:3, value:three\n*/\n\n\n遍历通道 channel：for range 遍历通道 channel 时，返回值只有一个，即管道内的类型对应的数据。\n\nfunc rangeexp() {\n    c := make(chan int)\n    go func() {\n        c <- 1\n        c <- 2\n        c <- 3\n        close(c)\n    }()\n    fmt.println("----------channel----------")\n    for value := range c {\n        fmt.printf("value:%d\\n", value)\n    }\n}\n\n/* output:\n----------channel----------\nvalue:1\nvalue:2\nvalue:3\n*/\n\n\n\n# 参考资料\n\n循环语句for · go语言中文文档\n\n循环语句range · go语言中文文档\n\ngo语言 if判断和for循环实战 goto使用的那些坑 - 掘金',charsets:{cjk:!0},lastUpdated:"2023/11/19, 12:55:48",lastUpdatedTimestamp:1700369748e3},{title:"函数基础",frontmatter:{title:"函数基础",date:"2023-03-24T19:10:42.000Z",permalink:"/pages/06199f/"},regularPath:"/02.Golang%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/01.Golang%E5%9F%BA%E7%A1%80/03.%E5%87%BD%E6%95%B0/01.%E5%87%BD%E6%95%B0%E5%9F%BA%E7%A1%80.html",relativePath:"02.Golang学习笔记/01.Golang基础/03.函数/01.函数基础.md",key:"v-5a00904b",path:"/pages/06199f/",headers:[{level:2,title:"01 函数声明",slug:"_01-函数声明",normalizedTitle:"01 函数声明",charIndex:134},{level:2,title:"02 更多样的参数列表",slug:"_02-更多样的参数列表",normalizedTitle:"02 更多样的参数列表",charIndex:801},{level:2,title:"03 更灵活的返回值列表",slug:"_03-更灵活的返回值列表",normalizedTitle:"03 更灵活的返回值列表",charIndex:3152},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:4205}],headersStr:"01 函数声明 02 更多样的参数列表 03 更灵活的返回值列表 参考资料",content:'# 函数基础\n\n函数是一个固定的、可重复使用的程序段（子程序），它在实现单一或相关联功能的同时，还可以带有入口和出口，所谓的入口，就是函数参数即形参，通过这个入口把函数的参数值传递给子程序；所谓出口，就是指函数的返回值，通过这个出口可以获取子程序的计算结果。\n\n\n# 01 函数声明\n\nGolang 中使用 func 关键字进行函数声明，声明语句中包含函数名，参数列表， 返回值列表和函数体四个部分，其中：\n\n * 函数名：由字母、数字、下画线组成，和其他语言一样函数名的首字母不能为数字；\n * 参数列表：由一个或多个形式参数和参数类型组成，同类型形参可以进行合并，参数列表中的形参作用域仅限于该函数体内。(支持不定变参 interface{}/any)\n * 返回值列表：由一个或多个变量类型类型组成，返回值列表可以省略，但是一旦声明在函数体中必须使用 return 语句提供返回值。函数从第一条语句开始执行，直到执行 return 语句或者执行函数的最后一条语句。(不同于C/C++，Golang 函数支持多个返回值类型)\n * 函数体：实现函数功能逻辑的代码片段。\n\n// 声明语法\nfunc函数名(参数列表)(返回值列表){\n    函数体\n}\n\n// example:\nfunc func1(a, b int, s string) (int, string) {\n    res := a + b\n    return res, fmt.Sprintf("%s:%d\\n", s, res)\n}\n\nfunc main() {\n    res, str := func1(2, 3, "res of func1")\n    fmt.Printf("result:%d\\n%s", res, str)\n}\n\n/* output:\nresult:5\nres of func1:5\n*/\n\n\n\n# 02 更多样的参数列表\n\n函数定义时有参数，该变量可称为函数的形参，形参就像定义在函数体内的局部变量；而在外部调用函数时传递的变量就是函数的实参。\n\n值传递与引用传递：值传递和引用传递都是传递的实参的副本，但值传递是值的拷贝，而引用传递则是地址的拷贝。所以值传递中对参数修改并不会影响外部的实际参数，因为它们的值存储在不同的内存空间中；但引用传递传递的是实际值所存储的内存空间地址，当实参和形参指向相同的内存空间，所以当对形式参数修改将会影响外部的实际参数。\n\n一般来说，地址拷贝更为高效，特别是传入对象很大时；而值拷贝取决于拷贝的对象大小，对象越大，则性能越低。\n\n切片slice、键值对map、通道chan、指针、接口interface 这几种类型默认以引用的方式传递。\n\nfunc func2(a int, b *int, sl []int) {\n    a++\n    *b--\n    if len(sl) != 0 {\n        sl[0] = -1\n    }\n    fmt.Printf("inner: a:%d, b:%d, ", a, *b)\n    fmt.Println("sl:", sl)\n}\n\nfunc main() {\n    s1 := []int{1, 2, 3}\n    a := 1\n    b := 1\n    fmt.Printf("outer(before): a:%d, b:%d, ", a, b)\n    fmt.Println("sl:", s1)\n    func2(a, &b, s1)\n    fmt.Printf("outer(after): a:%d, b:%d, ", a, b)\n    fmt.Println("sl:", s1)\n}\n\n/* output:\nouter(before): a:1, b:1, sl: [1 2 3]\ninner: a:2, b:0, sl: [-1 2 3]\nouter(after): a:1, b:0, sl: [-1 2 3]\n*/\n\n\n不定类型参数：Golang 中在 1.18 版本之前使用 interface{} 作为泛型，后又引入了 any 关键字作为空接口 interface{} 的别名，在泛型应用场景下使用 interface{}/any 可以表示任意类型。\n\nfunc func3(a any) {\n    switch t := a.(type) {\n    case nil:\n        fmt.Printf("变量的类型 :%T\\r\\n", t)\n    case int:\n        fmt.Println("变量是 int 型")\n    case float64:\n        fmt.Println("变量是 float64 型")\n    case func(int) float64:\n        fmt.Println("变量是 func(int) 型")\n    case bool, string:\n        fmt.Println("变量是 bool 或 string 型")\n    default:\n        fmt.Println("未知型")\n    }\n}\n\nfunc main() {\n    var i int = 1\n    func3(i)\n    var s string = "hello"\n    func3(s)\n}\n\n/* output:\n变量是 int 型\n变量是 bool 或 string 型\n*/\n\n\n数量可变参数：相较于 C/C++，Golang 支持可变参数，即函数在声明和调用时没有固定数量的参数。\n\n * 可变参数通常只能有一个且被放在参数列表的末尾，如果有固定参数放在其前面，没有固定参数时则所有变量都是可变参数。\n * 可变参数的声明方式是 args ...Type，其本质就是一个切片，可以通过 args[index]依次访问每个参数。\n * 任意类型可变参数：当声明中参数类型为 interface{}/any 时，可变参数中每个参数的类型都可以是不固定的。\n\nfunc func4(str string, hash map[string]int, args ...any) {\n    fmt.Println("(Fixed) first param:", str)\n    fmt.Println("(Fixed) second param:", hash)\n    fmt.Println("(Variable) args:")\n    for _, arg := range args {\n        func3(arg)\n    }\n}\n\nfunc main() {\n    var i int = 1\n    var s string = "hello"\n    hash := map[string]int{\n        "one": 1,\n        "two": 2,\n    }\n    func4("testString", hash, i, s, 3.14, false)\n}\n\n/* output:\n(Fixed) first param: testString\n(Fixed) second param: map[one:1 two:2]\n(Variable) args:\n变量是 int 型\n变量是 bool 或 string 型\n变量是 float64 型\n变量是 bool 或 string 型\n*/\n\n\n\n# 03 更灵活的返回值列表\n\nGolang 支持多返回值，能方便地获得函数执行后的多个返回结果；由于 Golang 在错误处理上的不足，经常会使用多返回值中的最后一个返回参数返回函数执行中可能发生的错误。\n\nfunc func5(a, b int) (int, int) {\n    sum := a + b\n    sub := a - b\n    return sum, sub\n}\n\nfunc main() {\n    sum5, sub5 := func5(1, 1)\n    fmt.Printf("func5 sum:%d, sub:%d\\n", sum5, sub5)\n}\n\n\n返回值作为函数实参：如果某个函数的参数列表与另一个函数的返回值列表匹配，那么可以直接将后者的多个返回值作为前者的实参。\n\nfunc func6(a, b int) float32 {\n    res := float32(a / b)\n    return res\n}\n\nfunc func7(args ...int) int {\n    res := 1\n    for _, arg := range args {\n        res *= arg\n    }\n    return res\n}\n\nfunc main() {\n    res6 := func6(func5(2, 1))\n    res7 := func7(func5(4, 2))\n    fmt.Printf("func6:%f, func7:%d\\n", res6, res7)\n}\n\n/* output:\nfunc6:3.000000, func7:12\n*/\n\n\n命名函数返回参数：返回值列表中还可以对返回值进行命名，这样返回值就和参数一样拥有参数变量名和类型，这种被命名的返回参数和函数的局部变量类似，他们具备类型对应的默认值，最后由 return 语句隐式返回。(这种方式允许 defer 延迟调用通过闭包读取和修改)\n\nfunc func8(a, b int) (res int, test int) {\n    res = a + b\n    return\n}\n\nfunc main() {\n    res8, test8 := func8(1, 1)\n    fmt.Printf("res:%d, test:%d\\n", res8, test8)\n}\n\n/* output:\nres:2, test:0\n*/\n\n\n\n# 参考资料\n\n函数定义 · Go语言中文文档\n\n参数 · Go语言中文文档\n\n返回值 · Go语言中文文档',normalizedContent:'# 函数基础\n\n函数是一个固定的、可重复使用的程序段（子程序），它在实现单一或相关联功能的同时，还可以带有入口和出口，所谓的入口，就是函数参数即形参，通过这个入口把函数的参数值传递给子程序；所谓出口，就是指函数的返回值，通过这个出口可以获取子程序的计算结果。\n\n\n# 01 函数声明\n\ngolang 中使用 func 关键字进行函数声明，声明语句中包含函数名，参数列表， 返回值列表和函数体四个部分，其中：\n\n * 函数名：由字母、数字、下画线组成，和其他语言一样函数名的首字母不能为数字；\n * 参数列表：由一个或多个形式参数和参数类型组成，同类型形参可以进行合并，参数列表中的形参作用域仅限于该函数体内。(支持不定变参 interface{}/any)\n * 返回值列表：由一个或多个变量类型类型组成，返回值列表可以省略，但是一旦声明在函数体中必须使用 return 语句提供返回值。函数从第一条语句开始执行，直到执行 return 语句或者执行函数的最后一条语句。(不同于c/c++，golang 函数支持多个返回值类型)\n * 函数体：实现函数功能逻辑的代码片段。\n\n// 声明语法\nfunc函数名(参数列表)(返回值列表){\n    函数体\n}\n\n// example:\nfunc func1(a, b int, s string) (int, string) {\n    res := a + b\n    return res, fmt.sprintf("%s:%d\\n", s, res)\n}\n\nfunc main() {\n    res, str := func1(2, 3, "res of func1")\n    fmt.printf("result:%d\\n%s", res, str)\n}\n\n/* output:\nresult:5\nres of func1:5\n*/\n\n\n\n# 02 更多样的参数列表\n\n函数定义时有参数，该变量可称为函数的形参，形参就像定义在函数体内的局部变量；而在外部调用函数时传递的变量就是函数的实参。\n\n值传递与引用传递：值传递和引用传递都是传递的实参的副本，但值传递是值的拷贝，而引用传递则是地址的拷贝。所以值传递中对参数修改并不会影响外部的实际参数，因为它们的值存储在不同的内存空间中；但引用传递传递的是实际值所存储的内存空间地址，当实参和形参指向相同的内存空间，所以当对形式参数修改将会影响外部的实际参数。\n\n一般来说，地址拷贝更为高效，特别是传入对象很大时；而值拷贝取决于拷贝的对象大小，对象越大，则性能越低。\n\n切片slice、键值对map、通道chan、指针、接口interface 这几种类型默认以引用的方式传递。\n\nfunc func2(a int, b *int, sl []int) {\n    a++\n    *b--\n    if len(sl) != 0 {\n        sl[0] = -1\n    }\n    fmt.printf("inner: a:%d, b:%d, ", a, *b)\n    fmt.println("sl:", sl)\n}\n\nfunc main() {\n    s1 := []int{1, 2, 3}\n    a := 1\n    b := 1\n    fmt.printf("outer(before): a:%d, b:%d, ", a, b)\n    fmt.println("sl:", s1)\n    func2(a, &b, s1)\n    fmt.printf("outer(after): a:%d, b:%d, ", a, b)\n    fmt.println("sl:", s1)\n}\n\n/* output:\nouter(before): a:1, b:1, sl: [1 2 3]\ninner: a:2, b:0, sl: [-1 2 3]\nouter(after): a:1, b:0, sl: [-1 2 3]\n*/\n\n\n不定类型参数：golang 中在 1.18 版本之前使用 interface{} 作为泛型，后又引入了 any 关键字作为空接口 interface{} 的别名，在泛型应用场景下使用 interface{}/any 可以表示任意类型。\n\nfunc func3(a any) {\n    switch t := a.(type) {\n    case nil:\n        fmt.printf("变量的类型 :%t\\r\\n", t)\n    case int:\n        fmt.println("变量是 int 型")\n    case float64:\n        fmt.println("变量是 float64 型")\n    case func(int) float64:\n        fmt.println("变量是 func(int) 型")\n    case bool, string:\n        fmt.println("变量是 bool 或 string 型")\n    default:\n        fmt.println("未知型")\n    }\n}\n\nfunc main() {\n    var i int = 1\n    func3(i)\n    var s string = "hello"\n    func3(s)\n}\n\n/* output:\n变量是 int 型\n变量是 bool 或 string 型\n*/\n\n\n数量可变参数：相较于 c/c++，golang 支持可变参数，即函数在声明和调用时没有固定数量的参数。\n\n * 可变参数通常只能有一个且被放在参数列表的末尾，如果有固定参数放在其前面，没有固定参数时则所有变量都是可变参数。\n * 可变参数的声明方式是 args ...type，其本质就是一个切片，可以通过 args[index]依次访问每个参数。\n * 任意类型可变参数：当声明中参数类型为 interface{}/any 时，可变参数中每个参数的类型都可以是不固定的。\n\nfunc func4(str string, hash map[string]int, args ...any) {\n    fmt.println("(fixed) first param:", str)\n    fmt.println("(fixed) second param:", hash)\n    fmt.println("(variable) args:")\n    for _, arg := range args {\n        func3(arg)\n    }\n}\n\nfunc main() {\n    var i int = 1\n    var s string = "hello"\n    hash := map[string]int{\n        "one": 1,\n        "two": 2,\n    }\n    func4("teststring", hash, i, s, 3.14, false)\n}\n\n/* output:\n(fixed) first param: teststring\n(fixed) second param: map[one:1 two:2]\n(variable) args:\n变量是 int 型\n变量是 bool 或 string 型\n变量是 float64 型\n变量是 bool 或 string 型\n*/\n\n\n\n# 03 更灵活的返回值列表\n\ngolang 支持多返回值，能方便地获得函数执行后的多个返回结果；由于 golang 在错误处理上的不足，经常会使用多返回值中的最后一个返回参数返回函数执行中可能发生的错误。\n\nfunc func5(a, b int) (int, int) {\n    sum := a + b\n    sub := a - b\n    return sum, sub\n}\n\nfunc main() {\n    sum5, sub5 := func5(1, 1)\n    fmt.printf("func5 sum:%d, sub:%d\\n", sum5, sub5)\n}\n\n\n返回值作为函数实参：如果某个函数的参数列表与另一个函数的返回值列表匹配，那么可以直接将后者的多个返回值作为前者的实参。\n\nfunc func6(a, b int) float32 {\n    res := float32(a / b)\n    return res\n}\n\nfunc func7(args ...int) int {\n    res := 1\n    for _, arg := range args {\n        res *= arg\n    }\n    return res\n}\n\nfunc main() {\n    res6 := func6(func5(2, 1))\n    res7 := func7(func5(4, 2))\n    fmt.printf("func6:%f, func7:%d\\n", res6, res7)\n}\n\n/* output:\nfunc6:3.000000, func7:12\n*/\n\n\n命名函数返回参数：返回值列表中还可以对返回值进行命名，这样返回值就和参数一样拥有参数变量名和类型，这种被命名的返回参数和函数的局部变量类似，他们具备类型对应的默认值，最后由 return 语句隐式返回。(这种方式允许 defer 延迟调用通过闭包读取和修改)\n\nfunc func8(a, b int) (res int, test int) {\n    res = a + b\n    return\n}\n\nfunc main() {\n    res8, test8 := func8(1, 1)\n    fmt.printf("res:%d, test:%d\\n", res8, test8)\n}\n\n/* output:\nres:2, test:0\n*/\n\n\n\n# 参考资料\n\n函数定义 · go语言中文文档\n\n参数 · go语言中文文档\n\n返回值 · go语言中文文档',charsets:{cjk:!0},lastUpdated:"2023/11/19, 12:55:48",lastUpdatedTimestamp:1700369748e3},{title:"延迟调用",frontmatter:{title:"延迟调用",date:"2023-03-24T19:10:42.000Z",permalink:"/pages/f5e003/"},regularPath:"/02.Golang%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/01.Golang%E5%9F%BA%E7%A1%80/03.%E5%87%BD%E6%95%B0/03.%E5%BB%B6%E8%BF%9F%E8%B0%83%E7%94%A8.html",relativePath:"02.Golang学习笔记/01.Golang基础/03.函数/03.延迟调用.md",key:"v-4e2c513c",path:"/pages/f5e003/",headers:[{level:2,title:"01 defer 简介",slug:"_01-defer-简介",normalizedTitle:"01 defer 简介",charIndex:11},{level:2,title:"02 defer 用途",slug:"_02-defer-用途",normalizedTitle:"02 defer 用途",charIndex:60},{level:3,title:"2.1 关闭文件句柄",slug:"_2-1-关闭文件句柄",normalizedTitle:"2.1 关闭文件句柄",charIndex:76},{level:3,title:"2.2 锁资源释放",slug:"_2-2-锁资源释放",normalizedTitle:"2.2 锁资源释放",charIndex:91},{level:3,title:"2.3 数据库连接释放",slug:"_2-3-数据库连接释放",normalizedTitle:"2.3 数据库连接释放",charIndex:105},{level:2,title:"03 defer 避坑",slug:"_03-defer-避坑",normalizedTitle:"03 defer 避坑",charIndex:121},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:137}],headersStr:"01 defer 简介 02 defer 用途 2.1 关闭文件句柄 2.2 锁资源释放 2.3 数据库连接释放 03 defer 避坑 参考资料",content:"# 延迟调用\n\n\n# 01 defer 简介\n\nGolang 中的延迟调用机制使用 defer 关键字注册实现\n\n\n# 02 defer 用途\n\n\n# 2.1 关闭文件句柄\n\n\n# 2.2 锁资源释放\n\n\n# 2.3 数据库连接释放\n\n\n# 03 defer 避坑\n\n\n# 参考资料",normalizedContent:"# 延迟调用\n\n\n# 01 defer 简介\n\ngolang 中的延迟调用机制使用 defer 关键字注册实现\n\n\n# 02 defer 用途\n\n\n# 2.1 关闭文件句柄\n\n\n# 2.2 锁资源释放\n\n\n# 2.3 数据库连接释放\n\n\n# 03 defer 避坑\n\n\n# 参考资料",charsets:{cjk:!0},lastUpdated:"2023/11/19, 12:55:48",lastUpdatedTimestamp:1700369748e3},{title:"双指针基础",frontmatter:{title:"双指针基础",date:"2023-03-24T18:39:48.000Z",permalink:"/pages/0f3851/"},regularPath:"/03.LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/01.%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/01.%E5%8F%8C%E6%8C%87%E9%92%88/01.%E5%8F%8C%E6%8C%87%E9%92%88%E5%9F%BA%E7%A1%80.html",relativePath:"03.LeetCode刷题笔记/01.基础算法/01.双指针/01.双指针基础.md",key:"v-bdc2433c",path:"/pages/0f3851/",headers:[{level:2,title:"01 双指针基础",slug:"_01-双指针基础",normalizedTitle:"01 双指针基础",charIndex:2},{level:3,title:"双指针简介",slug:"双指针简介",normalizedTitle:"双指针简介",charIndex:15},{level:4,title:"88 合并两个有序数组",slug:"_88-合并两个有序数组",normalizedTitle:"88 合并两个有序数组",charIndex:421},{level:4,title:"524 通过删除字母匹配到字典里最长单词",slug:"_524-通过删除字母匹配到字典里最长单词",normalizedTitle:"524 通过删除字母匹配到字典里最长单词",charIndex:1609},{level:4,title:"160 相交链表",slug:"_160-相交链表",normalizedTitle:"160 相交链表",charIndex:2805}],headersStr:"01 双指针基础 双指针简介 88 合并两个有序数组 524 通过删除字母匹配到字典里最长单词 160 相交链表",content:'# 01 双指针基础\n\n\n# 双指针简介\n\n**双指针的用途：**双指针主要用于单循环遍历线性表数据结构，两个指针指向不同的元素，从而协同完成任务（通常双指针分别指向元素比较，或者两元素联合与某一条件比较）\n\n**双指针的特点：**不管数据输入是字符串、数组还是链表，使用一般方法的遍历方法时间复杂度度在O(n^3)和O(n^2)使用双指针对其进行遍历的平均时间复杂度为O(nlogn)，最好的情况下时间复杂度为O(n)\n\n两种特殊形式的双指针\n\n * 碰撞指针 Opposite directional：两个指针指向同一线性表，但是遍历方向相反，一个指针指向开头，另一个指向末尾，它们相向移动直到相遇或满足其他特殊条件为止\n * 快慢指针 Equi-directional：两个指针指向同一线性表，遍历方向相同，且两个指针起点可以相同，也可以不同形成一个滑动窗口，两个指针以不同的策略移动，直到两个指针的值相等或满足其他特殊条件为止\n\n# 88 合并两个有序数组\n\n给定两个有序数组，把两个数组合并为一个\n\n输入是两个数组和它们分别的长度 m 和 n。其中第一个数组的长度被延长至 m + n，多出的 n 位被 0 填补。题目要求把第二个数组归并到第一个数组上，不需要开辟额外空间。\n\n> 输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3 输出：[1,2,2,3,5,6] 解释：需要合并 [1,2,3] 和 [2,5,6] 。合并结果是 [1,2,2,3,5,6] ，其中斜体加粗标注的为 nums1 中的元素。\n\n解析：\n\n因为两个数组都是有序的，所以可以把两个指针分别放在两个数组的末尾，即 nums1 的 m-1 位和 nums2 的 n-1 位。每次将较大的那个数字复制到 nums1 的后边，然后向前移动一位。\n\n因为本题是将结果全部存储在 nums1 中，所以还要一个指针指向 nums1 剩余空间的末尾，以便复制。\n\n还需要分析输入的几种特殊情况：\n\n * nums2 为空，不管 nums1 是否为空直接返回 nums1\n * nums1 元素为空，直接将 nums2 中元素位置不变的移入 nums1 中即可\n * nums1 先于 nums2 遍历完，直接将 nums2 中剩余元素按顺序移入 nums1 中即可\n\nclass Solution {\npublic:\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\n        # nums2 为空，不管 nums1 是否为空直接返回 nums1\n        if(!n){\n            return;\n        }\n        int tail1 = m-1, tail2 = n-1, tail = m+n-1;\n        while(tail1>=0 && tail2>=0){\n            if(nums1[tail1]>nums2[tail2]){\n                nums1[tail--] = nums1[tail1--];\n            }else{\n                nums1[tail--] = nums2[tail2--];\n            }\n        }\n        # nums1 先于 nums2 遍历完，直接将 nums2 中剩余元素按顺序移入 nums1 中即可\n        while(tail2>=0){\n            nums1[tail--] = nums2[tail2--];\n        }\n    }\n};\n\n\n# 524 通过删除字母匹配到字典里最长单词\n\n给定一个字符串 s 和一个字符串数组 dictionary ，找出并返回 dictionary 中最长的字符串，该字符串可以通过删除 s 中的某些字符得到。\n\n输入一个字符串和一个字符串数组，输出一个数组中按条件要求的字符串，如果答案不止一个，返回长度最长且字母序最小的字符串。\n\n> 输入：s = "abpcplea", dictionary = ["ale","apple","monkey","plea"]\n> 输出："apple"\n\n解析：\n\n根据题意，我们需要完成两个任务：首先找到 s 可构成字符串数组中的所有字符串；然后，我们要选出这些候选字符串中长度最长且字母序最小的。\n\n第一个任务我们采用双指针完成，一个指针指向 s 的首元素，从左向右遍历；另一个指针指向字典中当前比较的字符串首元素，也从左向右遍历，每匹配一个元素该指针移动一步。如果全都匹配，形成一个候选字符串。\n\n第二个任务我们可以对字典进行预处理，根据字符串长度进行排序，优先匹配较长的字符串，只要匹配成功就直接返回该字符串。\n\nclass Solution {\npublic:\n    string findLongestWord(string s, vector<string>& dictionary) {\n        // labmda表达式自定义排序\n        sort(dictionary.begin(), dictionary.end(), [](string a, string b){\n            // 让字母序更小的排在前面\n            if(a.size()==b.size()) return a < b;\n            // 让长度更长的排在前面\n            return a.size() > b.size();\n        });\n        \n        for(const auto str: dictionary){\n            int ps = 0, pstr = 0;\n            while(ps<s.size() && pstr<str.size()){\n                if(s[ps]==str[pstr]){\n                    ++pstr;\n                }\n                ++ps;\n            }\n            if(pstr==str.size()){\n                return str;\n            }\n        }\n        return "";\n    }\n};\n\n\n# 160 相交链表\n\n给定两个单链表的头节点 headA 和 headB ，找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。 输入两个单链表，输出一个节点表示两链表的交点。\n\n> 输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3 输出：Intersected at \'8\' 解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。\n\n解析：\n\n用双指针可以简单解决本题，我们定义两个指针分别指向两个链表的头节点 pa 和 pb，他们同时出发从左向右遍历，如果遍历完当前链表就接着从另一个链表的头节点开始遍历。这种遍历方式有如下两种情况：\n\n * 如果两个链表存在交点，假设 headA 到交点的节点个数为 a，headB 到交点的节点个数为 b，交点到链表尾节点的节点个数为 c。那么在遍历过程中 pa 的移动距离为 a + c + b，而 pb 的移动距离为 b + c + a，所以 pa 和 pb 最终会在交点处相遇。\n * 如果两个链表不存在交点，那么在遍历过程中 pa 的移动距离为 a + b，pb 的移动距离为 b + a，所以 pa 和 pb 最终会在两个链表结尾相等，返回 nullptr\n\nclass Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n        if(headA == nullptr || headB == nullptr){\n            return nullptr;\n        }\n        ListNode *pa = headA, *pb = headB;\n        while(pa!=pb){\n            if(pa){\n                pa = pa->next;\n            }else{\n                pa = headB;\n            }\n            if(pb){\n                pb = pb->next;\n            }else{\n                pb = headA;\n            }\n        }\n        return pa;\n    }\n};\n',normalizedContent:'# 01 双指针基础\n\n\n# 双指针简介\n\n**双指针的用途：**双指针主要用于单循环遍历线性表数据结构，两个指针指向不同的元素，从而协同完成任务（通常双指针分别指向元素比较，或者两元素联合与某一条件比较）\n\n**双指针的特点：**不管数据输入是字符串、数组还是链表，使用一般方法的遍历方法时间复杂度度在o(n^3)和o(n^2)使用双指针对其进行遍历的平均时间复杂度为o(nlogn)，最好的情况下时间复杂度为o(n)\n\n两种特殊形式的双指针\n\n * 碰撞指针 opposite directional：两个指针指向同一线性表，但是遍历方向相反，一个指针指向开头，另一个指向末尾，它们相向移动直到相遇或满足其他特殊条件为止\n * 快慢指针 equi-directional：两个指针指向同一线性表，遍历方向相同，且两个指针起点可以相同，也可以不同形成一个滑动窗口，两个指针以不同的策略移动，直到两个指针的值相等或满足其他特殊条件为止\n\n# 88 合并两个有序数组\n\n给定两个有序数组，把两个数组合并为一个\n\n输入是两个数组和它们分别的长度 m 和 n。其中第一个数组的长度被延长至 m + n，多出的 n 位被 0 填补。题目要求把第二个数组归并到第一个数组上，不需要开辟额外空间。\n\n> 输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3 输出：[1,2,2,3,5,6] 解释：需要合并 [1,2,3] 和 [2,5,6] 。合并结果是 [1,2,2,3,5,6] ，其中斜体加粗标注的为 nums1 中的元素。\n\n解析：\n\n因为两个数组都是有序的，所以可以把两个指针分别放在两个数组的末尾，即 nums1 的 m-1 位和 nums2 的 n-1 位。每次将较大的那个数字复制到 nums1 的后边，然后向前移动一位。\n\n因为本题是将结果全部存储在 nums1 中，所以还要一个指针指向 nums1 剩余空间的末尾，以便复制。\n\n还需要分析输入的几种特殊情况：\n\n * nums2 为空，不管 nums1 是否为空直接返回 nums1\n * nums1 元素为空，直接将 nums2 中元素位置不变的移入 nums1 中即可\n * nums1 先于 nums2 遍历完，直接将 nums2 中剩余元素按顺序移入 nums1 中即可\n\nclass solution {\npublic:\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\n        # nums2 为空，不管 nums1 是否为空直接返回 nums1\n        if(!n){\n            return;\n        }\n        int tail1 = m-1, tail2 = n-1, tail = m+n-1;\n        while(tail1>=0 && tail2>=0){\n            if(nums1[tail1]>nums2[tail2]){\n                nums1[tail--] = nums1[tail1--];\n            }else{\n                nums1[tail--] = nums2[tail2--];\n            }\n        }\n        # nums1 先于 nums2 遍历完，直接将 nums2 中剩余元素按顺序移入 nums1 中即可\n        while(tail2>=0){\n            nums1[tail--] = nums2[tail2--];\n        }\n    }\n};\n\n\n# 524 通过删除字母匹配到字典里最长单词\n\n给定一个字符串 s 和一个字符串数组 dictionary ，找出并返回 dictionary 中最长的字符串，该字符串可以通过删除 s 中的某些字符得到。\n\n输入一个字符串和一个字符串数组，输出一个数组中按条件要求的字符串，如果答案不止一个，返回长度最长且字母序最小的字符串。\n\n> 输入：s = "abpcplea", dictionary = ["ale","apple","monkey","plea"]\n> 输出："apple"\n\n解析：\n\n根据题意，我们需要完成两个任务：首先找到 s 可构成字符串数组中的所有字符串；然后，我们要选出这些候选字符串中长度最长且字母序最小的。\n\n第一个任务我们采用双指针完成，一个指针指向 s 的首元素，从左向右遍历；另一个指针指向字典中当前比较的字符串首元素，也从左向右遍历，每匹配一个元素该指针移动一步。如果全都匹配，形成一个候选字符串。\n\n第二个任务我们可以对字典进行预处理，根据字符串长度进行排序，优先匹配较长的字符串，只要匹配成功就直接返回该字符串。\n\nclass solution {\npublic:\n    string findlongestword(string s, vector<string>& dictionary) {\n        // labmda表达式自定义排序\n        sort(dictionary.begin(), dictionary.end(), [](string a, string b){\n            // 让字母序更小的排在前面\n            if(a.size()==b.size()) return a < b;\n            // 让长度更长的排在前面\n            return a.size() > b.size();\n        });\n        \n        for(const auto str: dictionary){\n            int ps = 0, pstr = 0;\n            while(ps<s.size() && pstr<str.size()){\n                if(s[ps]==str[pstr]){\n                    ++pstr;\n                }\n                ++ps;\n            }\n            if(pstr==str.size()){\n                return str;\n            }\n        }\n        return "";\n    }\n};\n\n\n# 160 相交链表\n\n给定两个单链表的头节点 heada 和 headb ，找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。 输入两个单链表，输出一个节点表示两链表的交点。\n\n> 输入：intersectval = 8, lista = [4,1,8,4,5], listb = [5,0,1,8,4,5], skipa = 2, skipb = 3 输出：intersected at \'8\' 解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 a 为 [4,1,8,4,5]，链表 b 为 [5,0,1,8,4,5]。在 a 中，相交节点前有 2 个节点；在 b 中，相交节点前有 3 个节点。\n\n解析：\n\n用双指针可以简单解决本题，我们定义两个指针分别指向两个链表的头节点 pa 和 pb，他们同时出发从左向右遍历，如果遍历完当前链表就接着从另一个链表的头节点开始遍历。这种遍历方式有如下两种情况：\n\n * 如果两个链表存在交点，假设 heada 到交点的节点个数为 a，headb 到交点的节点个数为 b，交点到链表尾节点的节点个数为 c。那么在遍历过程中 pa 的移动距离为 a + c + b，而 pb 的移动距离为 b + c + a，所以 pa 和 pb 最终会在交点处相遇。\n * 如果两个链表不存在交点，那么在遍历过程中 pa 的移动距离为 a + b，pb 的移动距离为 b + a，所以 pa 和 pb 最终会在两个链表结尾相等，返回 nullptr\n\nclass solution {\npublic:\n    listnode *getintersectionnode(listnode *heada, listnode *headb) {\n        if(heada == nullptr || headb == nullptr){\n            return nullptr;\n        }\n        listnode *pa = heada, *pb = headb;\n        while(pa!=pb){\n            if(pa){\n                pa = pa->next;\n            }else{\n                pa = headb;\n            }\n            if(pb){\n                pb = pb->next;\n            }else{\n                pb = heada;\n            }\n        }\n        return pa;\n    }\n};\n',charsets:{cjk:!0},lastUpdated:"2023/11/19, 12:55:48",lastUpdatedTimestamp:1700369748e3},{title:"匿名函数与闭包",frontmatter:{title:"匿名函数与闭包",date:"2023-03-24T19:10:42.000Z",permalink:"/pages/95ec3d/"},regularPath:"/02.Golang%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/01.Golang%E5%9F%BA%E7%A1%80/03.%E5%87%BD%E6%95%B0/02.%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0%E4%B8%8E%E9%97%AD%E5%8C%85.html",relativePath:"02.Golang学习笔记/01.Golang基础/03.函数/02.匿名函数与闭包.md",key:"v-72f63995",path:"/pages/95ec3d/",headers:[{level:2,title:"01 匿名函数",slug:"_01-匿名函数",normalizedTitle:"01 匿名函数",charIndex:67},{level:3,title:"1.1 定义匿名函数",slug:"_1-1-定义匿名函数",normalizedTitle:"1.1 定义匿名函数",charIndex:178},{level:3,title:"1.2 匿名函数使用场景",slug:"_1-2-匿名函数使用场景",normalizedTitle:"1.2 匿名函数使用场景",charIndex:926},{level:2,title:"02 闭包",slug:"_02-闭包",normalizedTitle:"02 闭包",charIndex:2015},{level:3,title:"2.1 闭包实现公有变量",slug:"_2-1-闭包实现公有变量",normalizedTitle:"2.1 闭包实现公有变量",charIndex:2396},{level:3,title:"2.2 闭包实现缓存效果",slug:"_2-2-闭包实现缓存效果",normalizedTitle:"2.2 闭包实现缓存效果",charIndex:3524},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:4757}],headersStr:"01 匿名函数 1.1 定义匿名函数 1.2 匿名函数使用场景 02 闭包 2.1 闭包实现公有变量 2.2 闭包实现缓存效果 参考资料",content:'# 匿名函数与闭包\n\n匿名函数是指不需要定义函数名的一种函数实现方式（即没有名字的函数）。匿名函数多用于实现回调函数和闭包。\n\n\n# 01 匿名函数\n\nGo语言支持匿名函数，即在需要使用函数时，再定义函数；匿名函数没有函数名，只有函数体。在Go语言里面，函数可以被作为一种类型被赋值给函数类型的变量进行传递或使用，匿名函数也往往以变量方式被传递。\n\n\n# 1.1 定义匿名函数\n\n不同于 C++ 11 中提供的 Lambda 表达式形式来定义匿名函数，Golang 中匿名函数的定义格式除了没有函数名，其他部分与普通函数定义格式一致。换言之，匿名函数的定义就是没有名字的普通函数定义，其格式如下所示：\n\n// 声明格式\nfunc(参数列表)(返回值列表){\n    函数体\n}\n\n// example:\nfunc main() {\n    func1 := func(m, n int) bool {\n        return m < n\n    }\n\n    a := 1\n    b := 2\n    if func1(a, b) {\n        fmt.Printf("%d<%d\\n", a, b)\n    } else {\n        fmt.Printf("%d>=%d\\n", a, b)\n    }\n}\n\n/* output:\n1<2\n*/\n\n\n将匿名函数赋值给变量：如上例所示，将匿名函数赋值给变量，然后以变量的形式进行传递是较为常见的方式，类似给没有函数名的匿名函数起了个名字。\n\n在定义时调用匿名函数：匿名函数也可以在定义时直接进行调用执行，不需要外部调用，这样这个函数仅会被调用一次，如下例子所示：\n\nfunc main() {\n    a := 2\n    b := 1\n    if func(m, n int) bool { return m < n }(a, b) {\n        fmt.Printf("%d<%d\\n", a, b)\n    } else {\n        fmt.Printf("%d>=%d\\n", a, b)\n    }\n}\n\n/* output:\n2>=1\n*/\n\n\n\n# 1.2 匿名函数使用场景\n\n匿名函数作为值使用：由于匿名函数没有函数名，这时它就相当于是一条表达式，可以把它赋值给一个变量，在需要使用的地方进行按值调用即可。\n\nfunc main() {\n    func2 := func(s []int) int {\n        sum := 0\n        for _, v := range s {\n            sum += v\n        }\n        return sum\n    }\n\n    fmt.Printf("sqrt 0f func2 is : %f\\n", math.Sqrt(float64(func2([]int{1, 2, 3, 3}))))\n}\n\n/* output:\nsqrt 0f func2 is : 3.000000\n*/\n\n\n匿名函数作为回调函数使用：\n\n回调函数就是通过函数引用调用的函数，例如函数A的参数列表中函数B的引用作为参数之一，并且在函数A中使用该函数引用调用执行函数B，那么函数B就是回调函数。回调函数不是由该函数的实现方直接调用，而是在特定的事件或条件发生时由另外一方调用，用于对该事件或条件进行响应（回调函数是一种事件驱动机制）。\n\n匿名函数也可以以函数引用的形式作为其他函数的参数使用，使用匿名函数作为回调函数的优点在于不需要耗费额外的空间去专门定义处理回调事件的函数，因为当函数被执行时才会调用回调函数。\n\n匿名函数作为回调函数需要注意如下两点：\n\n\n * 回调函数所必须的值由外部调用函数传入\n * 外部调用函数的参数列表中必须正确声明回调函数\n\nfunc scanSlice(s []int, f func(int)) {\n    for _, v := range s {\n        f(v)\n    }\n}\n\nfunc main() {\n    func3 := func(v int) {\n        fmt.Printf(" %d ", v)\n    }\n    // func3 作为回调函数打印切片中的元素\n    scanSlice([]int{1, 2, 3, 4, 5}, func3)\n}\n\n/* output:\n 1  2  3  4  5 \n*/\n\n\n匿名函数用来获取父作用域中的变量：通过匿名函数访问父作用域中的变量是创建闭包的一种常见方式，就是在一个函数内部声明一个匿名函数，通过该匿名函数访问这个函数的局部变量。通过这种方式可以把局部变量留在内存中，避免使用全局变量引发潜在的全部变量污染情况。\n\n\n# 02 闭包\n\n闭包的形式化定义是：一个拥有许多变量和绑定了这些变量的环境的表达式（通常是一个函数），因而这些变量也是该表达式的一部分。\n\n通俗来讲，闭包就是引用了自由变量的函数，被引用的自由变量和函数一同存在，即使已经离开了自由变量的环境也不会被释放或者删除，在闭包中可以继续使用这个自由变量。\n\n函数 + 引用环境 = 闭包\n\n函数和相关引用环境的组合形成了闭包实例，闭包在运行时可以有多个实例，不同的引用环境和相同的函数组合可以产生不同的实例。其中，函数本身不存储任何信息，只有与引用环境结合后形成的闭包才具有“记忆性”。函数是编译期的静态概念，而闭包是运行期的动态概念。（可以与程序和进程的概念进行类比）\n\n闭包机制的主要用途在于如下两点：\n\n * 可以获取函数内部的局部变量，实现公有变量\n * 可以让自由变量的值始终保存在内存中，实现缓存效果\n\n\n# 2.1 闭包实现公有变量\n\n闭包机制使得函数的内部变量可以在函数外部被重复使用，并且不会造成变量污染。\n\n这相较于全局变量和普通局部变量具有明显优势，虽然全局变量可以重复使用，但是容易造成变量污染；而局部变量仅在局部作用域内有效，虽然不会造成变量污染，但是不可以重复使用。\n\n如下例子中声明了一个累加函数 accumulate，他的返回值是函数类型 func() int，每次调用这个累加函数时，其内部的匿名函数都会对累加函数中的局部变量 x 进行 +1 修改，并打印该变量的地址。在 main 函数中分别声明两个初始值不同的累加函数 func4，func5，并分别调用两次。\n\nfunc accumulate(n int) func() int {\n    var x int = n\n    //返回一个自己定义的函数类型 (返回一个闭包：匿名函数 + accumulate引用环境)\n    return func() int {\n        x++             // 修改accumulate的变量 x\n        fmt.Println(&x) // 打印这个变量的地址\n        return x        // 返回累加值\n    }\n}\n\nfunc main() {\n    // 初始值为 1 累加\n    func4 := accumulate(1)\n    fmt.Printf("%p\\n", func4)\n    fmt.Println(func4())\n    fmt.Println(func4())\n\n    // 初始值为 10 累加\n    func5 := accumulate(10)\n    fmt.Printf("%p\\n", func5)\n    fmt.Println(func5())\n    fmt.Println(func5())\n}\n\n/* output:\n0x8df1c0\n0xc000012300\n2\n0xc000012300\n3\n0x8df1c0\n0xc000012308\n11\n0xc000012308\n12\n*/\n\n\n从输出结果可以看出，闭包与函数与引用环境的关系，声明的两个函数他们的地址是一致的，函数中操作的变量地址在同一个闭包中是一致的，然而在不同闭包中变量地址是不一致的。\n\n这表示被捕获到闭包中的变量让闭包本身拥有了记忆效应，闭包中的逻辑可以修改闭包捕获的变量，变量会跟随闭包生命期一直存在，闭包本身就如同变量一样拥有了记忆效应，其中的变量在闭包的声明周期内变成了“公有变量”。函数在不同引用环境下会形成不同的闭包，所以闭包是一个动态概念。\n\n\n# 2.2 闭包实现缓存效果\n\n闭包会把父作用域（函数）中的变量保存在内存中，直到闭包的生命周期结束，所以利用这一特点可以将被闭包捕获的变量作为缓存空间来使用。\n\n如下例子中声明了一个 dish 函数，其自由变量名称为 food 作为缓存空间，其中声明了两个匿名函数，分别实现重置 food 的 pop 操作和修改 food 的 push 操作，用来模拟消费和生产两种行为。(由于pop 和 push 的参数列表不一样不好抽象统一，例子中的实现并不优雅，暂时没有想到比较好的实现方式，欢迎指正！)\n\nfunc dish(s string) map[string]func(string) {\n    var food = s\n    var function = map[string]func(string){\n        "pop": func(newFood string) {\n            if food != "" {\n                fmt.Printf("pop: %s, pos: %p\\n", food, &food)\n                food = ""\n            } else {\n                fmt.Println("the dish is empty!")\n            }\n        },\n        "push": func(newFood string) {\n            food = newFood\n            fmt.Printf("push: %s, pos: %p\\n", food, &food)\n        },\n    }\n\n    return function\n}\n\nfunc main() {\n    func6 := dish("apple")\n    func6["pop"]("")\n    func6["pop"]("")\n    func6["push"]("banana")\n    func6["pop"]("")\n}\n\n/* output:\npop: apple, pos: 0xc0000465e0\nthe dish is empty!\npush: banana, pos: 0xc0000465e0\npop: banana, pos: 0xc0000465e0\n*/\n\n\n可以看到输出结果中，不管是 pop 还是 push 操作，food 的地址都没有改变过，所以自由变量 food 一直被保存在内存中，并没有在 dish 调用结束后被自动清除，通过这种方式可以实现缓存效果。\n\n但是这种闭包实现缓存的也存在着明显的缺点：函数执行完后, 函数内的局部变量没有释放，占用内存时间会变长，容易造成内存泄露。一种解决方法是在退出函数之前，将不使用的局部变量全部删除。\n\n\n# 参考资料\n\n匿名函数 · Go语言中文文档\n\nC++11 Lambda表达式（匿名函数）\n\n匿名函数的应用&命名空间的应用&类与对象的关系与使用方式--2019年9月29日\n\n回调函数（callback）是什么？ - 简书\n\n闭包、递归 · Go语言中文文档\n\n闭包的作用 - 简书',normalizedContent:'# 匿名函数与闭包\n\n匿名函数是指不需要定义函数名的一种函数实现方式（即没有名字的函数）。匿名函数多用于实现回调函数和闭包。\n\n\n# 01 匿名函数\n\ngo语言支持匿名函数，即在需要使用函数时，再定义函数；匿名函数没有函数名，只有函数体。在go语言里面，函数可以被作为一种类型被赋值给函数类型的变量进行传递或使用，匿名函数也往往以变量方式被传递。\n\n\n# 1.1 定义匿名函数\n\n不同于 c++ 11 中提供的 lambda 表达式形式来定义匿名函数，golang 中匿名函数的定义格式除了没有函数名，其他部分与普通函数定义格式一致。换言之，匿名函数的定义就是没有名字的普通函数定义，其格式如下所示：\n\n// 声明格式\nfunc(参数列表)(返回值列表){\n    函数体\n}\n\n// example:\nfunc main() {\n    func1 := func(m, n int) bool {\n        return m < n\n    }\n\n    a := 1\n    b := 2\n    if func1(a, b) {\n        fmt.printf("%d<%d\\n", a, b)\n    } else {\n        fmt.printf("%d>=%d\\n", a, b)\n    }\n}\n\n/* output:\n1<2\n*/\n\n\n将匿名函数赋值给变量：如上例所示，将匿名函数赋值给变量，然后以变量的形式进行传递是较为常见的方式，类似给没有函数名的匿名函数起了个名字。\n\n在定义时调用匿名函数：匿名函数也可以在定义时直接进行调用执行，不需要外部调用，这样这个函数仅会被调用一次，如下例子所示：\n\nfunc main() {\n    a := 2\n    b := 1\n    if func(m, n int) bool { return m < n }(a, b) {\n        fmt.printf("%d<%d\\n", a, b)\n    } else {\n        fmt.printf("%d>=%d\\n", a, b)\n    }\n}\n\n/* output:\n2>=1\n*/\n\n\n\n# 1.2 匿名函数使用场景\n\n匿名函数作为值使用：由于匿名函数没有函数名，这时它就相当于是一条表达式，可以把它赋值给一个变量，在需要使用的地方进行按值调用即可。\n\nfunc main() {\n    func2 := func(s []int) int {\n        sum := 0\n        for _, v := range s {\n            sum += v\n        }\n        return sum\n    }\n\n    fmt.printf("sqrt 0f func2 is : %f\\n", math.sqrt(float64(func2([]int{1, 2, 3, 3}))))\n}\n\n/* output:\nsqrt 0f func2 is : 3.000000\n*/\n\n\n匿名函数作为回调函数使用：\n\n回调函数就是通过函数引用调用的函数，例如函数a的参数列表中函数b的引用作为参数之一，并且在函数a中使用该函数引用调用执行函数b，那么函数b就是回调函数。回调函数不是由该函数的实现方直接调用，而是在特定的事件或条件发生时由另外一方调用，用于对该事件或条件进行响应（回调函数是一种事件驱动机制）。\n\n匿名函数也可以以函数引用的形式作为其他函数的参数使用，使用匿名函数作为回调函数的优点在于不需要耗费额外的空间去专门定义处理回调事件的函数，因为当函数被执行时才会调用回调函数。\n\n匿名函数作为回调函数需要注意如下两点：\n\n\n * 回调函数所必须的值由外部调用函数传入\n * 外部调用函数的参数列表中必须正确声明回调函数\n\nfunc scanslice(s []int, f func(int)) {\n    for _, v := range s {\n        f(v)\n    }\n}\n\nfunc main() {\n    func3 := func(v int) {\n        fmt.printf(" %d ", v)\n    }\n    // func3 作为回调函数打印切片中的元素\n    scanslice([]int{1, 2, 3, 4, 5}, func3)\n}\n\n/* output:\n 1  2  3  4  5 \n*/\n\n\n匿名函数用来获取父作用域中的变量：通过匿名函数访问父作用域中的变量是创建闭包的一种常见方式，就是在一个函数内部声明一个匿名函数，通过该匿名函数访问这个函数的局部变量。通过这种方式可以把局部变量留在内存中，避免使用全局变量引发潜在的全部变量污染情况。\n\n\n# 02 闭包\n\n闭包的形式化定义是：一个拥有许多变量和绑定了这些变量的环境的表达式（通常是一个函数），因而这些变量也是该表达式的一部分。\n\n通俗来讲，闭包就是引用了自由变量的函数，被引用的自由变量和函数一同存在，即使已经离开了自由变量的环境也不会被释放或者删除，在闭包中可以继续使用这个自由变量。\n\n函数 + 引用环境 = 闭包\n\n函数和相关引用环境的组合形成了闭包实例，闭包在运行时可以有多个实例，不同的引用环境和相同的函数组合可以产生不同的实例。其中，函数本身不存储任何信息，只有与引用环境结合后形成的闭包才具有“记忆性”。函数是编译期的静态概念，而闭包是运行期的动态概念。（可以与程序和进程的概念进行类比）\n\n闭包机制的主要用途在于如下两点：\n\n * 可以获取函数内部的局部变量，实现公有变量\n * 可以让自由变量的值始终保存在内存中，实现缓存效果\n\n\n# 2.1 闭包实现公有变量\n\n闭包机制使得函数的内部变量可以在函数外部被重复使用，并且不会造成变量污染。\n\n这相较于全局变量和普通局部变量具有明显优势，虽然全局变量可以重复使用，但是容易造成变量污染；而局部变量仅在局部作用域内有效，虽然不会造成变量污染，但是不可以重复使用。\n\n如下例子中声明了一个累加函数 accumulate，他的返回值是函数类型 func() int，每次调用这个累加函数时，其内部的匿名函数都会对累加函数中的局部变量 x 进行 +1 修改，并打印该变量的地址。在 main 函数中分别声明两个初始值不同的累加函数 func4，func5，并分别调用两次。\n\nfunc accumulate(n int) func() int {\n    var x int = n\n    //返回一个自己定义的函数类型 (返回一个闭包：匿名函数 + accumulate引用环境)\n    return func() int {\n        x++             // 修改accumulate的变量 x\n        fmt.println(&x) // 打印这个变量的地址\n        return x        // 返回累加值\n    }\n}\n\nfunc main() {\n    // 初始值为 1 累加\n    func4 := accumulate(1)\n    fmt.printf("%p\\n", func4)\n    fmt.println(func4())\n    fmt.println(func4())\n\n    // 初始值为 10 累加\n    func5 := accumulate(10)\n    fmt.printf("%p\\n", func5)\n    fmt.println(func5())\n    fmt.println(func5())\n}\n\n/* output:\n0x8df1c0\n0xc000012300\n2\n0xc000012300\n3\n0x8df1c0\n0xc000012308\n11\n0xc000012308\n12\n*/\n\n\n从输出结果可以看出，闭包与函数与引用环境的关系，声明的两个函数他们的地址是一致的，函数中操作的变量地址在同一个闭包中是一致的，然而在不同闭包中变量地址是不一致的。\n\n这表示被捕获到闭包中的变量让闭包本身拥有了记忆效应，闭包中的逻辑可以修改闭包捕获的变量，变量会跟随闭包生命期一直存在，闭包本身就如同变量一样拥有了记忆效应，其中的变量在闭包的声明周期内变成了“公有变量”。函数在不同引用环境下会形成不同的闭包，所以闭包是一个动态概念。\n\n\n# 2.2 闭包实现缓存效果\n\n闭包会把父作用域（函数）中的变量保存在内存中，直到闭包的生命周期结束，所以利用这一特点可以将被闭包捕获的变量作为缓存空间来使用。\n\n如下例子中声明了一个 dish 函数，其自由变量名称为 food 作为缓存空间，其中声明了两个匿名函数，分别实现重置 food 的 pop 操作和修改 food 的 push 操作，用来模拟消费和生产两种行为。(由于pop 和 push 的参数列表不一样不好抽象统一，例子中的实现并不优雅，暂时没有想到比较好的实现方式，欢迎指正！)\n\nfunc dish(s string) map[string]func(string) {\n    var food = s\n    var function = map[string]func(string){\n        "pop": func(newfood string) {\n            if food != "" {\n                fmt.printf("pop: %s, pos: %p\\n", food, &food)\n                food = ""\n            } else {\n                fmt.println("the dish is empty!")\n            }\n        },\n        "push": func(newfood string) {\n            food = newfood\n            fmt.printf("push: %s, pos: %p\\n", food, &food)\n        },\n    }\n\n    return function\n}\n\nfunc main() {\n    func6 := dish("apple")\n    func6["pop"]("")\n    func6["pop"]("")\n    func6["push"]("banana")\n    func6["pop"]("")\n}\n\n/* output:\npop: apple, pos: 0xc0000465e0\nthe dish is empty!\npush: banana, pos: 0xc0000465e0\npop: banana, pos: 0xc0000465e0\n*/\n\n\n可以看到输出结果中，不管是 pop 还是 push 操作，food 的地址都没有改变过，所以自由变量 food 一直被保存在内存中，并没有在 dish 调用结束后被自动清除，通过这种方式可以实现缓存效果。\n\n但是这种闭包实现缓存的也存在着明显的缺点：函数执行完后, 函数内的局部变量没有释放，占用内存时间会变长，容易造成内存泄露。一种解决方法是在退出函数之前，将不使用的局部变量全部删除。\n\n\n# 参考资料\n\n匿名函数 · go语言中文文档\n\nc++11 lambda表达式（匿名函数）\n\n匿名函数的应用&命名空间的应用&类与对象的关系与使用方式--2019年9月29日\n\n回调函数（callback）是什么？ - 简书\n\n闭包、递归 · go语言中文文档\n\n闭包的作用 - 简书',charsets:{cjk:!0},lastUpdated:"2023/11/19, 12:55:48",lastUpdatedTimestamp:1700369748e3},{title:"C++ 标准模板库 STL 关联容器",frontmatter:{title:"C++ 标准模板库 STL 关联容器",date:"2023-11-18T15:46:10.000Z",permalink:"/pages/56c2ea/"},regularPath:"/01.C&Cpp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/02.C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/02.C++%20STL/07.C++%20%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93%20STL%20%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8.html",relativePath:"01.C&Cpp学习笔记/02.C++面向对象编程/02.C++ STL/07.C++ 标准模板库 STL 关联容器.md",key:"v-a83c2a9c",path:"/pages/56c2ea/",headers:[{level:2,title:"关联容器概述",slug:"关联容器概述",normalizedTitle:"关联容器概述",charIndex:588},{level:2,title:"集合 set/multiset",slug:"集合-set-multiset",normalizedTitle:"集合 set/multiset",charIndex:1730},{level:3,title:"multiset",slug:"multiset",normalizedTitle:"multiset",charIndex:147},{level:3,title:"multiset 成员函数",slug:"multiset-成员函数",normalizedTitle:"multiset 成员函数",charIndex:2841},{level:3,title:"set",slug:"set",normalizedTitle:"set",charIndex:84},{level:2,title:"键值对集合 map/multimap",slug:"键值对集合-map-multimap",normalizedTitle:"键值对集合 map/multimap",charIndex:6402},{level:3,title:"multimap",slug:"multimap",normalizedTitle:"multimap",charIndex:272},{level:3,title:"map",slug:"map",normalizedTitle:"map",charIndex:209}],headersStr:"关联容器概述 集合 set/multiset multiset multiset 成员函数 set 键值对集合 map/multimap multimap map",content:'# C++ 标准模板库 STL 关联容器\n\n容器                   数据结构   时间复杂度                   顺序性   重复性\nset                  红黑树    插入、删除、查找 O(log2n)       有序    不可重复\nmultiset             红黑树    插入、删除、查找 O(log2n)       有序    可重复\nmap                  红黑树    插入、删除、查找 O(log2n)       有序    不可重复\nmultimap             红黑树    插入、删除、查找 O(log2n)       有序    可重复\nunordered_set        哈希表    插入、删除、查找 O(1) 最差 O(n)   无序    不可重复\nunordered_multiset   哈希表    插入、删除、查找 O(1) 最差 O(n)   无序    可重复\nunordered_map        哈希表    插入、删除、查找 O(1) 最差 O(n)   无序    不可重复\nunordered_multimap   哈希表    插入、删除、查找 O(1) 最差 O(n)   无序    可重复\n\n\n# 关联容器概述\n\n关联容器和顺序容器的本质的不同在于：关联容器中的元素是按关键字来保存和访问的；与之相对，顺序容器中的元素是按它们在容器中的位置来顺序保存和访问的。关联容器支持高效的关键字查找与访问，其内部元素有序排列，新元素插入的位置取决于它的值，查找速度快。两个主要的关联容器类型是map与set，除了各容器都有的函数外，还支持以下成员函数：\n\n函数            函数描述\nfind          在容器中搜索具有等于 key 键的元素，如果找到则返回一个迭代器\ncount         在容器中搜索具有等于 key 键的键的元素，并返回匹配的数量\nlower_bound   返回一个非递减序列 [first, last)中的第一个大于等于值 val 的位置的迭代器\nupper_bound   返回一个非递减序列 [first, last)中第一个大于 val 的位置的迭代器\nequal_range   获取相同元素的范围，返回包含容器中所有具有与 key 等价的键的元素的范围边界\ninsert        用以插入一个元素或一个区间\n\n关联容器的基础是名为 pair 的标准库类型，它定义在头文件utility中。pair是一个用来生成特定类型的模板，一个pair保存两个数据成员。当创建一个pair时，需要提供两个类型名，pair的数据成员将具有对应的类型，一个pair类型的对象，其实存储的是一个键值对（key-value）。pair 模板的源码如下所示：\n\ntemplate<class _T1, class _T2>\nstruct\npair\n{\n    typedef _T1 first_type ;\n    typedef _T2 second_type ;\n    // pair 存储的键值对\n    _T1 first ;\n    _T2 second ;\n    // pair 的三种构造函数\n    pair(): first(), second() { }\n    pair(const _T1& __a, const _T2& __b): first(__a), second(__b) { }\n    template<class _U1, class _U2>\n    pair(const pair<_U1, _U2>& __p): first(__p.first ), second(__p.second) { }\n};\n\n// 第三个构造函数的使用示例\npair<int,int>\np(pair<double,double>(5.5,4.6));\n//p.first = 5, p.second = 4\n\n\n\n# 集合 set/multiset\n\nset/multiset #include<set> 集合：set 集合中不允许存在相同的元素，multiset 集合中允许存在相同的元素。\n\n\n# multiset\n\nmultiset 类模板定义中有3个模板参数如下：\n\ntemplate <typename Key, typename Pred = less<Key>, typename A = allocator<Key> >\nclass multiset { …… };\n\n\nmultiset 类模板中3个模板参数的后两个模板参数是可以缺省的，其中第二个模板参数 Pred 类型的变量决定了multiset 中的元素，大小顺序是怎么定义的。multiset 运行过程中，比较两个元素x,y的大小的做法，就是生成一个 Pred 类型的变量，假定为 op，若表达式op(x,y) 返回值为true,则 x比y小。Pred 的缺省类型是 less<Key>，起模板定义如下：\n\n// 第二个模板参数Pred中的模板函数less是使用<运算符比较大小，其模板定义如下\ntemplate<class T>\nstruct less : public binary_function<T, T, bool>{ \n    bool operator()(const T& x, const T& y) { \n        return x < y ; \n    } \n    const; \n};\n\n\n一种由第二个模板参数缺省导致错误的 multiset 使用错误：\n\n#include <set>\nusing namespace std;\nclass A { };\nint main() {\n    multiset<A> a;\n    a.insert(A()); // Error\n}\n\n\n由于参数缺省，multiset<A> a; 就等价于 multiset<A, less<A>> a;；插入元素时，multiset 会将被插入元素和已有元素进行比较。由于 less 模板是用 < 进行比较的；所以，这都要求 A 的对象能用 < 比较，即需要该对象中对 < 运算符进行了重载。\n\nclass A {\nprivate:\n\tint n;\npublic:\n    A(int n_ ) { n = n_; }\n    friend bool operator< ( const A & a1, const A & a2 ) { // 重载 < 运算符\n        return a1.n < a2.n; \n    }\n};\n\n\n\n# multiset 成员函数\n\n函数                                                   函数描述\niterator find(const T & val)                         在容器中查找值为val的元素，返回其迭代器; 如果找不到，返回end()\niterator insert(const T & val)                       将val插入到容器中并返回其迭代器\nvoid insert( iterator first,iterator last)           将区间[first,last)插入容器\nint count(const T & val)                             统计有多少个元素的值和val相等\niterator lower_bound(const T & val)                  查找一个最大的位置 it,使得[begin(),it) 中所有的元素都比 val 小\niterator upper_bound(const T & val)                  查找一个最小的位置 it,使得[it,end()) 中所有的元素都比 val 大\npair<iterator,iterator> equal_range(const T & val)   同时求得lower_bound和upper_bound\niterator erase(iterator it)                          删除it指向的元素，返回其后面的元素的迭代器\n\n一个 multiset 常用函数使用实例如下：\n\n#include <iostream>\n#include <set> //使用multiset须包含此文件\nusing namespace std;\n\n// 输出[first,last)内的所有元素\ntemplate <class T>\nvoid Print(T first, T last){ \n    for(;first != last ; ++first)\n        cout << * first << " ";\n\tcout << endl;\n}\n\nclass A {\nprivate:\n\tint n;\npublic:\n    A(int n_ ) { n = n_; }\n    friend bool operator< ( const A & a1, const A & a2 ) { // 重载 < 运算符\n        return a1.n < a2.n; \n    }\n    friend ostream & operator<< ( ostream & o, const A & a2 ) { \n        o << a2.n; \n        return o; \n    }\n    friend class MyLess;\n};\n\nstruct MyLess { \n\tbool operator()( const A & a1, const A & a2){ \n        return ( a1.n % 10 ) < (a2.n % 10); //按个位数比较大小\n    }\n};\n\n// 定义两个使用不同大小比较方式的 Multiset\ntypedef multiset<A> MSET1; //MSET1用默认方式的 < 运算符比较大小\ntypedef multiset<A,MyLess> MSET2; //MSET2用 MyLess::operator()比较大小\n\nint main()\n{\n    const int SIZE = 6;\n    A a[SIZE] = {4,22,19,8,33,40};\n    // m1中的元素默认大小比较方式排序\n    MSET1 m1; \n    m1.insert(a,a+SIZE);\n    m1.insert(22);\n    \n\t// 使用count成员函数获取元素值为22的元素个数\n    cout << "1) " << m1.count(22) << endl; \n    //输出m1的所有元素： 4 8 19 22 22 33 40\n    cout << "2) "; Print(m1.begin(),m1.end()); \n    \n    // 使用find成员函数查找元素值为19的元素\n    MSET1::iterator pp = m1.find(19);\n    if( pp != m1.end() ) //条件为真说明找到\n    \tcout << "found" << endl;\n   \n    // 使用 lower_bound 成员函数返回m1中第一个大于等于22的元素的迭代器\n    // upper_bound 成员函数返回m1中最后一个大于等于22的元素的迭代器\n    cout << "3) "; cout << *m1.lower_bound(22) << "," << *m1.upper_bound(22)<< endl;\n    \n    // 使用 erase 成员函数删除区间内的元素\n    pp = m1.erase(m1.lower_bound(22),m1.upper_bound(22)); //pp指向被删元素的下一个元素\n    cout << "4) "; Print(m1.begin(),m1.end()); // 4 8 19 33 40\n    cout << "5) "; cout << * pp << endl; // 33\n    \n    // m2里的元素按n的个位数从小到大排\n    MSET2 m2; \n    m2.insert(a,a+SIZE);\n    cout << "6) "; Print(m2.begin(),m2.end()); //输出 6) 40 22 33 4 8 19\n    return 0;\n}\n\n\n\n# set\n\n和 multiset 相似 set 类模板定义中有3个模板参数如下：\n\ntemplate <typename Key, typename Pred = less<Key>, typename A = allocator<Key> >\nclass set { …… };=\n\n\nset和multiset的最大区别：set支持去重， multiset不支持，所以他们的成员函数大都相同，但是在使用insert() 成员函数时，如果插入set中的是已存在的元素，则忽略插入。\n\n一个 set 常用函数使用实例如下：\n\n#include <iostream>\n#include <set>\nusing namespace std;\nint main() {\n    typedef set<int>::iterator IT;\n    int a[5] = { 3,4,6,1,2 };\n    set<int> st(a,a+5); // st里是 1 2 3 4 6 有序集合\n    pair< IT,bool> result;\n    result = st.insert(5); // st变成 1 2 3 4 5 6 插入数据时会和已有数据进行比较\n    if(result.second) //插入成功则输出被插入元素\n    \tcout << * result.first << " inserted" << endl; // 输出: 5 inserted\n    if( st.insert(5).second ) \n        cout << * result.first << endl;\n    else\n    \tcout << * result.first << " already exists" << endl; //输出 5 already exists\n    pair<IT,IT> bounds = st.equal_range(4); // 使用equal_range成员函数同时求得lower_bound和upper_bound\n    cout << * bounds.first << "," << * bounds.second ; //输出：4,5\n    return 0;\n}\n\n\n\n# 键值对集合 map/multimap\n\nmap/multimap #include <map> 键值对集合：map/multimap里放着的都是pair模版类的对象，且按first从小到大排序。所以，map 和 set 的不同在于前者存放的元素有且仅有两个成员变量 (first,second)，一个名为 first，另一个名为 second ，first 的值用来对整体元素进行从小到大的排序，并可以通过 first 快速检索元素。\n\n\n# multimap\n\nmultimap 类模板定义中有4个模板参数如下：\n\ntemplate <typename Key, typename T, typename Pred = less<Key>, typename A = allocator<Key> >\nclass multiset { …… };\n\n\nmultimap 类模板中4个模板参数的后两个模板参数是可以缺省的，其中第一个模板参数key代表关键字的类型，第二个模板参数T代表值的类型，第三个模板参数 Pred 类型和set类似，该变量决定了multimap 中的元素大小比较的规则。\n\n * multimap 中的元素由<关键字,值>组成，每个元素是一个pair对象，关键字就是 first 成员变量，其类型是Key\n * multimap 中允许多个元素的关键字相同。元素按照first成员变量从小到大排列，缺省情况下用 less<Key> 定义关键字的小于关系\n\n所有适用于 set 的操作都适用于 map，一个 multimap 使用实例如下：\n\n#include <iostream>\n#include <map>\nusing namespace std;\nint main()\n{\n    typedef multimap<int,double,less<int> > mmid;\n    mmid pairs;\n    // 使用insert()函数插入键值对\n    pairs.insert(pair<int,double>(15,4.2));\n    pairs.insert(make_pair(15,3.1));\n    pairs.insert(mmid::value_type(15,2.7));\n    pairs.insert(mmid::value_type(15,99.3));\n    // 使用count()函数求关键字等于某值的元素个数\n    cout << pairs.count(15) << endl;\n    pairs.insert(mmid::value_type(30,111.11));\n    pairs.insert(mmid::value_type(10,22.22));\n    pairs.insert(mmid::value_type(25,33.333));\n    pairs.insert(mmid::value_type(20,9.3));\n    // 使用erase()函数删除关键字为25的元素\n    pairs.erase(25)\n    for( mmid::const_iterator i = pairs.begin();\n        i != pairs.end() ;i ++ )\n        cout << "(" << i->first << "," << i->second << ")" << ",";\n}\n\n\nmap 插入数据是需要插入一个pair对象，从上例中有三种插入方式：\n\n * pair<int,double>()：pair构造函数生成pair对象，需要指定first和second的类型\n\n * make_pair()：无需写出类型就可以生成一个pair对象，通过实参自动匹配类型；但是需要注意的是pair<int, float>(1, 1.1);和make_pair(1, 1.1);是不同的，前者指定了second就是float，而后再会将其匹配成double\n\n * mmid::value_type()：在定义mmid时会同时定义value_type，typedef pair<const Key, T> value_type;所以也可以使用value_type构造pair对象\n\n\n# map\n\n和 multimap 一样 map 类模板定义中有4个模板参数如下：\n\ntemplate <typename Key, typename T, typename Pred = less<Key>, typename A = allocator<Key> >\nclass multiset { \n    …… \n\ttypedef pair<const Key, T> value_type;\n    …… \n};\n\n\n和 multimap 一样 map 中的元素也是由<关键字,值>组成，每个元素是一个pair对象；但是，和 multimap 的主要区别在于 map 的关键字也就是 first 成员变量各不相同，不存在重复的关键字。同样，在第三个模板参数缺省的情况下，其中的元素使用less<Key> 大小比较方法，按照关键字从小到大排列。\n\nmap的[ ]成员函数\n\n因为 map 中的元素关键字都是各不相同的，所以可以使用类似于顺序容器的[]对元素进行检索与修改。若 mymap 为 map 模版类的对象，则可以使用mymap[key]返回对关键字等于key的元素的值（second成员变量）的引用。若没有关键字为key的元素，则会往mymap里插入一个关键字为key的元素，其值用无参构造函数初始化，并返回其值的引用。\n\n一个 map 使用实例如下：\n\n#include <iostream>\n#include <map>\nusing namespace std;\n\n// 重载 << 运算符，用于输出map元素\ntemplate <class Key,class Value>\nostream & operator <<( ostream & o, const pair<Key,Value> & p){\n    o << "(" << p.first << "," << p.second << ")";\n    return o;\n}\n\nint main() {\n    typedef map<int, double,less<int> > mmid;\n    mmid pairs;\n    pairs.insert(mmid::value_type(15,2.7));\n    cout << pairs.count(15) << endl;\n    pairs.insert(mmid::value_type(20,9.3));\n    mmid::iterator i; \n    for( i = pairs.begin(); i != pairs.end();i ++ ) \n    \tcout << * i << ",";\n    cout << endl;\n   \t// 使用[]成员函数检索map元素，如果没有关键字为40的元素，则插入一个\n    int n = pairs[40];\n    for( i = pairs.begin(); i != pairs.end();i ++ )\n    \tcout << * i << ",";\n    cout << endl;\n    cout << "5) ";\n    // 使用[]成员函数修改map元素，把关键字为15的元素值改成6.28\n    pairs[15] = 6.28; \n    for( i = pairs.begin(); i != pairs.end();i ++ )\n    \tcout << * i << ",";\n}\n',normalizedContent:'# c++ 标准模板库 stl 关联容器\n\n容器                   数据结构   时间复杂度                   顺序性   重复性\nset                  红黑树    插入、删除、查找 o(log2n)       有序    不可重复\nmultiset             红黑树    插入、删除、查找 o(log2n)       有序    可重复\nmap                  红黑树    插入、删除、查找 o(log2n)       有序    不可重复\nmultimap             红黑树    插入、删除、查找 o(log2n)       有序    可重复\nunordered_set        哈希表    插入、删除、查找 o(1) 最差 o(n)   无序    不可重复\nunordered_multiset   哈希表    插入、删除、查找 o(1) 最差 o(n)   无序    可重复\nunordered_map        哈希表    插入、删除、查找 o(1) 最差 o(n)   无序    不可重复\nunordered_multimap   哈希表    插入、删除、查找 o(1) 最差 o(n)   无序    可重复\n\n\n# 关联容器概述\n\n关联容器和顺序容器的本质的不同在于：关联容器中的元素是按关键字来保存和访问的；与之相对，顺序容器中的元素是按它们在容器中的位置来顺序保存和访问的。关联容器支持高效的关键字查找与访问，其内部元素有序排列，新元素插入的位置取决于它的值，查找速度快。两个主要的关联容器类型是map与set，除了各容器都有的函数外，还支持以下成员函数：\n\n函数            函数描述\nfind          在容器中搜索具有等于 key 键的元素，如果找到则返回一个迭代器\ncount         在容器中搜索具有等于 key 键的键的元素，并返回匹配的数量\nlower_bound   返回一个非递减序列 [first, last)中的第一个大于等于值 val 的位置的迭代器\nupper_bound   返回一个非递减序列 [first, last)中第一个大于 val 的位置的迭代器\nequal_range   获取相同元素的范围，返回包含容器中所有具有与 key 等价的键的元素的范围边界\ninsert        用以插入一个元素或一个区间\n\n关联容器的基础是名为 pair 的标准库类型，它定义在头文件utility中。pair是一个用来生成特定类型的模板，一个pair保存两个数据成员。当创建一个pair时，需要提供两个类型名，pair的数据成员将具有对应的类型，一个pair类型的对象，其实存储的是一个键值对（key-value）。pair 模板的源码如下所示：\n\ntemplate<class _t1, class _t2>\nstruct\npair\n{\n    typedef _t1 first_type ;\n    typedef _t2 second_type ;\n    // pair 存储的键值对\n    _t1 first ;\n    _t2 second ;\n    // pair 的三种构造函数\n    pair(): first(), second() { }\n    pair(const _t1& __a, const _t2& __b): first(__a), second(__b) { }\n    template<class _u1, class _u2>\n    pair(const pair<_u1, _u2>& __p): first(__p.first ), second(__p.second) { }\n};\n\n// 第三个构造函数的使用示例\npair<int,int>\np(pair<double,double>(5.5,4.6));\n//p.first = 5, p.second = 4\n\n\n\n# 集合 set/multiset\n\nset/multiset #include<set> 集合：set 集合中不允许存在相同的元素，multiset 集合中允许存在相同的元素。\n\n\n# multiset\n\nmultiset 类模板定义中有3个模板参数如下：\n\ntemplate <typename key, typename pred = less<key>, typename a = allocator<key> >\nclass multiset { …… };\n\n\nmultiset 类模板中3个模板参数的后两个模板参数是可以缺省的，其中第二个模板参数 pred 类型的变量决定了multiset 中的元素，大小顺序是怎么定义的。multiset 运行过程中，比较两个元素x,y的大小的做法，就是生成一个 pred 类型的变量，假定为 op，若表达式op(x,y) 返回值为true,则 x比y小。pred 的缺省类型是 less<key>，起模板定义如下：\n\n// 第二个模板参数pred中的模板函数less是使用<运算符比较大小，其模板定义如下\ntemplate<class t>\nstruct less : public binary_function<t, t, bool>{ \n    bool operator()(const t& x, const t& y) { \n        return x < y ; \n    } \n    const; \n};\n\n\n一种由第二个模板参数缺省导致错误的 multiset 使用错误：\n\n#include <set>\nusing namespace std;\nclass a { };\nint main() {\n    multiset<a> a;\n    a.insert(a()); // error\n}\n\n\n由于参数缺省，multiset<a> a; 就等价于 multiset<a, less<a>> a;；插入元素时，multiset 会将被插入元素和已有元素进行比较。由于 less 模板是用 < 进行比较的；所以，这都要求 a 的对象能用 < 比较，即需要该对象中对 < 运算符进行了重载。\n\nclass a {\nprivate:\n\tint n;\npublic:\n    a(int n_ ) { n = n_; }\n    friend bool operator< ( const a & a1, const a & a2 ) { // 重载 < 运算符\n        return a1.n < a2.n; \n    }\n};\n\n\n\n# multiset 成员函数\n\n函数                                                   函数描述\niterator find(const t & val)                         在容器中查找值为val的元素，返回其迭代器; 如果找不到，返回end()\niterator insert(const t & val)                       将val插入到容器中并返回其迭代器\nvoid insert( iterator first,iterator last)           将区间[first,last)插入容器\nint count(const t & val)                             统计有多少个元素的值和val相等\niterator lower_bound(const t & val)                  查找一个最大的位置 it,使得[begin(),it) 中所有的元素都比 val 小\niterator upper_bound(const t & val)                  查找一个最小的位置 it,使得[it,end()) 中所有的元素都比 val 大\npair<iterator,iterator> equal_range(const t & val)   同时求得lower_bound和upper_bound\niterator erase(iterator it)                          删除it指向的元素，返回其后面的元素的迭代器\n\n一个 multiset 常用函数使用实例如下：\n\n#include <iostream>\n#include <set> //使用multiset须包含此文件\nusing namespace std;\n\n// 输出[first,last)内的所有元素\ntemplate <class t>\nvoid print(t first, t last){ \n    for(;first != last ; ++first)\n        cout << * first << " ";\n\tcout << endl;\n}\n\nclass a {\nprivate:\n\tint n;\npublic:\n    a(int n_ ) { n = n_; }\n    friend bool operator< ( const a & a1, const a & a2 ) { // 重载 < 运算符\n        return a1.n < a2.n; \n    }\n    friend ostream & operator<< ( ostream & o, const a & a2 ) { \n        o << a2.n; \n        return o; \n    }\n    friend class myless;\n};\n\nstruct myless { \n\tbool operator()( const a & a1, const a & a2){ \n        return ( a1.n % 10 ) < (a2.n % 10); //按个位数比较大小\n    }\n};\n\n// 定义两个使用不同大小比较方式的 multiset\ntypedef multiset<a> mset1; //mset1用默认方式的 < 运算符比较大小\ntypedef multiset<a,myless> mset2; //mset2用 myless::operator()比较大小\n\nint main()\n{\n    const int size = 6;\n    a a[size] = {4,22,19,8,33,40};\n    // m1中的元素默认大小比较方式排序\n    mset1 m1; \n    m1.insert(a,a+size);\n    m1.insert(22);\n    \n\t// 使用count成员函数获取元素值为22的元素个数\n    cout << "1) " << m1.count(22) << endl; \n    //输出m1的所有元素： 4 8 19 22 22 33 40\n    cout << "2) "; print(m1.begin(),m1.end()); \n    \n    // 使用find成员函数查找元素值为19的元素\n    mset1::iterator pp = m1.find(19);\n    if( pp != m1.end() ) //条件为真说明找到\n    \tcout << "found" << endl;\n   \n    // 使用 lower_bound 成员函数返回m1中第一个大于等于22的元素的迭代器\n    // upper_bound 成员函数返回m1中最后一个大于等于22的元素的迭代器\n    cout << "3) "; cout << *m1.lower_bound(22) << "," << *m1.upper_bound(22)<< endl;\n    \n    // 使用 erase 成员函数删除区间内的元素\n    pp = m1.erase(m1.lower_bound(22),m1.upper_bound(22)); //pp指向被删元素的下一个元素\n    cout << "4) "; print(m1.begin(),m1.end()); // 4 8 19 33 40\n    cout << "5) "; cout << * pp << endl; // 33\n    \n    // m2里的元素按n的个位数从小到大排\n    mset2 m2; \n    m2.insert(a,a+size);\n    cout << "6) "; print(m2.begin(),m2.end()); //输出 6) 40 22 33 4 8 19\n    return 0;\n}\n\n\n\n# set\n\n和 multiset 相似 set 类模板定义中有3个模板参数如下：\n\ntemplate <typename key, typename pred = less<key>, typename a = allocator<key> >\nclass set { …… };=\n\n\nset和multiset的最大区别：set支持去重， multiset不支持，所以他们的成员函数大都相同，但是在使用insert() 成员函数时，如果插入set中的是已存在的元素，则忽略插入。\n\n一个 set 常用函数使用实例如下：\n\n#include <iostream>\n#include <set>\nusing namespace std;\nint main() {\n    typedef set<int>::iterator it;\n    int a[5] = { 3,4,6,1,2 };\n    set<int> st(a,a+5); // st里是 1 2 3 4 6 有序集合\n    pair< it,bool> result;\n    result = st.insert(5); // st变成 1 2 3 4 5 6 插入数据时会和已有数据进行比较\n    if(result.second) //插入成功则输出被插入元素\n    \tcout << * result.first << " inserted" << endl; // 输出: 5 inserted\n    if( st.insert(5).second ) \n        cout << * result.first << endl;\n    else\n    \tcout << * result.first << " already exists" << endl; //输出 5 already exists\n    pair<it,it> bounds = st.equal_range(4); // 使用equal_range成员函数同时求得lower_bound和upper_bound\n    cout << * bounds.first << "," << * bounds.second ; //输出：4,5\n    return 0;\n}\n\n\n\n# 键值对集合 map/multimap\n\nmap/multimap #include <map> 键值对集合：map/multimap里放着的都是pair模版类的对象，且按first从小到大排序。所以，map 和 set 的不同在于前者存放的元素有且仅有两个成员变量 (first,second)，一个名为 first，另一个名为 second ，first 的值用来对整体元素进行从小到大的排序，并可以通过 first 快速检索元素。\n\n\n# multimap\n\nmultimap 类模板定义中有4个模板参数如下：\n\ntemplate <typename key, typename t, typename pred = less<key>, typename a = allocator<key> >\nclass multiset { …… };\n\n\nmultimap 类模板中4个模板参数的后两个模板参数是可以缺省的，其中第一个模板参数key代表关键字的类型，第二个模板参数t代表值的类型，第三个模板参数 pred 类型和set类似，该变量决定了multimap 中的元素大小比较的规则。\n\n * multimap 中的元素由<关键字,值>组成，每个元素是一个pair对象，关键字就是 first 成员变量，其类型是key\n * multimap 中允许多个元素的关键字相同。元素按照first成员变量从小到大排列，缺省情况下用 less<key> 定义关键字的小于关系\n\n所有适用于 set 的操作都适用于 map，一个 multimap 使用实例如下：\n\n#include <iostream>\n#include <map>\nusing namespace std;\nint main()\n{\n    typedef multimap<int,double,less<int> > mmid;\n    mmid pairs;\n    // 使用insert()函数插入键值对\n    pairs.insert(pair<int,double>(15,4.2));\n    pairs.insert(make_pair(15,3.1));\n    pairs.insert(mmid::value_type(15,2.7));\n    pairs.insert(mmid::value_type(15,99.3));\n    // 使用count()函数求关键字等于某值的元素个数\n    cout << pairs.count(15) << endl;\n    pairs.insert(mmid::value_type(30,111.11));\n    pairs.insert(mmid::value_type(10,22.22));\n    pairs.insert(mmid::value_type(25,33.333));\n    pairs.insert(mmid::value_type(20,9.3));\n    // 使用erase()函数删除关键字为25的元素\n    pairs.erase(25)\n    for( mmid::const_iterator i = pairs.begin();\n        i != pairs.end() ;i ++ )\n        cout << "(" << i->first << "," << i->second << ")" << ",";\n}\n\n\nmap 插入数据是需要插入一个pair对象，从上例中有三种插入方式：\n\n * pair<int,double>()：pair构造函数生成pair对象，需要指定first和second的类型\n\n * make_pair()：无需写出类型就可以生成一个pair对象，通过实参自动匹配类型；但是需要注意的是pair<int, float>(1, 1.1);和make_pair(1, 1.1);是不同的，前者指定了second就是float，而后再会将其匹配成double\n\n * mmid::value_type()：在定义mmid时会同时定义value_type，typedef pair<const key, t> value_type;所以也可以使用value_type构造pair对象\n\n\n# map\n\n和 multimap 一样 map 类模板定义中有4个模板参数如下：\n\ntemplate <typename key, typename t, typename pred = less<key>, typename a = allocator<key> >\nclass multiset { \n    …… \n\ttypedef pair<const key, t> value_type;\n    …… \n};\n\n\n和 multimap 一样 map 中的元素也是由<关键字,值>组成，每个元素是一个pair对象；但是，和 multimap 的主要区别在于 map 的关键字也就是 first 成员变量各不相同，不存在重复的关键字。同样，在第三个模板参数缺省的情况下，其中的元素使用less<key> 大小比较方法，按照关键字从小到大排列。\n\nmap的[ ]成员函数\n\n因为 map 中的元素关键字都是各不相同的，所以可以使用类似于顺序容器的[]对元素进行检索与修改。若 mymap 为 map 模版类的对象，则可以使用mymap[key]返回对关键字等于key的元素的值（second成员变量）的引用。若没有关键字为key的元素，则会往mymap里插入一个关键字为key的元素，其值用无参构造函数初始化，并返回其值的引用。\n\n一个 map 使用实例如下：\n\n#include <iostream>\n#include <map>\nusing namespace std;\n\n// 重载 << 运算符，用于输出map元素\ntemplate <class key,class value>\nostream & operator <<( ostream & o, const pair<key,value> & p){\n    o << "(" << p.first << "," << p.second << ")";\n    return o;\n}\n\nint main() {\n    typedef map<int, double,less<int> > mmid;\n    mmid pairs;\n    pairs.insert(mmid::value_type(15,2.7));\n    cout << pairs.count(15) << endl;\n    pairs.insert(mmid::value_type(20,9.3));\n    mmid::iterator i; \n    for( i = pairs.begin(); i != pairs.end();i ++ ) \n    \tcout << * i << ",";\n    cout << endl;\n   \t// 使用[]成员函数检索map元素，如果没有关键字为40的元素，则插入一个\n    int n = pairs[40];\n    for( i = pairs.begin(); i != pairs.end();i ++ )\n    \tcout << * i << ",";\n    cout << endl;\n    cout << "5) ";\n    // 使用[]成员函数修改map元素，把关键字为15的元素值改成6.28\n    pairs[15] = 6.28; \n    for( i = pairs.begin(); i != pairs.end();i ++ )\n    \tcout << * i << ",";\n}\n',charsets:{cjk:!0},lastUpdated:"2023/11/19, 12:55:48",lastUpdatedTimestamp:1700369748e3},{title:"碰撞指针",frontmatter:{title:"碰撞指针",date:"2023-03-24T18:39:48.000Z",permalink:"/pages/700e2e/"},regularPath:"/03.LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/01.%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/01.%E5%8F%8C%E6%8C%87%E9%92%88/02.%E7%A2%B0%E6%92%9E%E6%8C%87%E9%92%88.html",relativePath:"03.LeetCode刷题笔记/01.基础算法/01.双指针/02.碰撞指针.md",key:"v-b34a2986",path:"/pages/700e2e/",headers:[{level:2,title:"02 碰撞指针",slug:"_02-碰撞指针",normalizedTitle:"02 碰撞指针",charIndex:2},{level:4,title:"344 反转字符串",slug:"_344-反转字符串",normalizedTitle:"344 反转字符串",charIndex:13},{level:4,title:"345 反转字符串中的元音字母",slug:"_345-反转字符串中的元音字母",normalizedTitle:"345 反转字符串中的元音字母",charIndex:443},{level:4,title:"680 验证回文字符串 Ⅱ",slug:"_680-验证回文字符串-ii",normalizedTitle:"680 验证回文字符串 ⅱ",charIndex:1495},{level:4,title:"167 两数之和 II - 输入有序数组",slug:"_167-两数之和-ii-输入有序数组",normalizedTitle:"167 两数之和 ii - 输入有序数组",charIndex:2368},{level:4,title:"633 平方数之和",slug:"_633-平方数之和",normalizedTitle:"633 平方数之和",charIndex:3555},{level:4,title:"15 三数之和",slug:"_15-三数之和",normalizedTitle:"15 三数之和",charIndex:4308},{level:4,title:"18 四数之和",slug:"_18-四数之和",normalizedTitle:"18 四数之和",charIndex:6209},{level:4,title:"27 移除元素",slug:"_27-移除元素",normalizedTitle:"27 移除元素",charIndex:8247}],headersStr:"02 碰撞指针 344 反转字符串 345 反转字符串中的元音字母 680 验证回文字符串 Ⅱ 167 两数之和 II - 输入有序数组 633 平方数之和 15 三数之和 18 四数之和 27 移除元素",content:'# 02 碰撞指针\n\n# 344 反转字符串\n\n编写一个函数，其作用是将输入的字符串反转过来。\n\n输入一个字符数组，输出将其反转的字符数组\n\n> 输入：s = ["h","e","l","l","o"]\n> 输出：["o","l","l","e","h"]\n\n解析：\n\n本题使用双指针可以快速简单地解决。我们定义一对碰撞指针分别指向字符数组的头和尾，然后循环执行如下两步，直到两指针相遇循环终止：\n\n * 交换 head 和 tail 指向的元素\n * head 和 tail 相向移动一步\n\nclass Solution {\npublic:\n    void reverseString(vector<char>& s) {\n        int head = 0, tail = s.size()-1;\n        while(head<tail){\n            swap(s[head++],s[tail--]);\n        }\n    }\n};\n\n\n# 345 反转字符串中的元音字母\n\n给定一个字符串 s ，仅反转字符串中的所有元音字母，并返回结果字符串。元音字母包括 \'a\'、\'e\'、\'i\'、\'o\'、\'u\'，且可能以大小写两种形式出现。\n\n输入一个字符串，输出一个元音字母反转后的字符串\n\n> 输入：s = "lEetcode"\n> 输出："leotcedE"\n\n解析：\n\n本题有两个关键任务：一是判断当前字符是否为元音字母；二是找到两个要进行反转的元音字母。\n\n第一个任务我们使用哈希表解决，哈希表经常用于元素搜索和查重。我们定义一个哈希表存储所有的元音字母，然后使用其count方法判断字符是否为元音字母。\n\n第二个任务我们仍采用碰撞指针解决，定义一对指针分别指向字符数组的头和尾，然后相向移动寻找元音字母。如果两指针都指向了元音字母，则交换两指针指向的元素；如果指向的不是元音字母，则向前移动。\n\nclass Solution {\npublic:\n    string reverseVowels(string s) {\n        vector<char> vowel{\'a\',\'e\',\'i\',\'o\',\'u\'};\n        unordered_set<char> hash;\n        for(const auto ch: vowel){\n            hash.insert(ch);\n            hash.insert(ch-32);\n        }\n\n        int head = 0, tail = s.size()-1;\n        while(head < tail){\n            if(hash.count(s[head]) && hash.count(s[tail])){\n                swap(s[head],s[tail]);\n                ++head;\n                --tail;\n            }\n            if(!hash.count(s[head])){\n                ++head;\n            }\n            if(!hash.count(s[tail])){\n                --tail;\n            }\n        }\n        return s;\n    }\n};\n\n\n# 680 验证回文字符串 Ⅱ\n\n给定一个非空字符串 s，最多删除一个字符。判断是否能成为回文字符串。\n\n输入一个字符串，输出一个布尔值判断是否能够按照条件构成回文串\n\n> 输入: s = "abca"\n> 输出: true\n> 解释: 可以删除c字符。\n\n解析：\n\n本题用碰撞指针检验回文串，检验过程分为两步：\n\n首先，使用两个指针分别指向字符串的头和尾，逐对比较字符是否相同\n\n如果出现不同的情况，则分别验证删除头指针指向的字符和删除尾指针指向的字符两种情况下剩余子串是否是回文字符串。任一情况成立则放回 true，否在返回 false。\n\n根据上述我们需要一个辅助函数，能根据子串的起始和终止位置验证该子串是否是回文串。\n\nclass Solution {\npublic:\n    bool validPalindrome(string s, int start, int end){\n        while(start <= end){\n            if(s[start++]!=s[end--]){\n                return false;\n            }\n        }\n        return true;\n    }\n\n    bool validPalindrome(string s) {\n        int head = 0, tail = s.size()-1;\n        while(head <= tail){\n            if(s[head]!=s[tail]){\n                return (validPalindrome(s,head+1,tail) || validPalindrome(s,head,tail-1));\n            }\n            ++head;\n            --tail;\n        }\n        return true;\n    }\n};\n\n\n# 167 两数之和 II - 输入有序数组\n\n在一个增序的整数数组里找到两个数，使它们的和为给定值，已知有且只有一对解。\n\n输入是一个数组（numbers）和一个给定值（target），输出是两个数的位置，从 1 开始计数。\n\n> 输入：numbers = [2,7,11,15], target = 9 输出：[1,2] 解释：2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。\n\n解析：\n\n本题和1 两数之和的区别在于输入的是有序数组。\n\n因为数组已经排好序，我们可以采用碰撞指针来寻找这两个数字，一个指向数组开头 head，一个指向数组末尾 tail。判断这两个指针指向的元素之和 TwoSum 与 target 值的关系：\n\n * 如果大于 target 则将 tail 向左移动获取更小的两数之和；\n * 如果小于 target 则将 head 向右移动获取更大的两数之和；\n * 如果与 target 值相等则 head 和 tail 指向的元素为所找的一对解\n\n对于排好序且有解的数组，双指针一定能以 O(n) 时间复杂度遍历到最优解。碰撞指针缩减搜索空间的关键在于它每一次移动指针都直接排除了一行或一列的搜索空间，例如当TwoSum = numbers[head]+numbers[tail] < target这时就将head++，因为tail已经对应的是最大值无需再去搜索本行中其他解，这样就直接排除了当前一行的搜索空间；同理，TwoSum = numbers[head]+numbers[tail] > target时就将tail--，此时head对应的是当前最小值也无需去搜索本列中其他解，这样就直接排除了head当前一列的搜索空间。\n\nclass Solution {\npublic:\n    vector<int> twoSum(vector<int>& numbers, int target) {\n        int head = 0, tail = numbers.size()-1;\n        while(head<tail){\n            int sum = numbers[head] + numbers[tail];\n            if(sum > target){\n                --tail;\n            }else if(sum < target){\n                ++head;\n            }else{\n                return {head+1,tail+1};\n            }\n        }\n        return {};\n    }\n};\n\n\n# 633 平方数之和\n\n给定一个非负整数 c ，判断是否存在两个整数 a 和 b，使得 a2 + b2 = c\n\n输入一个整数，输出一个布尔值表示该值是否为两个整数的平方和\n\n> 输入：c = 5\n> 输出：true\n> 解释：1 * 1 + 2 * 2 = 5\n\n解析：\n\n本题是167 两数之和 II - 输入有序数组的变种题。\n\n我们用碰撞指针遍历数组空间为[0,sqrt(c)]的范围：\n\n * 如果大于 target 则将 tail 向左移动获取更小的两数平方和；\n * 如果小于 target 则将 head 向右移动获取更大的两数平方和；\n * 如果与 target 值相等则 head 和 tail 指向的元素为所找的一对解\n\n需要注意的是，因为测试用例范围很大，用长整型存储结果\n\nclass Solution {\npublic:\n    bool judgeSquareSum(int c) {\n        long  head = 0;\n        long  tail = (int)sqrt(c);\n        while(lsh<=rsh){\n            long sum = pow(head,2) + pow(tail,2);\n            if(sum == c){\n                return true;\n            }else if(sum > c){\n                --tail;\n            }else{\n                ++head;\n            }\n        }\n        return false;\n    }\n};\n\n\n# 15 三数之和\n\n给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请找出所有和为 0 且不重复的三元组。\n\n输入一个一维数组，输出一个二维数组包含所有和为 0 且不重复的三元组\n\n> 输入：nums = [-1,0,1,2,-1,-4]\n> 输出：[[-1,-1,2],[-1,0,1]]\n\n解析：\n\n本题我们可以将三数之和转化为167 两数之和 II - 输入有序数组，即 a + b = -c。将 -c 转化 target 在除 c 之外的元素中寻找 a 和 b。当然要采用和 167 相同的碰撞指针解决本题，我们要对数组进行排序才能有双指针。所以本题主要有如下两个任务：\n\n * 对数组进行排序，使得可以使用双指针找两数之和\n * 遍历每个元素，在数组中位于该元素之后的所有元素中寻找两数之和为当前元素值相反数的两个数，如果存在则构成一个三元组。这里我们需要考虑一个问题：为什么只用考虑该元素之后的元素，而不需要考虑之前遍历过的元素？因为如果之前的元素和当前元素能够构成三数之和为 0，那么该结果在遍历前面的元素时就已经加入了结果集，如果再考虑就会产生重复的三元组。\n\n本题最为关键的就是结果去重，不仅要考虑到外层循环遍历相同元素产生的重复结果，还要考虑到双指针在遍历过程中如果前后遍历到相同元素也会产生重复结果。\n\nclass Solution {\npublic:\n    vector<vector<int>> threeSum(vector<int>& nums) {\n        // 数组长度小于3，无法构成三元组\n        int len = nums.size();\n        vector<vector<int>> ans;\n        if(len < 3){\n            return ans;\n        }\n\t\t\n        // 排序数组\n        sort(nums.begin(),nums.end());\n        // 如果数组最小的元素都大于零，那么无法构成 a + b + c = 0\n        if(nums[0] > 0){\n            return ans;\n        }\n\n        for(int i=0;i<len;++i){    \n            // 外层遍历去重，遍历到相同的元素会产生重复结果\n            if(i>0 && nums[i] == nums[i-1]){\n                continue;\n            }\n            // 双指针寻找两数之和\n            int head = i+1, tail = len-1;\n            while(head<tail){\n                int sum = nums[head] + nums[tail];\n                if(sum == -nums[i]){\n                    ans.push_back({nums[i],nums[head++],nums[tail--]});\n                    // 双指针遍历去重，如果双指针前后遍历到相同元素也会产生重复结果\n                    while(head<tail && nums[head] == nums[head-1]){\n                        ++head;\n                    }\n                    while(head<tail && nums[tail] == nums[tail+1]){\n                        --tail;\n                    }\n                }else if(sum > -nums[i]){\n                    --tail;\n                }else{\n                    ++head;\n                }\n            }\n        }\n        return ans;\n    }\n};\n\n\n# 18 四数之和\n\n给定一个由 n 个整数组成的数组 nums ，和一个目标值 target 。找出并返回满足下述全部条件且不重复的四元组 [nums[a], nums[b], nums[c], nums[d]]\n\n输入一个数组和一个整型值，输出一个二维数组包含不重复的和为目标值的四元组\n\n> 输入：nums = [1,0,-1,0,-2,2], target = 0\n> 输出：[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]\n\n解析：\n\n本题本质上和15 三数之和一样，还是使用循环+双指针的思路去找到和为目标是 target 的四元组。\n\n本题更加复杂的地方在于：三数之和中双指针寻找的 target 为循环中遍历值的相反数，是一个确定值；而四数之和中双指针寻找的 subTarget 是给定的目标值 target 减去两数之和后的一个不确定的值，我们需要再在外层嵌套一层循环，用两个 for 循环去遍历这两个数的所有组合形成的 subTarget。\n\n基于上述思路本题解题思路如下：\n\n * 对数组排序\n * 双层循环遍历 subTarget = target - (nums[c] + nums[d]) 的所有情况\n * 在循环内使用双指针寻找两数之和为 target\n\n同样需要注意去重问题。\n\nclass Solution {\npublic:\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\n        int len = nums.size();\n        vector<vector<int>> ans;\n        if(len < 4){\n            return ans;\n        }\n\t\t\n        // 排序数组\n        sort(nums.begin(), nums.end());\n\n        for(int i=0;i<len;++i){\n            // 外层遍历去重复\n            if(i>0 && nums[i] == nums[i-1]){\n                continue;\n            }\n\n            for(int j=i+1;j<len;++j){\n                // 外层遍历去重复\n                if(j>i+1 && nums[j] == nums[j-1]){\n                    continue;\n                }\n                // 双指针寻找两数和为 subTarget\n                int subTarget = target - nums[i] - nums[j];\n                int head = j+1, tail = len-1;\n                while(head<tail){\n                    int sum = nums[head] + nums[tail];\n                    if(sum == subTarget){\n                        ans.push_back({nums[i],nums[j],nums[head++],nums[tail--]});\n                        // 双指针遍历去重复\n                        while(head<tail && nums[head] == nums[head-1]){\n                            ++head;\n                        }\n                        while(head<tail && nums[tail] == nums[tail+1]){\n                            --tail;\n                        }\n                    }else if(sum > subTarget){\n                        --tail;\n                    }else{\n                        ++head;\n                    }\n                }\n            }\n        }\n        return ans;\n    }\n};\n\n\n# 27 移除元素\n\n给定一个数组 nums 和一个值 val，要求原地移除所有数值等于 val 的元素，并返回移除后数组的新长度。\n\n输入一个数组和一个值，输出一个整型值表示按条件操作数组之后的新长度\n\n> 输入：nums = [0,1,2,2,3,0,4,2], val = 2 输出：5, nums = [0,1,4,0,3] 解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。\n\n解析：\n\n本题要求在 O(1) 的空间复杂度内完成，数组元素的顺序可以改变，并且不需要考虑数组中超出新长度后面的元素。所以本题可以考虑使用碰撞指针完成。\n\n我们定义两个指针 head 和 tail 分别指向数组的头和尾并相向移动，然后按如下两个步骤移动指针：\n\n * 先移动 tail 如果指向的元素等于 val，则继续移动直到指向的元素值不为 val\n * tail指向的元素不为 val，转过来看 head 指向的元素。如果 head 指向的元素值不为 val 则移动指针；如果其指向的元素刚好为 val 则将当前 tail 指向的元素覆盖到 head 指向的位置，并同时移动两指针。\n\n总的来说就是 head 找需要删除的元素， tail 找不用被删除的元素，然后用 tail 覆盖 head，并继续该操作直到两指针相遇。\n\n上诉思路可以进一步简化：上面的思路中我们用 tail 取寻找不等于 val 的元素，可以通过改变指针的移动规则省略这一步骤。不论 tail 值是否为 val，在 head 找到 val 时我们就用 tail 指向的元素覆盖，完成覆盖后只移动 tail 而不移动 head。这样就可以再次判断覆盖的值是否为 val，直到用于覆盖的值不为 val 时，head 才向前移动。\n\nclass Solution {\npublic:\n    int removeElement(vector<int>& nums, int val) {\n        int head = 0, tail = nums.size();\n        while(head < tail){\n            if(nums[head] == val){\n                nums[head] = nums[--tail];\n            }else{\n                ++head;\n            }\n        }\n        return head;\n    }\n};\n',normalizedContent:'# 02 碰撞指针\n\n# 344 反转字符串\n\n编写一个函数，其作用是将输入的字符串反转过来。\n\n输入一个字符数组，输出将其反转的字符数组\n\n> 输入：s = ["h","e","l","l","o"]\n> 输出：["o","l","l","e","h"]\n\n解析：\n\n本题使用双指针可以快速简单地解决。我们定义一对碰撞指针分别指向字符数组的头和尾，然后循环执行如下两步，直到两指针相遇循环终止：\n\n * 交换 head 和 tail 指向的元素\n * head 和 tail 相向移动一步\n\nclass solution {\npublic:\n    void reversestring(vector<char>& s) {\n        int head = 0, tail = s.size()-1;\n        while(head<tail){\n            swap(s[head++],s[tail--]);\n        }\n    }\n};\n\n\n# 345 反转字符串中的元音字母\n\n给定一个字符串 s ，仅反转字符串中的所有元音字母，并返回结果字符串。元音字母包括 \'a\'、\'e\'、\'i\'、\'o\'、\'u\'，且可能以大小写两种形式出现。\n\n输入一个字符串，输出一个元音字母反转后的字符串\n\n> 输入：s = "leetcode"\n> 输出："leotcede"\n\n解析：\n\n本题有两个关键任务：一是判断当前字符是否为元音字母；二是找到两个要进行反转的元音字母。\n\n第一个任务我们使用哈希表解决，哈希表经常用于元素搜索和查重。我们定义一个哈希表存储所有的元音字母，然后使用其count方法判断字符是否为元音字母。\n\n第二个任务我们仍采用碰撞指针解决，定义一对指针分别指向字符数组的头和尾，然后相向移动寻找元音字母。如果两指针都指向了元音字母，则交换两指针指向的元素；如果指向的不是元音字母，则向前移动。\n\nclass solution {\npublic:\n    string reversevowels(string s) {\n        vector<char> vowel{\'a\',\'e\',\'i\',\'o\',\'u\'};\n        unordered_set<char> hash;\n        for(const auto ch: vowel){\n            hash.insert(ch);\n            hash.insert(ch-32);\n        }\n\n        int head = 0, tail = s.size()-1;\n        while(head < tail){\n            if(hash.count(s[head]) && hash.count(s[tail])){\n                swap(s[head],s[tail]);\n                ++head;\n                --tail;\n            }\n            if(!hash.count(s[head])){\n                ++head;\n            }\n            if(!hash.count(s[tail])){\n                --tail;\n            }\n        }\n        return s;\n    }\n};\n\n\n# 680 验证回文字符串 ⅱ\n\n给定一个非空字符串 s，最多删除一个字符。判断是否能成为回文字符串。\n\n输入一个字符串，输出一个布尔值判断是否能够按照条件构成回文串\n\n> 输入: s = "abca"\n> 输出: true\n> 解释: 可以删除c字符。\n\n解析：\n\n本题用碰撞指针检验回文串，检验过程分为两步：\n\n首先，使用两个指针分别指向字符串的头和尾，逐对比较字符是否相同\n\n如果出现不同的情况，则分别验证删除头指针指向的字符和删除尾指针指向的字符两种情况下剩余子串是否是回文字符串。任一情况成立则放回 true，否在返回 false。\n\n根据上述我们需要一个辅助函数，能根据子串的起始和终止位置验证该子串是否是回文串。\n\nclass solution {\npublic:\n    bool validpalindrome(string s, int start, int end){\n        while(start <= end){\n            if(s[start++]!=s[end--]){\n                return false;\n            }\n        }\n        return true;\n    }\n\n    bool validpalindrome(string s) {\n        int head = 0, tail = s.size()-1;\n        while(head <= tail){\n            if(s[head]!=s[tail]){\n                return (validpalindrome(s,head+1,tail) || validpalindrome(s,head,tail-1));\n            }\n            ++head;\n            --tail;\n        }\n        return true;\n    }\n};\n\n\n# 167 两数之和 ii - 输入有序数组\n\n在一个增序的整数数组里找到两个数，使它们的和为给定值，已知有且只有一对解。\n\n输入是一个数组（numbers）和一个给定值（target），输出是两个数的位置，从 1 开始计数。\n\n> 输入：numbers = [2,7,11,15], target = 9 输出：[1,2] 解释：2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。\n\n解析：\n\n本题和1 两数之和的区别在于输入的是有序数组。\n\n因为数组已经排好序，我们可以采用碰撞指针来寻找这两个数字，一个指向数组开头 head，一个指向数组末尾 tail。判断这两个指针指向的元素之和 twosum 与 target 值的关系：\n\n * 如果大于 target 则将 tail 向左移动获取更小的两数之和；\n * 如果小于 target 则将 head 向右移动获取更大的两数之和；\n * 如果与 target 值相等则 head 和 tail 指向的元素为所找的一对解\n\n对于排好序且有解的数组，双指针一定能以 o(n) 时间复杂度遍历到最优解。碰撞指针缩减搜索空间的关键在于它每一次移动指针都直接排除了一行或一列的搜索空间，例如当twosum = numbers[head]+numbers[tail] < target这时就将head++，因为tail已经对应的是最大值无需再去搜索本行中其他解，这样就直接排除了当前一行的搜索空间；同理，twosum = numbers[head]+numbers[tail] > target时就将tail--，此时head对应的是当前最小值也无需去搜索本列中其他解，这样就直接排除了head当前一列的搜索空间。\n\nclass solution {\npublic:\n    vector<int> twosum(vector<int>& numbers, int target) {\n        int head = 0, tail = numbers.size()-1;\n        while(head<tail){\n            int sum = numbers[head] + numbers[tail];\n            if(sum > target){\n                --tail;\n            }else if(sum < target){\n                ++head;\n            }else{\n                return {head+1,tail+1};\n            }\n        }\n        return {};\n    }\n};\n\n\n# 633 平方数之和\n\n给定一个非负整数 c ，判断是否存在两个整数 a 和 b，使得 a2 + b2 = c\n\n输入一个整数，输出一个布尔值表示该值是否为两个整数的平方和\n\n> 输入：c = 5\n> 输出：true\n> 解释：1 * 1 + 2 * 2 = 5\n\n解析：\n\n本题是167 两数之和 ii - 输入有序数组的变种题。\n\n我们用碰撞指针遍历数组空间为[0,sqrt(c)]的范围：\n\n * 如果大于 target 则将 tail 向左移动获取更小的两数平方和；\n * 如果小于 target 则将 head 向右移动获取更大的两数平方和；\n * 如果与 target 值相等则 head 和 tail 指向的元素为所找的一对解\n\n需要注意的是，因为测试用例范围很大，用长整型存储结果\n\nclass solution {\npublic:\n    bool judgesquaresum(int c) {\n        long  head = 0;\n        long  tail = (int)sqrt(c);\n        while(lsh<=rsh){\n            long sum = pow(head,2) + pow(tail,2);\n            if(sum == c){\n                return true;\n            }else if(sum > c){\n                --tail;\n            }else{\n                ++head;\n            }\n        }\n        return false;\n    }\n};\n\n\n# 15 三数之和\n\n给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请找出所有和为 0 且不重复的三元组。\n\n输入一个一维数组，输出一个二维数组包含所有和为 0 且不重复的三元组\n\n> 输入：nums = [-1,0,1,2,-1,-4]\n> 输出：[[-1,-1,2],[-1,0,1]]\n\n解析：\n\n本题我们可以将三数之和转化为167 两数之和 ii - 输入有序数组，即 a + b = -c。将 -c 转化 target 在除 c 之外的元素中寻找 a 和 b。当然要采用和 167 相同的碰撞指针解决本题，我们要对数组进行排序才能有双指针。所以本题主要有如下两个任务：\n\n * 对数组进行排序，使得可以使用双指针找两数之和\n * 遍历每个元素，在数组中位于该元素之后的所有元素中寻找两数之和为当前元素值相反数的两个数，如果存在则构成一个三元组。这里我们需要考虑一个问题：为什么只用考虑该元素之后的元素，而不需要考虑之前遍历过的元素？因为如果之前的元素和当前元素能够构成三数之和为 0，那么该结果在遍历前面的元素时就已经加入了结果集，如果再考虑就会产生重复的三元组。\n\n本题最为关键的就是结果去重，不仅要考虑到外层循环遍历相同元素产生的重复结果，还要考虑到双指针在遍历过程中如果前后遍历到相同元素也会产生重复结果。\n\nclass solution {\npublic:\n    vector<vector<int>> threesum(vector<int>& nums) {\n        // 数组长度小于3，无法构成三元组\n        int len = nums.size();\n        vector<vector<int>> ans;\n        if(len < 3){\n            return ans;\n        }\n\t\t\n        // 排序数组\n        sort(nums.begin(),nums.end());\n        // 如果数组最小的元素都大于零，那么无法构成 a + b + c = 0\n        if(nums[0] > 0){\n            return ans;\n        }\n\n        for(int i=0;i<len;++i){    \n            // 外层遍历去重，遍历到相同的元素会产生重复结果\n            if(i>0 && nums[i] == nums[i-1]){\n                continue;\n            }\n            // 双指针寻找两数之和\n            int head = i+1, tail = len-1;\n            while(head<tail){\n                int sum = nums[head] + nums[tail];\n                if(sum == -nums[i]){\n                    ans.push_back({nums[i],nums[head++],nums[tail--]});\n                    // 双指针遍历去重，如果双指针前后遍历到相同元素也会产生重复结果\n                    while(head<tail && nums[head] == nums[head-1]){\n                        ++head;\n                    }\n                    while(head<tail && nums[tail] == nums[tail+1]){\n                        --tail;\n                    }\n                }else if(sum > -nums[i]){\n                    --tail;\n                }else{\n                    ++head;\n                }\n            }\n        }\n        return ans;\n    }\n};\n\n\n# 18 四数之和\n\n给定一个由 n 个整数组成的数组 nums ，和一个目标值 target 。找出并返回满足下述全部条件且不重复的四元组 [nums[a], nums[b], nums[c], nums[d]]\n\n输入一个数组和一个整型值，输出一个二维数组包含不重复的和为目标值的四元组\n\n> 输入：nums = [1,0,-1,0,-2,2], target = 0\n> 输出：[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]\n\n解析：\n\n本题本质上和15 三数之和一样，还是使用循环+双指针的思路去找到和为目标是 target 的四元组。\n\n本题更加复杂的地方在于：三数之和中双指针寻找的 target 为循环中遍历值的相反数，是一个确定值；而四数之和中双指针寻找的 subtarget 是给定的目标值 target 减去两数之和后的一个不确定的值，我们需要再在外层嵌套一层循环，用两个 for 循环去遍历这两个数的所有组合形成的 subtarget。\n\n基于上述思路本题解题思路如下：\n\n * 对数组排序\n * 双层循环遍历 subtarget = target - (nums[c] + nums[d]) 的所有情况\n * 在循环内使用双指针寻找两数之和为 target\n\n同样需要注意去重问题。\n\nclass solution {\npublic:\n    vector<vector<int>> foursum(vector<int>& nums, int target) {\n        int len = nums.size();\n        vector<vector<int>> ans;\n        if(len < 4){\n            return ans;\n        }\n\t\t\n        // 排序数组\n        sort(nums.begin(), nums.end());\n\n        for(int i=0;i<len;++i){\n            // 外层遍历去重复\n            if(i>0 && nums[i] == nums[i-1]){\n                continue;\n            }\n\n            for(int j=i+1;j<len;++j){\n                // 外层遍历去重复\n                if(j>i+1 && nums[j] == nums[j-1]){\n                    continue;\n                }\n                // 双指针寻找两数和为 subtarget\n                int subtarget = target - nums[i] - nums[j];\n                int head = j+1, tail = len-1;\n                while(head<tail){\n                    int sum = nums[head] + nums[tail];\n                    if(sum == subtarget){\n                        ans.push_back({nums[i],nums[j],nums[head++],nums[tail--]});\n                        // 双指针遍历去重复\n                        while(head<tail && nums[head] == nums[head-1]){\n                            ++head;\n                        }\n                        while(head<tail && nums[tail] == nums[tail+1]){\n                            --tail;\n                        }\n                    }else if(sum > subtarget){\n                        --tail;\n                    }else{\n                        ++head;\n                    }\n                }\n            }\n        }\n        return ans;\n    }\n};\n\n\n# 27 移除元素\n\n给定一个数组 nums 和一个值 val，要求原地移除所有数值等于 val 的元素，并返回移除后数组的新长度。\n\n输入一个数组和一个值，输出一个整型值表示按条件操作数组之后的新长度\n\n> 输入：nums = [0,1,2,2,3,0,4,2], val = 2 输出：5, nums = [0,1,4,0,3] 解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。\n\n解析：\n\n本题要求在 o(1) 的空间复杂度内完成，数组元素的顺序可以改变，并且不需要考虑数组中超出新长度后面的元素。所以本题可以考虑使用碰撞指针完成。\n\n我们定义两个指针 head 和 tail 分别指向数组的头和尾并相向移动，然后按如下两个步骤移动指针：\n\n * 先移动 tail 如果指向的元素等于 val，则继续移动直到指向的元素值不为 val\n * tail指向的元素不为 val，转过来看 head 指向的元素。如果 head 指向的元素值不为 val 则移动指针；如果其指向的元素刚好为 val 则将当前 tail 指向的元素覆盖到 head 指向的位置，并同时移动两指针。\n\n总的来说就是 head 找需要删除的元素， tail 找不用被删除的元素，然后用 tail 覆盖 head，并继续该操作直到两指针相遇。\n\n上诉思路可以进一步简化：上面的思路中我们用 tail 取寻找不等于 val 的元素，可以通过改变指针的移动规则省略这一步骤。不论 tail 值是否为 val，在 head 找到 val 时我们就用 tail 指向的元素覆盖，完成覆盖后只移动 tail 而不移动 head。这样就可以再次判断覆盖的值是否为 val，直到用于覆盖的值不为 val 时，head 才向前移动。\n\nclass solution {\npublic:\n    int removeelement(vector<int>& nums, int val) {\n        int head = 0, tail = nums.size();\n        while(head < tail){\n            if(nums[head] == val){\n                nums[head] = nums[--tail];\n            }else{\n                ++head;\n            }\n        }\n        return head;\n    }\n};\n',charsets:{cjk:!0},lastUpdated:"2023/11/19, 12:55:48",lastUpdatedTimestamp:1700369748e3},{title:"快慢指针",frontmatter:{title:"快慢指针",date:"2023-03-24T18:39:48.000Z",permalink:"/pages/85ec9f/"},regularPath:"/03.LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/01.%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/01.%E5%8F%8C%E6%8C%87%E9%92%88/03.%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88.html",relativePath:"03.LeetCode刷题笔记/01.基础算法/01.双指针/03.快慢指针.md",key:"v-dec39b1a",path:"/pages/85ec9f/",headers:[{level:2,title:"快慢指针",slug:"快慢指针",normalizedTitle:"快慢指针",charIndex:2},{level:4,title:"142 环形链表 II",slug:"_142-环形链表-ii",normalizedTitle:"142 环形链表 ii",charIndex:10},{level:4,title:"206 反转链表",slug:"_206-反转链表",normalizedTitle:"206 反转链表",charIndex:1058},{level:4,title:"19 删除链表的倒数第 N 个结点",slug:"_19-删除链表的倒数第-n-个结点",normalizedTitle:"19 删除链表的倒数第 n 个结点",charIndex:1784}],headersStr:"快慢指针 142 环形链表 II 206 反转链表 19 删除链表的倒数第 N 个结点",content:"# 快慢指针\n\n# 142 环形链表 II\n\n给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。\n\n输入是一个链表，输出是链表的一个节点，如果没有环路，返回一个空指针。\n\n> 输入：head = [3,2,0,-4], pos = 1\n> 输出：返回索引为 1 的链表节点\n> 解释：链表中有一个环，其尾部连接到第二个节点。\n\n解析：\n\n通常使用 Floyd 判圈法，解决链表找环路的问题。其基本思路就是使用快慢指针，快指针一次走两步，慢指针一次走一步，如果这两个指针会相遇则说明存在环路。现在再用一个指针从链表头节点开始一次走一步，慢指针从两个指针相遇的点开始继续一次一步往前走，当这两个指针相遇时，就是环路的入口。\n\n根据上述思路，我们给定两个指针，分别命名为 slow 和 fast，起始位置在链表的开头。每次 fast 前进两步，slow 前进一步：\n\n * 如果 fast可以走到尽头，那么说明没有环路；\n * 如果 fast 可以无限走下去，那么说明一定有环路，且一定存在一个时刻 slow 和 fast 相遇。\n\n如果存在环路，当 slow 和 fast 第一次相遇时，我们将 fast 重新移动到链表开头，并让 slow 和 fast 每次都前进一步。当 slow 和 fast 第二次相遇时，相遇的节点即为环路的开始点。\n\nclass Solution {\npublic:\n    ListNode *detectCycle(ListNode *head) {\n        ListNode *fast = head, *slow = head;\n        do{\n            if(!fast || !fast->next){\n                return nullptr;\n            }\n            fast = fast->next->next;\n            slow = slow->next;\n        }while(slow != fast);\n        \n        fast = head;\n        while(slow != fast){\n            slow = slow->next;\n            fast = fast->next;\n        }\n        return fast;\n    }\n};\n\n\n# 206 反转链表\n\n给定单链表的头节点 head ，请反转链表，并返回反转后的链表\n\n输入一个链表，输出一个反转后的链表\n\n> 输入：head = [1,2,3,4,5]\n> 输出：[5,4,3,2,1]\n\n解析：\n\n反转链表是快慢指针的经典应用场景。\n\n为了便于统一节点处理方式，我们在链表中加入一个虚拟头节点dummy，其 next 指向链表头节点。然后我们给定两个指针 slow 和 fast，初始时分别指向 dummy 和链表头节点。然后我们进行反转操作：\n\n * 首先使用 tmp 保存 fast 的 next 指向的节点\n * 反转 fast 的 next 指向，指向前一节点即 slow\n * 移动 slow 到当前 fast\n * 更新 fast 指向为其原始 next 指向节点，即 tmp 保存的节点\n\nclass Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode *slow = nullptr, *fast = head;\n        while(fast){\n            // 为了便于理解，我还是新建了 tmp。当然你可以直接使用闲置的 head 记录，节省空间开销\n            ListNode* tmp = fast->next;\n            fast->next = slow;\n            slow = fast;\n            fast = tmp;\n        } \n        return slow;\n    }\n};\n\n\n# 19 删除链表的倒数第 N 个结点\n\n给定一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。\n\n输入一个链表，输出一个按条件操作之后的链表\n\n> 输入：head = [1,2,3,4,5], n = 2\n> 输出：[1,2,3,5]\n\n解析：\n\n对于本题首先我们来考虑删除链表的第 N 个节点怎么操作。我们可以使用一个指针从头节点开始遍历找到链表的第 N-1 个节点，然后改变其 next 指向为 next->next ，最后删除第 N 个节点即可。\n\n那么我们怎么删除倒数第 N 个节点呢？我们要找到倒数第 N 个节点的前一个节点。假设链表总共有 M 个节点，那么倒数第 N 个节点就是第 M - N 个节点。\n\n所以我们可以使用快慢指针，快指针 fast 先遍历到链表的第 N 个节点，此时慢指针 slow 再出发与 fast 同步移动。当 fast 遍历完链表最后一个节点时，slow 指向的就是倒数第 N 个节点。\n\n为了便于删除操作，我们让 fast 先遍历到第 N+1 个节点，这时当 fast 遍历完时，slow 指向就是倒数第 N+1 个节点，即待删除节点的前一个节点。\n\n值得注意的是，我们定义一个虚拟头节点指向链表的头节点，这样同一的对头节点的删除操作。\n\nclass Solution {\npublic:\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\n        // 创建虚拟头节点\n        ListNode* dummy = new ListNode(0,head);\n        ListNode *slow = dummy, *fast = dummy;\n        // 让 fast 先遍历到第 N+1 个节点\n        int cnt = 0;\n        while(cnt < n+1){\n            fast = fast->next;\n            ++cnt;\n        }\n        // 慢指针 slow 与 fast 同步移动到第 N+1 个节点\n        while(fast){\n            fast = fast->next;\n            slow = slow->next;\n        }\n        // 删除第 N 个节点\n        ListNode* tmp = slow->next;\n        slow->next = slow->next->next;\n        delete(tmp);\n        return dummy->next;\n    }\n};\n",normalizedContent:"# 快慢指针\n\n# 142 环形链表 ii\n\n给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。\n\n输入是一个链表，输出是链表的一个节点，如果没有环路，返回一个空指针。\n\n> 输入：head = [3,2,0,-4], pos = 1\n> 输出：返回索引为 1 的链表节点\n> 解释：链表中有一个环，其尾部连接到第二个节点。\n\n解析：\n\n通常使用 floyd 判圈法，解决链表找环路的问题。其基本思路就是使用快慢指针，快指针一次走两步，慢指针一次走一步，如果这两个指针会相遇则说明存在环路。现在再用一个指针从链表头节点开始一次走一步，慢指针从两个指针相遇的点开始继续一次一步往前走，当这两个指针相遇时，就是环路的入口。\n\n根据上述思路，我们给定两个指针，分别命名为 slow 和 fast，起始位置在链表的开头。每次 fast 前进两步，slow 前进一步：\n\n * 如果 fast可以走到尽头，那么说明没有环路；\n * 如果 fast 可以无限走下去，那么说明一定有环路，且一定存在一个时刻 slow 和 fast 相遇。\n\n如果存在环路，当 slow 和 fast 第一次相遇时，我们将 fast 重新移动到链表开头，并让 slow 和 fast 每次都前进一步。当 slow 和 fast 第二次相遇时，相遇的节点即为环路的开始点。\n\nclass solution {\npublic:\n    listnode *detectcycle(listnode *head) {\n        listnode *fast = head, *slow = head;\n        do{\n            if(!fast || !fast->next){\n                return nullptr;\n            }\n            fast = fast->next->next;\n            slow = slow->next;\n        }while(slow != fast);\n        \n        fast = head;\n        while(slow != fast){\n            slow = slow->next;\n            fast = fast->next;\n        }\n        return fast;\n    }\n};\n\n\n# 206 反转链表\n\n给定单链表的头节点 head ，请反转链表，并返回反转后的链表\n\n输入一个链表，输出一个反转后的链表\n\n> 输入：head = [1,2,3,4,5]\n> 输出：[5,4,3,2,1]\n\n解析：\n\n反转链表是快慢指针的经典应用场景。\n\n为了便于统一节点处理方式，我们在链表中加入一个虚拟头节点dummy，其 next 指向链表头节点。然后我们给定两个指针 slow 和 fast，初始时分别指向 dummy 和链表头节点。然后我们进行反转操作：\n\n * 首先使用 tmp 保存 fast 的 next 指向的节点\n * 反转 fast 的 next 指向，指向前一节点即 slow\n * 移动 slow 到当前 fast\n * 更新 fast 指向为其原始 next 指向节点，即 tmp 保存的节点\n\nclass solution {\npublic:\n    listnode* reverselist(listnode* head) {\n        listnode *slow = nullptr, *fast = head;\n        while(fast){\n            // 为了便于理解，我还是新建了 tmp。当然你可以直接使用闲置的 head 记录，节省空间开销\n            listnode* tmp = fast->next;\n            fast->next = slow;\n            slow = fast;\n            fast = tmp;\n        } \n        return slow;\n    }\n};\n\n\n# 19 删除链表的倒数第 n 个结点\n\n给定一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。\n\n输入一个链表，输出一个按条件操作之后的链表\n\n> 输入：head = [1,2,3,4,5], n = 2\n> 输出：[1,2,3,5]\n\n解析：\n\n对于本题首先我们来考虑删除链表的第 n 个节点怎么操作。我们可以使用一个指针从头节点开始遍历找到链表的第 n-1 个节点，然后改变其 next 指向为 next->next ，最后删除第 n 个节点即可。\n\n那么我们怎么删除倒数第 n 个节点呢？我们要找到倒数第 n 个节点的前一个节点。假设链表总共有 m 个节点，那么倒数第 n 个节点就是第 m - n 个节点。\n\n所以我们可以使用快慢指针，快指针 fast 先遍历到链表的第 n 个节点，此时慢指针 slow 再出发与 fast 同步移动。当 fast 遍历完链表最后一个节点时，slow 指向的就是倒数第 n 个节点。\n\n为了便于删除操作，我们让 fast 先遍历到第 n+1 个节点，这时当 fast 遍历完时，slow 指向就是倒数第 n+1 个节点，即待删除节点的前一个节点。\n\n值得注意的是，我们定义一个虚拟头节点指向链表的头节点，这样同一的对头节点的删除操作。\n\nclass solution {\npublic:\n    listnode* removenthfromend(listnode* head, int n) {\n        // 创建虚拟头节点\n        listnode* dummy = new listnode(0,head);\n        listnode *slow = dummy, *fast = dummy;\n        // 让 fast 先遍历到第 n+1 个节点\n        int cnt = 0;\n        while(cnt < n+1){\n            fast = fast->next;\n            ++cnt;\n        }\n        // 慢指针 slow 与 fast 同步移动到第 n+1 个节点\n        while(fast){\n            fast = fast->next;\n            slow = slow->next;\n        }\n        // 删除第 n 个节点\n        listnode* tmp = slow->next;\n        slow->next = slow->next->next;\n        delete(tmp);\n        return dummy->next;\n    }\n};\n",charsets:{cjk:!0},lastUpdated:"2023/11/19, 12:55:48",lastUpdatedTimestamp:1700369748e3},{title:"滑动窗口",frontmatter:{title:"滑动窗口",date:"2023-03-24T18:39:48.000Z",permalink:"/pages/90a84d/"},regularPath:"/03.LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/01.%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/01.%E5%8F%8C%E6%8C%87%E9%92%88/04.%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3.html",relativePath:"03.LeetCode刷题笔记/01.基础算法/01.双指针/04.滑动窗口.md",key:"v-a12e0342",path:"/pages/90a84d/",headers:[{level:2,title:"滑动窗口",slug:"滑动窗口",normalizedTitle:"滑动窗口",charIndex:2},{level:4,title:"76 最小覆盖子串",slug:"_76-最小覆盖子串",normalizedTitle:"76 最小覆盖子串",charIndex:10},{level:4,title:"剑指 Offersh 05 替换空格",slug:"剑指-offersh-05-替换空格",normalizedTitle:"剑指 offersh 05 替换空格",charIndex:1930},{level:4,title:"151 翻转字符串里的单词",slug:"_151-翻转字符串里的单词",normalizedTitle:"151 翻转字符串里的单词",charIndex:1952},{level:4,title:"438 找到字符串中所有字母异位词",slug:"_438-找到字符串中所有字母异位词",normalizedTitle:"438 找到字符串中所有字母异位词",charIndex:4628}],headersStr:"滑动窗口 76 最小覆盖子串 剑指 Offersh 05 替换空格 151 翻转字符串里的单词 438 找到字符串中所有字母异位词",content:'# 滑动窗口\n\n# 76 最小覆盖子串\n\n给定一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 "" 。\n\n输入是两个字符串 S 和 T，输出是一个 S 字符串的子串。\n\n> 输入：s = "ADOBECODEBANC", t = "ABC"\n> 输出："BANC"\n> 解释：S 中同时包含一个 A、一个 B、一个 C 的最短子字符串是“BANC”\n\n解析：\n\n本题使用滑动窗口求解，即两个指针 lsh 和 rsh 都是从最左端向最右端移动，且 lsh 的位置一定在 rsh 的左边或重合。\n\n在本题中滑动窗口右边界指针 rsh 不断从左向右移动，同时判断由 lsh 和 rsh 构成的滑动窗口内的字符串是否覆盖了 T。如果没有覆盖，rsh 继续向右移动；如果刚好覆盖，记录当前子串的其实位置和长度，然后开始移动左边界指针 lsh，寻找新的覆盖子串起点。移动过程中记录最短覆盖子串的起始位置和长度。\n\n另外，为了快速判别滑动窗口内的字符串是否覆盖 T，需要先统计T中字符的情况。我们使用一个哈希表存储 T 中的字符频数。注意T中重复字符的判断情况\n\n在滑动窗口移动过程中：\n\n * 移动右边界 rsh 指针根据 T 的长度找到覆盖 T 的子串\n * 移动左边界 lsh 指针更新覆盖子串的起始位置，寻找更短的覆盖子串\n\nclshass Solshution {\npublshic:\n    strshing minWindow(strshing s, strshing t) {\n        unorshdershed_map<charsh, int> hash;\n        forsh(const charsh ch: t){\n            if(hash.find(ch)!=hash.end()){\n                ++hash[ch];\n            }elshse{\n                hash[ch] = 1;\n            }\n        }\n\n        int cnt = 0;\n        int lsh = 0, rsh = 0;\n        int min_lsh = lsh, min_size = INT_MAX;\n        forsh(rsh = 0;rsh<s.size();++rsh){\n            if(hash.find(s[rsh]) != hash.end()){\n                // 判断 t 中重复出现的字符\n                if(--hash[s[rsh]] >= 0){\n                    ++cnt;\n                }\n\n                // 当前滑动窗口[lsh,rsh]覆盖了 T，即 cnt == T.size()\n                whilshe(cnt == t.size()){\n                    // 如果出现更短的覆盖子串，更新最短覆盖子串的起始位置和长度\n                    int cursh_size = rsh-lsh+1;\n                    if(cursh_size < min_size){\n                        min_lsh = lsh;\n                        min_size = cursh_size;\n                    }\n                    // 左边界移动过程中如果遍历到了 T 中的字符，当前覆盖字符数减少，当前遍历的字符容量增加\n                    if(hash.find(s[lsh]) != hash.end() && ++hash[s[lsh]] > 0){\n                        --cnt;\n                    }\n                    ++lsh;\n                }\n            }\n        }\n        rsheturshn min_size > s.size()?"":s.substrsh(min_lsh,min_size);\n    }\n};\n\n\n# 剑指 Offersh 05 替换空格\n\n# 151 翻转字符串里的单词\n\n给定一个字符串 s ，逐个翻转字符串中的所有 单词 。单词前后包含多个空格\n\n输入一个字符串，输出一个单词反转并去除多余空格的字符串\n\n> 输入：s = " hello world " 输出："world hello" 解释：输入字符串可以在前面或者后面包含多余的空格，但是翻转后的字符不能包括。\n\n解析：\n\n本题一种简单的思路将单词根据分隔符进行分割，然后按照逆序拼接，形成反转单词的字符串。根据这个思路我们要完成两个任务：\n\n * 根据分隔符即本题中的空格，分割单词\n * 将分割好的单词逆序拼接\n\n第一个任务我们可以使用滑动窗口实现 split 函数对单词进行分割。使用两个指针 lsh 和 rsh 从字符串头部出发从左向右遍历。首先移动窗口右边界指针 rsh，当 rsh 指向的元素是空格时，存在两种情况：\n\n（1）lsh 与 rsh 相邻，即 lsh 和 rsh 都指向的是空格，这时窗口中单词长度为 0，我们直接将 lsh 移动到 rsh 的后一个位置。\n\n（2）lsh 与 rsh 不相邻，这时窗口中就存在单词，我们计算该单词的长度为 len = rsh - lsh，并存储单词，同时将 lsh 移动到 rsh 的后一个位置作为新窗口的左边界。\n\n最后如果 rsh==s.size() 即判断最后一个单词是否存在，我们将越界的s.size()视为一个空格即可，通过相同的方式取判断是否存在单词。\n\n第二个任务我们可以利用栈的先入后出特性来反转单词，我们将字符串中的单词根据分隔符进行分割并存入栈中，然后将单词逐个出栈并拼接即可完成单词反转。最后要注意删除最后一个单词后的多余空格。\n\nclass Solution {\npublic:\n    string reverseWords(string s) {\n        stack<string> arr;\n        int lsh = 0, rsh = 0;\n        for(rsh;rsh<=s.size();++rsh){\n            if(s[rsh]==\' \' || rsh==s.size()){\n                int len = rsh-lsh;\n                if(len){\n                    arr.push(s.substr(lsh,len));\n                }\n                lsh = rsh+1;\n            }\n        }\n        string res = "";\n        while(!arr.empty()){\n            res += arr.top();\n            res += " ";\n            arr.pop();\n        }\n        return res.erase(res.size()-1);\n    }\n};\n\n\nC++不支持split函数，但是其他高级语言对字符分割都有很好的支持，所以本题从算法角度考虑可以不使用字符串分割方法主观增加本题的难度。\n\n本题可以基于344 反转字符串的思想解决本题：\n\n * 首先删除字符串头部和尾部多余的空格\n * 然后使用碰撞指针将整个字符串反转\n * 最后我们将字符串中单词逐个反转，恢复到原始单词字符顺序\n\n在第三步的单词反转中我们要用到字符串分割相似的滑动窗口方法，用窗口取找到单词的范围，然后在该窗口内反转单词。\n\nclass Solution {\npublic:\n    string reverseWords(string s) {\n        // 删除头尾多余空格\n        int head = 0, tail = s.size()-1;\n        while(true){\n            if(s[head]!=\' \' && s[tail]!=\' \'){\n                break;\n            }\n            if(s[head]==\' \'){\n                ++head;\n            }\n            if(s[tail]==\' \'){\n                --tail;\n            }\n        }\n        string res = s.substr(head,tail-head+1);\n        // 删除中间多余空格\n        for(int i = 0;i < res.size(); i++){\n            if(res[i] == res[i + 1] && res[i] == \' \'){  \n                res.erase(res.begin() + i);\n                i--;   //由于删除了一个空格，所以i要前移一位才能\n            }\n        }\n\n        // 整体反转字符串\n        head = 0, tail = res.size()-1;\n        while(head<tail){\n            swap(res[head++],res[tail--]);\n        }\n\n        // 反转单词\n        int lsh = 0, rsh = 0;\n        for(rsh;rsh<=res.size();++rsh){\n            if(res[rsh]==\' \' || rsh == res.size()){\n                head = lsh, tail = rsh-1;\n                while(head<tail){\n                    swap(res[head++],res[tail--]);\n                }\n                lsh = rsh+1;\n            }\n        }\n        return res;\n    }\n};\n\n\n# 438 找到字符串中所有字母异位词\n\n给定两个字符串 s 和 p，找到 s 中所有 p 的 异位词 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。\n\n异位词是指由相同字母重排列形成的字符串（包括相同的字符串）。\n\n> 输入: s = "cbaebabacd", p = "abc" 输出: [0,6] 解释: 起始索引等于 0 的子串是 "cba", 它是 "abc" 的异位词。 起始索引等于 6 的子串是 "bac", 它是 "abc" 的异位词。\n\n解析:\n\nclass Solution {\npublic:\n    bool isSame(unordered_map<char,int>& pCount,unordered_map<char,int>& winCount){\n        for(auto [key,val]:winCount){\n            if(pCount[key] != val){ // 验证元素数量是否一致\n                return false;\n            }\n        }\n        return true;\n    }\n    vector<int> findAnagrams(string s, string p) {\n        int slen = s.length(), plen = p.length();\n        // p 比 s 长直接返回\n        if(slen<plen){\n            return {};\n        }\n\n        // 计算 p 的字符组成\n        unordered_map<char,int> pCount;\n        for(auto ch:p){\n            ++pCount[ch];\n        }\n\n        // 滑动窗口, 找到组成一致的子串\n        unordered_map<char,int> winCount;\n        int left = 0, right = 0;\n        vector<int> res;\n        for(;right<slen;++right){\n            ++winCount[s[right]]; // (1) 长度不够时一直++right\n            if(right-left+1 > plen){ // (2) 长度过长时 --left\n                --winCount[s[left]];\n                ++left;\n            }\n\n            if(right-left+1==plen && isSame(pCount,winCount)){ // (3) 长度一致时验证组成是否一致\n                res.push_back(left);\n            }\n        }\n        return res;\n    }\n};\n',normalizedContent:'# 滑动窗口\n\n# 76 最小覆盖子串\n\n给定一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 "" 。\n\n输入是两个字符串 s 和 t，输出是一个 s 字符串的子串。\n\n> 输入：s = "adobecodebanc", t = "abc"\n> 输出："banc"\n> 解释：s 中同时包含一个 a、一个 b、一个 c 的最短子字符串是“banc”\n\n解析：\n\n本题使用滑动窗口求解，即两个指针 lsh 和 rsh 都是从最左端向最右端移动，且 lsh 的位置一定在 rsh 的左边或重合。\n\n在本题中滑动窗口右边界指针 rsh 不断从左向右移动，同时判断由 lsh 和 rsh 构成的滑动窗口内的字符串是否覆盖了 t。如果没有覆盖，rsh 继续向右移动；如果刚好覆盖，记录当前子串的其实位置和长度，然后开始移动左边界指针 lsh，寻找新的覆盖子串起点。移动过程中记录最短覆盖子串的起始位置和长度。\n\n另外，为了快速判别滑动窗口内的字符串是否覆盖 t，需要先统计t中字符的情况。我们使用一个哈希表存储 t 中的字符频数。注意t中重复字符的判断情况\n\n在滑动窗口移动过程中：\n\n * 移动右边界 rsh 指针根据 t 的长度找到覆盖 t 的子串\n * 移动左边界 lsh 指针更新覆盖子串的起始位置，寻找更短的覆盖子串\n\nclshass solshution {\npublshic:\n    strshing minwindow(strshing s, strshing t) {\n        unorshdershed_map<charsh, int> hash;\n        forsh(const charsh ch: t){\n            if(hash.find(ch)!=hash.end()){\n                ++hash[ch];\n            }elshse{\n                hash[ch] = 1;\n            }\n        }\n\n        int cnt = 0;\n        int lsh = 0, rsh = 0;\n        int min_lsh = lsh, min_size = int_max;\n        forsh(rsh = 0;rsh<s.size();++rsh){\n            if(hash.find(s[rsh]) != hash.end()){\n                // 判断 t 中重复出现的字符\n                if(--hash[s[rsh]] >= 0){\n                    ++cnt;\n                }\n\n                // 当前滑动窗口[lsh,rsh]覆盖了 t，即 cnt == t.size()\n                whilshe(cnt == t.size()){\n                    // 如果出现更短的覆盖子串，更新最短覆盖子串的起始位置和长度\n                    int cursh_size = rsh-lsh+1;\n                    if(cursh_size < min_size){\n                        min_lsh = lsh;\n                        min_size = cursh_size;\n                    }\n                    // 左边界移动过程中如果遍历到了 t 中的字符，当前覆盖字符数减少，当前遍历的字符容量增加\n                    if(hash.find(s[lsh]) != hash.end() && ++hash[s[lsh]] > 0){\n                        --cnt;\n                    }\n                    ++lsh;\n                }\n            }\n        }\n        rsheturshn min_size > s.size()?"":s.substrsh(min_lsh,min_size);\n    }\n};\n\n\n# 剑指 offersh 05 替换空格\n\n# 151 翻转字符串里的单词\n\n给定一个字符串 s ，逐个翻转字符串中的所有 单词 。单词前后包含多个空格\n\n输入一个字符串，输出一个单词反转并去除多余空格的字符串\n\n> 输入：s = " hello world " 输出："world hello" 解释：输入字符串可以在前面或者后面包含多余的空格，但是翻转后的字符不能包括。\n\n解析：\n\n本题一种简单的思路将单词根据分隔符进行分割，然后按照逆序拼接，形成反转单词的字符串。根据这个思路我们要完成两个任务：\n\n * 根据分隔符即本题中的空格，分割单词\n * 将分割好的单词逆序拼接\n\n第一个任务我们可以使用滑动窗口实现 split 函数对单词进行分割。使用两个指针 lsh 和 rsh 从字符串头部出发从左向右遍历。首先移动窗口右边界指针 rsh，当 rsh 指向的元素是空格时，存在两种情况：\n\n（1）lsh 与 rsh 相邻，即 lsh 和 rsh 都指向的是空格，这时窗口中单词长度为 0，我们直接将 lsh 移动到 rsh 的后一个位置。\n\n（2）lsh 与 rsh 不相邻，这时窗口中就存在单词，我们计算该单词的长度为 len = rsh - lsh，并存储单词，同时将 lsh 移动到 rsh 的后一个位置作为新窗口的左边界。\n\n最后如果 rsh==s.size() 即判断最后一个单词是否存在，我们将越界的s.size()视为一个空格即可，通过相同的方式取判断是否存在单词。\n\n第二个任务我们可以利用栈的先入后出特性来反转单词，我们将字符串中的单词根据分隔符进行分割并存入栈中，然后将单词逐个出栈并拼接即可完成单词反转。最后要注意删除最后一个单词后的多余空格。\n\nclass solution {\npublic:\n    string reversewords(string s) {\n        stack<string> arr;\n        int lsh = 0, rsh = 0;\n        for(rsh;rsh<=s.size();++rsh){\n            if(s[rsh]==\' \' || rsh==s.size()){\n                int len = rsh-lsh;\n                if(len){\n                    arr.push(s.substr(lsh,len));\n                }\n                lsh = rsh+1;\n            }\n        }\n        string res = "";\n        while(!arr.empty()){\n            res += arr.top();\n            res += " ";\n            arr.pop();\n        }\n        return res.erase(res.size()-1);\n    }\n};\n\n\nc++不支持split函数，但是其他高级语言对字符分割都有很好的支持，所以本题从算法角度考虑可以不使用字符串分割方法主观增加本题的难度。\n\n本题可以基于344 反转字符串的思想解决本题：\n\n * 首先删除字符串头部和尾部多余的空格\n * 然后使用碰撞指针将整个字符串反转\n * 最后我们将字符串中单词逐个反转，恢复到原始单词字符顺序\n\n在第三步的单词反转中我们要用到字符串分割相似的滑动窗口方法，用窗口取找到单词的范围，然后在该窗口内反转单词。\n\nclass solution {\npublic:\n    string reversewords(string s) {\n        // 删除头尾多余空格\n        int head = 0, tail = s.size()-1;\n        while(true){\n            if(s[head]!=\' \' && s[tail]!=\' \'){\n                break;\n            }\n            if(s[head]==\' \'){\n                ++head;\n            }\n            if(s[tail]==\' \'){\n                --tail;\n            }\n        }\n        string res = s.substr(head,tail-head+1);\n        // 删除中间多余空格\n        for(int i = 0;i < res.size(); i++){\n            if(res[i] == res[i + 1] && res[i] == \' \'){  \n                res.erase(res.begin() + i);\n                i--;   //由于删除了一个空格，所以i要前移一位才能\n            }\n        }\n\n        // 整体反转字符串\n        head = 0, tail = res.size()-1;\n        while(head<tail){\n            swap(res[head++],res[tail--]);\n        }\n\n        // 反转单词\n        int lsh = 0, rsh = 0;\n        for(rsh;rsh<=res.size();++rsh){\n            if(res[rsh]==\' \' || rsh == res.size()){\n                head = lsh, tail = rsh-1;\n                while(head<tail){\n                    swap(res[head++],res[tail--]);\n                }\n                lsh = rsh+1;\n            }\n        }\n        return res;\n    }\n};\n\n\n# 438 找到字符串中所有字母异位词\n\n给定两个字符串 s 和 p，找到 s 中所有 p 的 异位词 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。\n\n异位词是指由相同字母重排列形成的字符串（包括相同的字符串）。\n\n> 输入: s = "cbaebabacd", p = "abc" 输出: [0,6] 解释: 起始索引等于 0 的子串是 "cba", 它是 "abc" 的异位词。 起始索引等于 6 的子串是 "bac", 它是 "abc" 的异位词。\n\n解析:\n\nclass solution {\npublic:\n    bool issame(unordered_map<char,int>& pcount,unordered_map<char,int>& wincount){\n        for(auto [key,val]:wincount){\n            if(pcount[key] != val){ // 验证元素数量是否一致\n                return false;\n            }\n        }\n        return true;\n    }\n    vector<int> findanagrams(string s, string p) {\n        int slen = s.length(), plen = p.length();\n        // p 比 s 长直接返回\n        if(slen<plen){\n            return {};\n        }\n\n        // 计算 p 的字符组成\n        unordered_map<char,int> pcount;\n        for(auto ch:p){\n            ++pcount[ch];\n        }\n\n        // 滑动窗口, 找到组成一致的子串\n        unordered_map<char,int> wincount;\n        int left = 0, right = 0;\n        vector<int> res;\n        for(;right<slen;++right){\n            ++wincount[s[right]]; // (1) 长度不够时一直++right\n            if(right-left+1 > plen){ // (2) 长度过长时 --left\n                --wincount[s[left]];\n                ++left;\n            }\n\n            if(right-left+1==plen && issame(pcount,wincount)){ // (3) 长度一致时验证组成是否一致\n                res.push_back(left);\n            }\n        }\n        return res;\n    }\n};\n',charsets:{cjk:!0},lastUpdated:"2023/11/19, 12:55:48",lastUpdatedTimestamp:1700369748e3},{title:"TwoPointer",frontmatter:{title:"TwoPointer",date:"2023-03-24T18:39:48.000Z",permalink:"/pages/2971fd/"},regularPath:"/03.LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/01.%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/01.%E5%8F%8C%E6%8C%87%E9%92%88/TwoPointer.html",relativePath:"03.LeetCode刷题笔记/01.基础算法/01.双指针/TwoPointer.md",key:"v-3842244f",path:"/pages/2971fd/",headers:[{level:2,title:"LeetCode刷题笔记 双指针",slug:"leetcode刷题笔记-双指针",normalizedTitle:"leetcode刷题笔记 双指针",charIndex:2},{level:4,title:"什么是双指针",slug:"什么是双指针",normalizedTitle:"什么是双指针",charIndex:22}],headersStr:"LeetCode刷题笔记 双指针 什么是双指针",content:"# LeetCode刷题笔记 双指针\n\n# 什么是双指针\n\n**双指针的用途：**双指针主要用于单循环遍历线性表数据结构，两个指针指向不同的元素，从而协同完成任务（通常双指针分别指向元素比较，或者两元素联合与某一条件比较）\n\n**双指针的特点：**不管数据输入是字符串、数组还是链表，使用一般方法的遍历方法时间复杂度度在O(n^3)和O(n^2)使用双指针对其进行遍历的平均时间复杂度为O(nlogn)，最好的情况下时间复杂度为O(n)\n\n两种特殊形式的双指针\n\n>  * 碰撞指针Opposite directional：两个指针指向同一线性表，但是遍历方向相反，一个指针指向开头，另一个指向末尾，它们相向移动直到相遇或满足其他特殊条件为止\n>  * 快慢指针Equi-directional：两个指针指向同一线性表，遍历方向相同，且两个指针起点可以相同，也可以不同形成一个滑动窗口，两个指针以不同的策略移动，直到两个指针的值相等或满足其他特殊条件为止",normalizedContent:"# leetcode刷题笔记 双指针\n\n# 什么是双指针\n\n**双指针的用途：**双指针主要用于单循环遍历线性表数据结构，两个指针指向不同的元素，从而协同完成任务（通常双指针分别指向元素比较，或者两元素联合与某一条件比较）\n\n**双指针的特点：**不管数据输入是字符串、数组还是链表，使用一般方法的遍历方法时间复杂度度在o(n^3)和o(n^2)使用双指针对其进行遍历的平均时间复杂度为o(nlogn)，最好的情况下时间复杂度为o(n)\n\n两种特殊形式的双指针\n\n>  * 碰撞指针opposite directional：两个指针指向同一线性表，但是遍历方向相反，一个指针指向开头，另一个指向末尾，它们相向移动直到相遇或满足其他特殊条件为止\n>  * 快慢指针equi-directional：两个指针指向同一线性表，遍历方向相同，且两个指针起点可以相同，也可以不同形成一个滑动窗口，两个指针以不同的策略移动，直到两个指针的值相等或满足其他特殊条件为止",charsets:{cjk:!0},lastUpdated:"2023/11/19, 12:55:48",lastUpdatedTimestamp:1700369748e3},{title:"基础应用",frontmatter:{title:"基础应用",date:"2023-03-24T18:43:11.000Z",permalink:"/pages/3b46c0/"},regularPath:"/03.LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/01.%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/02.%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/01.%E5%9F%BA%E7%A1%80%E5%BA%94%E7%94%A8.html",relativePath:"03.LeetCode刷题笔记/01.基础算法/02.二分查找/01.基础应用.md",key:"v-60717c59",path:"/pages/3b46c0/",headers:[{level:2,title:"01 二分查找的基础应用",slug:"_01-二分查找的基础应用",normalizedTitle:"01 二分查找的基础应用",charIndex:2},{level:3,title:"二分查找简介",slug:"二分查找简介",normalizedTitle:"二分查找简介",charIndex:19},{level:3,title:"二分查找的基础应用",slug:"二分查找的基础应用",normalizedTitle:"二分查找的基础应用",charIndex:5},{level:4,title:"35 搜索插入位置",slug:"_35-搜索插入位置",normalizedTitle:"35 搜索插入位置",charIndex:1153},{level:4,title:"69 Sqrt(x)",slug:"_69-sqrt-x",normalizedTitle:"69 sqrt(x)",charIndex:1953},{level:4,title:"74 搜索二维矩阵",slug:"_74-搜索二维矩阵",normalizedTitle:"74 搜索二维矩阵",charIndex:2852},{level:4,title:"540 有序数组中的单一元素",slug:"_540-有序数组中的单一元素",normalizedTitle:"540 有序数组中的单一元素",charIndex:4490},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:6337}],headersStr:"01 二分查找的基础应用 二分查找简介 二分查找的基础应用 35 搜索插入位置 69 Sqrt(x) 74 搜索二维矩阵 540 有序数组中的单一元素 参考资料",content:"# 01 二分查找的基础应用\n\n\n# 二分查找简介\n\n二分查找也常被称为二分法或者折半查找，它是一种在有序数组中查找某一特定元素的查找算法。这种查找方法将查找的时间复杂度从原本的线性时间提升到了对数时间范围，大大缩短了搜索时间。对于一个长度为 O(n) 的数组，二分查找的时间复杂度为 O(log n)。\n\n举例来说，给定一个排好序的数组 {3,4,5,6,7}，我们希望查找 4 在不在这个数组内。第一次折半时考虑中位数 5，因为 5 大于 4, 所以如果 4 存在于这个数组，那么其必定存在于 5 左边这一半。于是我们的查找区间变成了 {3,4,5}。根据具体情况和您的刷题习惯，这里的 5 可以保留也可以不保留，并不影响时间复杂度的级别。第二次折半时考虑新的中位数 4，正好是我们是需要查找的数字。于是我们发现，对于一个长度为 5 的数组，我们只进行了 2 次查找。如果是遍历数组，最坏的情况则需要查找 5 次。\n\n具体到代码上，二分查找时区间的左右端取开区间还是闭区间在绝大多数时候都可以，因此有些初学者会容易搞不清楚如何定义区间开闭性。这里我提供两个小诀窍，第一是尝试熟练使用一种写法，比如左闭右开（满足 C++、Python 等语言的习惯）或左闭右闭（便于处理边界条件），尽量只保持这一种写法；第二是在刷题时思考如果最后区间只剩下一个数或者两个数，自己的写法是否会陷入死循环，如果某种写法无法跳出死循环，则考虑尝试另一种写法。我们给出左闭右开的二分查找基本程序结构如下：\n\nint basicBinarySearch(vector<int> arr, int target){\n    int left = 0;\n    int right = arr.size();\n    while(left < right){\n        int mid = left + (right-left)/2;\n        if(arr[mid] == target){\n            return mid;\n        }\n        else if (arr[mid] > target){\n        \tright = mid; \n        }\n        else{\n            left = mid + 1;\n        }\n    }\n    return -1;\n}\n\n\n二分查找也可以看作双指针的一种特殊情况，但我们一般会将二者区分。双指针类型的题，指针通常是一步一步移动的，而在二分查找里，指针每次移动半个区间长度。\n\n\n# 二分查找的基础应用\n\n二分查找最为基础的应用就是在有序数组中查找某一特定元素，即查找数组中的某个值。\n\n# 35 搜索插入位置\n\n给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。\n\n输入一个数组和一个目标值，输出一个整数表示目标值插入的位置\n\n> 输入: nums = [1,3,5,6], target = 2\n> 输出: 1\n\n解析：\n\n题目要求使用时间复杂度为 O(log n) 的算法。我们可以考虑使用二分查找来寻找合适位置，计算中间位置 mid，有如下三种情况：\n\n * nums[mid] == target 那么 mid 的位置就是插入位置\n * nums[mid] > target 那么其插入位置在 mid 的左侧\n * nums[mid] < target 那么其插入位置在 mid 的右侧\n\nclass Solution {\npublic:\n    int searchInsert(vector<int>& nums, int target) {\n        int left = 0, right = nums.size();\n        int pos = -1;\n        while(left<right){\n            int mid = left + (right-left)/2;\n            if(nums[mid] == target){\n                return mid;\n            }else if(nums[mid] > target){\n                right = mid;\n            }else{\n                left = mid + 1;\n            }\n        }\n        return left;\n    }\n};\n\n\n# 69 Sqrt(x)\n\n给定一个非负整数 x ，计算并返回 x 的 算术平方根 ，由于返回类型是整数，结果只保留 整数部分 ，小数部分将被 舍去 。\n\n输入一个整数，输出一个整数。\n\n> 输入：x = 8\n> 输出：2\n> 解释：8 的算术平方根是 2.82842..., 由于返回类型是整数，小数部分将被舍去。\n\n解析：\n\n我们可以把这道题想象成，给定一个非负整数 a，求 f (x) = x^2 − a = 0 的解。因为我们只考虑 x ≥ 0，所以 f (x) 在定义域上是单调递增的。考虑到 f (0) = −a ≤ 0， f (a) = a^2 − a ≥ 0，我们可以对 [0, a] 区间使用二分法找到 f (x) = 0 的解。\n\n值得注意的是，为了防止除以 0，我们把 a = 0 的情况单独考虑，然后对区间 [1, a] 进行二分查找；同时，我们采用左闭右开的写法所以 a = 1 时会出现结果处理不一致的情况也要单独考虑。\n\nclass Solution {\npublic:\n    int mySqrt(int x) {\n        if(!x) return 0;\n        int left = 1, right = x;\n        if(left==right) return left;\n        while(left<right){\n            int mid = left + (right-left)/2;\n            int sqrt = x/mid;\n            if(mid == sqrt){\n                return mid;\n            }else if(mid > sqrt){\n                right = mid;\n            }else{\n                left = mid+1;\n            }\n        }\n        return left-1;\n    }\n};\n\n\n# 74 搜索二维矩阵\n\n给定一个 m x n 二维矩阵，已知每行从左到右按升序排列，尝试设计一个快速搜索一个数字是否在矩阵中存在的算法。\n\n输入是一个二维整数矩阵，和一个待搜索整数。输出是一个布尔值，表示这个整数是否存在于矩阵中。\n\n> 输入：matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3\n> 输出：true\n\n解析：\n\n本题使用二分查找有两种思路，一种是先对列二分查找然后对行二分查找，这种两次查找完成搜索；另一种则是将二维数组展平为一个一维数组，然后在该基础上进行二分查找。\n\n这里介绍第二种方法，当然我们不需要真的去做二维数组到一维数组的转化，而是用一维数组的索引去映射二维数组的元素位置。例如，一维数组中索引为 6 的元素映射到 3X4 的二维数组中的位置为matrix[6/4][6%4] 即 matrix[1][2]。又数组整体为递增关系，所以可以方便的采用二分查找搜索元素。当然这种方法中，如果二维矩阵不是对齐的就无法正确应用。\n\nclass Solution {\npublic:\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\n        int m = matrix.size(), n = matrix[0].size();\n        int left = 0, right = m*n;\n        while(left<right){\n            int mid = left + (right-left)/2;\n            if(matrix[mid/n][mid%n] == target){\n                return true;\n            }else if(matrix[mid/n][mid%n] > target){\n                right = mid;\n            }else{\n                left = mid + 1;\n            }\n        }\n        return false;\n    }\n};\n\n\n除了二分查找，对于这种元素呈现从左上角向右下角递增的排列方式，我们可以直接利用其特性进行快速剪枝搜索目标元素。从矩阵右上角开始搜索 target，如果 target 大于当前值就向下移动，当前行被剪枝；如果 target 小于当前值就向左移动，当前列被剪枝。通过这种快速剪枝的策略可以快速完成搜索。\n\nclass Solution {\npublic:\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\n       if(matrix.empty() || matrix[0].empty()){\n           return false;\n       } \n       int m = matrix.size(), n = matrix[0].size();\n       int i = 0, j = n-1;\n       while(i<m && j>=0){\n           if(target == matrix[i][j]){\n                return true;\n            }else if(target < matrix[i][j]){\n                --j;\n            }else{\n                ++i;\n            }\n       }\n       return false;\n    }\n};\n\n\n# 540 有序数组中的单一元素\n\n给定一个只包含整数的有序数组，每个元素都会出现两次，唯有一个数只会出现一次，找出这个数。\n\n输入一个数组，输出一个整型值表示数组中唯一仅出现一次的元素。\n\n> 输入: nums = [1,1,2,3,3,4,4,8,8]\n> 输出: 2\n\n解析：\n\n借助本题我们可以进一步抽象二分查找的应用场景。一般的二分查找应用场景都是根据目标值来将整个数组划分为两部分，一部分整体大于等于目标值，另一部分整体小于目标值。\n\n我们可以进一步抽象二分法为：将数组整体划分为两个局部连续区间，这两个局部区间具有相对的性质。\n\n在本题中采用二分法，我们可以将两个局部区间分为区间长度为偶数和奇数两部分，而奇数区间内就包含着那个唯一出现一次的元素。\n\n使用二分法解决本题的步骤如下：\n\n * 计算 mid，并判断当前元素是出现一次还是两次\n * 如果仅出现一次即 nums[mid] != nums[mid-1] && nums[mid] != nums[mid+1]，直接返回当前元素\n * 如果出现两次就要考虑两种情况，即nums[mid] == nums[mid-1] 还是 nums[mid] == nums[mid+1]。如果是前者，判断[0,mid]区间长度是偶数还是奇数，偶数则在 mid 右侧区间找分界点即left = mid + 1，奇数则在 mid 左侧区间找分界点即right = mid - 1；同理，如果是后者判断[0,mid-1]区间长度为奇数还是偶数，并进行相似操作。\n\nclass Solution {\npublic:\n    int singleNonDuplicate(vector<int>& nums) {\n        int left = 0, right = nums.size();\n        while(left<right){\n            int mid = left + (right-left)/2;\n            // 元素出现两次的情况 nums[mid] == nums[mid-1]\n            if(mid > 0 && nums[mid] == nums[mid-1]){\n                // 判断区间长度的奇偶性，与运算，奇数与0001进行与运算结果为1,偶数为0。mid表示的是元素位置\n                if(mid&1){\n                    left = mid + 1;\n                }else{\n                    right = mid - 1;\n                }\n            // 元素出现两次的情况 nums[mid] == nums[mid+1]\n            }else if(mid < nums.size()-1 && nums[mid] == nums[mid+1]){\n                // 判断区间长度的奇偶性\n                if(mid&1){\n                    right = mid;\n                }else{\n                    left = mid + 2;\n                }\n            }else{\n                return nums[mid];\n            }\n        }\n        return -1;\n    }\n};\n\n\n当然本题也可以使用异或运算的特性快速解决，与自身进行异或运算结果为0，与0进行异或运算的结果为自身x^x=0, x^0=x。利用这一特性我们将数组元素逐一进行异或运算就可以得到只出现一次的元素了。\n\nclass Solution {\npublic:\n    int singleNonDuplicate(vector<int>& nums) {\n        int ans = 0;\n        for(const auto num:nums){\n            ans ^= num;\n        }\n        return ans;\n    }\n};\n\n\n\n# 参考资料\n\n一文带你刷遍二分查找（视频+绘图）",normalizedContent:"# 01 二分查找的基础应用\n\n\n# 二分查找简介\n\n二分查找也常被称为二分法或者折半查找，它是一种在有序数组中查找某一特定元素的查找算法。这种查找方法将查找的时间复杂度从原本的线性时间提升到了对数时间范围，大大缩短了搜索时间。对于一个长度为 o(n) 的数组，二分查找的时间复杂度为 o(log n)。\n\n举例来说，给定一个排好序的数组 {3,4,5,6,7}，我们希望查找 4 在不在这个数组内。第一次折半时考虑中位数 5，因为 5 大于 4, 所以如果 4 存在于这个数组，那么其必定存在于 5 左边这一半。于是我们的查找区间变成了 {3,4,5}。根据具体情况和您的刷题习惯，这里的 5 可以保留也可以不保留，并不影响时间复杂度的级别。第二次折半时考虑新的中位数 4，正好是我们是需要查找的数字。于是我们发现，对于一个长度为 5 的数组，我们只进行了 2 次查找。如果是遍历数组，最坏的情况则需要查找 5 次。\n\n具体到代码上，二分查找时区间的左右端取开区间还是闭区间在绝大多数时候都可以，因此有些初学者会容易搞不清楚如何定义区间开闭性。这里我提供两个小诀窍，第一是尝试熟练使用一种写法，比如左闭右开（满足 c++、python 等语言的习惯）或左闭右闭（便于处理边界条件），尽量只保持这一种写法；第二是在刷题时思考如果最后区间只剩下一个数或者两个数，自己的写法是否会陷入死循环，如果某种写法无法跳出死循环，则考虑尝试另一种写法。我们给出左闭右开的二分查找基本程序结构如下：\n\nint basicbinarysearch(vector<int> arr, int target){\n    int left = 0;\n    int right = arr.size();\n    while(left < right){\n        int mid = left + (right-left)/2;\n        if(arr[mid] == target){\n            return mid;\n        }\n        else if (arr[mid] > target){\n        \tright = mid; \n        }\n        else{\n            left = mid + 1;\n        }\n    }\n    return -1;\n}\n\n\n二分查找也可以看作双指针的一种特殊情况，但我们一般会将二者区分。双指针类型的题，指针通常是一步一步移动的，而在二分查找里，指针每次移动半个区间长度。\n\n\n# 二分查找的基础应用\n\n二分查找最为基础的应用就是在有序数组中查找某一特定元素，即查找数组中的某个值。\n\n# 35 搜索插入位置\n\n给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。\n\n输入一个数组和一个目标值，输出一个整数表示目标值插入的位置\n\n> 输入: nums = [1,3,5,6], target = 2\n> 输出: 1\n\n解析：\n\n题目要求使用时间复杂度为 o(log n) 的算法。我们可以考虑使用二分查找来寻找合适位置，计算中间位置 mid，有如下三种情况：\n\n * nums[mid] == target 那么 mid 的位置就是插入位置\n * nums[mid] > target 那么其插入位置在 mid 的左侧\n * nums[mid] < target 那么其插入位置在 mid 的右侧\n\nclass solution {\npublic:\n    int searchinsert(vector<int>& nums, int target) {\n        int left = 0, right = nums.size();\n        int pos = -1;\n        while(left<right){\n            int mid = left + (right-left)/2;\n            if(nums[mid] == target){\n                return mid;\n            }else if(nums[mid] > target){\n                right = mid;\n            }else{\n                left = mid + 1;\n            }\n        }\n        return left;\n    }\n};\n\n\n# 69 sqrt(x)\n\n给定一个非负整数 x ，计算并返回 x 的 算术平方根 ，由于返回类型是整数，结果只保留 整数部分 ，小数部分将被 舍去 。\n\n输入一个整数，输出一个整数。\n\n> 输入：x = 8\n> 输出：2\n> 解释：8 的算术平方根是 2.82842..., 由于返回类型是整数，小数部分将被舍去。\n\n解析：\n\n我们可以把这道题想象成，给定一个非负整数 a，求 f (x) = x^2 − a = 0 的解。因为我们只考虑 x ≥ 0，所以 f (x) 在定义域上是单调递增的。考虑到 f (0) = −a ≤ 0， f (a) = a^2 − a ≥ 0，我们可以对 [0, a] 区间使用二分法找到 f (x) = 0 的解。\n\n值得注意的是，为了防止除以 0，我们把 a = 0 的情况单独考虑，然后对区间 [1, a] 进行二分查找；同时，我们采用左闭右开的写法所以 a = 1 时会出现结果处理不一致的情况也要单独考虑。\n\nclass solution {\npublic:\n    int mysqrt(int x) {\n        if(!x) return 0;\n        int left = 1, right = x;\n        if(left==right) return left;\n        while(left<right){\n            int mid = left + (right-left)/2;\n            int sqrt = x/mid;\n            if(mid == sqrt){\n                return mid;\n            }else if(mid > sqrt){\n                right = mid;\n            }else{\n                left = mid+1;\n            }\n        }\n        return left-1;\n    }\n};\n\n\n# 74 搜索二维矩阵\n\n给定一个 m x n 二维矩阵，已知每行从左到右按升序排列，尝试设计一个快速搜索一个数字是否在矩阵中存在的算法。\n\n输入是一个二维整数矩阵，和一个待搜索整数。输出是一个布尔值，表示这个整数是否存在于矩阵中。\n\n> 输入：matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3\n> 输出：true\n\n解析：\n\n本题使用二分查找有两种思路，一种是先对列二分查找然后对行二分查找，这种两次查找完成搜索；另一种则是将二维数组展平为一个一维数组，然后在该基础上进行二分查找。\n\n这里介绍第二种方法，当然我们不需要真的去做二维数组到一维数组的转化，而是用一维数组的索引去映射二维数组的元素位置。例如，一维数组中索引为 6 的元素映射到 3x4 的二维数组中的位置为matrix[6/4][6%4] 即 matrix[1][2]。又数组整体为递增关系，所以可以方便的采用二分查找搜索元素。当然这种方法中，如果二维矩阵不是对齐的就无法正确应用。\n\nclass solution {\npublic:\n    bool searchmatrix(vector<vector<int>>& matrix, int target) {\n        int m = matrix.size(), n = matrix[0].size();\n        int left = 0, right = m*n;\n        while(left<right){\n            int mid = left + (right-left)/2;\n            if(matrix[mid/n][mid%n] == target){\n                return true;\n            }else if(matrix[mid/n][mid%n] > target){\n                right = mid;\n            }else{\n                left = mid + 1;\n            }\n        }\n        return false;\n    }\n};\n\n\n除了二分查找，对于这种元素呈现从左上角向右下角递增的排列方式，我们可以直接利用其特性进行快速剪枝搜索目标元素。从矩阵右上角开始搜索 target，如果 target 大于当前值就向下移动，当前行被剪枝；如果 target 小于当前值就向左移动，当前列被剪枝。通过这种快速剪枝的策略可以快速完成搜索。\n\nclass solution {\npublic:\n    bool searchmatrix(vector<vector<int>>& matrix, int target) {\n       if(matrix.empty() || matrix[0].empty()){\n           return false;\n       } \n       int m = matrix.size(), n = matrix[0].size();\n       int i = 0, j = n-1;\n       while(i<m && j>=0){\n           if(target == matrix[i][j]){\n                return true;\n            }else if(target < matrix[i][j]){\n                --j;\n            }else{\n                ++i;\n            }\n       }\n       return false;\n    }\n};\n\n\n# 540 有序数组中的单一元素\n\n给定一个只包含整数的有序数组，每个元素都会出现两次，唯有一个数只会出现一次，找出这个数。\n\n输入一个数组，输出一个整型值表示数组中唯一仅出现一次的元素。\n\n> 输入: nums = [1,1,2,3,3,4,4,8,8]\n> 输出: 2\n\n解析：\n\n借助本题我们可以进一步抽象二分查找的应用场景。一般的二分查找应用场景都是根据目标值来将整个数组划分为两部分，一部分整体大于等于目标值，另一部分整体小于目标值。\n\n我们可以进一步抽象二分法为：将数组整体划分为两个局部连续区间，这两个局部区间具有相对的性质。\n\n在本题中采用二分法，我们可以将两个局部区间分为区间长度为偶数和奇数两部分，而奇数区间内就包含着那个唯一出现一次的元素。\n\n使用二分法解决本题的步骤如下：\n\n * 计算 mid，并判断当前元素是出现一次还是两次\n * 如果仅出现一次即 nums[mid] != nums[mid-1] && nums[mid] != nums[mid+1]，直接返回当前元素\n * 如果出现两次就要考虑两种情况，即nums[mid] == nums[mid-1] 还是 nums[mid] == nums[mid+1]。如果是前者，判断[0,mid]区间长度是偶数还是奇数，偶数则在 mid 右侧区间找分界点即left = mid + 1，奇数则在 mid 左侧区间找分界点即right = mid - 1；同理，如果是后者判断[0,mid-1]区间长度为奇数还是偶数，并进行相似操作。\n\nclass solution {\npublic:\n    int singlenonduplicate(vector<int>& nums) {\n        int left = 0, right = nums.size();\n        while(left<right){\n            int mid = left + (right-left)/2;\n            // 元素出现两次的情况 nums[mid] == nums[mid-1]\n            if(mid > 0 && nums[mid] == nums[mid-1]){\n                // 判断区间长度的奇偶性，与运算，奇数与0001进行与运算结果为1,偶数为0。mid表示的是元素位置\n                if(mid&1){\n                    left = mid + 1;\n                }else{\n                    right = mid - 1;\n                }\n            // 元素出现两次的情况 nums[mid] == nums[mid+1]\n            }else if(mid < nums.size()-1 && nums[mid] == nums[mid+1]){\n                // 判断区间长度的奇偶性\n                if(mid&1){\n                    right = mid;\n                }else{\n                    left = mid + 2;\n                }\n            }else{\n                return nums[mid];\n            }\n        }\n        return -1;\n    }\n};\n\n\n当然本题也可以使用异或运算的特性快速解决，与自身进行异或运算结果为0，与0进行异或运算的结果为自身x^x=0, x^0=x。利用这一特性我们将数组元素逐一进行异或运算就可以得到只出现一次的元素了。\n\nclass solution {\npublic:\n    int singlenonduplicate(vector<int>& nums) {\n        int ans = 0;\n        for(const auto num:nums){\n            ans ^= num;\n        }\n        return ans;\n    }\n};\n\n\n\n# 参考资料\n\n一文带你刷遍二分查找（视频+绘图）",charsets:{cjk:!0},lastUpdated:"2023/11/19, 12:55:48",lastUpdatedTimestamp:1700369748e3},{title:"边界收缩",frontmatter:{title:"边界收缩",date:"2023-03-24T18:43:11.000Z",permalink:"/pages/0a4983/"},regularPath:"/03.LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/01.%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/02.%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/02.%E8%BE%B9%E7%95%8C%E6%94%B6%E7%BC%A9.html",relativePath:"03.LeetCode刷题笔记/01.基础算法/02.二分查找/02.边界收缩.md",key:"v-4b7cce06",path:"/pages/0a4983/",headers:[{level:2,title:"02 二分查找 边界收缩",slug:"_02-二分查找-边界收缩",normalizedTitle:"02 二分查找 边界收缩",charIndex:2},{level:3,title:"二分查找的边界值",slug:"二分查找的边界值",normalizedTitle:"二分查找的边界值",charIndex:19},{level:4,title:"34 在排序数组中查找元素的第一个和最后一个位置",slug:"_34-在排序数组中查找元素的第一个和最后一个位置",normalizedTitle:"34 在排序数组中查找元素的第一个和最后一个位置",charIndex:1388}],headersStr:"02 二分查找 边界收缩 二分查找的边界值 34 在排序数组中查找元素的第一个和最后一个位置",content:"# 02 二分查找 边界收缩\n\n\n# 二分查找的边界值\n\n二分查找很简单，但是也有它的难点，其难点就在于在判定条件和边界值的选择上，很容易就会导致越界或者死循环的情况。\n\n对于循环的判定条件，如果查找区间是闭区间[left, right]，则判定条件要设为while(left<=right)，该判定条件是在出现left > right的情况下终止循环；如果这种闭区间查找区间下使用while(left < right)作为判定条件，该判定条件是在出现left >= right的情况下终止循环，这种情况就没有查找left == right是对应数组位置上的元素，导致错误的查找结果。如果查找区间是闭区间[left, right)，则判定条件可以设为while(left < right)。\n\n对于边界值，例如有序数组array = [1,2,4,4,4,4,5,6], target = 4，存在目标值有多个的情况，此时我们希望得到上边界目标值的索引，即为 5；或者希望得到下边界目标值的索引，即为 2。这时就不能找到目标值就返回，而是需要继续收紧边界进一步查找边界值。二分查找求左右边界值的基本实现如下：\n\nint lowerBound(vector<int> arr, int target){\n    int left = 0;\n    int right = arr.size();\n    int pos = -1;\n    while(left < right){\n        int mid = left + (right-left)/2;\n        if(target == arr[mid]){\n            pos = mid;\n            right = mid;\n        }\n        else if(target < arr[mid]){\n            right = mid;\n        }\n        else if(target > arr[mid]){\n            left = mid + 1;\n        }\n    }\n    return pos;\n}\n\nint upperBound(vector<int> arr, int target){\n    int left = 0;\n    int right = arr.size();\n    int pos = -1;\n    while (left < right)\n    {\n        int mid = left + (right-left)/2;\n        if(target == arr[mid]){\n            pos = mid;\n            left = mid + 1;\n        }\n        else if(target < arr[mid]){\n            right = mid;\n        }\n        else if(target > arr[mid]){\n            left = mid + 1;\n        }\n    }\n    return pos;\n}\n\n\n# 34 在排序数组中查找元素的第一个和最后一个位置\n\n给定一个增序的整数数组和一个值，查找该值第一次和最后一次出现的位置\n\n输入是一个数组和一个值，输出为该值第一次出现的位置和最后一次出现的位置（从 0 开始）；如果不存在该值，则两个返回值都设为-1\n\n> 输入：nums = [5,7,7,8,8,10], target = 8\n> 输出：[3,4]\n\n解析：\n\n本题希望在存在目标值有多个的情况下，找到上边界或下边界目标值的索引。这时使用二分查找搜索目标值时，就不能找到目标值就返回，而是需要继续收紧边界进一步查找边界值。\n\n对于查找目标值的第一个和最后一个位置两种情况我们采用不同的收缩策略：\n\n * 第一个位置即下边界：在找到目标值之后，我们将二分查找的区间更新为中点的左侧区间继续查找目标值\n * 最后一个位置即上边界：在找到目标值之后，我们将二分查找的区间更新为中点的右侧区间继续查找目标值\n\nclass Solution {\npublic:\n\n    int lower_bound(vector<int>& nums, int target){\n        int left = 0, right = nums.size();\n        int pos = -1;\n        while(left<right){\n            int mid = left + (right-left)/2;\n            if(nums[mid]==target){\n                pos = mid;\n                right = mid;\n            }else if(nums[mid]>target){\n                right = mid;\n            }else{\n                left = mid + 1;\n            }\n        }\n        return pos;\n    }\n\n    int upper_bound(vector<int>& nums, int target){\n        int left = 0, right = nums.size();\n        int pos = -1;\n        while(left<right){\n            int mid = left + (right-left)/2;\n            if(nums[mid]==target){\n                pos = mid;\n                left = mid + 1;\n            }else if(nums[mid]>target){\n                right = mid;\n            }else{\n                left = mid + 1;\n            }\n        }\n        return pos;\n    }\n\n    vector<int> searchRange(vector<int>& nums, int target) {\n        vector<int> ans(2,-1);\n        if(nums.empty()){\n            return ans;\n        }\n        ans[0] = lower_bound(nums,target);\n        ans[1] = upper_bound(nums,target);\n        return ans;\n    }\n};\n\n\n所以本质上边界收缩就是实现 C++ STL 中的 lower_bound(),upper_bound()两个函数\n\nlower_bound(Iterator first, Iterator last,const T& val);\nupper_bound(Iterator first, Iterator last,const T& val);\n\n\n其中 first 和 last 都为正向迭代器，[first, last)用于指定该函数的作用范围；val 用于执行目标值。该函数的返回值是一个正向迭代器，当查找成功时，迭代器指向找到的小于或大于目标值的第一个元素；反之，如果查找失败，迭代器的指向和 last 迭代器相同。\n\n直接调用 STL 中 <algorithm> 的对应方法可以更加简洁的完成\n\nclass Solution {\npublic:\n    vector<int> searchRange(vector<int>& nums, int target) {\n        vector<int> ans(2,-1);\n        if(nums.empty()){\n            return ans;\n        }\n        ans[0] = std::lower_bound(nums.begin(),nums.end(),target)-nums.begin();\n        ans[1] = std::upper_bound(nums.begin(),nums.end(),target)-nums.begin()-1;\n        return ans[0]>ans[1]?vector<int>{-1,-1}:ans;\n    }\n};\n",normalizedContent:"# 02 二分查找 边界收缩\n\n\n# 二分查找的边界值\n\n二分查找很简单，但是也有它的难点，其难点就在于在判定条件和边界值的选择上，很容易就会导致越界或者死循环的情况。\n\n对于循环的判定条件，如果查找区间是闭区间[left, right]，则判定条件要设为while(left<=right)，该判定条件是在出现left > right的情况下终止循环；如果这种闭区间查找区间下使用while(left < right)作为判定条件，该判定条件是在出现left >= right的情况下终止循环，这种情况就没有查找left == right是对应数组位置上的元素，导致错误的查找结果。如果查找区间是闭区间[left, right)，则判定条件可以设为while(left < right)。\n\n对于边界值，例如有序数组array = [1,2,4,4,4,4,5,6], target = 4，存在目标值有多个的情况，此时我们希望得到上边界目标值的索引，即为 5；或者希望得到下边界目标值的索引，即为 2。这时就不能找到目标值就返回，而是需要继续收紧边界进一步查找边界值。二分查找求左右边界值的基本实现如下：\n\nint lowerbound(vector<int> arr, int target){\n    int left = 0;\n    int right = arr.size();\n    int pos = -1;\n    while(left < right){\n        int mid = left + (right-left)/2;\n        if(target == arr[mid]){\n            pos = mid;\n            right = mid;\n        }\n        else if(target < arr[mid]){\n            right = mid;\n        }\n        else if(target > arr[mid]){\n            left = mid + 1;\n        }\n    }\n    return pos;\n}\n\nint upperbound(vector<int> arr, int target){\n    int left = 0;\n    int right = arr.size();\n    int pos = -1;\n    while (left < right)\n    {\n        int mid = left + (right-left)/2;\n        if(target == arr[mid]){\n            pos = mid;\n            left = mid + 1;\n        }\n        else if(target < arr[mid]){\n            right = mid;\n        }\n        else if(target > arr[mid]){\n            left = mid + 1;\n        }\n    }\n    return pos;\n}\n\n\n# 34 在排序数组中查找元素的第一个和最后一个位置\n\n给定一个增序的整数数组和一个值，查找该值第一次和最后一次出现的位置\n\n输入是一个数组和一个值，输出为该值第一次出现的位置和最后一次出现的位置（从 0 开始）；如果不存在该值，则两个返回值都设为-1\n\n> 输入：nums = [5,7,7,8,8,10], target = 8\n> 输出：[3,4]\n\n解析：\n\n本题希望在存在目标值有多个的情况下，找到上边界或下边界目标值的索引。这时使用二分查找搜索目标值时，就不能找到目标值就返回，而是需要继续收紧边界进一步查找边界值。\n\n对于查找目标值的第一个和最后一个位置两种情况我们采用不同的收缩策略：\n\n * 第一个位置即下边界：在找到目标值之后，我们将二分查找的区间更新为中点的左侧区间继续查找目标值\n * 最后一个位置即上边界：在找到目标值之后，我们将二分查找的区间更新为中点的右侧区间继续查找目标值\n\nclass solution {\npublic:\n\n    int lower_bound(vector<int>& nums, int target){\n        int left = 0, right = nums.size();\n        int pos = -1;\n        while(left<right){\n            int mid = left + (right-left)/2;\n            if(nums[mid]==target){\n                pos = mid;\n                right = mid;\n            }else if(nums[mid]>target){\n                right = mid;\n            }else{\n                left = mid + 1;\n            }\n        }\n        return pos;\n    }\n\n    int upper_bound(vector<int>& nums, int target){\n        int left = 0, right = nums.size();\n        int pos = -1;\n        while(left<right){\n            int mid = left + (right-left)/2;\n            if(nums[mid]==target){\n                pos = mid;\n                left = mid + 1;\n            }else if(nums[mid]>target){\n                right = mid;\n            }else{\n                left = mid + 1;\n            }\n        }\n        return pos;\n    }\n\n    vector<int> searchrange(vector<int>& nums, int target) {\n        vector<int> ans(2,-1);\n        if(nums.empty()){\n            return ans;\n        }\n        ans[0] = lower_bound(nums,target);\n        ans[1] = upper_bound(nums,target);\n        return ans;\n    }\n};\n\n\n所以本质上边界收缩就是实现 c++ stl 中的 lower_bound(),upper_bound()两个函数\n\nlower_bound(iterator first, iterator last,const t& val);\nupper_bound(iterator first, iterator last,const t& val);\n\n\n其中 first 和 last 都为正向迭代器，[first, last)用于指定该函数的作用范围；val 用于执行目标值。该函数的返回值是一个正向迭代器，当查找成功时，迭代器指向找到的小于或大于目标值的第一个元素；反之，如果查找失败，迭代器的指向和 last 迭代器相同。\n\n直接调用 stl 中 <algorithm> 的对应方法可以更加简洁的完成\n\nclass solution {\npublic:\n    vector<int> searchrange(vector<int>& nums, int target) {\n        vector<int> ans(2,-1);\n        if(nums.empty()){\n            return ans;\n        }\n        ans[0] = std::lower_bound(nums.begin(),nums.end(),target)-nums.begin();\n        ans[1] = std::upper_bound(nums.begin(),nums.end(),target)-nums.begin()-1;\n        return ans[0]>ans[1]?vector<int>{-1,-1}:ans;\n    }\n};\n",charsets:{cjk:!0},lastUpdated:"2023/11/19, 12:55:48",lastUpdatedTimestamp:1700369748e3},{title:"BinSearch",frontmatter:{title:"BinSearch",date:"2023-03-24T18:43:11.000Z",permalink:"/pages/b8ad26/"},regularPath:"/03.LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/01.%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/02.%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/BinSearch.html",relativePath:"03.LeetCode刷题笔记/01.基础算法/02.二分查找/BinSearch.md",key:"v-78213b4e",path:"/pages/b8ad26/",headers:[{level:2,title:"LeetCode刷题笔记 二分查找",slug:"leetcode刷题笔记-二分查找",normalizedTitle:"leetcode刷题笔记 二分查找",charIndex:2},{level:3,title:"二分查找简介",slug:"二分查找简介",normalizedTitle:"二分查找简介",charIndex:24}],headersStr:"LeetCode刷题笔记 二分查找 二分查找简介",content:"# LeetCode刷题笔记 二分查找\n\n\n# 二分查找简介\n\n二分查找也常被称为二分法或者折半查找，它是一种在有序数组中查找某一特定元素的查找算法。这种查找方法将查找的时间复杂度从原本的线性时间提升到了对数时间范围，大大缩短了搜索时间。对于一个长度为 O(n) 的数组，二分查找的时间复杂度为 O(log n)。\n\n举例来说，给定一个排好序的数组 {3,4,5,6,7}，我们希望查找 4 在不在这个数组内。第一次折半时考虑中位数 5，因为 5 大于 4, 所以如果 4 存在于这个数组，那么其必定存在于 5 左边这一半。于是我们的查找区间变成了 {3,4,5}。根据具体情况和您的刷题习惯，这里的 5 可以保留也可以不保留，并不影响时间复杂度的级别。第二次折半时考虑新的中位数 4，正好是我们是需要查找的数字。于是我们发现，对于一个长度为 5 的数组，我们只进行了 2 次查找。如果是遍历数组，最坏的情况则需要查找 5 次。\n\n具体到代码上，二分查找时区间的左右端取开区间还是闭区间在绝大多数时候都可以，因此有些初学者会容易搞不清楚如何定义区间开闭性。这里我提供两个小诀窍，第一是尝试熟练使用一种写法，比如左闭右开（满足 C++、Python 等语言的习惯）或左闭右闭（便于处理边界条件），尽量只保持这一种写法；第二是在刷题时思考如果最后区间只剩下一个数或者两个数，自己的写法是否会陷入死循环，如果某种写法无法跳出死循环，则考虑尝试另一种写法。我们给出左闭右开的二分查找基本程序结构如下：\n\nint basicBinarySearch(vector<int> arr, int target){\n    int left = 0;\n    int right = arr.size();\n    while(left < right){\n        int mid = left + (right-left)/2;\n        if(arr[mid] == target){\n            return mid;\n        }\n        else if (arr[mid] > target){\n        \tright = mid; \n        }\n        else{\n            left = mid + 1;\n        }\n    }\n    return -1;\n}\n\n\n二分查找也可以看作双指针的一种特殊情况，但我们一般会将二者区分。双指针类型的题，指针通常是一步一步移动的，而在二分查找里，指针每次移动半个区间长度。",normalizedContent:"# leetcode刷题笔记 二分查找\n\n\n# 二分查找简介\n\n二分查找也常被称为二分法或者折半查找，它是一种在有序数组中查找某一特定元素的查找算法。这种查找方法将查找的时间复杂度从原本的线性时间提升到了对数时间范围，大大缩短了搜索时间。对于一个长度为 o(n) 的数组，二分查找的时间复杂度为 o(log n)。\n\n举例来说，给定一个排好序的数组 {3,4,5,6,7}，我们希望查找 4 在不在这个数组内。第一次折半时考虑中位数 5，因为 5 大于 4, 所以如果 4 存在于这个数组，那么其必定存在于 5 左边这一半。于是我们的查找区间变成了 {3,4,5}。根据具体情况和您的刷题习惯，这里的 5 可以保留也可以不保留，并不影响时间复杂度的级别。第二次折半时考虑新的中位数 4，正好是我们是需要查找的数字。于是我们发现，对于一个长度为 5 的数组，我们只进行了 2 次查找。如果是遍历数组，最坏的情况则需要查找 5 次。\n\n具体到代码上，二分查找时区间的左右端取开区间还是闭区间在绝大多数时候都可以，因此有些初学者会容易搞不清楚如何定义区间开闭性。这里我提供两个小诀窍，第一是尝试熟练使用一种写法，比如左闭右开（满足 c++、python 等语言的习惯）或左闭右闭（便于处理边界条件），尽量只保持这一种写法；第二是在刷题时思考如果最后区间只剩下一个数或者两个数，自己的写法是否会陷入死循环，如果某种写法无法跳出死循环，则考虑尝试另一种写法。我们给出左闭右开的二分查找基本程序结构如下：\n\nint basicbinarysearch(vector<int> arr, int target){\n    int left = 0;\n    int right = arr.size();\n    while(left < right){\n        int mid = left + (right-left)/2;\n        if(arr[mid] == target){\n            return mid;\n        }\n        else if (arr[mid] > target){\n        \tright = mid; \n        }\n        else{\n            left = mid + 1;\n        }\n    }\n    return -1;\n}\n\n\n二分查找也可以看作双指针的一种特殊情况，但我们一般会将二者区分。双指针类型的题，指针通常是一步一步移动的，而在二分查找里，指针每次移动半个区间长度。",charsets:{cjk:!0},lastUpdated:"2023/11/19, 12:55:48",lastUpdatedTimestamp:1700369748e3},{title:"局部有序",frontmatter:{title:"局部有序",date:"2023-03-24T18:43:11.000Z",permalink:"/pages/d09927/"},regularPath:"/03.LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/01.%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/02.%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/03.%E5%B1%80%E9%83%A8%E6%9C%89%E5%BA%8F.html",relativePath:"03.LeetCode刷题笔记/01.基础算法/02.二分查找/03.局部有序.md",key:"v-5590ed59",path:"/pages/d09927/",headers:[{level:2,title:"03 二分查找 局部有序",slug:"_03-二分查找-局部有序",normalizedTitle:"03 二分查找 局部有序",charIndex:2},{level:4,title:"153 寻找旋转排序数组中的最小值",slug:"_153-寻找旋转排序数组中的最小值",normalizedTitle:"153 寻找旋转排序数组中的最小值",charIndex:126},{level:4,title:"154 寻找旋转排序数组中的最小值 II",slug:"_154-寻找旋转排序数组中的最小值-ii",normalizedTitle:"154 寻找旋转排序数组中的最小值 ii",charIndex:1537},{level:4,title:"33 搜索旋转排序数组",slug:"_33-搜索旋转排序数组",normalizedTitle:"33 搜索旋转排序数组",charIndex:3081},{level:4,title:"81 搜索旋转排序数组 II",slug:"_81-搜索旋转排序数组-ii",normalizedTitle:"81 搜索旋转排序数组 ii",charIndex:5049},{level:4,title:"4 寻找两个正序数组的中位数",slug:"_4-寻找两个正序数组的中位数",normalizedTitle:"4 寻找两个正序数组的中位数",charIndex:7177}],headersStr:"03 二分查找 局部有序 153 寻找旋转排序数组中的最小值 154 寻找旋转排序数组中的最小值 II 33 搜索旋转排序数组 81 搜索旋转排序数组 II 4 寻找两个正序数组的中位数",content:"# 03 二分查找 局部有序\n\n我们已经知道二分查找是一种在有序数组中查找某一特定元素的查找算法。\n\n那如果一个数组不是整体有序，而是局部有序呢？这时我们就可以通过分治策略，我们在局部有序的区间内进行二分查找，然后合并各个局部结果组成整体结果。\n\n# 153 寻找旋转排序数组中的最小值\n\n已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。数组 [a[0], a[1], a[2], ..., a[n-1]] 旋转一次的结果为数组 [a[n-1], a[0], a[1], a[2], ..., a[n-2]]。\n\n输入一个元素互不相同的数组，输出一个整型值表示数组的最小值。\n\n> 输入：nums = [4,5,6,7,0,1,2]\n> 输出：0\n> 解释：原数组为 [0,1,2,4,5,6,7] ，旋转 4 次得到输入数组。\n\n解析：\n\n一个不包含重复元素的升序数组在经过旋转之后，我们可以直接将其划分为两个部分，例如数组[4,5,6,7,0,1,2]可以划分为[4,5,6,7] 和 [0,1,2]两个部分。可以看出数组的最小值就是旋转数组两个局部有序区间的分界点。\n\n那我们怎么找到这个分界点呢？因为数组在旋转之前是整体有序的，所以旋转之后nums[0]是进行旋转的中心，那么旋转之后数组局部有序的两个部分中一部分中的元素全都大于等于nums[0]，另一部分中的元素全都小于nums[0]。\n\n利用这一特性，我们使用二分查找的方法找到旋转数组这两部分的分界点：\n\n * 从中间开始找，如果当前查找的值大于等于nums[0]，那么分界点在 mid 的右侧 left = mid+1\n * 如果当前查找的值小于nums[0]，那么分界点在 mid 的左侧 right = mid\n * 循环上述步骤最终找到分界点 left == right\n\n当然我们要考虑到一个特殊情况：长度问n的数组旋转了n恢复到原来的状态。这种情况下我们不能用上述寻找分界点的方式去找最小值，因为该情况不能将旋转数组划分为大于等于nums[0]局部有序区间 + 全都小于nums[0]局部有序区间的两部分组合。但是这种情况的最小值也很好找就是nums[0]，且很容易判断这种情况就是数组首元素小于尾元素，说明该数组整体有序。\n\nclass Solution {\npublic:\n    int findMin(vector<int>& nums) {\n        int left = 0, right = nums.size();\n        // nums[left] < nums[right-1] 判断数组是否是整体有序\n        // nums[left] == nums[right-1] 判断数组是否只有一个元素\n        if(nums[left]<=nums[right-1]){\n            return nums[left];\n        }\n        // 二分查找寻找分界即最小值\n        while(left<right){\n            int mid = left + (right-left)/2;\n            if(nums[mid] < nums[0]){\n                right = mid;\n            }else{\n                left = mid+1;\n            }\n        }\n        return nums[left];\n    }\n};\n\n\n# 154 寻找旋转排序数组中的最小值 II\n\n已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。数组 [a[0], a[1], a[2], ..., a[n-1]] 旋转一次的结果为数组 [a[n-1], a[0], a[1], a[2], ..., a[n-2]]。\n\n输入一个可能存在重复元素的数组，输出一个整型值表示数组的最小值。\n\n> 输入：nums = [2,2,2,0,1,2]\n> 输出：0\n\n解析：\n\n本题和153 寻找旋转排序数组中的最小值解决方法一样，唯一的区别是我们需要考虑元素重复的情况。\n\n旋转情况我们还是通过寻找分界点来找数组中的最小值，还是根据旋转数组的特性以nums[0]作为参考值将数组划分为大于等于nums[0]和小于nums[0]的两部分。\n\n但是如果存在重复的元素，这种二分类的划分将无法实现。例如[2,3,0,1,2,2,2,2,2]，我们将其划分为[2,3]和[0,1,2,2,2,2,2]，显然[0,1,2,2,2,2,2]并不满足全都小于nums[0]==2的条件。这种情况下我们无法正确地使用二分查找寻找分界点，例如上例中第一次循环中 nums[mid] == nums[4] == 2，这将导致向其右侧寻找分界点，显然那无法找到。\n\n那么我们怎么让存在重复元素的旋转数组恢复可二分类的特性呢？\n\n可以观察到只有当以重复元素为旋转中心时才会破坏旋转数组的可二分类特性。恢复方法也很简单，只需要删除小于nums[0]局部区间中的等于nums[0]的元素即可，即将旋转数组尾部与nums[0]相等的元素删除即可。这种操作并不会影响对数组整体最小值的判断，也恢复了旋转数组的可二分类特性。\n\nclass Solution {\npublic:\n    int findMin(vector<int>& nums) {\n        // 删除旋转数组尾部与nums[0]相等的元素，tail>0 如果数组元素全都一样要保留nums[0]\n        int tail = nums.size()-1;\n        while(tail>0){\n            if(nums[tail]==nums[0]){\n                --tail;\n            }else{\n                break;\n            }\n        }\n\t\t\n        // nums[left] < nums[right-1] 判断数组是否是整体有序\n        // nums[left] == nums[right-1] 判断数组是否只有一个元素\t\n        int left = 0, right = tail+1;\n        if(nums[left]<=nums[right-1]){\n            return nums[left];\n        }\n        // 二分查找寻找分界即最小值\n        while(left<right){\n            int mid = left + (right-left)/2;\n            if(nums[mid] < nums[0]){\n                right = mid;\n            }else{\n                left = mid+1;\n            }\n        }\n        return nums[left];\n    }\n};\n\n\n# 33 搜索旋转排序数组\n\n一个原本增序的数组被首尾相连后按某个位置断开（如 [0,1,2,4,5,6,7] → [4,5,6,7,0,1,2]，在第4位断开），我们称其为旋转数组。给定一个值，判断这个值是否存在于这个为旋转数组中。\n\n输入是一个数组和一个值，输出是一个整型值，表示目标值在旋转数组中的位置，若不存在则返回 -1。\n\n> 输入：nums = [4,5,6,7,0,1,2], target = 0\n> 输出：4\n\n解析：\n\n我们观察这个所谓的旋转数组可以看到数组[4,5,6,7,0,1,2]可以划分为有序的两个部分，分别为[4,5,6,7] 和 [0,1,2]。所以我们可以在这两个局部有序的部分中使用二分查找搜索目标值。\n\n基于上述思路我们需要完成两个任务：\n\n * 找到划分局部有序的分界点\n * 使用二分查找在局部有序的数组中搜索目标值\n\n第一个任务我们可以利用旋转数组的特性快速找到分界点。旋转数组中两个局部有序的部分可以用一个简单的性质划分：因为数组在旋转之前是整体有序的，所以旋转之后nums[0]是进行旋转的中心，那么旋转之后数组局部有序的两个部分中一部分中的元素全都大于等于nums[0]，另一部分中的元素全都小于nums[0]。\n\n利用这一特性，我们使用二分查找的方法找到旋转数组这两部分的分界点：\n\n * 从中间开始找，如果当前查找的值大于等于nums[0]，那么分界点在 mid 的右侧 left = mid+1\n * 如果当前查找的值小于nums[0]，那么分界点在 mid 的左侧 right = mid\n * 循环上述步骤最终找到分界点 left == right\n\n第二个任务我们仍然可以基于旋转数组的特性，直接将目标值 target 与 nums[0] 比较选择对应的局部有序区间中进行二分查找。\n\n当然也可以使用分治策略，不进行比较而是直接根据分界点划分的两个区间，同时在两个区间中使用二分查找搜索目标值 target，返回由多个局部结果组成的最终结果。\n\nclass Solution {\npublic:\n    int binarySerach(vector<int> nums, int target, int leftBound, int rightBound){\n        int left = leftBound, right = rightBound;\n        while(left<right){\n            int mid = left + (right-left)/2;\n            if(nums[mid] == target){\n                return mid;\n            }else if(nums[mid] > target){\n                right = mid;\n            }else{\n                left = mid + 1;\n            }\n        }\n        return -1;\n    }\n\n    int search(vector<int>& nums, int target) {\n        // 使用二分查找找到分界点，将数组分为大于等于nums[0]的和小于nums[0]的两部分\n        int left = 0, right = nums.size();\n        while(left<right){\n            int mid = left + (right-left)/2;\n            if(nums[mid] < nums[0]){\n                right = mid;\n            }else{\n                left = mid + 1;\n            }\n        }\n\t\t// 如果目标值小于nums[0]，则在分界点右侧的局部有序区间中用二分查找搜索目标值\n        if(nums[0] > target){\n            return binarySerach(nums,target,left,nums.size());\n        }else{\n            // 如果目标值大于等于nums[0]，则在分界点左侧的局部有序区间中用二分查找搜索目标值\n            return binarySerach(nums,target,0,left);\n        }\n    }\n};\n\n\n# 81 搜索旋转排序数组 II\n\n一个存在重复元素且原本增序的数组被首尾相连后按某个位置断开（如 [0,0,1,2,2,5,6] → [2,5,6,0,0,1,2]，在第4位断开），我们称其为旋转数组。给定一个值，判断这个值是否存在于这个为旋转数组中。\n\n输入是一个数组和一个值，输出是一个布尔值，表示数组中是否存在该值。\n\n> 输入：nums = [2,5,6,0,0,1,2], target = 0\n> 输出：true\n\n解析：\n\n本题和33 搜索旋转排序数组解决方法一样，唯一的区别是我们需要考虑元素重复的情况。\n\n同样，我们可以通过找分界点将旋转数组划分为两个局部有序的部分，并在局部有序的区间中使用二分查找搜索目标值。我们仍然需要完成两个任务：\n\n * 找到划分局部有序的分界点\n * 使用二分查找在局部有序的数组中搜索目标值\n\n寻找分界点我们还是根据旋转数组的特性以nums[0]作为参考值将数组划分为大于等于nums[0]和小于nums[0]的两部分。\n\n但是如果存在重复的元素，这种二分类的划分将无法实现。例如[2,5,6,0,0,1,2]，我们将其划分为[2,5,6]和[0,0,1,2]，显然[0,0,1,2]并不满足全都小于nums[0]==2的条件。\n\n那么我们怎么让存在重复元素的旋转数组恢复可二分类的特性呢？\n\n可以观察到只有当以重复元素为旋转中心时才会破坏旋转数组的可二分类特性。恢复方法也很简单，只需要删除小于nums[0]局部区间中的等于nums[0]的元素即可，即将旋转数组尾部与nums[0]相等的元素删除即可。这种操作并不会影响对元素存在性的判断，也恢复了旋转数组的可二分类特性。\n\n解决了重复元素的问题，其他的步骤就和33 搜索旋转排序数组解决方法一致了。\n\nclass Solution {\npublic:\n    bool  binarySearch(vector<int> nums, int target, int leftBound, int rightBound){\n        int left = leftBound, right = rightBound;\n        while(left<right){\n            int mid = left + (right-left)/2;\n            if(nums[mid] == target){\n                return true;\n            }else if(nums[mid] > target){\n                right = mid;\n            }else{\n                left = mid + 1;\n            }\n        }\n        return false;\n    }\n\n    bool search(vector<int>& nums, int target) {\n        // 删除旋转数组尾部与nums[0]相等的元素，tail>0 如果数组元素全都一样要保留nums[0]\n        int tail = nums.size()-1;\n        while(tail>0){\n            if(nums[tail]==nums[0]){\n                --tail;\n            }else{\n                break;\n            }\n        }\n        \n        // 使用二分查找找到分界点，将数组分为大于等于nums[0]的和小于nums[0]的两部分\n        int left = 0, right = tail+1;\n        while(left<right){\n            int mid = left + (right-left)/2;\n            if(nums[mid] < nums[0]){\n                right = mid;\n            }else{\n                left = mid+1;\n            }\n        }\n\t\t\n        // 如果目标值小于nums[0]，则在分界点右侧的局部有序区间中用二分查找搜索目标值\n        if(nums[0] > target){\n            return binarySearch(nums,target,left,nums.size());\n        }else{\n            // 如果目标值大于等于nums[0]，则在分界点左侧的局部有序区间中用二分查找搜索目标值\n            return binarySearch(nums,target,0,left);\n        }\n    }\n};\n\n\n# 4 寻找两个正序数组的中位数\n\n给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请找出并返回这两个正序数组的 中位数 。\n\n输入两个有序数组，输出一个浮点型值表示两个数组的中位数，要求算法的时间复杂度应该为 O(log (m+n))。\n\n> 输入：nums1 = [1,3], nums2 = [2]\n> 输出：2.00000\n> 解释：合并数组 = [1,2,3] ，中位数 2\n\n解析：\n\n本题没有完全理解，有待更新\n\nclass Solution {\npublic:\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\n        int tot = nums1.size() + nums2.size();\n        if (tot % 2 == 0) {\n            int left = find(nums1, 0, nums2, 0, tot / 2);\n            int right = find(nums1, 0, nums2, 0, tot / 2 + 1);\n            return (left + right) / 2.0;\n        } else {\n            return find(nums1, 0, nums2, 0, tot / 2 + 1);\n        }\n    }\n\n    int find(vector<int>& nums1, int i, vector<int>& nums2, int j, int k) {\n        if (nums1.size() - i > nums2.size() - j) return find(nums2, j, nums1, i, k);\n        if (k == 1) {\n            if (nums1.size() == i) return nums2[j];\n            else return min(nums1[i], nums2[j]);\n        }\n        if (nums1.size() == i) return nums2[j + k - 1];\n        int si = min((int)nums1.size(), i + k / 2), sj = j + k - k / 2;\n        if (nums1[si - 1] > nums2[sj - 1])\n            return find(nums1, i, nums2, sj, k - (sj - j));\n        else\n            return find(nums1, si, nums2, j, k - (si - i));\n    }\n};\n",normalizedContent:"# 03 二分查找 局部有序\n\n我们已经知道二分查找是一种在有序数组中查找某一特定元素的查找算法。\n\n那如果一个数组不是整体有序，而是局部有序呢？这时我们就可以通过分治策略，我们在局部有序的区间内进行二分查找，然后合并各个局部结果组成整体结果。\n\n# 153 寻找旋转排序数组中的最小值\n\n已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。数组 [a[0], a[1], a[2], ..., a[n-1]] 旋转一次的结果为数组 [a[n-1], a[0], a[1], a[2], ..., a[n-2]]。\n\n输入一个元素互不相同的数组，输出一个整型值表示数组的最小值。\n\n> 输入：nums = [4,5,6,7,0,1,2]\n> 输出：0\n> 解释：原数组为 [0,1,2,4,5,6,7] ，旋转 4 次得到输入数组。\n\n解析：\n\n一个不包含重复元素的升序数组在经过旋转之后，我们可以直接将其划分为两个部分，例如数组[4,5,6,7,0,1,2]可以划分为[4,5,6,7] 和 [0,1,2]两个部分。可以看出数组的最小值就是旋转数组两个局部有序区间的分界点。\n\n那我们怎么找到这个分界点呢？因为数组在旋转之前是整体有序的，所以旋转之后nums[0]是进行旋转的中心，那么旋转之后数组局部有序的两个部分中一部分中的元素全都大于等于nums[0]，另一部分中的元素全都小于nums[0]。\n\n利用这一特性，我们使用二分查找的方法找到旋转数组这两部分的分界点：\n\n * 从中间开始找，如果当前查找的值大于等于nums[0]，那么分界点在 mid 的右侧 left = mid+1\n * 如果当前查找的值小于nums[0]，那么分界点在 mid 的左侧 right = mid\n * 循环上述步骤最终找到分界点 left == right\n\n当然我们要考虑到一个特殊情况：长度问n的数组旋转了n恢复到原来的状态。这种情况下我们不能用上述寻找分界点的方式去找最小值，因为该情况不能将旋转数组划分为大于等于nums[0]局部有序区间 + 全都小于nums[0]局部有序区间的两部分组合。但是这种情况的最小值也很好找就是nums[0]，且很容易判断这种情况就是数组首元素小于尾元素，说明该数组整体有序。\n\nclass solution {\npublic:\n    int findmin(vector<int>& nums) {\n        int left = 0, right = nums.size();\n        // nums[left] < nums[right-1] 判断数组是否是整体有序\n        // nums[left] == nums[right-1] 判断数组是否只有一个元素\n        if(nums[left]<=nums[right-1]){\n            return nums[left];\n        }\n        // 二分查找寻找分界即最小值\n        while(left<right){\n            int mid = left + (right-left)/2;\n            if(nums[mid] < nums[0]){\n                right = mid;\n            }else{\n                left = mid+1;\n            }\n        }\n        return nums[left];\n    }\n};\n\n\n# 154 寻找旋转排序数组中的最小值 ii\n\n已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。数组 [a[0], a[1], a[2], ..., a[n-1]] 旋转一次的结果为数组 [a[n-1], a[0], a[1], a[2], ..., a[n-2]]。\n\n输入一个可能存在重复元素的数组，输出一个整型值表示数组的最小值。\n\n> 输入：nums = [2,2,2,0,1,2]\n> 输出：0\n\n解析：\n\n本题和153 寻找旋转排序数组中的最小值解决方法一样，唯一的区别是我们需要考虑元素重复的情况。\n\n旋转情况我们还是通过寻找分界点来找数组中的最小值，还是根据旋转数组的特性以nums[0]作为参考值将数组划分为大于等于nums[0]和小于nums[0]的两部分。\n\n但是如果存在重复的元素，这种二分类的划分将无法实现。例如[2,3,0,1,2,2,2,2,2]，我们将其划分为[2,3]和[0,1,2,2,2,2,2]，显然[0,1,2,2,2,2,2]并不满足全都小于nums[0]==2的条件。这种情况下我们无法正确地使用二分查找寻找分界点，例如上例中第一次循环中 nums[mid] == nums[4] == 2，这将导致向其右侧寻找分界点，显然那无法找到。\n\n那么我们怎么让存在重复元素的旋转数组恢复可二分类的特性呢？\n\n可以观察到只有当以重复元素为旋转中心时才会破坏旋转数组的可二分类特性。恢复方法也很简单，只需要删除小于nums[0]局部区间中的等于nums[0]的元素即可，即将旋转数组尾部与nums[0]相等的元素删除即可。这种操作并不会影响对数组整体最小值的判断，也恢复了旋转数组的可二分类特性。\n\nclass solution {\npublic:\n    int findmin(vector<int>& nums) {\n        // 删除旋转数组尾部与nums[0]相等的元素，tail>0 如果数组元素全都一样要保留nums[0]\n        int tail = nums.size()-1;\n        while(tail>0){\n            if(nums[tail]==nums[0]){\n                --tail;\n            }else{\n                break;\n            }\n        }\n\t\t\n        // nums[left] < nums[right-1] 判断数组是否是整体有序\n        // nums[left] == nums[right-1] 判断数组是否只有一个元素\t\n        int left = 0, right = tail+1;\n        if(nums[left]<=nums[right-1]){\n            return nums[left];\n        }\n        // 二分查找寻找分界即最小值\n        while(left<right){\n            int mid = left + (right-left)/2;\n            if(nums[mid] < nums[0]){\n                right = mid;\n            }else{\n                left = mid+1;\n            }\n        }\n        return nums[left];\n    }\n};\n\n\n# 33 搜索旋转排序数组\n\n一个原本增序的数组被首尾相连后按某个位置断开（如 [0,1,2,4,5,6,7] → [4,5,6,7,0,1,2]，在第4位断开），我们称其为旋转数组。给定一个值，判断这个值是否存在于这个为旋转数组中。\n\n输入是一个数组和一个值，输出是一个整型值，表示目标值在旋转数组中的位置，若不存在则返回 -1。\n\n> 输入：nums = [4,5,6,7,0,1,2], target = 0\n> 输出：4\n\n解析：\n\n我们观察这个所谓的旋转数组可以看到数组[4,5,6,7,0,1,2]可以划分为有序的两个部分，分别为[4,5,6,7] 和 [0,1,2]。所以我们可以在这两个局部有序的部分中使用二分查找搜索目标值。\n\n基于上述思路我们需要完成两个任务：\n\n * 找到划分局部有序的分界点\n * 使用二分查找在局部有序的数组中搜索目标值\n\n第一个任务我们可以利用旋转数组的特性快速找到分界点。旋转数组中两个局部有序的部分可以用一个简单的性质划分：因为数组在旋转之前是整体有序的，所以旋转之后nums[0]是进行旋转的中心，那么旋转之后数组局部有序的两个部分中一部分中的元素全都大于等于nums[0]，另一部分中的元素全都小于nums[0]。\n\n利用这一特性，我们使用二分查找的方法找到旋转数组这两部分的分界点：\n\n * 从中间开始找，如果当前查找的值大于等于nums[0]，那么分界点在 mid 的右侧 left = mid+1\n * 如果当前查找的值小于nums[0]，那么分界点在 mid 的左侧 right = mid\n * 循环上述步骤最终找到分界点 left == right\n\n第二个任务我们仍然可以基于旋转数组的特性，直接将目标值 target 与 nums[0] 比较选择对应的局部有序区间中进行二分查找。\n\n当然也可以使用分治策略，不进行比较而是直接根据分界点划分的两个区间，同时在两个区间中使用二分查找搜索目标值 target，返回由多个局部结果组成的最终结果。\n\nclass solution {\npublic:\n    int binaryserach(vector<int> nums, int target, int leftbound, int rightbound){\n        int left = leftbound, right = rightbound;\n        while(left<right){\n            int mid = left + (right-left)/2;\n            if(nums[mid] == target){\n                return mid;\n            }else if(nums[mid] > target){\n                right = mid;\n            }else{\n                left = mid + 1;\n            }\n        }\n        return -1;\n    }\n\n    int search(vector<int>& nums, int target) {\n        // 使用二分查找找到分界点，将数组分为大于等于nums[0]的和小于nums[0]的两部分\n        int left = 0, right = nums.size();\n        while(left<right){\n            int mid = left + (right-left)/2;\n            if(nums[mid] < nums[0]){\n                right = mid;\n            }else{\n                left = mid + 1;\n            }\n        }\n\t\t// 如果目标值小于nums[0]，则在分界点右侧的局部有序区间中用二分查找搜索目标值\n        if(nums[0] > target){\n            return binaryserach(nums,target,left,nums.size());\n        }else{\n            // 如果目标值大于等于nums[0]，则在分界点左侧的局部有序区间中用二分查找搜索目标值\n            return binaryserach(nums,target,0,left);\n        }\n    }\n};\n\n\n# 81 搜索旋转排序数组 ii\n\n一个存在重复元素且原本增序的数组被首尾相连后按某个位置断开（如 [0,0,1,2,2,5,6] → [2,5,6,0,0,1,2]，在第4位断开），我们称其为旋转数组。给定一个值，判断这个值是否存在于这个为旋转数组中。\n\n输入是一个数组和一个值，输出是一个布尔值，表示数组中是否存在该值。\n\n> 输入：nums = [2,5,6,0,0,1,2], target = 0\n> 输出：true\n\n解析：\n\n本题和33 搜索旋转排序数组解决方法一样，唯一的区别是我们需要考虑元素重复的情况。\n\n同样，我们可以通过找分界点将旋转数组划分为两个局部有序的部分，并在局部有序的区间中使用二分查找搜索目标值。我们仍然需要完成两个任务：\n\n * 找到划分局部有序的分界点\n * 使用二分查找在局部有序的数组中搜索目标值\n\n寻找分界点我们还是根据旋转数组的特性以nums[0]作为参考值将数组划分为大于等于nums[0]和小于nums[0]的两部分。\n\n但是如果存在重复的元素，这种二分类的划分将无法实现。例如[2,5,6,0,0,1,2]，我们将其划分为[2,5,6]和[0,0,1,2]，显然[0,0,1,2]并不满足全都小于nums[0]==2的条件。\n\n那么我们怎么让存在重复元素的旋转数组恢复可二分类的特性呢？\n\n可以观察到只有当以重复元素为旋转中心时才会破坏旋转数组的可二分类特性。恢复方法也很简单，只需要删除小于nums[0]局部区间中的等于nums[0]的元素即可，即将旋转数组尾部与nums[0]相等的元素删除即可。这种操作并不会影响对元素存在性的判断，也恢复了旋转数组的可二分类特性。\n\n解决了重复元素的问题，其他的步骤就和33 搜索旋转排序数组解决方法一致了。\n\nclass solution {\npublic:\n    bool  binarysearch(vector<int> nums, int target, int leftbound, int rightbound){\n        int left = leftbound, right = rightbound;\n        while(left<right){\n            int mid = left + (right-left)/2;\n            if(nums[mid] == target){\n                return true;\n            }else if(nums[mid] > target){\n                right = mid;\n            }else{\n                left = mid + 1;\n            }\n        }\n        return false;\n    }\n\n    bool search(vector<int>& nums, int target) {\n        // 删除旋转数组尾部与nums[0]相等的元素，tail>0 如果数组元素全都一样要保留nums[0]\n        int tail = nums.size()-1;\n        while(tail>0){\n            if(nums[tail]==nums[0]){\n                --tail;\n            }else{\n                break;\n            }\n        }\n        \n        // 使用二分查找找到分界点，将数组分为大于等于nums[0]的和小于nums[0]的两部分\n        int left = 0, right = tail+1;\n        while(left<right){\n            int mid = left + (right-left)/2;\n            if(nums[mid] < nums[0]){\n                right = mid;\n            }else{\n                left = mid+1;\n            }\n        }\n\t\t\n        // 如果目标值小于nums[0]，则在分界点右侧的局部有序区间中用二分查找搜索目标值\n        if(nums[0] > target){\n            return binarysearch(nums,target,left,nums.size());\n        }else{\n            // 如果目标值大于等于nums[0]，则在分界点左侧的局部有序区间中用二分查找搜索目标值\n            return binarysearch(nums,target,0,left);\n        }\n    }\n};\n\n\n# 4 寻找两个正序数组的中位数\n\n给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请找出并返回这两个正序数组的 中位数 。\n\n输入两个有序数组，输出一个浮点型值表示两个数组的中位数，要求算法的时间复杂度应该为 o(log (m+n))。\n\n> 输入：nums1 = [1,3], nums2 = [2]\n> 输出：2.00000\n> 解释：合并数组 = [1,2,3] ，中位数 2\n\n解析：\n\n本题没有完全理解，有待更新\n\nclass solution {\npublic:\n    double findmediansortedarrays(vector<int>& nums1, vector<int>& nums2) {\n        int tot = nums1.size() + nums2.size();\n        if (tot % 2 == 0) {\n            int left = find(nums1, 0, nums2, 0, tot / 2);\n            int right = find(nums1, 0, nums2, 0, tot / 2 + 1);\n            return (left + right) / 2.0;\n        } else {\n            return find(nums1, 0, nums2, 0, tot / 2 + 1);\n        }\n    }\n\n    int find(vector<int>& nums1, int i, vector<int>& nums2, int j, int k) {\n        if (nums1.size() - i > nums2.size() - j) return find(nums2, j, nums1, i, k);\n        if (k == 1) {\n            if (nums1.size() == i) return nums2[j];\n            else return min(nums1[i], nums2[j]);\n        }\n        if (nums1.size() == i) return nums2[j + k - 1];\n        int si = min((int)nums1.size(), i + k / 2), sj = j + k - k / 2;\n        if (nums1[si - 1] > nums2[sj - 1])\n            return find(nums1, i, nums2, sj, k - (sj - j));\n        else\n            return find(nums1, si, nums2, j, k - (si - i));\n    }\n};\n",charsets:{cjk:!0},lastUpdated:"2023/11/19, 12:55:48",lastUpdatedTimestamp:1700369748e3},{title:"01八大排序",frontmatter:{title:"01八大排序",date:"2023-03-24T18:39:49.000Z",permalink:"/pages/3aa832/"},regularPath:"/03.LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/01.%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/03.%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/01.%E5%85%AB%E5%A4%A7%E6%8E%92%E5%BA%8F.html",relativePath:"03.LeetCode刷题笔记/01.基础算法/03.排序算法/01.八大排序.md",key:"v-3094c696",path:"/pages/3aa832/",headers:[{level:2,title:"01 八大排序",slug:"_01-八大排序",normalizedTitle:"01 八大排序",charIndex:2},{level:3,title:"冒泡排序",slug:"冒泡排序",normalizedTitle:"冒泡排序",charIndex:436},{level:3,title:"直接插入排序",slug:"直接插入排序",normalizedTitle:"直接插入排序",charIndex:398},{level:3,title:"简单选择排序",slug:"简单选择排序",normalizedTitle:"简单选择排序",charIndex:406},{level:3,title:"希尔排序",slug:"希尔排序",normalizedTitle:"希尔排序",charIndex:2120},{level:3,title:"快速排序",slug:"快速排序",normalizedTitle:"快速排序",charIndex:68},{level:3,title:"堆排序",slug:"堆排序",normalizedTitle:"堆排序",charIndex:289},{level:3,title:"归并排序",slug:"归并排序",normalizedTitle:"归并排序",charIndex:293},{level:3,title:"桶排序/基数排序",slug:"桶排序-基数排序",normalizedTitle:"桶排序/基数排序",charIndex:459},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:8202}],headersStr:"01 八大排序 冒泡排序 直接插入排序 简单选择排序 希尔排序 快速排序 堆排序 归并排序 桶排序/基数排序 参考资料",content:"# 01 八大排序\n\n虽然在刷题中我们可以使用高级编程语言提供封装好的排序算法便捷实现排序任务，例如 C++ 里可以通过 STL 中基于快速排序实现的 std::sort() 算法便捷实现排序任务。而且刷题时除非题目考点就是排序算法，否则也不建议自己手写排序算法。\n\n但是知识都是有着累积发展的过程，我们熟习各种基础的排序算法可以加深自己对算法的基本理解；同时我们也可以基于对基础排序算法的理解，快速解出由这些排序算法引申出来的题目。\n\n八大排序算法有着不同的实现思想，他们实现的时间复杂度也有所差异，根据不同的时间复杂度和算法稳定性他们有着不同的应用场景：\n\n * 快速排序、堆排序和归并排序具有较好的算法效率，其中快速排序性能最好但是算法不稳定，堆排序不需要额外的空间开销，而归并排序是稳定性较高的算法但是需要较大空间开销。\n\n * 在排序数据量较小的情况下，可以根据元素分布是否有序选择使用直接插入排序或者简单选择排序，他们也能够提供稳定且较高的算法性能。一般不使用冒泡排序，其性能相交于其他算法较差。\n\n * 桶排序/基数排序是一种稳定的算法且具有较好算法性能，但是该算法的使用存在一定局限性。\n   \n   分别根据算法平均时间复杂度和算法实现难度划分八大排序算法如下图\n\n开始详细介绍排序算法之前，我想向你强烈安利一个学习数据结构与算法的神奇网站VisuAlgo http://visualgo.net。这个网站里面有各种数据结构和算法的动画展示，在教师教授或者学生自行学习相关数据结构和算法时可以十分直观的呈现算法执行过程。\n\n**一个神奇的数据结构和算法学习网站：[VisuAlgo](http://visualgo.net)**\n\n\n\n# 冒泡排序\n\n算法思想：\n\n冒泡排序是一种简单的比较排序算法。在待排序的数组中，使用双层循环遍历数组，外循环保证遍历每个元素，内循环进行比较和交换。每一遍内循环过程中，对相邻的两个数依次进行比较和交换，让较大的数往下沉（向右移动），较小的往上冒（向左移动）。\n\n内循环不交换直接结束：如果内循环完全不交换，这意味着数组已经排序完成，我们可以在这个点上停止冒泡排序，这样可以提高算法效率。\n\n执行样例：\n\n输入：[29,10,14,37,14,25,10]\n\n算法实现：\n\nvoid bubbleSort(vector<int> &nums, int n){\n    for(int i=0;i<n;++i){\n        bool swapped = false;\n        for(int j=1;j<numsLen-i+1;++j){\n            if(nums[j]<nums[j-1]){\n                swap(nums[j],nums[j-1]);\n                swapped = true;\n            }\n        }\n        if(!swapped){\n            break;\n        }\n    }\n}\n\n\n\n# 直接插入排序\n\n算法思想：\n\n直接插入排序的主要思想就是将序列视为有序和无序两个部分，将无序部分中的元素插入到有序部分的适当位置保证仍然有序。\n\n可以采用双层循环实现插入排序，外层循环扩展有序区间大小，内层循环用于将待排序元素插入到有序部分。\n\n执行样例：\n\n输入：[29,10,14,37,14,25,10]\n\n算法实现：\n\nvoid insertionSort(vector<int> &nums, int n) {\n    for (int i = 0; i < n; ++i) {\n        for (int j = i; j > 0 && nums[j] < nums[j-1]; --j) {\n        \tswap(nums[j], nums[j-1]);\n        }\n    }\n}\n\n\n\n# 简单选择排序\n\n算法思想：\n\n简单选择排序的核心思想就是对号入座，第一步将待排序序列中最小的元素放在数组第一个位置，以此类推始终找无序部分中最小的元素放到有序部分的末尾。\n\n可以采用双层循环实现简单选择排序：外层循环遍历每一个待放入正确元素的位置；内层循环用于选择无序部分中最小的元素，并将该元素与外层循环位置元素交换。\n\n执行样例：\n\n输入：[29,10,14,37,14,25,10]\n\n算法实现：\n\nvoid selectSort(vector<int> &nums, int n){\n    for(int i=0;i<n-1;++i){\n        int min = i;\n        for(int j=i+1;j<n;++j){\n            if(nums[min]>nums[j]){\n                min = j;\n            }\n        }\n        swap(nums[i],nums[min]);\n    }\n}\n\n\n\n# 希尔排序\n\n算法思想：\n\n希尔排序是对直接插入排序的改进，又被称为缩小增量排序。该算法的核心思想是多轮分割，分别插入，将数组分割成若干个子集，然后在子集内分别使用直接插入排序；然后迭代缩小增量即分割的步长，并重复插入排序过程，直到最终数组排序完成。\n\n实现过程中，首先以步长为 gap = length/2 把数组分割成若干个子集，然后在每个子集中进行插入排序。完成一轮分割和排序后，迭代缩小分割步长并根据缩小的步长进行下一轮分割和插入排序。直到步长缩小为 gap = 1时，则数组排序完成。\n\n执行样例：\n\n输入：[29,10,14,37,14,25,10]\n\n步长                分割                       排序\ngap = 7 / 2 = 3   [29,10,14,37,14,25,10]   [10,10,14,29,14,25,37]\ngap = 3 / 2 = 1   [10,10,14,29,14,25,37]   [10,10,14,14,25,29,37]\n\n算法实现：\n\nvoid shellSort(vector<int> &nums){\n    int length = nums.size();\n    int tmp;\n    //步长\n    int gap = length / 2;\n    while (gap > 0) {\n        for (int i = gap; i < length; i++) {\n            tmp = nums[i];\n            int preIndex = i - gap;\n            while (preIndex >= 0 && nums[preIndex] > tmp) {\n                nums[preIndex + gap] = nums[preIndex];\n                preIndex -= gap;\n            }\n            nums[preIndex + gap] = tmp;\n        }\n        gap /= 2;\n    }\n}\n\n\n\n# 快速排序\n\n算法思想：\n\n快速排序是对冒泡排序的一种改进，其核心算法思想是：使用基准将要排序的数据分割成小于基准和大于基准的两部分；然后在被分割的两个部分中递归按基准划分的步骤，最终递归到一个部分仅有一个元素组成，此时数组排序完成。\n\n算法实现过程中，在使用快排之前可以将数组打乱，因为快排是不稳定的算法，在原数组大部分元素是有序的情况下效率提升不明显。\n\n实现快排步骤如下：\n\n\n * 先选取基准，可以以序列第一个元素作为基准\n * 然后使用碰撞指针遍历数组，从指向数组尾部的指针 tail 开始移动，将数组尾部小于基准的元素覆盖到指向数组头部的指针 head；接着移动 head 找到大于基准的元素覆盖到 tail；重复该过程直到一次遍历完成，将基准值放到指针相遇位置，将数组划分为小于基准和大于基准的两部分。\n * 在被分割的两部分中递归选择基准和划分序列的步骤，直到递归结束完成排序\n\n执行样例：\n\n输入：[29,10,37,14,25,10,14]\n\n为了友好展示快排的效果我们稍微调整了一下之前的例子。另外更值得注意的是，受限于VisuAlgo网站动态演示创建方式，动画中并不是使用双指针遍历序列，而是直接使用冒泡排序对划分的部分进行排序。\n\n算法实现：\n\nvoid quickSort(vector<int> &nums, int l, int r) {\n    if (l + 1 >= r) {\n    \treturn;\n    }\n    int head = l, tail = r - 1, key = nums[head];\n    while (head < tail){\n        while(head < tail && nums[tail] >= key) {\n        \t--tail;\n        }\n        nums[head] = nums[tail];\n        while (head < tail && nums[head] <= key) {\n        \t++head;\n        }\n        nums[tail] = nums[head];\n    }\n    nums[head] = key;\n    quick_sort(nums, l, head);\n    quick_sort(nums, head + 1, r);\n}\n\n\n\n# 堆排序\n\n算法思想：\n\n堆排序是对简单选择排序的改进，其核心思想是利用大根堆或者小根堆的树形结构，不断获取堆顶元素存入排序序列。大根堆是指一棵二叉树的每个节点值都大于或者等于它的左右子节点值，其根节点为最大值；小根堆反之。\n\n实现堆排序由两个关键任务：一是要构建大根堆或者小根堆；二是在取出堆顶之后，调整堆保持大根堆或者小根堆的树形结构。\n\n堆构建过程：堆构建有自上而下和自下而上两种方法，我们采用简单的自上而下构建\n\n * 根据数组顺序插入树节点\n\n * 如果插入节点值小于父节点，继续插入其他节点\n\n * 如果插入节点值大于父节点，那么需要将该节点不断上浮，直到找到合适的插入位置\n\n * 需要注意的是大根堆或者小根堆都是一棵完全二叉树，可以直接使用数组映射完全二叉树，不需要去另外构建树节点结构体；使用数组映射完全二叉树，索引从 0 开始具有如下性质：\n   \n   * 当前节点的父节点索引为 (i-1)/2\n   \n   * 当前节点的左节点索引为 2*i+1\n   \n   * 当前节点的左节点索引为 2*i+2 = 2*(i+1)\n     \n     堆调整过程：\n\n * 取出堆顶之后，用最后一个叶子节点与堆顶交换\n\n * 因为最后一个叶子节点是数组的最小元素，所以将它放到大根堆堆顶，就破坏大根堆堆的树形结构，需要调整堆\n\n * 选取根节点的左右节点中较大的节点与当前根节点交换\n\n * 交换后如果破坏了子树的堆结构，就需要按照上述调整步骤递归地调整堆结构\n\n执行样例：\n\n输入：[29,10,14,37,16,25,20]\n\n为了友好展示快排的效果我们稍微调整了一下之前的例子，删去了重复的元素\n\n 1. 大根堆构建过程\n\n 2. 堆排序过程\n\n算法实现：\n\n// 下沉调整大根堆，比较节点及其子节点，节点值大的子节点与父节点交换\nvoid sink(vector<int> &nums, int i,int heapSize){\n    if(heapSize==0 || nums.empty()) return;\n\n    // 找到当前节点、左节点、右节点中较大的一个节点索引\n    int bigger = i;\n    int leftChild = 2*i+1;\n    if(leftChild < heapSize){\n        bigger = nums[leftChild] > nums[i] ? leftChild:i;\n    }\n    int rightChild = 2*i+2;\n    if(rightChild < heapSize){\n        bigger = nums[rightChild] > nums[bigger] ? rightChild:bigger;\n    }\n\n    // 如果较大节点是左右节点中的一个，交换当前节点和较大节点\n    if(bigger!=i){\n        swap(nums[i],nums[bigger]);\n        sink(nums,bigger,heapSize); // 递归调整\n    }\n}\n\nvoid buildHeap(vector<int> &nums, int heapSize){\n    // 从最后一个非叶子节点开始构造\n    int i=(heapSize-1)/2;\n    for(i;i>=0;--i){\n        sink(nums,i,heapSize);\n    }\n}\n\n// 递归排序时，堆根节点先与最后一个节点进行交换，交换后，堆大小减1，并对根节点进行下沉调整\nvoid sort(vector<int> &nums, int &heapSize){\n\tswap(nums[0], nums[heapSize - 1]);\n\t--heapSize;\n\tsink(nums,0,heapSize);\n}\n\nvoid heapSort(vector<int> &nums){\n    int heapSize = nums.size();\n    buildHeap(nums,heapSize);\n    for(int i=0;i<nums.size()-1;++i){\n        sort(nums,heapSize);\n    }\n}\n\n\n\n# 归并排序\n\n算法思想：\n\n归并排序的核心思想是采用分治策略，将整个数组的排序任务分类为两个子问题，前一半排序和后一半排序，然后整合两个有序部分完成整体排序。即把数组分为若干个子序列，直到单个元素组成一个序列，然后将各阶段得到的序列组合在一起得到最终完整排序序列。\n\n归并排序任务可以如下分治完成：\n\n\n 1. 把前一半排序\n 2. 把后一半排序\n 3. 把两半归并到一个新的有序数组，然后再拷贝回原数组，排序完成。\n\n执行样例：\n\n输入：[29,10,14,37,14,25,10]\n\n算法实现：\n\n// 将数组 a 的局部 a[s,m] 和 a[m+1,e] 合并到 tmp, 并保证 tmp 有序，然后再拷贝回 a[s,m]\nvoid merge(vector<int>& arr, int start, int mid, int end, vector<int> tmp){\n    int pTmp = 0;\n    int pLeft = start; int pRight = mid+1;\n    while(pLeft<=mid&&pRight<=end){\n        if(arr[pLeft] < arr[pRight]){\n            tmp[pTmp++] = arr[pLeft++];\n        }else{\n            tmp[pTmp++] = arr[pRight++];\n        }\n    }\n    while(pLeft<=mid){\n        tmp[pTmp++] = arr[pLeft++];\n    }\n    while (pRight<=end)\n    {\n        tmp[pTmp++] = arr[pRight++];\n    }\n    for(int i=0;i<pTmp;i++){\n        arr[start+i] = tmp[i];\n    }\n}\n\n// 归并排序递归调用，先排前半部分，在排后半部分，最后将两部分结果合并\nvoid mergeSort(vector<int>& arr, int start, int end, vector<int> tmp){\n    if(start < end){\n        int mid = start + (end-start)/2;\n        mergeSort(arr,start,mid,tmp);\n        mergeSort(arr,mid+1,end,tmp);\n        merge(arr,start,mid,end,tmp);\n    }\n}\n\n\n\n# 桶排序/基数排序\n\n算法思想：\n\n通排序，顾名思义就是为一个值设立一个桶，在通内记录每个值的属性，然后对桶进行排序。例如 [25,10,14,14,14,25,10]，我们遍历一遍数组可以建立三个桶 [25,10,14]，并将相同值的元素放到同一个桶中形成 [[25,25],[10,10],[14,14,14]]；然后对三个桶进行排序 [10,14,25]，然后依次输出桶中的元素完成排序。\n\n基数排序就是进行多次桶排序，基数排序中根据进制位数字分配桶，然后根据桶的顺序收集，接着在高进制位继续迭代该过程直到最高进制位完成排序。当然，基数排序也可以根据其他属性用于其他类型的排序，核心思想都是先按低优先级分配收集排序，再按高优先级分配收集排序。\n\n执行样例：\n\n输入：[8,27,19,15,30,6,9]\n\n算法实现：\n\nvoid radixSort(vector<int> &nums){\n    // 计算最大位数\n    int maxOne = *max_element(nums.begin(),nums.end());\n    int bit = 1;\n    while(maxOne>=10){\n        maxOne /= 10;\n        ++bit;\n    }\n    // 创建十个桶\n    vector<queue<int>> buckets(10);\n    // 多次桶排序\n    for(int m=0;m<bit;++m){\n        // 分配 一次遍历将根据对应位的数值放到对应桶中\n        for(int i=0;i<nums.size();++i){\n            int tmp = nums[i];\n            for(int j=0;j<m;++j){\n                tmp/=10;\n            }\n            buckets[tmp%10].push(nums[i]);\n        }\n        // 情况原数组内容\n        nums.clear();\n        // 收集 根据桶的顺序收集桶中的元素\n        for(int i=0;i<10;++i){\n            while(!buckets[i].empty()){\n                nums.push_back(buckets[i].front());\n                buckets[i].pop();\n            }\n        }\n    }\n\n}\n\n\n\n# 参考资料\n\n算法总结：这是一份全面&详细的排序算法学习指南\n\n八大排序算法\n\nC++堆排序的实现（超详细）",normalizedContent:"# 01 八大排序\n\n虽然在刷题中我们可以使用高级编程语言提供封装好的排序算法便捷实现排序任务，例如 c++ 里可以通过 stl 中基于快速排序实现的 std::sort() 算法便捷实现排序任务。而且刷题时除非题目考点就是排序算法，否则也不建议自己手写排序算法。\n\n但是知识都是有着累积发展的过程，我们熟习各种基础的排序算法可以加深自己对算法的基本理解；同时我们也可以基于对基础排序算法的理解，快速解出由这些排序算法引申出来的题目。\n\n八大排序算法有着不同的实现思想，他们实现的时间复杂度也有所差异，根据不同的时间复杂度和算法稳定性他们有着不同的应用场景：\n\n * 快速排序、堆排序和归并排序具有较好的算法效率，其中快速排序性能最好但是算法不稳定，堆排序不需要额外的空间开销，而归并排序是稳定性较高的算法但是需要较大空间开销。\n\n * 在排序数据量较小的情况下，可以根据元素分布是否有序选择使用直接插入排序或者简单选择排序，他们也能够提供稳定且较高的算法性能。一般不使用冒泡排序，其性能相交于其他算法较差。\n\n * 桶排序/基数排序是一种稳定的算法且具有较好算法性能，但是该算法的使用存在一定局限性。\n   \n   分别根据算法平均时间复杂度和算法实现难度划分八大排序算法如下图\n\n开始详细介绍排序算法之前，我想向你强烈安利一个学习数据结构与算法的神奇网站visualgo http://visualgo.net。这个网站里面有各种数据结构和算法的动画展示，在教师教授或者学生自行学习相关数据结构和算法时可以十分直观的呈现算法执行过程。\n\n**一个神奇的数据结构和算法学习网站：[visualgo](http://visualgo.net)**\n\n\n\n# 冒泡排序\n\n算法思想：\n\n冒泡排序是一种简单的比较排序算法。在待排序的数组中，使用双层循环遍历数组，外循环保证遍历每个元素，内循环进行比较和交换。每一遍内循环过程中，对相邻的两个数依次进行比较和交换，让较大的数往下沉（向右移动），较小的往上冒（向左移动）。\n\n内循环不交换直接结束：如果内循环完全不交换，这意味着数组已经排序完成，我们可以在这个点上停止冒泡排序，这样可以提高算法效率。\n\n执行样例：\n\n输入：[29,10,14,37,14,25,10]\n\n算法实现：\n\nvoid bubblesort(vector<int> &nums, int n){\n    for(int i=0;i<n;++i){\n        bool swapped = false;\n        for(int j=1;j<numslen-i+1;++j){\n            if(nums[j]<nums[j-1]){\n                swap(nums[j],nums[j-1]);\n                swapped = true;\n            }\n        }\n        if(!swapped){\n            break;\n        }\n    }\n}\n\n\n\n# 直接插入排序\n\n算法思想：\n\n直接插入排序的主要思想就是将序列视为有序和无序两个部分，将无序部分中的元素插入到有序部分的适当位置保证仍然有序。\n\n可以采用双层循环实现插入排序，外层循环扩展有序区间大小，内层循环用于将待排序元素插入到有序部分。\n\n执行样例：\n\n输入：[29,10,14,37,14,25,10]\n\n算法实现：\n\nvoid insertionsort(vector<int> &nums, int n) {\n    for (int i = 0; i < n; ++i) {\n        for (int j = i; j > 0 && nums[j] < nums[j-1]; --j) {\n        \tswap(nums[j], nums[j-1]);\n        }\n    }\n}\n\n\n\n# 简单选择排序\n\n算法思想：\n\n简单选择排序的核心思想就是对号入座，第一步将待排序序列中最小的元素放在数组第一个位置，以此类推始终找无序部分中最小的元素放到有序部分的末尾。\n\n可以采用双层循环实现简单选择排序：外层循环遍历每一个待放入正确元素的位置；内层循环用于选择无序部分中最小的元素，并将该元素与外层循环位置元素交换。\n\n执行样例：\n\n输入：[29,10,14,37,14,25,10]\n\n算法实现：\n\nvoid selectsort(vector<int> &nums, int n){\n    for(int i=0;i<n-1;++i){\n        int min = i;\n        for(int j=i+1;j<n;++j){\n            if(nums[min]>nums[j]){\n                min = j;\n            }\n        }\n        swap(nums[i],nums[min]);\n    }\n}\n\n\n\n# 希尔排序\n\n算法思想：\n\n希尔排序是对直接插入排序的改进，又被称为缩小增量排序。该算法的核心思想是多轮分割，分别插入，将数组分割成若干个子集，然后在子集内分别使用直接插入排序；然后迭代缩小增量即分割的步长，并重复插入排序过程，直到最终数组排序完成。\n\n实现过程中，首先以步长为 gap = length/2 把数组分割成若干个子集，然后在每个子集中进行插入排序。完成一轮分割和排序后，迭代缩小分割步长并根据缩小的步长进行下一轮分割和插入排序。直到步长缩小为 gap = 1时，则数组排序完成。\n\n执行样例：\n\n输入：[29,10,14,37,14,25,10]\n\n步长                分割                       排序\ngap = 7 / 2 = 3   [29,10,14,37,14,25,10]   [10,10,14,29,14,25,37]\ngap = 3 / 2 = 1   [10,10,14,29,14,25,37]   [10,10,14,14,25,29,37]\n\n算法实现：\n\nvoid shellsort(vector<int> &nums){\n    int length = nums.size();\n    int tmp;\n    //步长\n    int gap = length / 2;\n    while (gap > 0) {\n        for (int i = gap; i < length; i++) {\n            tmp = nums[i];\n            int preindex = i - gap;\n            while (preindex >= 0 && nums[preindex] > tmp) {\n                nums[preindex + gap] = nums[preindex];\n                preindex -= gap;\n            }\n            nums[preindex + gap] = tmp;\n        }\n        gap /= 2;\n    }\n}\n\n\n\n# 快速排序\n\n算法思想：\n\n快速排序是对冒泡排序的一种改进，其核心算法思想是：使用基准将要排序的数据分割成小于基准和大于基准的两部分；然后在被分割的两个部分中递归按基准划分的步骤，最终递归到一个部分仅有一个元素组成，此时数组排序完成。\n\n算法实现过程中，在使用快排之前可以将数组打乱，因为快排是不稳定的算法，在原数组大部分元素是有序的情况下效率提升不明显。\n\n实现快排步骤如下：\n\n\n * 先选取基准，可以以序列第一个元素作为基准\n * 然后使用碰撞指针遍历数组，从指向数组尾部的指针 tail 开始移动，将数组尾部小于基准的元素覆盖到指向数组头部的指针 head；接着移动 head 找到大于基准的元素覆盖到 tail；重复该过程直到一次遍历完成，将基准值放到指针相遇位置，将数组划分为小于基准和大于基准的两部分。\n * 在被分割的两部分中递归选择基准和划分序列的步骤，直到递归结束完成排序\n\n执行样例：\n\n输入：[29,10,37,14,25,10,14]\n\n为了友好展示快排的效果我们稍微调整了一下之前的例子。另外更值得注意的是，受限于visualgo网站动态演示创建方式，动画中并不是使用双指针遍历序列，而是直接使用冒泡排序对划分的部分进行排序。\n\n算法实现：\n\nvoid quicksort(vector<int> &nums, int l, int r) {\n    if (l + 1 >= r) {\n    \treturn;\n    }\n    int head = l, tail = r - 1, key = nums[head];\n    while (head < tail){\n        while(head < tail && nums[tail] >= key) {\n        \t--tail;\n        }\n        nums[head] = nums[tail];\n        while (head < tail && nums[head] <= key) {\n        \t++head;\n        }\n        nums[tail] = nums[head];\n    }\n    nums[head] = key;\n    quick_sort(nums, l, head);\n    quick_sort(nums, head + 1, r);\n}\n\n\n\n# 堆排序\n\n算法思想：\n\n堆排序是对简单选择排序的改进，其核心思想是利用大根堆或者小根堆的树形结构，不断获取堆顶元素存入排序序列。大根堆是指一棵二叉树的每个节点值都大于或者等于它的左右子节点值，其根节点为最大值；小根堆反之。\n\n实现堆排序由两个关键任务：一是要构建大根堆或者小根堆；二是在取出堆顶之后，调整堆保持大根堆或者小根堆的树形结构。\n\n堆构建过程：堆构建有自上而下和自下而上两种方法，我们采用简单的自上而下构建\n\n * 根据数组顺序插入树节点\n\n * 如果插入节点值小于父节点，继续插入其他节点\n\n * 如果插入节点值大于父节点，那么需要将该节点不断上浮，直到找到合适的插入位置\n\n * 需要注意的是大根堆或者小根堆都是一棵完全二叉树，可以直接使用数组映射完全二叉树，不需要去另外构建树节点结构体；使用数组映射完全二叉树，索引从 0 开始具有如下性质：\n   \n   * 当前节点的父节点索引为 (i-1)/2\n   \n   * 当前节点的左节点索引为 2*i+1\n   \n   * 当前节点的左节点索引为 2*i+2 = 2*(i+1)\n     \n     堆调整过程：\n\n * 取出堆顶之后，用最后一个叶子节点与堆顶交换\n\n * 因为最后一个叶子节点是数组的最小元素，所以将它放到大根堆堆顶，就破坏大根堆堆的树形结构，需要调整堆\n\n * 选取根节点的左右节点中较大的节点与当前根节点交换\n\n * 交换后如果破坏了子树的堆结构，就需要按照上述调整步骤递归地调整堆结构\n\n执行样例：\n\n输入：[29,10,14,37,16,25,20]\n\n为了友好展示快排的效果我们稍微调整了一下之前的例子，删去了重复的元素\n\n 1. 大根堆构建过程\n\n 2. 堆排序过程\n\n算法实现：\n\n// 下沉调整大根堆，比较节点及其子节点，节点值大的子节点与父节点交换\nvoid sink(vector<int> &nums, int i,int heapsize){\n    if(heapsize==0 || nums.empty()) return;\n\n    // 找到当前节点、左节点、右节点中较大的一个节点索引\n    int bigger = i;\n    int leftchild = 2*i+1;\n    if(leftchild < heapsize){\n        bigger = nums[leftchild] > nums[i] ? leftchild:i;\n    }\n    int rightchild = 2*i+2;\n    if(rightchild < heapsize){\n        bigger = nums[rightchild] > nums[bigger] ? rightchild:bigger;\n    }\n\n    // 如果较大节点是左右节点中的一个，交换当前节点和较大节点\n    if(bigger!=i){\n        swap(nums[i],nums[bigger]);\n        sink(nums,bigger,heapsize); // 递归调整\n    }\n}\n\nvoid buildheap(vector<int> &nums, int heapsize){\n    // 从最后一个非叶子节点开始构造\n    int i=(heapsize-1)/2;\n    for(i;i>=0;--i){\n        sink(nums,i,heapsize);\n    }\n}\n\n// 递归排序时，堆根节点先与最后一个节点进行交换，交换后，堆大小减1，并对根节点进行下沉调整\nvoid sort(vector<int> &nums, int &heapsize){\n\tswap(nums[0], nums[heapsize - 1]);\n\t--heapsize;\n\tsink(nums,0,heapsize);\n}\n\nvoid heapsort(vector<int> &nums){\n    int heapsize = nums.size();\n    buildheap(nums,heapsize);\n    for(int i=0;i<nums.size()-1;++i){\n        sort(nums,heapsize);\n    }\n}\n\n\n\n# 归并排序\n\n算法思想：\n\n归并排序的核心思想是采用分治策略，将整个数组的排序任务分类为两个子问题，前一半排序和后一半排序，然后整合两个有序部分完成整体排序。即把数组分为若干个子序列，直到单个元素组成一个序列，然后将各阶段得到的序列组合在一起得到最终完整排序序列。\n\n归并排序任务可以如下分治完成：\n\n\n 1. 把前一半排序\n 2. 把后一半排序\n 3. 把两半归并到一个新的有序数组，然后再拷贝回原数组，排序完成。\n\n执行样例：\n\n输入：[29,10,14,37,14,25,10]\n\n算法实现：\n\n// 将数组 a 的局部 a[s,m] 和 a[m+1,e] 合并到 tmp, 并保证 tmp 有序，然后再拷贝回 a[s,m]\nvoid merge(vector<int>& arr, int start, int mid, int end, vector<int> tmp){\n    int ptmp = 0;\n    int pleft = start; int pright = mid+1;\n    while(pleft<=mid&&pright<=end){\n        if(arr[pleft] < arr[pright]){\n            tmp[ptmp++] = arr[pleft++];\n        }else{\n            tmp[ptmp++] = arr[pright++];\n        }\n    }\n    while(pleft<=mid){\n        tmp[ptmp++] = arr[pleft++];\n    }\n    while (pright<=end)\n    {\n        tmp[ptmp++] = arr[pright++];\n    }\n    for(int i=0;i<ptmp;i++){\n        arr[start+i] = tmp[i];\n    }\n}\n\n// 归并排序递归调用，先排前半部分，在排后半部分，最后将两部分结果合并\nvoid mergesort(vector<int>& arr, int start, int end, vector<int> tmp){\n    if(start < end){\n        int mid = start + (end-start)/2;\n        mergesort(arr,start,mid,tmp);\n        mergesort(arr,mid+1,end,tmp);\n        merge(arr,start,mid,end,tmp);\n    }\n}\n\n\n\n# 桶排序/基数排序\n\n算法思想：\n\n通排序，顾名思义就是为一个值设立一个桶，在通内记录每个值的属性，然后对桶进行排序。例如 [25,10,14,14,14,25,10]，我们遍历一遍数组可以建立三个桶 [25,10,14]，并将相同值的元素放到同一个桶中形成 [[25,25],[10,10],[14,14,14]]；然后对三个桶进行排序 [10,14,25]，然后依次输出桶中的元素完成排序。\n\n基数排序就是进行多次桶排序，基数排序中根据进制位数字分配桶，然后根据桶的顺序收集，接着在高进制位继续迭代该过程直到最高进制位完成排序。当然，基数排序也可以根据其他属性用于其他类型的排序，核心思想都是先按低优先级分配收集排序，再按高优先级分配收集排序。\n\n执行样例：\n\n输入：[8,27,19,15,30,6,9]\n\n算法实现：\n\nvoid radixsort(vector<int> &nums){\n    // 计算最大位数\n    int maxone = *max_element(nums.begin(),nums.end());\n    int bit = 1;\n    while(maxone>=10){\n        maxone /= 10;\n        ++bit;\n    }\n    // 创建十个桶\n    vector<queue<int>> buckets(10);\n    // 多次桶排序\n    for(int m=0;m<bit;++m){\n        // 分配 一次遍历将根据对应位的数值放到对应桶中\n        for(int i=0;i<nums.size();++i){\n            int tmp = nums[i];\n            for(int j=0;j<m;++j){\n                tmp/=10;\n            }\n            buckets[tmp%10].push(nums[i]);\n        }\n        // 情况原数组内容\n        nums.clear();\n        // 收集 根据桶的顺序收集桶中的元素\n        for(int i=0;i<10;++i){\n            while(!buckets[i].empty()){\n                nums.push_back(buckets[i].front());\n                buckets[i].pop();\n            }\n        }\n    }\n\n}\n\n\n\n# 参考资料\n\n算法总结：这是一份全面&详细的排序算法学习指南\n\n八大排序算法\n\nc++堆排序的实现（超详细）",charsets:{cjk:!0},lastUpdated:"2023/11/19, 12:55:48",lastUpdatedTimestamp:1700369748e3},{title:"02快速排序",frontmatter:{title:"02快速排序",date:"2023-03-24T18:39:49.000Z",permalink:"/pages/8c54f6/"},regularPath:"/03.LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/01.%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/03.%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/02.%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.html",relativePath:"03.LeetCode刷题笔记/01.基础算法/03.排序算法/02.快速排序.md",key:"v-a241b3e0",path:"/pages/8c54f6/",headers:[{level:2,title:"02 快速排序",slug:"_02-快速排序",normalizedTitle:"02 快速排序",charIndex:2},{level:3,title:"快速排序简介",slug:"快速排序简介",normalizedTitle:"快速排序简介",charIndex:14},{level:4,title:"215 数组中的第K个最大元素",slug:"_215-数组中的第k个最大元素",normalizedTitle:"215 数组中的第k个最大元素",charIndex:1386}],headersStr:"02 快速排序 快速排序简介 215 数组中的第K个最大元素",content:"# 02 快速排序\n\n\n# 快速排序简介\n\n算法思想：\n\n快速排序是对冒泡排序的一种改进，其核心算法思想是：使用基准将要排序的数据分割成小于基准和大于基准的两部分；然后在被分割的两个部分中递归按基准划分的步骤，最终递归到一个部分仅有一个元素组成，此时数组排序完成。\n\n算法实现过程中，在使用快排之前可以将数组打乱，因为快排是不稳定的算法，在原数组大部分元素是有序的情况下效率提升不明显。\n\n实现快排步骤如下：\n\n\n * 先选取基准，可以以序列第一个元素作为基准\n * 然后使用碰撞指针遍历数组，从指向数组尾部的指针 tail 开始移动，将数组尾部小于基准的元素覆盖到指向数组头部的指针 head；接着移动 head 找到大于基准的元素覆盖到 tail；重复该过程直到一次遍历完成，将基准值放到指针相遇位置，将数组划分为小于基准和大于基准的两部分。\n * 在被分割的两部分中递归选择基准和划分序列的步骤，直到递归结束完成排序\n\n执行样例：\n\n输入：[6,1,2,7,9,3,4,5,10,8]\n\n算法实现：\n\n// 碰撞指针实现\nvoid quickSort(vector<int> &nums, int l, int r) {\n    if (l + 1 >= r) {\n    \treturn;\n    }\n    int head = l, tail = r - 1, key = nums[head];\n    while (head < tail){\n        while(head < tail && nums[tail] >= key) {\n        \t--tail;\n        }\n        nums[head] = nums[tail];\n        while (head < tail && nums[head] <= key) {\n        \t++head;\n        }\n        nums[tail] = nums[head];\n    }\n    nums[head] = key;\n    quick_sort(nums, l, head);\n    quick_sort(nums, head + 1, r);\n}\n\n// 快慢指针实现\nvoid quickSort(vector<int> &nums, int l, int r) {\n    if (l + 1 >= r) {\n        return;\n    }\n      \n    int cur = l;\n    int pre = cur - 1;\n    int key = nums[r-1];\n      \n    while (cur < r) {\n        while (nums[cur] < key && ++pre != cur) {\n            swap(nums[cur], nums[pre]);\n        }\n        cur++;\n    }   \n    swap(nums[++pre], nums[r-1]);\n      \n    quickSort(nums, l, pre);\n    quickSort(nums, pre + 1, r);\n}\n\n\n# 215 数组中的第K个最大元素\n\n给定整数数组 nums 和整数 k，请返回数组中第 k 个最大的元素。\n\n输入一个数组和一个目标值 k，输出一个整数表示第 k 大的数字。题目默认一定有解。\n\n> 输入: [3,2,3,1,2,4,5,5,6] 和 k = 4\n> 输出: 4\n\n解析：\n\n一种简单的思路就是将整个数组排完序，然后输出第 k 个最大元素。\n\n我们可以使用快速排序的思想，减少程序的时间复杂度。根据快速排序核心思想衍生出的**快速选择一般用于求解 k-th Element 问题**，可以在 O(n) 时间复杂度，O(1) 空间复杂度完成求解工作。\n\n快速选择的实现和快速排序相似，不过只需要找到第 k 大的枢（pivot）即可，不需要对其左右再进行排序，即在快速排序的基础上增加递归跳出条件，在找到第 k 大的枢时直接终止递归即可，减少时间复杂度。与快速排序一样，快速选择一般需要先打乱数组，否则最坏情况下时间复杂度为 O(n^2)。\n\n\nclass Solution {\npublic:\n    int partation(vector<int>& nums, int k, int start, int end){\n        if(start>=end) return -1;\n        // 随机化处理\n        int idx = start + rand() % (end - start); \n        swap(nums[start], nums[idx]);\n        // 一遍遍历与交换\n        int head = start, tail = end-1;\n        int key = nums[head];\n        while(head < tail){\n            while(head<tail && nums[tail]>=key){\n                --tail;\n            }\n            nums[head] = nums[tail];\n            while(head<tail && nums[head]<=key){\n                ++head;\n            }\n            nums[tail] = nums[head];\n        }\n        nums[head] = key;\n        // 计算当前枢是否为第 k 大的枢\n        int a = end - tail;\n        // 是第 k 大的枢直接返回\n        if(a==k){\n            return nums[head];\n        }else if(a > k){\n            // 在当前枢右侧，递归快速选择\n            partation(nums,k,tail+1,end);\n        }else{\n            // 在当前枢左侧，递归快速选择\n            partation(nums,k-a,start,tail);\n        }\n        return nums[nums.size()-k];\n    }\n\n    int findKthLargest(vector<int>& nums, int k) {\n        return partation(nums,k,0,nums.size());\n    }\n};\n",normalizedContent:"# 02 快速排序\n\n\n# 快速排序简介\n\n算法思想：\n\n快速排序是对冒泡排序的一种改进，其核心算法思想是：使用基准将要排序的数据分割成小于基准和大于基准的两部分；然后在被分割的两个部分中递归按基准划分的步骤，最终递归到一个部分仅有一个元素组成，此时数组排序完成。\n\n算法实现过程中，在使用快排之前可以将数组打乱，因为快排是不稳定的算法，在原数组大部分元素是有序的情况下效率提升不明显。\n\n实现快排步骤如下：\n\n\n * 先选取基准，可以以序列第一个元素作为基准\n * 然后使用碰撞指针遍历数组，从指向数组尾部的指针 tail 开始移动，将数组尾部小于基准的元素覆盖到指向数组头部的指针 head；接着移动 head 找到大于基准的元素覆盖到 tail；重复该过程直到一次遍历完成，将基准值放到指针相遇位置，将数组划分为小于基准和大于基准的两部分。\n * 在被分割的两部分中递归选择基准和划分序列的步骤，直到递归结束完成排序\n\n执行样例：\n\n输入：[6,1,2,7,9,3,4,5,10,8]\n\n算法实现：\n\n// 碰撞指针实现\nvoid quicksort(vector<int> &nums, int l, int r) {\n    if (l + 1 >= r) {\n    \treturn;\n    }\n    int head = l, tail = r - 1, key = nums[head];\n    while (head < tail){\n        while(head < tail && nums[tail] >= key) {\n        \t--tail;\n        }\n        nums[head] = nums[tail];\n        while (head < tail && nums[head] <= key) {\n        \t++head;\n        }\n        nums[tail] = nums[head];\n    }\n    nums[head] = key;\n    quick_sort(nums, l, head);\n    quick_sort(nums, head + 1, r);\n}\n\n// 快慢指针实现\nvoid quicksort(vector<int> &nums, int l, int r) {\n    if (l + 1 >= r) {\n        return;\n    }\n      \n    int cur = l;\n    int pre = cur - 1;\n    int key = nums[r-1];\n      \n    while (cur < r) {\n        while (nums[cur] < key && ++pre != cur) {\n            swap(nums[cur], nums[pre]);\n        }\n        cur++;\n    }   \n    swap(nums[++pre], nums[r-1]);\n      \n    quicksort(nums, l, pre);\n    quicksort(nums, pre + 1, r);\n}\n\n\n# 215 数组中的第k个最大元素\n\n给定整数数组 nums 和整数 k，请返回数组中第 k 个最大的元素。\n\n输入一个数组和一个目标值 k，输出一个整数表示第 k 大的数字。题目默认一定有解。\n\n> 输入: [3,2,3,1,2,4,5,5,6] 和 k = 4\n> 输出: 4\n\n解析：\n\n一种简单的思路就是将整个数组排完序，然后输出第 k 个最大元素。\n\n我们可以使用快速排序的思想，减少程序的时间复杂度。根据快速排序核心思想衍生出的**快速选择一般用于求解 k-th element 问题**，可以在 o(n) 时间复杂度，o(1) 空间复杂度完成求解工作。\n\n快速选择的实现和快速排序相似，不过只需要找到第 k 大的枢（pivot）即可，不需要对其左右再进行排序，即在快速排序的基础上增加递归跳出条件，在找到第 k 大的枢时直接终止递归即可，减少时间复杂度。与快速排序一样，快速选择一般需要先打乱数组，否则最坏情况下时间复杂度为 o(n^2)。\n\n\nclass solution {\npublic:\n    int partation(vector<int>& nums, int k, int start, int end){\n        if(start>=end) return -1;\n        // 随机化处理\n        int idx = start + rand() % (end - start); \n        swap(nums[start], nums[idx]);\n        // 一遍遍历与交换\n        int head = start, tail = end-1;\n        int key = nums[head];\n        while(head < tail){\n            while(head<tail && nums[tail]>=key){\n                --tail;\n            }\n            nums[head] = nums[tail];\n            while(head<tail && nums[head]<=key){\n                ++head;\n            }\n            nums[tail] = nums[head];\n        }\n        nums[head] = key;\n        // 计算当前枢是否为第 k 大的枢\n        int a = end - tail;\n        // 是第 k 大的枢直接返回\n        if(a==k){\n            return nums[head];\n        }else if(a > k){\n            // 在当前枢右侧，递归快速选择\n            partation(nums,k,tail+1,end);\n        }else{\n            // 在当前枢左侧，递归快速选择\n            partation(nums,k-a,start,tail);\n        }\n        return nums[nums.size()-k];\n    }\n\n    int findkthlargest(vector<int>& nums, int k) {\n        return partation(nums,k,0,nums.size());\n    }\n};\n",charsets:{cjk:!0},lastUpdated:"2023/11/19, 12:55:48",lastUpdatedTimestamp:1700369748e3},{title:"02网格结构深度优先搜索",frontmatter:{title:"02网格结构深度优先搜索",date:"2023-03-24T18:39:49.000Z",permalink:"/pages/88ecc3/"},regularPath:"/03.LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/01.%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/04.%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/02.%E7%BD%91%E6%A0%BC%E7%BB%93%E6%9E%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2.html",relativePath:"03.LeetCode刷题笔记/01.基础算法/04.优先搜索/02.网格结构深度优先搜索.md",key:"v-00efbfe0",path:"/pages/88ecc3/",headers:[{level:2,title:"01 二维数组深度优先搜索",slug:"_01-二维数组深度优先搜索",normalizedTitle:"01 二维数组深度优先搜索",charIndex:2},{level:3,title:"深度优先搜索简介",slug:"深度优先搜索简介",normalizedTitle:"深度优先搜索简介",charIndex:20},{level:4,title:"695 岛屿的最大面积",slug:"_695-岛屿的最大面积",normalizedTitle:"695 岛屿的最大面积",charIndex:814},{level:4,title:"200 岛屿数量",slug:"_200-岛屿数量",normalizedTitle:"200 岛屿数量",charIndex:2497},{level:4,title:"463 岛屿的周长",slug:"_463-岛屿的周长",normalizedTitle:"463 岛屿的周长",charIndex:3818},{level:4,title:"417 太平洋大西洋水流问题",slug:"_417-太平洋大西洋水流问题",normalizedTitle:"417 太平洋大西洋水流问题",charIndex:5377},{level:4,title:"130 被围绕的区域",slug:"_130-被围绕的区域",normalizedTitle:"130 被围绕的区域",charIndex:7666}],headersStr:"01 二维数组深度优先搜索 深度优先搜索简介 695 岛屿的最大面积 200 岛屿数量 463 岛屿的周长 417 太平洋大西洋水流问题 130 被围绕的区域",content:'# 01 二维数组深度优先搜索\n\n\n# 深度优先搜索简介\n\n深度优先搜索（depth-first seach，DFS）在搜索到一个新的节点时，立即对该新节点进行遍历；因此遍历需要用先入后出的栈来实现，也可以通过与栈等价的递归来实现。\n\n二维数组深度优先搜索的一般写法：\n\n一般来说，深度优先搜索类型的题可以分为主函数和辅函数，主函数用于遍历所有的搜索位置，判断是否满足开始搜索的条件，如果可以即在辅函数中进行搜索。\n\n辅函数负责实现深度优先搜索过程。这一过程可以使用递归调用调用实现；当然，我们也可以使用栈（stack）实现深度优先搜索，与使用队列 （queue）实现广度优先搜索类比。但因为栈与递归的调用原理相同，而递归相对便于实现，因此刷题时推荐使用递归式写法，可以将深度优先搜索与回溯算法进行类比。不过在实际工程上，直接使用栈可能才是最好的选择，一是因为便于理解，二是更不易出现递归栈满的情况。\n\n在辅函数里，一个一定要注意的点是辅函数内递归搜索时，对矩阵边界条件的判定。边界判定一般有两种写法：一种是先判定是否越界，只有在合法的情况下才进行下一步搜索（即判断放在调用递归函数前）；另一种是不管三七二十一先进行下一步搜索，待下一步搜索开始时再判断是否合法（即判断放在辅函数第一行）。两种方法任选一种符合自身代码习惯的写法即可。\n\n二维数组四向遍历小技巧：对于四个方向的遍历，可以创造一个数组 direction = [-1, 0, 1, 0, -1]，每相邻两位即为上下左右四个方向之一，即：\n\n * 左移 x+=direction[0]; y+=direction[1]；\n * 上移 x+=direction[1]; y+=direction[2]；\n * 右移 x+=direction[2]; y+=direction[3]；\n * 下移 x+=direction[3]; y+=direction[4]；\n\n# 695 岛屿的最大面积\n\n给定一个大小为 m x n 的二维 0-1 矩阵 grid ，其中 0 表示海洋，1 表示陆地。单独的或相邻的陆地可以形成岛 屿，每个格子只与其上下左右四个格子相邻。求最大的岛屿面积。\n\n输入一个二维数组，输出是一个整数，表示最大的岛屿面积。\n\n输入：grid = [[0,0,1,0,0,0,0,1,0,0,0,0,0],\n[0,0,0,0,0,0,0,1,1,1,0,0,0],\n[0,1,1,0,1,0,0,0,0,0,0,0,0],\n[0,1,0,0,1,1,0,0,1,0,1,0,0],\n[0,1,0,0,1,1,0,0,1,1,1,0,0],\n[0,0,0,0,0,0,0,0,0,0,1,0,0],\n[0,0,0,0,0,0,0,1,1,1,0,0,0],\n[0,0,0,0,0,0,0,1,1,0,0,0,0]]\n输出：6\n解释：答案不应该是 11 ，因为岛屿只能包含水平或垂直这四个方向上的 1 。\n\n\n解析：\n\n本题是十分标准的搜索题，我们编写主函数和辅函数，主函数用于遍历所有的搜索位置，判断是否满足开始搜索的条件，如果可以即在辅函数中进行搜索。\n\n主函数寻找符合启动辅助函数进行搜索的位置，并记录辅助函数计算的岛屿最大值。我们可以使用双重循环实现，双重循环遍历矩阵的每一个位置，当发现岛屿即位置值为1时，开始用辅助函数搜索。\n\n辅函数中从开始搜索的位置向相邻四个方向递归搜索值为1的位置，并累计岛屿面积。搜索过程中我们对边界条件的判定采用先判断再搜索的方式，即先判断搜索节点是否越界，再决定是否继续进行深度递归搜索。遍历值为1的节点之后注意要将其值置为0，避免重复遍历无限递归。\n\nclass Solution {\n    // 四个方向的遍历\n    vector<int> direction = {-1,0,1,0,-1};\npublic:\n    int dfs(vector<vector<int>>& grid, int i, int j){\n        if(grid[i][j] == 0) return 0;\n        // 遍历后值置为 0\n        grid[i][j] = 0;\n        // 四向深度优先搜索\n        int x, y, area = 1;\n        for(int s=0;s<4;++s){\n            x = i+direction[s];\n            y = j+direction[s+1];\n            if(x>=0 && x<grid.size() && y>=0 && y<grid[0].size()){\n                area += dfs(grid,x,y);\n            }\n        }\n        return area;\n    }\n\n    int maxAreaOfIsland(vector<vector<int>>& grid) {\n        if(grid.empty() || grid[0].empty()){\n            return 0;\n        }\n        int maxArea = 0;\n        // 寻找符合启动辅助函数进行搜索的位置\n        for(int i=0;i<grid.size();++i){\n            for(int j=0;j<grid[0].size();++j){\n                if(grid[i][j] == 1){\n                    maxArea = max(maxArea,dfs(grid,i,j));\n                }\n            }\n        }\n        return maxArea;\n    }\n};\n\n\n# 200 岛屿数量\n\n给定一个大小为 m x n 的二维 0-1 矩阵 grid ，其中 0 表示海洋，1 表示陆地。单独的或相邻的陆地可以形成岛 屿，每个格子只与其上下左右四个格子相邻。求二维数组中一共有多少个岛屿。\n\n输入一个二维数组，输出是一个整数，表示岛屿数量。\n\n输入：grid = [\n  ["1","1","0","0","0"],\n  ["1","1","0","0","0"],\n  ["0","0","1","0","0"],\n  ["0","0","0","1","1"]\n]\n输出：3\n\n\n解析：\n\n本题与695 岛屿的最大面积题十分相似，我们同样编写主函数和辅函数：\n\n主函数寻找符合启动辅助函数进行搜索的位置，每找到这样一个位置就相当与找到一个岛屿 。使用双重循环遍历矩阵的每一个位置，当发现岛屿即位置值为1时，开始用辅助函数搜索。\n\n辅函数中从开始搜索的位置向相邻四个方向递归搜索，将属于同一岛屿的网格从\'1\' 置为\'0\'，避免重复计算岛屿数量。同样搜索过程中我们需要对边界条件进行判定，仍采用先判断是否越界，再进行递归搜索的方式。\n\nclass Solution {\n    vector<int> direction={-1,0,1,0,-1};\npublic:\n    void dfs(vector<vector<char>>& grid, int i, int j){\n        if(grid[i][j] == \'0\') return;\n        grid[i][j] = \'0\';\n        int x, y;\n        for(int s=0;s<4;++s){\n            x = i+direction[s];\n            y = j+direction[s+1];\n            if(x>=0 && x<grid.size() && y>=0 && y<grid[0].size()){\n                dfs(grid,x,y);\n            }\n        }\n    }\n\n    int numIslands(vector<vector<char>>& grid) {\n        if(grid.empty() || grid[0].empty()){\n            return 0;\n        }\n        int ans = 0;\n        for(int i=0;i<grid.size();++i){\n            for(int j=0;j<grid[0].size();++j){\n                if(grid[i][j] == \'1\'){\n                    dfs(grid,i,j);\n                    ++ans;\n                }\n            }\n        }\n        return ans;\n    }\n};\n\n\n# 463 岛屿的周长\n\n给定一个大小为 m x n 的二维 0-1 矩阵 grid ，其中 0 表示海洋，1 表示陆地。单独的或相邻的陆地可以形成岛 屿，每个格子只与其上下左右四个格子相邻。求二维数组中一个或多个岛屿的周长。\n\n输入一个二维数组，输出是一个整数，表示岛屿的周长。\n\n\n\n输入：grid = [[0,1,0,0],[1,1,1,0],[0,1,0,0],[1,1,0,0]]\n输出：16\n解释：它的周长是上面图片中的 16 个黄色的边\n\n\n解析：\n\n本题与695 岛屿的最大面积题十分相似，我们同样编写主函数和辅函数：\n\n主函数寻找符合启动辅助函数进行搜索的位置，并记录辅助函数计算的每个岛屿的周长 。使用双重循环遍历矩阵的每一个位置，当发现岛屿即位置值为1时，开始用辅助函数搜索。\n\n辅函数中从开始搜索的位置向相邻四个方向递归搜索。对于一个值为1的位置的每条边，它被算作岛屿的周长当且仅当这条边为网格的边界或者相邻的另一个格子为水域。 因此，我们可以遍历每个陆地格子，看其四个方向是否为边界或者水域：如果是，则将这条边作为岛屿的周长的一段加入中结果；如果不是，则不加入周长并继续递归搜索。\n\n搜索过程中我们对边界条件的判定采用先判断再搜索的方式，即先判断搜索节点是否越界，再决定是否继续进行深度递归搜索。遍历值为1的节点之后注意要将其值置为2，避免重复遍历无限递归和错误地周长计算。\n\nclass Solution {\n    vector<int> direction={-1,0,1,0,-1};\npublic:\n    int dfs(vector<vector<int>>& grid, int i, int j){\n        if(grid[i][j]==0) return 1;\n        if(grid[i][j]==2) return 0;\n        grid[i][j] = 2;\n        int x, y, perimeter = 0;\n        for(int s=0;s<4;++s){\n            int x = i+direction[s];\n            int y = j+direction[s+1];\n            if(x>=0 && x<grid.size() && y>=0 && y<grid[0].size()){\n                perimeter += dfs(grid,x,y);\n            }else{\n                ++perimeter;\n            }\n        }\n        return perimeter;\n    }\n\n    int islandPerimeter(vector<vector<int>>& grid) {\n        if(grid.empty() || grid[0].empty()){\n            return 0;\n        }\n        int ans = 0;\n        for(int i=0;i<grid.size();++i){\n            for(int j=0;j<grid[0].size();++j){\n                if(grid[i][j]==1){\n                    ans += dfs(grid,i,j);\n                }\n            }\n        }\n        return ans;\n    }\n};\n\n\n# 417 太平洋大西洋水流问题\n\n给定一个二维的非负整数矩阵，每个位置的值表示海拔高度。假设左边和上边是太平洋，右边和下边是大西洋，求从哪些位置向下流水，可以流到太平洋和大西洋。水只能从海拔高的位置流到海拔低或相同的位置。\n\n输入是一个二维的非负整数数组，表示海拔高度。输出是一个二维的数组，其中第二个维度大小固定为 2，表示满足条件的位置坐标。\n\n输入如下的 5x5 矩阵:\n\n  太平洋 ~   ~   ~   ~   ~ \n       ~  1   2   2   3  (5) *\n       ~  3   2   3  (4) (4) *\n       ~  2   4  (5)  3   1  *\n       ~ (6) (7)  1   4   5  *\n       ~ (5)  1   1   2   4  *\n          *   *   *   *   * 大西洋\n\n输出:[[0, 4], [1, 3], [1, 4], [2, 2], [3, 0], [3, 1], [4, 0]] (上图中带括号的位置).\n\n\n解析：\n\n虽然题目要求的是满足向下流能到达两个大洋的位置，如果我们对所有的位置进行搜索，那么在不剪枝的情况下复杂度会很高。因此我们可以反过来想，从两个大洋开始向上流，这样我们只需要对矩形四条边进行搜索。搜索完成后，只需遍历一遍矩阵，满足条件的位置即为两个大洋向上流都能到达的位置。\n\n具体来说，我们仍然使用主函数加辅函数的形式：\n\n主函数用于从边界（即大洋位置）开始搜索满足数值上升的路径（即可以留到大洋的位置）。结合辅函数完成搜索之后，遍历矩阵中所有的位置，找到既能流到太平洋又可以流到大西洋的位置。\n\n辅函数中使用递归实现当前位置的四向搜索，继续递归的边界条件是下一位置在矩阵内且该位置的值大于等于当前值。搜索过程中将已访问的位置标记，避免重复搜索。\n\nclass Solution {\n    vector<int> direction={-1,0,1,0,-1};\npublic:\n    void dfs(vector<vector<int>>& heights, vector<vector<bool>>& can_reach, int i, int j){\n        if(can_reach[i][j]) return;\n        can_reach[i][j] = true;\n        int x, y;\n        for(int s=0;s<4;++s){\n            x = i+direction[s];\n            y = j+direction[s+1];\n            if(x>=0 && x<heights.size() && y>=0 && y<heights[0].size() && heights[i][j]<=heights[x][y]){\n                dfs(heights,can_reach,x,y);\n            }\n        }\n    }\n\n    vector<vector<int>> pacificAtlantic(vector<vector<int>>& heights) {\n        if(heights.empty() || heights[0].empty()){\n            return {};\n        }\n        int m = heights.size(), n = heights[0].size();\n        vector<vector<int>> ans;\n        // 从边界四向搜索上升路径\n        vector<vector<bool>> can_reach_p(m,vector<bool>(n,false));\n        vector<vector<bool>> can_reach_a(m,vector<bool>(n,false));\n        for(int i=0;i<m;++i){\n            dfs(heights,can_reach_p,i,0);\n            dfs(heights,can_reach_a,i,n-1);\n        }\n        for(int i=0;i<n;++i){\n            dfs(heights,can_reach_p,0,i);\n            dfs(heights,can_reach_a,m-1,i);\n        }\n        // 标记 can_reach_p 和 can_reach_a 搜索均为 true 即可以流向太平洋也可以流向大西洋的节点\n        for(int i=0;i<m;++i){\n            for(int j=0;j<n;++j){\n                if(can_reach_p[i][j] && can_reach_a[i][j]){\n                    ans.push_back({i,j});\n                }\n            }\n        }\n        return ans;\n    }\n};\n\n\n# 130 被围绕的区域\n\n给定一个大小为 m x n 的二维矩阵 board，由若干字符 \'X\' 和 \'O\'组成，找到所有被 \'X\' 围绕的区域，并将这些区域里所有的 \'O\' 用 \'X\' 填充。\n\n输入一个二维数组，输出是一个被围绕区域覆盖之后的二维数组。\n\n输入：board = [["X","X","X","X"],\n["X","O","O","X"],\n["X","X","O","X"],\n["X","O","X","X"]]\n输出：[["X","X","X","X"],\n["X","X","X","X"],\n["X","X","X","X"],\n["X","O","X","X"]]\n解释：被围绕的区间不会存在于边界上，换句话说，任何边界上的 \'O\' 都不会被填充为 \'X\'。 任何不在边界上，或不与边界上的 \'O\' 相连的 \'O\' 最终都会被填充为 \'X\'。如果两个元素在水平或垂直方向相邻，则称它们是“相连”的。\n\n\n解析：\n\n本题和417 太平洋大西洋水流问题思路相似，虽然题目是要求找到所有被 \'X\' 围绕的区域，我们可以反向考虑找到所有没有被围绕的区域，即与边界连接的区域，然后将剩余的区域全部用\'X\' 覆盖。\n\n所以本题我们也从边界开始搜索，主函数完成两个任务：首先从矩阵的四个边界搜索没有被围绕的区域，开始搜索的条件是发现边界位置值为\'O\'字符；然后调用辅函数遍历矩阵将所有被围绕的区域用\'X\' 覆盖。辅函数完成当前位置的四向遍历，递归搜索出没有被围绕的区域，为了区分没有被围绕的区域和被围绕区域，我们使用\'Y\'字符标识没有被围绕的区域。\n\n完成深度优先搜索之后，矩阵中包含三种字符覆盖字符\'X\' ，没有被围绕的区域\'Y\'，被围绕区域\'O\'，遍历矩阵将所有\'Y\'字符用\'O\'字符覆盖，将所有\'O\'字符用\'X\'字符覆盖，就解决了本题。\n\nclass Solution {\n    vector<int> direction={-1,0,1,0,-1};\npublic:\n    void dfs(vector<vector<char>>& board, int i, int j){\n        if(board[i][j] == \'Y\') return;\n        // 将没有被围绕的区域用 \'Y\' 字符标识\n        board[i][j] = \'Y\';\n        int x,y;\n        for(int s=0;s<4;++s){\n            x = i+direction[s];\n            y = j+direction[s+1];\n            if(x>=0 && x<board.size() && y>=0 && y<board[0].size() && board[x][y]==\'O\'){\n                dfs(board,x,y);\n            }\n        }\n    }\n\n    void solve(vector<vector<char>>& board) {\n        if(board.empty() || board[0].empty()){\n            return;\n        }\n        int m = board.size(), n = board[0].size();\n        // // 从边界四向搜索没有被围绕的区域\n        for(int i=0;i<m;++i){\n            if(board[i][0]==\'O\'){\n                dfs(board,i,0);\n            }\n            if(board[i][n-1]==\'O\'){\n                dfs(board,i,n-1);\n            }\n        }\n        for(int j=0;j<n;++j){\n            if(board[0][j]==\'O\'){\n                dfs(board,0,j);\n            }\n            if(board[m-1][j]==\'O\'){\n                dfs(board,m-1,j);\n            }\n        }\n        // 将所有\'Y\'字符用\'O\'字符覆盖，将所有\'O\'字符用\'X\'字符覆盖\n        for(int i=0;i<m;++i){\n            for(int j=0;j<n;++j){\n                if(board[i][j]==\'Y\'){\n                    board[i][j]=\'O\';\n                }else if(board[i][j]==\'O\'){\n                    board[i][j]=\'X\';\n                }\n            }\n        }\n    }\n};\n',normalizedContent:'# 01 二维数组深度优先搜索\n\n\n# 深度优先搜索简介\n\n深度优先搜索（depth-first seach，dfs）在搜索到一个新的节点时，立即对该新节点进行遍历；因此遍历需要用先入后出的栈来实现，也可以通过与栈等价的递归来实现。\n\n二维数组深度优先搜索的一般写法：\n\n一般来说，深度优先搜索类型的题可以分为主函数和辅函数，主函数用于遍历所有的搜索位置，判断是否满足开始搜索的条件，如果可以即在辅函数中进行搜索。\n\n辅函数负责实现深度优先搜索过程。这一过程可以使用递归调用调用实现；当然，我们也可以使用栈（stack）实现深度优先搜索，与使用队列 （queue）实现广度优先搜索类比。但因为栈与递归的调用原理相同，而递归相对便于实现，因此刷题时推荐使用递归式写法，可以将深度优先搜索与回溯算法进行类比。不过在实际工程上，直接使用栈可能才是最好的选择，一是因为便于理解，二是更不易出现递归栈满的情况。\n\n在辅函数里，一个一定要注意的点是辅函数内递归搜索时，对矩阵边界条件的判定。边界判定一般有两种写法：一种是先判定是否越界，只有在合法的情况下才进行下一步搜索（即判断放在调用递归函数前）；另一种是不管三七二十一先进行下一步搜索，待下一步搜索开始时再判断是否合法（即判断放在辅函数第一行）。两种方法任选一种符合自身代码习惯的写法即可。\n\n二维数组四向遍历小技巧：对于四个方向的遍历，可以创造一个数组 direction = [-1, 0, 1, 0, -1]，每相邻两位即为上下左右四个方向之一，即：\n\n * 左移 x+=direction[0]; y+=direction[1]；\n * 上移 x+=direction[1]; y+=direction[2]；\n * 右移 x+=direction[2]; y+=direction[3]；\n * 下移 x+=direction[3]; y+=direction[4]；\n\n# 695 岛屿的最大面积\n\n给定一个大小为 m x n 的二维 0-1 矩阵 grid ，其中 0 表示海洋，1 表示陆地。单独的或相邻的陆地可以形成岛 屿，每个格子只与其上下左右四个格子相邻。求最大的岛屿面积。\n\n输入一个二维数组，输出是一个整数，表示最大的岛屿面积。\n\n输入：grid = [[0,0,1,0,0,0,0,1,0,0,0,0,0],\n[0,0,0,0,0,0,0,1,1,1,0,0,0],\n[0,1,1,0,1,0,0,0,0,0,0,0,0],\n[0,1,0,0,1,1,0,0,1,0,1,0,0],\n[0,1,0,0,1,1,0,0,1,1,1,0,0],\n[0,0,0,0,0,0,0,0,0,0,1,0,0],\n[0,0,0,0,0,0,0,1,1,1,0,0,0],\n[0,0,0,0,0,0,0,1,1,0,0,0,0]]\n输出：6\n解释：答案不应该是 11 ，因为岛屿只能包含水平或垂直这四个方向上的 1 。\n\n\n解析：\n\n本题是十分标准的搜索题，我们编写主函数和辅函数，主函数用于遍历所有的搜索位置，判断是否满足开始搜索的条件，如果可以即在辅函数中进行搜索。\n\n主函数寻找符合启动辅助函数进行搜索的位置，并记录辅助函数计算的岛屿最大值。我们可以使用双重循环实现，双重循环遍历矩阵的每一个位置，当发现岛屿即位置值为1时，开始用辅助函数搜索。\n\n辅函数中从开始搜索的位置向相邻四个方向递归搜索值为1的位置，并累计岛屿面积。搜索过程中我们对边界条件的判定采用先判断再搜索的方式，即先判断搜索节点是否越界，再决定是否继续进行深度递归搜索。遍历值为1的节点之后注意要将其值置为0，避免重复遍历无限递归。\n\nclass solution {\n    // 四个方向的遍历\n    vector<int> direction = {-1,0,1,0,-1};\npublic:\n    int dfs(vector<vector<int>>& grid, int i, int j){\n        if(grid[i][j] == 0) return 0;\n        // 遍历后值置为 0\n        grid[i][j] = 0;\n        // 四向深度优先搜索\n        int x, y, area = 1;\n        for(int s=0;s<4;++s){\n            x = i+direction[s];\n            y = j+direction[s+1];\n            if(x>=0 && x<grid.size() && y>=0 && y<grid[0].size()){\n                area += dfs(grid,x,y);\n            }\n        }\n        return area;\n    }\n\n    int maxareaofisland(vector<vector<int>>& grid) {\n        if(grid.empty() || grid[0].empty()){\n            return 0;\n        }\n        int maxarea = 0;\n        // 寻找符合启动辅助函数进行搜索的位置\n        for(int i=0;i<grid.size();++i){\n            for(int j=0;j<grid[0].size();++j){\n                if(grid[i][j] == 1){\n                    maxarea = max(maxarea,dfs(grid,i,j));\n                }\n            }\n        }\n        return maxarea;\n    }\n};\n\n\n# 200 岛屿数量\n\n给定一个大小为 m x n 的二维 0-1 矩阵 grid ，其中 0 表示海洋，1 表示陆地。单独的或相邻的陆地可以形成岛 屿，每个格子只与其上下左右四个格子相邻。求二维数组中一共有多少个岛屿。\n\n输入一个二维数组，输出是一个整数，表示岛屿数量。\n\n输入：grid = [\n  ["1","1","0","0","0"],\n  ["1","1","0","0","0"],\n  ["0","0","1","0","0"],\n  ["0","0","0","1","1"]\n]\n输出：3\n\n\n解析：\n\n本题与695 岛屿的最大面积题十分相似，我们同样编写主函数和辅函数：\n\n主函数寻找符合启动辅助函数进行搜索的位置，每找到这样一个位置就相当与找到一个岛屿 。使用双重循环遍历矩阵的每一个位置，当发现岛屿即位置值为1时，开始用辅助函数搜索。\n\n辅函数中从开始搜索的位置向相邻四个方向递归搜索，将属于同一岛屿的网格从\'1\' 置为\'0\'，避免重复计算岛屿数量。同样搜索过程中我们需要对边界条件进行判定，仍采用先判断是否越界，再进行递归搜索的方式。\n\nclass solution {\n    vector<int> direction={-1,0,1,0,-1};\npublic:\n    void dfs(vector<vector<char>>& grid, int i, int j){\n        if(grid[i][j] == \'0\') return;\n        grid[i][j] = \'0\';\n        int x, y;\n        for(int s=0;s<4;++s){\n            x = i+direction[s];\n            y = j+direction[s+1];\n            if(x>=0 && x<grid.size() && y>=0 && y<grid[0].size()){\n                dfs(grid,x,y);\n            }\n        }\n    }\n\n    int numislands(vector<vector<char>>& grid) {\n        if(grid.empty() || grid[0].empty()){\n            return 0;\n        }\n        int ans = 0;\n        for(int i=0;i<grid.size();++i){\n            for(int j=0;j<grid[0].size();++j){\n                if(grid[i][j] == \'1\'){\n                    dfs(grid,i,j);\n                    ++ans;\n                }\n            }\n        }\n        return ans;\n    }\n};\n\n\n# 463 岛屿的周长\n\n给定一个大小为 m x n 的二维 0-1 矩阵 grid ，其中 0 表示海洋，1 表示陆地。单独的或相邻的陆地可以形成岛 屿，每个格子只与其上下左右四个格子相邻。求二维数组中一个或多个岛屿的周长。\n\n输入一个二维数组，输出是一个整数，表示岛屿的周长。\n\n\n\n输入：grid = [[0,1,0,0],[1,1,1,0],[0,1,0,0],[1,1,0,0]]\n输出：16\n解释：它的周长是上面图片中的 16 个黄色的边\n\n\n解析：\n\n本题与695 岛屿的最大面积题十分相似，我们同样编写主函数和辅函数：\n\n主函数寻找符合启动辅助函数进行搜索的位置，并记录辅助函数计算的每个岛屿的周长 。使用双重循环遍历矩阵的每一个位置，当发现岛屿即位置值为1时，开始用辅助函数搜索。\n\n辅函数中从开始搜索的位置向相邻四个方向递归搜索。对于一个值为1的位置的每条边，它被算作岛屿的周长当且仅当这条边为网格的边界或者相邻的另一个格子为水域。 因此，我们可以遍历每个陆地格子，看其四个方向是否为边界或者水域：如果是，则将这条边作为岛屿的周长的一段加入中结果；如果不是，则不加入周长并继续递归搜索。\n\n搜索过程中我们对边界条件的判定采用先判断再搜索的方式，即先判断搜索节点是否越界，再决定是否继续进行深度递归搜索。遍历值为1的节点之后注意要将其值置为2，避免重复遍历无限递归和错误地周长计算。\n\nclass solution {\n    vector<int> direction={-1,0,1,0,-1};\npublic:\n    int dfs(vector<vector<int>>& grid, int i, int j){\n        if(grid[i][j]==0) return 1;\n        if(grid[i][j]==2) return 0;\n        grid[i][j] = 2;\n        int x, y, perimeter = 0;\n        for(int s=0;s<4;++s){\n            int x = i+direction[s];\n            int y = j+direction[s+1];\n            if(x>=0 && x<grid.size() && y>=0 && y<grid[0].size()){\n                perimeter += dfs(grid,x,y);\n            }else{\n                ++perimeter;\n            }\n        }\n        return perimeter;\n    }\n\n    int islandperimeter(vector<vector<int>>& grid) {\n        if(grid.empty() || grid[0].empty()){\n            return 0;\n        }\n        int ans = 0;\n        for(int i=0;i<grid.size();++i){\n            for(int j=0;j<grid[0].size();++j){\n                if(grid[i][j]==1){\n                    ans += dfs(grid,i,j);\n                }\n            }\n        }\n        return ans;\n    }\n};\n\n\n# 417 太平洋大西洋水流问题\n\n给定一个二维的非负整数矩阵，每个位置的值表示海拔高度。假设左边和上边是太平洋，右边和下边是大西洋，求从哪些位置向下流水，可以流到太平洋和大西洋。水只能从海拔高的位置流到海拔低或相同的位置。\n\n输入是一个二维的非负整数数组，表示海拔高度。输出是一个二维的数组，其中第二个维度大小固定为 2，表示满足条件的位置坐标。\n\n输入如下的 5x5 矩阵:\n\n  太平洋 ~   ~   ~   ~   ~ \n       ~  1   2   2   3  (5) *\n       ~  3   2   3  (4) (4) *\n       ~  2   4  (5)  3   1  *\n       ~ (6) (7)  1   4   5  *\n       ~ (5)  1   1   2   4  *\n          *   *   *   *   * 大西洋\n\n输出:[[0, 4], [1, 3], [1, 4], [2, 2], [3, 0], [3, 1], [4, 0]] (上图中带括号的位置).\n\n\n解析：\n\n虽然题目要求的是满足向下流能到达两个大洋的位置，如果我们对所有的位置进行搜索，那么在不剪枝的情况下复杂度会很高。因此我们可以反过来想，从两个大洋开始向上流，这样我们只需要对矩形四条边进行搜索。搜索完成后，只需遍历一遍矩阵，满足条件的位置即为两个大洋向上流都能到达的位置。\n\n具体来说，我们仍然使用主函数加辅函数的形式：\n\n主函数用于从边界（即大洋位置）开始搜索满足数值上升的路径（即可以留到大洋的位置）。结合辅函数完成搜索之后，遍历矩阵中所有的位置，找到既能流到太平洋又可以流到大西洋的位置。\n\n辅函数中使用递归实现当前位置的四向搜索，继续递归的边界条件是下一位置在矩阵内且该位置的值大于等于当前值。搜索过程中将已访问的位置标记，避免重复搜索。\n\nclass solution {\n    vector<int> direction={-1,0,1,0,-1};\npublic:\n    void dfs(vector<vector<int>>& heights, vector<vector<bool>>& can_reach, int i, int j){\n        if(can_reach[i][j]) return;\n        can_reach[i][j] = true;\n        int x, y;\n        for(int s=0;s<4;++s){\n            x = i+direction[s];\n            y = j+direction[s+1];\n            if(x>=0 && x<heights.size() && y>=0 && y<heights[0].size() && heights[i][j]<=heights[x][y]){\n                dfs(heights,can_reach,x,y);\n            }\n        }\n    }\n\n    vector<vector<int>> pacificatlantic(vector<vector<int>>& heights) {\n        if(heights.empty() || heights[0].empty()){\n            return {};\n        }\n        int m = heights.size(), n = heights[0].size();\n        vector<vector<int>> ans;\n        // 从边界四向搜索上升路径\n        vector<vector<bool>> can_reach_p(m,vector<bool>(n,false));\n        vector<vector<bool>> can_reach_a(m,vector<bool>(n,false));\n        for(int i=0;i<m;++i){\n            dfs(heights,can_reach_p,i,0);\n            dfs(heights,can_reach_a,i,n-1);\n        }\n        for(int i=0;i<n;++i){\n            dfs(heights,can_reach_p,0,i);\n            dfs(heights,can_reach_a,m-1,i);\n        }\n        // 标记 can_reach_p 和 can_reach_a 搜索均为 true 即可以流向太平洋也可以流向大西洋的节点\n        for(int i=0;i<m;++i){\n            for(int j=0;j<n;++j){\n                if(can_reach_p[i][j] && can_reach_a[i][j]){\n                    ans.push_back({i,j});\n                }\n            }\n        }\n        return ans;\n    }\n};\n\n\n# 130 被围绕的区域\n\n给定一个大小为 m x n 的二维矩阵 board，由若干字符 \'x\' 和 \'o\'组成，找到所有被 \'x\' 围绕的区域，并将这些区域里所有的 \'o\' 用 \'x\' 填充。\n\n输入一个二维数组，输出是一个被围绕区域覆盖之后的二维数组。\n\n输入：board = [["x","x","x","x"],\n["x","o","o","x"],\n["x","x","o","x"],\n["x","o","x","x"]]\n输出：[["x","x","x","x"],\n["x","x","x","x"],\n["x","x","x","x"],\n["x","o","x","x"]]\n解释：被围绕的区间不会存在于边界上，换句话说，任何边界上的 \'o\' 都不会被填充为 \'x\'。 任何不在边界上，或不与边界上的 \'o\' 相连的 \'o\' 最终都会被填充为 \'x\'。如果两个元素在水平或垂直方向相邻，则称它们是“相连”的。\n\n\n解析：\n\n本题和417 太平洋大西洋水流问题思路相似，虽然题目是要求找到所有被 \'x\' 围绕的区域，我们可以反向考虑找到所有没有被围绕的区域，即与边界连接的区域，然后将剩余的区域全部用\'x\' 覆盖。\n\n所以本题我们也从边界开始搜索，主函数完成两个任务：首先从矩阵的四个边界搜索没有被围绕的区域，开始搜索的条件是发现边界位置值为\'o\'字符；然后调用辅函数遍历矩阵将所有被围绕的区域用\'x\' 覆盖。辅函数完成当前位置的四向遍历，递归搜索出没有被围绕的区域，为了区分没有被围绕的区域和被围绕区域，我们使用\'y\'字符标识没有被围绕的区域。\n\n完成深度优先搜索之后，矩阵中包含三种字符覆盖字符\'x\' ，没有被围绕的区域\'y\'，被围绕区域\'o\'，遍历矩阵将所有\'y\'字符用\'o\'字符覆盖，将所有\'o\'字符用\'x\'字符覆盖，就解决了本题。\n\nclass solution {\n    vector<int> direction={-1,0,1,0,-1};\npublic:\n    void dfs(vector<vector<char>>& board, int i, int j){\n        if(board[i][j] == \'y\') return;\n        // 将没有被围绕的区域用 \'y\' 字符标识\n        board[i][j] = \'y\';\n        int x,y;\n        for(int s=0;s<4;++s){\n            x = i+direction[s];\n            y = j+direction[s+1];\n            if(x>=0 && x<board.size() && y>=0 && y<board[0].size() && board[x][y]==\'o\'){\n                dfs(board,x,y);\n            }\n        }\n    }\n\n    void solve(vector<vector<char>>& board) {\n        if(board.empty() || board[0].empty()){\n            return;\n        }\n        int m = board.size(), n = board[0].size();\n        // // 从边界四向搜索没有被围绕的区域\n        for(int i=0;i<m;++i){\n            if(board[i][0]==\'o\'){\n                dfs(board,i,0);\n            }\n            if(board[i][n-1]==\'o\'){\n                dfs(board,i,n-1);\n            }\n        }\n        for(int j=0;j<n;++j){\n            if(board[0][j]==\'o\'){\n                dfs(board,0,j);\n            }\n            if(board[m-1][j]==\'o\'){\n                dfs(board,m-1,j);\n            }\n        }\n        // 将所有\'y\'字符用\'o\'字符覆盖，将所有\'o\'字符用\'x\'字符覆盖\n        for(int i=0;i<m;++i){\n            for(int j=0;j<n;++j){\n                if(board[i][j]==\'y\'){\n                    board[i][j]=\'o\';\n                }else if(board[i][j]==\'o\'){\n                    board[i][j]=\'x\';\n                }\n            }\n        }\n    }\n};\n',charsets:{cjk:!0},lastUpdated:"2023/11/19, 12:55:48",lastUpdatedTimestamp:1700369748e3},{title:"05堆排序",frontmatter:{title:"05堆排序",date:"2023-03-24T18:39:49.000Z",permalink:"/pages/c2b2d7/"},regularPath:"/03.LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/01.%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/03.%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/05.%E5%A0%86%E6%8E%92%E5%BA%8F.html",relativePath:"03.LeetCode刷题笔记/01.基础算法/03.排序算法/05.堆排序.md",key:"v-8fb6558c",path:"/pages/c2b2d7/",headers:[{level:2,title:"03 堆排序",slug:"_03-堆排序",normalizedTitle:"03 堆排序",charIndex:2},{level:3,title:"堆排序简介",slug:"堆排序简介",normalizedTitle:"堆排序简介",charIndex:13},{level:4,title:"912 排序数组",slug:"_912-排序数组",normalizedTitle:"912 排序数组",charIndex:1814}],headersStr:"03 堆排序 堆排序简介 912 排序数组",content:"# 03 堆排序\n\n\n# 堆排序简介\n\n算法思想：\n\n堆排序是对简单选择排序的改进，其核心思想是利用大根堆或者小根堆的树形结构，不断获取堆顶元素存入排序序列。大根堆是指一棵二叉树的每个节点值都大于或者等于它的左右子节点值，其根节点为最大值；小根堆反之。\n\n实现堆排序由两个关键任务：一是要构建大根堆或者小根堆；二是在取出堆顶之后，调整堆保持大根堆或者小根堆的树形结构。\n\n堆构建过程：堆构建有自上而下和自下而上两种方法，我们采用简单的自上而下构建\n\n * 根据数组顺序插入树节点\n * 如果插入节点值小于父节点，继续插入其他节点\n * 如果插入节点值大于父节点，那么需要将该节点不断上浮，直到找到合适的插入位置\n * 需要注意的是大根堆或者小根堆都是一棵完全二叉树，可以直接使用数组映射完全二叉树，不需要去另外构建树节点结构体；使用数组映射完全二叉树，索引从 0 开始具有如下性质：\n   * 当前节点的父节点索引为(i-1)/2\n   * 当前节点的左节点索引为2*i+1\n   * 当前节点的左节点索引为2*i+2 = 2*(i+1)\n\n堆调整过程：\n\n * 取出堆顶之后，用最后一个叶子节点与堆顶交换\n * 因为最后一个叶子节点是数组的最小元素，所以将它放到大根堆堆顶，就破坏大根堆堆的树形结构，需要调整堆\n * 选取根节点的左右节点中较大的节点与当前根节点交换\n * 交换后如果破坏了子树的堆结构，就需要按照上述调整步骤递归地调整堆结构\n\n执行样例：\n\n输入：[29,10,14,37,16,25,20]\n\n为了友好展示快排的效果我们稍微调整了一下之前的例子，删去了重复的元素\n\n 1. 大根堆构建过程\n\n\n\n 2. 堆排序过程\n\n\n\n算法实现：\n\n// 下沉调整大根堆，比较节点及其子节点，节点值大的子节点与父节点交换\nvoid sink(vector<int> &nums, int i,int heapSize){\n    if(heapSize==0 || nums.empty()) return;\n\n    // 找到当前节点、左节点、右节点中较大的一个节点索引\n    int bigger = i;\n    int leftChild = 2*i+1;\n    if(leftChild < heapSize){\n        bigger = nums[leftChild] > nums[i] ? leftChild:i;\n    }\n    int rightChild = 2*i+2;\n    if(rightChild < heapSize){\n        bigger = nums[rightChild] > nums[bigger] ? rightChild:bigger;\n    }\n\n    // 如果较大节点是左右节点中的一个，交换当前节点和较大节点\n    if(bigger!=i){\n        swap(nums[i],nums[bigger]);\n        sink(nums,bigger,heapSize); // 递归调整\n    }\n}\n\nvoid buildHeap(vector<int> &nums, int heapSize){\n    // 从最后一个非叶子节点开始构造\n    int i=(heapSize-1)/2;\n    for(i;i>=0;--i){\n        sink(nums,i,heapSize);\n    }\n}\n\n// 递归排序时，堆根节点先与最后一个节点进行交换，交换后，堆大小减1，并对根节点进行下沉调整\nvoid sort(vector<int> &nums, int &heapSize){\n\tswap(nums[0], nums[heapSize - 1]);\n\t--heapSize;\n\tsink(nums,0,heapSize);\n}\n\nvoid heapSort(vector<int> &nums){\n    int heapSize = nums.size();\n    buildHeap(nums,heapSize);\n    for(int i=0;i<nums.size()-1;++i){\n        sort(nums,heapSize);\n    }\n}\n\n\n# 912 排序数组\n\n给你一个整数数组 nums，请你将该数组升序排列。\n\n示例：\n\n输入：nums = [5,2,3,1]\n输出：[1,2,3,5]\n\n\n解析：\n\nclass Solution {\npublic:\n    void sink(vector<int>& nums, int root, int heapSize){\n        if(heapSize <=0 || nums.empty()){\n            return;\n        }\n        int bigger = root;\n        int leftChild = 2*root+1;\n        int rightChild = 2*root+2;\n        if(leftChild<heapSize){\n            bigger = nums[leftChild] > nums[root]?leftChild:root;\n        }\n        if(rightChild<heapSize){\n            bigger = nums[rightChild] > nums[bigger]?rightChild:bigger;\n        }\n\n        if(bigger!=root){\n            swap(nums[root],nums[bigger]);\n            sink(nums,bigger,heapSize);\n        }\n    }\n\n    void bulidHeap(vector<int>& nums, int heapSize){\n        for(int root = (heapSize-1)/2;root>=0;--root){\n            sink(nums,root,heapSize);\n        }\n    }\n\n    void top(vector<int>& nums, int& heapSize){\n        swap(nums[0],nums[heapSize-1]);\n        --heapSize;\n        sink(nums,0,heapSize);\n    }\n\n    vector<int> sortArray(vector<int>& nums) {\n        int heapSize = nums.size();\n        bulidHeap(nums,heapSize);\n        for(int i=0;i<nums.size();++i){\n            top(nums,heapSize);\n        }\n        return nums;\n    }\n};\n",normalizedContent:"# 03 堆排序\n\n\n# 堆排序简介\n\n算法思想：\n\n堆排序是对简单选择排序的改进，其核心思想是利用大根堆或者小根堆的树形结构，不断获取堆顶元素存入排序序列。大根堆是指一棵二叉树的每个节点值都大于或者等于它的左右子节点值，其根节点为最大值；小根堆反之。\n\n实现堆排序由两个关键任务：一是要构建大根堆或者小根堆；二是在取出堆顶之后，调整堆保持大根堆或者小根堆的树形结构。\n\n堆构建过程：堆构建有自上而下和自下而上两种方法，我们采用简单的自上而下构建\n\n * 根据数组顺序插入树节点\n * 如果插入节点值小于父节点，继续插入其他节点\n * 如果插入节点值大于父节点，那么需要将该节点不断上浮，直到找到合适的插入位置\n * 需要注意的是大根堆或者小根堆都是一棵完全二叉树，可以直接使用数组映射完全二叉树，不需要去另外构建树节点结构体；使用数组映射完全二叉树，索引从 0 开始具有如下性质：\n   * 当前节点的父节点索引为(i-1)/2\n   * 当前节点的左节点索引为2*i+1\n   * 当前节点的左节点索引为2*i+2 = 2*(i+1)\n\n堆调整过程：\n\n * 取出堆顶之后，用最后一个叶子节点与堆顶交换\n * 因为最后一个叶子节点是数组的最小元素，所以将它放到大根堆堆顶，就破坏大根堆堆的树形结构，需要调整堆\n * 选取根节点的左右节点中较大的节点与当前根节点交换\n * 交换后如果破坏了子树的堆结构，就需要按照上述调整步骤递归地调整堆结构\n\n执行样例：\n\n输入：[29,10,14,37,16,25,20]\n\n为了友好展示快排的效果我们稍微调整了一下之前的例子，删去了重复的元素\n\n 1. 大根堆构建过程\n\n\n\n 2. 堆排序过程\n\n\n\n算法实现：\n\n// 下沉调整大根堆，比较节点及其子节点，节点值大的子节点与父节点交换\nvoid sink(vector<int> &nums, int i,int heapsize){\n    if(heapsize==0 || nums.empty()) return;\n\n    // 找到当前节点、左节点、右节点中较大的一个节点索引\n    int bigger = i;\n    int leftchild = 2*i+1;\n    if(leftchild < heapsize){\n        bigger = nums[leftchild] > nums[i] ? leftchild:i;\n    }\n    int rightchild = 2*i+2;\n    if(rightchild < heapsize){\n        bigger = nums[rightchild] > nums[bigger] ? rightchild:bigger;\n    }\n\n    // 如果较大节点是左右节点中的一个，交换当前节点和较大节点\n    if(bigger!=i){\n        swap(nums[i],nums[bigger]);\n        sink(nums,bigger,heapsize); // 递归调整\n    }\n}\n\nvoid buildheap(vector<int> &nums, int heapsize){\n    // 从最后一个非叶子节点开始构造\n    int i=(heapsize-1)/2;\n    for(i;i>=0;--i){\n        sink(nums,i,heapsize);\n    }\n}\n\n// 递归排序时，堆根节点先与最后一个节点进行交换，交换后，堆大小减1，并对根节点进行下沉调整\nvoid sort(vector<int> &nums, int &heapsize){\n\tswap(nums[0], nums[heapsize - 1]);\n\t--heapsize;\n\tsink(nums,0,heapsize);\n}\n\nvoid heapsort(vector<int> &nums){\n    int heapsize = nums.size();\n    buildheap(nums,heapsize);\n    for(int i=0;i<nums.size()-1;++i){\n        sort(nums,heapsize);\n    }\n}\n\n\n# 912 排序数组\n\n给你一个整数数组 nums，请你将该数组升序排列。\n\n示例：\n\n输入：nums = [5,2,3,1]\n输出：[1,2,3,5]\n\n\n解析：\n\nclass solution {\npublic:\n    void sink(vector<int>& nums, int root, int heapsize){\n        if(heapsize <=0 || nums.empty()){\n            return;\n        }\n        int bigger = root;\n        int leftchild = 2*root+1;\n        int rightchild = 2*root+2;\n        if(leftchild<heapsize){\n            bigger = nums[leftchild] > nums[root]?leftchild:root;\n        }\n        if(rightchild<heapsize){\n            bigger = nums[rightchild] > nums[bigger]?rightchild:bigger;\n        }\n\n        if(bigger!=root){\n            swap(nums[root],nums[bigger]);\n            sink(nums,bigger,heapsize);\n        }\n    }\n\n    void bulidheap(vector<int>& nums, int heapsize){\n        for(int root = (heapsize-1)/2;root>=0;--root){\n            sink(nums,root,heapsize);\n        }\n    }\n\n    void top(vector<int>& nums, int& heapsize){\n        swap(nums[0],nums[heapsize-1]);\n        --heapsize;\n        sink(nums,0,heapsize);\n    }\n\n    vector<int> sortarray(vector<int>& nums) {\n        int heapsize = nums.size();\n        bulidheap(nums,heapsize);\n        for(int i=0;i<nums.size();++i){\n            top(nums,heapsize);\n        }\n        return nums;\n    }\n};\n",charsets:{cjk:!0},lastUpdated:"2023/11/19, 12:55:48",lastUpdatedTimestamp:1700369748e3},{title:"01递归",frontmatter:{title:"01递归",date:"2023-03-24T18:39:49.000Z",permalink:"/pages/9c6520/"},regularPath:"/03.LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/01.%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/04.%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/01.%E9%80%92%E5%BD%92.html",relativePath:"03.LeetCode刷题笔记/01.基础算法/04.优先搜索/01.递归.md",key:"v-f18cce36",path:"/pages/9c6520/",headers:[{level:2,title:"01 递归",slug:"_01-递归",normalizedTitle:"01 递归",charIndex:2},{level:3,title:"递归的基本概念",slug:"递归的基本概念",normalizedTitle:"递归的基本概念",charIndex:12},{level:4,title:"面试题 08.06. 汉诺塔问题",slug:"面试题-08-06-汉诺塔问题",normalizedTitle:"面试题 08.06. 汉诺塔问题",charIndex:601},{level:4,title:"509 斐波那契数",slug:"_509-斐波那契数",normalizedTitle:"509 斐波那契数",charIndex:1559},{level:4,title:"70 爬楼梯",slug:"_70-爬楼梯",normalizedTitle:"70 爬楼梯",charIndex:2235}],headersStr:"01 递归 递归的基本概念 面试题 08.06. 汉诺塔问题 509 斐波那契数 70 爬楼梯",content:"# 01 递归\n\n\n# 递归的基本概念\n\n递归作为一种算法结构是指在函数的定义中调用函数自身，一个经典的例子就是用递归函数求阶乘\n\nint factorial(int n){\n    if(n == 0){\n        return 1;\n    }else{\n        return n * factorial(n-1);\n    }\n}\n\n\n从上例可以看出递归的基本思想就是把规模大的问题拆解为规模小的相同的子问题来解决，且在这个不断拆解为更小问题的过程中有一个临界点，即问题拆解的终止条件。当达到临界点时，从被拆解的最小问题的解开始对战栈式地返回答案，累积得到原问题的解。\n\n所以在递归函数实现时，包含了两部分，一个是递归主体，另一个是终止条件：\n\n * 递归主体：因为大问题和小问题是一样的问题，因此大问题的解决方法和小问题的解决方法也是同一个方法这就是递归主体。一般情况下，递归主体就是一个递推公式，该递推公式来自将大问题拆解为小问题的规律。\n * 终止条件：这种函数调用它自身的情况，必须有明确的终止条件，否则就会导致无限递归。而终止条件就是问题的平凡解，即问题的最简单情况。\n\n总的来说，递归问题的求解关键在于找出问题转化的递推公式和终止条件。\n\n递归的作用：\n\n * 替代多重循环\n * 用于解决本来就是用递归形式定义的问题\n * 将问题分解为规模更小的子问题进行求解\n\n# 面试题 08.06. 汉诺塔问题\n\n有一个梵塔，塔内有三个座 A 、 B 、 C，A 座上有 N 个盘子，盘子大小不等，大的在下，小的在上。 现在想把这 N 个盘子从 A 座移到 C 座，但每次只能允许移动一个盘子，并且在移动过程中， 3 个座上的盘子始终保持大盘在下，小盘在上 。 在移动过程中可以利用 B 座。\n\n\n\n输入三个数组，输出一个数组表示移动结果\n\n>  输入：A = [2, 1, 0], B = [], C = []\n>  输出：C = [2, 1, 0]\n\n解析：\n\n汉诺塔问题是经典的递归问题，本题的初始情况：所有的圆盘按大小顺序堆放在 A 上，最大的在底部；移动规则：允许圆盘一次从一个木桩移动到另一个，大盘不能放在小盘的上面；要达到的最终目标：以最少的移动次数将所有圆盘从 A 转移到 C。\n\n分析本题的递推规律：先将 n-1 个盘子从 A 移动到中转 B，再将最大的一个盘子移动到 C，然后将 n-1 个盘子从 B 移动到 C。即将规模为 N 的大问题，转化为规模为 N-1 的子问题，直到最终转化为 1 的平凡解。\n\n递归的终止条件为：A 只有一个盘子，直接将它从 A 移动到 C\n\nclass Solution {\npublic:\n    void rec(int n, vector<int>& A, vector<int>& B, vector<int>& C){\n        // 终止条件\n        if(n==1){\n            C.push_back(A.back());\n            A.pop_back();\n            return;\n        }\n        // 递推公式\n        rec(n-1,A,C,B);\n        C.push_back(A.back());\n        A.pop_back();\n        rec(n-1,B,A,C);\n    }\n\n    void hanota(vector<int>& A, vector<int>& B, vector<int>& C) {\n        rec(A.size(),A,B,C);\n    }\n};\n\n\n# 509 斐波那契数\n\n斐波那契数，通常用 F(n) 表示，形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是：\n\n> F(0) = 0，F(1) = 1\n> F(n) = F(n - 1) + F(n - 2)，其中 n > 1\n\n现给定 n，请计算 F(n)\n\n输入一个整数，输出一个整数表示斐波那契数\n\n> 输入：2\n> 输出：1\n> 解释：F(2) = F(1) + F(0) = 1 + 0 = 1\n\n解析：\n\n斐波那契数列（Fibonacci sequence），又称黄金分割数列，0,1,1,2,3,5,8,13,21,34,……，其递归公式为:\n\n> F(0) = 0，F(1) = 1\n> F(n) = F(n - 1) + F(n - 2)，其中 n > 1\n\n更加直观的理解斐波那契数列如下图所示：\n\n我们可以直接根据斐波那契数列的递推公式得出递归主体和终止条件：\n\n * 终止条件：F(0) = 0，F(1) = 1\n * 递归主体：F(n) = F(n - 1) + F(n - 2)\n\nclass Solution {\npublic:\n    int fib(int n) {\n        if(n==0){\n            return 0;\n        }\n        if(n==1){\n            return 1;\n        }\n        return fib(n-1)+fib(n-2);\n    }\n};\n\n\n# 70 爬楼梯\n\n某人正在爬楼梯，需要 n 阶才能到达楼顶。每次可以爬 1 或 2 个台阶，请计算有多少种不同的方法可以爬到楼顶。\n\n输入一个整数 n，输出一个整数表示爬到楼顶的方法数。\n\n> 输入： 3\n> 输出： 3\n> 解释： 有三种方法可以爬到楼顶。\n> 1.  1 阶 + 1 阶 + 1 阶\n> 2.  1 阶 + 2 阶\n> 3.  2 阶 + 1 阶\n\n解析：\n\n本题可以转化为斐波那契数列问题。\n\n首先我们考虑爬楼梯的终止条件。本题可以有多种终止条件，n<0 时没有台阶可走，n=0 时需要返回上一步移动的结果；n=1 时只剩下一种移动方式；n=2 时有 1,1 和 2 两种移动方式。所以本题的终止条件可以为如下三种情况：\n\n * n < 0, return 0; n = 0, return 1;\n * n = 0, return 1; n = 1, return 1;\n * n = 1, return 1; n = 2, return 2;\n\n接着我们考虑爬楼梯的递推规律：先考虑规模为 N 的大问题，N 阶楼梯的走法等于第一次走一步和走两步之后规模为 N-1 和 N-2 两个子问题的走法之和。即 ( n 阶楼梯的走法) = (走一级台阶之后，n-1 级台阶的走法) + (走两级台阶之后，n-2 级台阶的走法)，形式化表达 f(n) = f(n-1) + f(n-2)。\n\nclass Solution {\npublic:\n    int climbStairs(int n) {\n        if(n==1){\n            return 1;\n        }\n        if(n==2){\n            return 2;\n        }\n\n        return climbStairs(n-1) + climbStairs(n-2);\n    }\n};\n\n\n需要注意的是，LeetCode 中本题不能直接使用递归求解，会超出时间限制，使用动态规划的方式求解。\n\nclass Solution {\npublic:\n    int climbStairs(int n) {\n        // 初始条件 只走一步\n        int r = 1, s = 0, t = 0;\n        for(int i=1;i<=n;++i){\n            s = t;\n            t = r;\n            r = s + t;\n        }\n        return r;\n    }\n};\n",normalizedContent:"# 01 递归\n\n\n# 递归的基本概念\n\n递归作为一种算法结构是指在函数的定义中调用函数自身，一个经典的例子就是用递归函数求阶乘\n\nint factorial(int n){\n    if(n == 0){\n        return 1;\n    }else{\n        return n * factorial(n-1);\n    }\n}\n\n\n从上例可以看出递归的基本思想就是把规模大的问题拆解为规模小的相同的子问题来解决，且在这个不断拆解为更小问题的过程中有一个临界点，即问题拆解的终止条件。当达到临界点时，从被拆解的最小问题的解开始对战栈式地返回答案，累积得到原问题的解。\n\n所以在递归函数实现时，包含了两部分，一个是递归主体，另一个是终止条件：\n\n * 递归主体：因为大问题和小问题是一样的问题，因此大问题的解决方法和小问题的解决方法也是同一个方法这就是递归主体。一般情况下，递归主体就是一个递推公式，该递推公式来自将大问题拆解为小问题的规律。\n * 终止条件：这种函数调用它自身的情况，必须有明确的终止条件，否则就会导致无限递归。而终止条件就是问题的平凡解，即问题的最简单情况。\n\n总的来说，递归问题的求解关键在于找出问题转化的递推公式和终止条件。\n\n递归的作用：\n\n * 替代多重循环\n * 用于解决本来就是用递归形式定义的问题\n * 将问题分解为规模更小的子问题进行求解\n\n# 面试题 08.06. 汉诺塔问题\n\n有一个梵塔，塔内有三个座 a 、 b 、 c，a 座上有 n 个盘子，盘子大小不等，大的在下，小的在上。 现在想把这 n 个盘子从 a 座移到 c 座，但每次只能允许移动一个盘子，并且在移动过程中， 3 个座上的盘子始终保持大盘在下，小盘在上 。 在移动过程中可以利用 b 座。\n\n\n\n输入三个数组，输出一个数组表示移动结果\n\n>  输入：a = [2, 1, 0], b = [], c = []\n>  输出：c = [2, 1, 0]\n\n解析：\n\n汉诺塔问题是经典的递归问题，本题的初始情况：所有的圆盘按大小顺序堆放在 a 上，最大的在底部；移动规则：允许圆盘一次从一个木桩移动到另一个，大盘不能放在小盘的上面；要达到的最终目标：以最少的移动次数将所有圆盘从 a 转移到 c。\n\n分析本题的递推规律：先将 n-1 个盘子从 a 移动到中转 b，再将最大的一个盘子移动到 c，然后将 n-1 个盘子从 b 移动到 c。即将规模为 n 的大问题，转化为规模为 n-1 的子问题，直到最终转化为 1 的平凡解。\n\n递归的终止条件为：a 只有一个盘子，直接将它从 a 移动到 c\n\nclass solution {\npublic:\n    void rec(int n, vector<int>& a, vector<int>& b, vector<int>& c){\n        // 终止条件\n        if(n==1){\n            c.push_back(a.back());\n            a.pop_back();\n            return;\n        }\n        // 递推公式\n        rec(n-1,a,c,b);\n        c.push_back(a.back());\n        a.pop_back();\n        rec(n-1,b,a,c);\n    }\n\n    void hanota(vector<int>& a, vector<int>& b, vector<int>& c) {\n        rec(a.size(),a,b,c);\n    }\n};\n\n\n# 509 斐波那契数\n\n斐波那契数，通常用 f(n) 表示，形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是：\n\n> f(0) = 0，f(1) = 1\n> f(n) = f(n - 1) + f(n - 2)，其中 n > 1\n\n现给定 n，请计算 f(n)\n\n输入一个整数，输出一个整数表示斐波那契数\n\n> 输入：2\n> 输出：1\n> 解释：f(2) = f(1) + f(0) = 1 + 0 = 1\n\n解析：\n\n斐波那契数列（fibonacci sequence），又称黄金分割数列，0,1,1,2,3,5,8,13,21,34,……，其递归公式为:\n\n> f(0) = 0，f(1) = 1\n> f(n) = f(n - 1) + f(n - 2)，其中 n > 1\n\n更加直观的理解斐波那契数列如下图所示：\n\n我们可以直接根据斐波那契数列的递推公式得出递归主体和终止条件：\n\n * 终止条件：f(0) = 0，f(1) = 1\n * 递归主体：f(n) = f(n - 1) + f(n - 2)\n\nclass solution {\npublic:\n    int fib(int n) {\n        if(n==0){\n            return 0;\n        }\n        if(n==1){\n            return 1;\n        }\n        return fib(n-1)+fib(n-2);\n    }\n};\n\n\n# 70 爬楼梯\n\n某人正在爬楼梯，需要 n 阶才能到达楼顶。每次可以爬 1 或 2 个台阶，请计算有多少种不同的方法可以爬到楼顶。\n\n输入一个整数 n，输出一个整数表示爬到楼顶的方法数。\n\n> 输入： 3\n> 输出： 3\n> 解释： 有三种方法可以爬到楼顶。\n> 1.  1 阶 + 1 阶 + 1 阶\n> 2.  1 阶 + 2 阶\n> 3.  2 阶 + 1 阶\n\n解析：\n\n本题可以转化为斐波那契数列问题。\n\n首先我们考虑爬楼梯的终止条件。本题可以有多种终止条件，n<0 时没有台阶可走，n=0 时需要返回上一步移动的结果；n=1 时只剩下一种移动方式；n=2 时有 1,1 和 2 两种移动方式。所以本题的终止条件可以为如下三种情况：\n\n * n < 0, return 0; n = 0, return 1;\n * n = 0, return 1; n = 1, return 1;\n * n = 1, return 1; n = 2, return 2;\n\n接着我们考虑爬楼梯的递推规律：先考虑规模为 n 的大问题，n 阶楼梯的走法等于第一次走一步和走两步之后规模为 n-1 和 n-2 两个子问题的走法之和。即 ( n 阶楼梯的走法) = (走一级台阶之后，n-1 级台阶的走法) + (走两级台阶之后，n-2 级台阶的走法)，形式化表达 f(n) = f(n-1) + f(n-2)。\n\nclass solution {\npublic:\n    int climbstairs(int n) {\n        if(n==1){\n            return 1;\n        }\n        if(n==2){\n            return 2;\n        }\n\n        return climbstairs(n-1) + climbstairs(n-2);\n    }\n};\n\n\n需要注意的是，leetcode 中本题不能直接使用递归求解，会超出时间限制，使用动态规划的方式求解。\n\nclass solution {\npublic:\n    int climbstairs(int n) {\n        // 初始条件 只走一步\n        int r = 1, s = 0, t = 0;\n        for(int i=1;i<=n;++i){\n            s = t;\n            t = r;\n            r = s + t;\n        }\n        return r;\n    }\n};\n",charsets:{cjk:!0},lastUpdated:"2023/11/19, 12:55:48",lastUpdatedTimestamp:1700369748e3},{title:"03树结构深度优先搜索",frontmatter:{title:"03树结构深度优先搜索",date:"2023-03-24T18:39:49.000Z",permalink:"/pages/35b7a7/"},regularPath:"/03.LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/01.%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/04.%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/03.%E6%A0%91%E7%BB%93%E6%9E%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2.html",relativePath:"03.LeetCode刷题笔记/01.基础算法/04.优先搜索/03.树结构深度优先搜索.md",key:"v-0ba825b2",path:"/pages/35b7a7/",headers:[{level:2,title:"02 树结构深度优先搜索",slug:"_02-树结构深度优先搜索",normalizedTitle:"02 树结构深度优先搜索",charIndex:2},{level:3,title:"深度优先搜索简介",slug:"深度优先搜索简介",normalizedTitle:"深度优先搜索简介",charIndex:19},{level:4,title:"104 二叉树的最大深度",slug:"_104-二叉树的最大深度",normalizedTitle:"104 二叉树的最大深度",charIndex:1110},{level:4,title:"110 平衡二叉树",slug:"_110-平衡二叉树",normalizedTitle:"110 平衡二叉树",charIndex:1584},{level:4,title:"129 求根节点到叶节点数字之和",slug:"_129-求根节点到叶节点数字之和",normalizedTitle:"129 求根节点到叶节点数字之和",charIndex:2398},{level:4,title:"113 路径总和 II",slug:"_113-路径总和-ii",normalizedTitle:"113 路径总和 ii",charIndex:3360},{level:4,title:"437 路径总和 III",slug:"_437-路径总和-iii",normalizedTitle:"437 路径总和 iii",charIndex:4365},{level:4,title:"124 二叉树中的最大路径和",slug:"_124-二叉树中的最大路径和",normalizedTitle:"124 二叉树中的最大路径和",charIndex:5730}],headersStr:"02 树结构深度优先搜索 深度优先搜索简介 104 二叉树的最大深度 110 平衡二叉树 129 求根节点到叶节点数字之和 113 路径总和 II 437 路径总和 III 124 二叉树中的最大路径和",content:'# 02 树结构深度优先搜索\n\n\n# 深度优先搜索简介\n\n深度优先搜索（depth-first seach，DFS）在搜索到一个新的节点时，立即对该新节点进行遍历；因此遍历需要用先入后出的栈来实现，也可以通过与栈等价的递归来实现。\n\n对于树结构而言，由于总是对新节点调用遍历，因此看起来是向着 深 的方向前进，或者说是垂直方向。考虑如下一颗简单的树，由4 个节点构成共三层，其 DFS 过程如下图所示：\n\n\n\n我们从 0 号节点开始遍历，假如遍历顺序是从左子节点到右子节点，那么按照优先向着深的方向前进的策略，假如我们使用递归实现，我们的遍历过程为： 0（起始节点）->1（遍历更深一层的左子节点）->3（遍历更深一层的左子节点）->1（无子节点，返回父结点）->0（子节点均已完成遍历，返回父结点）->2（遍历更深一层的右子节点）->0（无子节点，返回父结点）-> 结束程序（子节点均已完成遍历）。如果我们使用栈实现，我们的栈顶元素的变化过程为 0->1->3->2。\n\nDFS 的两种形式：\n\n 1. 自上而下：把值通过参数的形式，从上往下传值；这种 DFS 形式一般自身不返回值，即函数返回值类型通常为void\n 2. 自下而上：这是使用 DFS 最为常见的形式，即把子问题的解（或值）从下往上传，上层的递归层利用下层传递来的值计算当前层的解（或值），并继续向上传递；这种 DFS 形式都有返回值。这种形式的调用过程一般是 "V" 字型的，先逐层向下要子问题的解，然后从最小子问题开始逐层向上利用子问题的解构造当前问题解并向上传递，最终形成整体解。\n\n树结构深度优先搜索编码模板：\n\n// 先序遍历\nvoid dfs(TreeNode* node){\n    if(!node){\n        return;\n    }\n    cout<<node->val;\n    dfs(node->left);\n    dfs(node->right);\n}\n// 中序遍历\nvoid dfs(TreeNode* node){\n    if(!node){\n        return;\n    }\n    dfs(node->left);\n    cout<<node->val;\n    dfs(node->right);\n}\n// 后序遍历\nvoid dfs(TreeNode* node){\n    if(!node){\n        return;\n    }\n    dfs(node->left);\n    dfs(node->right);\n    cout<<node->val;\n}\n\n\n# 104 二叉树的最大深度\n\n求一个二叉树的最大深度。\n\n输入是一个二叉树，输出是一个整数，表示该树的最大深度。\n\n> 输入： [3,9,20,null,null,15,7]，\n> \n>  3\n> / \\\n> 9  20\n> /   \\\n> 15   7\n> \n> \n> 输出：3\n> \n> 解释：返回它的最大深度 3\n\n解析：\n\n采用深度优先搜索，其子问题是：假设左子树和右子树的最大深度 l 和 r，那么该二叉树的最大深度即为 max(l,r)+1。终止条件是访问的节点为空，推出递归。\n\nclass Solution {\npublic:\n    int maxDepth(TreeNode* root) {\n        if(!root){\n            return 0;\n        }\n        int l = maxDepth(root->left);\n        int r = maxDepth(root->right);\n        return max(l,r)+1;\n    }\n};\n\n\n# 110 平衡二叉树\n\n判断一个二叉树是否平衡。树平衡的定义是，对于树上的任意节点，其两侧节点的最大深度的差值不得大于 1。\n\n输入是一个二叉树，输出一个布尔值，表示树是否平衡。\n\n> 输入：root = [1,2,2,3,3,null,null,4,4]\n> \n> 输出：false\n\n解析：\n\n本题的思路类似104 二叉树的最大深度，也是 DFS 的典型应用场景。不同的是在获取子树深度时要对当前左右子树的深度进行比较，如果还未遍历完二叉树就已经发现左右子树不平衡，则结束搜索直接返回 -1，避免再继续往下计算子树深度。\n\n提前返回 -1 中断子树深度计算要注意的是：第一次返回 -1 的判断条件是 abs(left - right) > 1；但是在往上回溯深度计算结果的过程中，如果出现了中断，那么回溯结果为 -1，这时表明下层子树出现了不平衡情况，所以上层返回 -1 的判断条件是 left == -1 || right == -1。\n\nclass Solution {\npublic:\n    int treeDepth(TreeNode* root){\n        if(!root){\n            return 0;\n        }\n        int l = treeDepth(root->left);\n        int r = treeDepth(root->right);\n        if(l==-1 || r==-1 || abs(l-r)>1){\n            return -1;\n        }\n        return max(l,r)+1;\n    }\n    \n    bool isBalanced(TreeNode* root) {\n        return treeDepth(root) != -1;\n    }\n};\n\n\n# 129 求根节点到叶节点数字之和\n\n给定一个二叉树的根节点 root ，树中每个节点都存放有一个 0 到 9 之间的数字。每条从根节点到叶节点的路径都代表一个数字，计算从根节点到叶节点生成的 所有数字之和。\n\n输入一个二叉树，输出一个整数表示所有数字之和。\n\n> 输入：root = [4,9,0,5,1]\n> \n>   4\n>  / \\\n>  9  0\n> / \\\n> 5 1\n> \n> \n> 输出：1026\n> \n> 解释：从根到叶子节点路径 4->9->5 代表数字 495；从根到叶子节点路径 4->9->1 代表数字 491；从根到叶子节点路径 4->0 代表数字 40。因此，数字总和 = 495 + 491 + 40 = 1026\n\n解析：\n\n本题可以采用自上而下的递归，首先根据当前节点之前路径所代表的数字计算新路径所代表的数字，然后递归向下传播该结果找出二叉树中所有的数字，并计算和。\n\n递推过程为：根据当前节点之前路径所代表的数字，计算加入当前节点后路径所代表的数字；当遍历到叶子节点时返回从根节点到该叶子节点所代表的数字；如果当前节点不是叶子节点则向左右子树递归计算路径所代表的数字，并计算以当前节点为根节点的子树的所有数字之和。\n\n终止条件是访问的节点为空，推出递归。\n\nclass Solution {\npublic:\n    int dfs(TreeNode* root, int preSum){\n        if(!root){\n            return 0;\n        }\n        int sum = preSum*10 + root->val;\n        if(root->left == nullptr && root->right == nullptr){\n            return sum;\n        }else{\n            return dfs(root->left,sum)+dfs(root->right,sum);\n        }\n    }\n\n    int sumNumbers(TreeNode* root) {\n        return dfs(root,0);\n    }\n};\n\n\n# 113 路径总和 II\n\n给定一个整数二叉树和一个目标值，找出所有 从根节点到叶子节点 路径总和等于给定目标值的路径。\n\n输入一个二叉树和一个给定整数，输出一个二维数组，表示满足条件的所有路径。\n\n> 输入：root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22\n> \n> 输出：[[5,4,11,2],[5,8,4,5]]\n\n解析：\n\n本题和129 求根节点到叶节点数字之和相似，也可以采用自上而下的递归。\n\n递推过程：自上而下递归遍历二叉树，每遍历一个节点，先将其加入当前路径并更新目标值为targetSum -= root->val；当遍历到叶子节点时，如果targetSum刚好等于 0，那么就找到了一条路径和为目标值的路径，将其加入结果集合。每遍完一个节点后，将其从当前路径中弹出，以便存储其他路径。\n\n终止条件是访问的节点为空，推出递归。\n\nclass Solution {\nprivate:\n    vector<vector<int>> res;\n    vector<int> path;\npublic:\n    void dfs(TreeNode* root, int targetSum){\n        if(!root){\n            return;\n        }\n        path.push_back(root->val);\n        targetSum -= root->val;\n        if(root->left==nullptr && root->right==nullptr && targetSum == 0){\n            res.push_back(path);\n        }\n        dfs(root->left,targetSum);\n        dfs(root->right,targetSum);\n        path.pop_back();\n    }\n\n    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {\n        dfs(root,targetSum);\n        return res;\n    }\n};\n\n\n# 437 路径总和 III\n\n给定一个整数二叉树，求有多少条路径节点值的和等于给定值。路径 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的。\n\n输入一个二叉树和一个给定整数，输出一个整数，表示有多少条满足条件的路径。\n\n> 输入：root = [10,5,-3,3,2,null,11,3,-2,null,1], targetSum = 8\n> \n> 输出：3\n> \n> 解释：和等于 8 的路径有 3 条，如图所示。\n\n解析：\n\n本题和113 路径总和 II的区别在于路径 不需要从根节点开始，也不需要在叶子节点结束，但是路径必须是由连续节点构成。所以本题可以在113题的基础上，递归过程中判断是否加入当前节点即可。\n\n所以在递归遍历每个节点计算路径和过程中，需要分情况考虑：\n\n * 如果选取该节点加入路径，则之后必须继续加入连续节点，或停止加入节点\n * 如果不选取该节点加入路径，则对其左右节点进行重新进行考虑\n\n我们需要一个计算路径和的辅助函数，用于计算以当前节点为根节点的子树中满足目标和的路径数量，该函数的实现思路与113题一致。\n\n然后在主函数中递归遍历每个节点，并分别计算加入当前节点的满足目标值的路径数目和不加入当前节点的满足目标值的路径数目，两种情况之和即为二叉树中所有满足条件的路径数目。\n\nclass Solution {\npublic:\n    int pathWithRoot(TreeNode* root, int sum){\n        if(!root){\n            return 0;\n        }\n        int count = 0;\n        // 如果当前节点值与路径和一致则形成一条路径\n        if(root->val == sum){\n            count = 1;\n        }else{\n            count = 0;\n        }\n        // 往左右子节点继续寻找路径\n        count += pathWithRoot(root->left, sum-root->val);\n        count += pathWithRoot(root->right, sum-root->val);\n        return count;\n    }\n\n    int pathSum(TreeNode* root, int targetSum) {\n        if(!root){\n            return 0;\n        }\n        // 将当前节点加入路径\n        int ans = 0;\n        ans = pathWithRoot(root,targetSum);\n        // 不将当前节点加入路径，从左右子节点开始寻找新路径\n        ans += pathSum(root->left,targetSum);\n        ans += pathSum(root->right,targetSum);\n        return ans;\n    }\n};\n\n\n# 124 二叉树中的最大路径和\n\n给定一个二叉树，返回其最大路径和。路径指的是二叉树中任一节点到达另一节点的节点序列。\n\n输入一个二叉树，输出一个整数表示最大路径和。\n\n> 输入：root = [-10,9,20,null,null,15,7]\n> \n>   -10\n>   / \\\n>  9  20\n>     / \\\n>    15  7\n> \n> \n> 输出：42\n> \n> 解释：最优路径是 15 -> 20 -> 7 ，路径和为 15 + 20 + 7 = 42\n\n解析：\n\n本题路径的定义和前面的不同，是指二叉树中任一节点到达另一节点的节点序列。所以本题不用考虑子树的情况，而是考虑计算二叉树中的一个节点的最大贡献值，就是在以该节点为根节点的子树中寻找以该节点为起点的一条路径，使得该路径上的节点值之和最大。\n\n我们实现一个辅助函数 maxGain(node)用于计算节点的最大贡献值，该函数的递归计算过程如下：\n\n * 空节点的最大贡献值等于 0\n\n * 非空节点的最大贡献值等于节点值与其子节点中的最大贡献值之和，对于叶节点而言，最大贡献值等于节点值\n\nclass Solution {\nprivate:\n    int maxSum = INT_MIN;\npublic:\n    int maxGain(TreeNode* root){\n        if(!root){\n            return 0;\n        }\n\n        int l = max(maxGain(root->left),0);\n        int r = max(maxGain(root->right),0);\n        int pathSum = root->val+l+r;\n        maxSum = max(maxSum,pathSum);\n        return root->val + max(l,r);\n    }\n\n    int maxPathSum(TreeNode* root) {\n        maxGain(root);\n        return maxSum;\n    }\n};\n',normalizedContent:'# 02 树结构深度优先搜索\n\n\n# 深度优先搜索简介\n\n深度优先搜索（depth-first seach，dfs）在搜索到一个新的节点时，立即对该新节点进行遍历；因此遍历需要用先入后出的栈来实现，也可以通过与栈等价的递归来实现。\n\n对于树结构而言，由于总是对新节点调用遍历，因此看起来是向着 深 的方向前进，或者说是垂直方向。考虑如下一颗简单的树，由4 个节点构成共三层，其 dfs 过程如下图所示：\n\n\n\n我们从 0 号节点开始遍历，假如遍历顺序是从左子节点到右子节点，那么按照优先向着深的方向前进的策略，假如我们使用递归实现，我们的遍历过程为： 0（起始节点）->1（遍历更深一层的左子节点）->3（遍历更深一层的左子节点）->1（无子节点，返回父结点）->0（子节点均已完成遍历，返回父结点）->2（遍历更深一层的右子节点）->0（无子节点，返回父结点）-> 结束程序（子节点均已完成遍历）。如果我们使用栈实现，我们的栈顶元素的变化过程为 0->1->3->2。\n\ndfs 的两种形式：\n\n 1. 自上而下：把值通过参数的形式，从上往下传值；这种 dfs 形式一般自身不返回值，即函数返回值类型通常为void\n 2. 自下而上：这是使用 dfs 最为常见的形式，即把子问题的解（或值）从下往上传，上层的递归层利用下层传递来的值计算当前层的解（或值），并继续向上传递；这种 dfs 形式都有返回值。这种形式的调用过程一般是 "v" 字型的，先逐层向下要子问题的解，然后从最小子问题开始逐层向上利用子问题的解构造当前问题解并向上传递，最终形成整体解。\n\n树结构深度优先搜索编码模板：\n\n// 先序遍历\nvoid dfs(treenode* node){\n    if(!node){\n        return;\n    }\n    cout<<node->val;\n    dfs(node->left);\n    dfs(node->right);\n}\n// 中序遍历\nvoid dfs(treenode* node){\n    if(!node){\n        return;\n    }\n    dfs(node->left);\n    cout<<node->val;\n    dfs(node->right);\n}\n// 后序遍历\nvoid dfs(treenode* node){\n    if(!node){\n        return;\n    }\n    dfs(node->left);\n    dfs(node->right);\n    cout<<node->val;\n}\n\n\n# 104 二叉树的最大深度\n\n求一个二叉树的最大深度。\n\n输入是一个二叉树，输出是一个整数，表示该树的最大深度。\n\n> 输入： [3,9,20,null,null,15,7]，\n> \n>  3\n> / \\\n> 9  20\n> /   \\\n> 15   7\n> \n> \n> 输出：3\n> \n> 解释：返回它的最大深度 3\n\n解析：\n\n采用深度优先搜索，其子问题是：假设左子树和右子树的最大深度 l 和 r，那么该二叉树的最大深度即为 max(l,r)+1。终止条件是访问的节点为空，推出递归。\n\nclass solution {\npublic:\n    int maxdepth(treenode* root) {\n        if(!root){\n            return 0;\n        }\n        int l = maxdepth(root->left);\n        int r = maxdepth(root->right);\n        return max(l,r)+1;\n    }\n};\n\n\n# 110 平衡二叉树\n\n判断一个二叉树是否平衡。树平衡的定义是，对于树上的任意节点，其两侧节点的最大深度的差值不得大于 1。\n\n输入是一个二叉树，输出一个布尔值，表示树是否平衡。\n\n> 输入：root = [1,2,2,3,3,null,null,4,4]\n> \n> 输出：false\n\n解析：\n\n本题的思路类似104 二叉树的最大深度，也是 dfs 的典型应用场景。不同的是在获取子树深度时要对当前左右子树的深度进行比较，如果还未遍历完二叉树就已经发现左右子树不平衡，则结束搜索直接返回 -1，避免再继续往下计算子树深度。\n\n提前返回 -1 中断子树深度计算要注意的是：第一次返回 -1 的判断条件是 abs(left - right) > 1；但是在往上回溯深度计算结果的过程中，如果出现了中断，那么回溯结果为 -1，这时表明下层子树出现了不平衡情况，所以上层返回 -1 的判断条件是 left == -1 || right == -1。\n\nclass solution {\npublic:\n    int treedepth(treenode* root){\n        if(!root){\n            return 0;\n        }\n        int l = treedepth(root->left);\n        int r = treedepth(root->right);\n        if(l==-1 || r==-1 || abs(l-r)>1){\n            return -1;\n        }\n        return max(l,r)+1;\n    }\n    \n    bool isbalanced(treenode* root) {\n        return treedepth(root) != -1;\n    }\n};\n\n\n# 129 求根节点到叶节点数字之和\n\n给定一个二叉树的根节点 root ，树中每个节点都存放有一个 0 到 9 之间的数字。每条从根节点到叶节点的路径都代表一个数字，计算从根节点到叶节点生成的 所有数字之和。\n\n输入一个二叉树，输出一个整数表示所有数字之和。\n\n> 输入：root = [4,9,0,5,1]\n> \n>   4\n>  / \\\n>  9  0\n> / \\\n> 5 1\n> \n> \n> 输出：1026\n> \n> 解释：从根到叶子节点路径 4->9->5 代表数字 495；从根到叶子节点路径 4->9->1 代表数字 491；从根到叶子节点路径 4->0 代表数字 40。因此，数字总和 = 495 + 491 + 40 = 1026\n\n解析：\n\n本题可以采用自上而下的递归，首先根据当前节点之前路径所代表的数字计算新路径所代表的数字，然后递归向下传播该结果找出二叉树中所有的数字，并计算和。\n\n递推过程为：根据当前节点之前路径所代表的数字，计算加入当前节点后路径所代表的数字；当遍历到叶子节点时返回从根节点到该叶子节点所代表的数字；如果当前节点不是叶子节点则向左右子树递归计算路径所代表的数字，并计算以当前节点为根节点的子树的所有数字之和。\n\n终止条件是访问的节点为空，推出递归。\n\nclass solution {\npublic:\n    int dfs(treenode* root, int presum){\n        if(!root){\n            return 0;\n        }\n        int sum = presum*10 + root->val;\n        if(root->left == nullptr && root->right == nullptr){\n            return sum;\n        }else{\n            return dfs(root->left,sum)+dfs(root->right,sum);\n        }\n    }\n\n    int sumnumbers(treenode* root) {\n        return dfs(root,0);\n    }\n};\n\n\n# 113 路径总和 ii\n\n给定一个整数二叉树和一个目标值，找出所有 从根节点到叶子节点 路径总和等于给定目标值的路径。\n\n输入一个二叉树和一个给定整数，输出一个二维数组，表示满足条件的所有路径。\n\n> 输入：root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetsum = 22\n> \n> 输出：[[5,4,11,2],[5,8,4,5]]\n\n解析：\n\n本题和129 求根节点到叶节点数字之和相似，也可以采用自上而下的递归。\n\n递推过程：自上而下递归遍历二叉树，每遍历一个节点，先将其加入当前路径并更新目标值为targetsum -= root->val；当遍历到叶子节点时，如果targetsum刚好等于 0，那么就找到了一条路径和为目标值的路径，将其加入结果集合。每遍完一个节点后，将其从当前路径中弹出，以便存储其他路径。\n\n终止条件是访问的节点为空，推出递归。\n\nclass solution {\nprivate:\n    vector<vector<int>> res;\n    vector<int> path;\npublic:\n    void dfs(treenode* root, int targetsum){\n        if(!root){\n            return;\n        }\n        path.push_back(root->val);\n        targetsum -= root->val;\n        if(root->left==nullptr && root->right==nullptr && targetsum == 0){\n            res.push_back(path);\n        }\n        dfs(root->left,targetsum);\n        dfs(root->right,targetsum);\n        path.pop_back();\n    }\n\n    vector<vector<int>> pathsum(treenode* root, int targetsum) {\n        dfs(root,targetsum);\n        return res;\n    }\n};\n\n\n# 437 路径总和 iii\n\n给定一个整数二叉树，求有多少条路径节点值的和等于给定值。路径 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的。\n\n输入一个二叉树和一个给定整数，输出一个整数，表示有多少条满足条件的路径。\n\n> 输入：root = [10,5,-3,3,2,null,11,3,-2,null,1], targetsum = 8\n> \n> 输出：3\n> \n> 解释：和等于 8 的路径有 3 条，如图所示。\n\n解析：\n\n本题和113 路径总和 ii的区别在于路径 不需要从根节点开始，也不需要在叶子节点结束，但是路径必须是由连续节点构成。所以本题可以在113题的基础上，递归过程中判断是否加入当前节点即可。\n\n所以在递归遍历每个节点计算路径和过程中，需要分情况考虑：\n\n * 如果选取该节点加入路径，则之后必须继续加入连续节点，或停止加入节点\n * 如果不选取该节点加入路径，则对其左右节点进行重新进行考虑\n\n我们需要一个计算路径和的辅助函数，用于计算以当前节点为根节点的子树中满足目标和的路径数量，该函数的实现思路与113题一致。\n\n然后在主函数中递归遍历每个节点，并分别计算加入当前节点的满足目标值的路径数目和不加入当前节点的满足目标值的路径数目，两种情况之和即为二叉树中所有满足条件的路径数目。\n\nclass solution {\npublic:\n    int pathwithroot(treenode* root, int sum){\n        if(!root){\n            return 0;\n        }\n        int count = 0;\n        // 如果当前节点值与路径和一致则形成一条路径\n        if(root->val == sum){\n            count = 1;\n        }else{\n            count = 0;\n        }\n        // 往左右子节点继续寻找路径\n        count += pathwithroot(root->left, sum-root->val);\n        count += pathwithroot(root->right, sum-root->val);\n        return count;\n    }\n\n    int pathsum(treenode* root, int targetsum) {\n        if(!root){\n            return 0;\n        }\n        // 将当前节点加入路径\n        int ans = 0;\n        ans = pathwithroot(root,targetsum);\n        // 不将当前节点加入路径，从左右子节点开始寻找新路径\n        ans += pathsum(root->left,targetsum);\n        ans += pathsum(root->right,targetsum);\n        return ans;\n    }\n};\n\n\n# 124 二叉树中的最大路径和\n\n给定一个二叉树，返回其最大路径和。路径指的是二叉树中任一节点到达另一节点的节点序列。\n\n输入一个二叉树，输出一个整数表示最大路径和。\n\n> 输入：root = [-10,9,20,null,null,15,7]\n> \n>   -10\n>   / \\\n>  9  20\n>     / \\\n>    15  7\n> \n> \n> 输出：42\n> \n> 解释：最优路径是 15 -> 20 -> 7 ，路径和为 15 + 20 + 7 = 42\n\n解析：\n\n本题路径的定义和前面的不同，是指二叉树中任一节点到达另一节点的节点序列。所以本题不用考虑子树的情况，而是考虑计算二叉树中的一个节点的最大贡献值，就是在以该节点为根节点的子树中寻找以该节点为起点的一条路径，使得该路径上的节点值之和最大。\n\n我们实现一个辅助函数 maxgain(node)用于计算节点的最大贡献值，该函数的递归计算过程如下：\n\n * 空节点的最大贡献值等于 0\n\n * 非空节点的最大贡献值等于节点值与其子节点中的最大贡献值之和，对于叶节点而言，最大贡献值等于节点值\n\nclass solution {\nprivate:\n    int maxsum = int_min;\npublic:\n    int maxgain(treenode* root){\n        if(!root){\n            return 0;\n        }\n\n        int l = max(maxgain(root->left),0);\n        int r = max(maxgain(root->right),0);\n        int pathsum = root->val+l+r;\n        maxsum = max(maxsum,pathsum);\n        return root->val + max(l,r);\n    }\n\n    int maxpathsum(treenode* root) {\n        maxgain(root);\n        return maxsum;\n    }\n};\n',charsets:{cjk:!0},lastUpdated:"2023/11/19, 12:55:48",lastUpdatedTimestamp:1700369748e3},{title:"06树结构广度优先搜索",frontmatter:{title:"06树结构广度优先搜索",date:"2023-03-24T18:39:49.000Z",permalink:"/pages/5134a9/"},regularPath:"/03.LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/01.%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/04.%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/06.%E6%A0%91%E7%BB%93%E6%9E%84%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2.html",relativePath:"03.LeetCode刷题笔记/01.基础算法/04.优先搜索/06.树结构广度优先搜索.md",key:"v-74e5670c",path:"/pages/5134a9/",headers:[{level:2,title:"04 树结构广度优先搜索",slug:"_04-树结构广度优先搜索",normalizedTitle:"04 树结构广度优先搜索",charIndex:2},{level:3,title:"广度优先搜索简介",slug:"广度优先搜索简介",normalizedTitle:"广度优先搜索简介",charIndex:19},{level:4,title:"102 二叉树的层序遍历",slug:"_102-二叉树的层序遍历",normalizedTitle:"102 二叉树的层序遍历",charIndex:645},{level:4,title:"107 二叉树的层序遍历 II",slug:"_107-二叉树的层序遍历-ii",normalizedTitle:"107 二叉树的层序遍历 ii",charIndex:1831},{level:4,title:"429 N 叉树的层序遍历",slug:"_429-n-叉树的层序遍历",normalizedTitle:"429 n 叉树的层序遍历",charIndex:2980},{level:4,title:"199 二叉树的右视图",slug:"_199-二叉树的右视图",normalizedTitle:"199 二叉树的右视图",charIndex:4015},{level:4,title:"515 在每个树行中找最大值",slug:"_515-在每个树行中找最大值",normalizedTitle:"515 在每个树行中找最大值",charIndex:4961},{level:4,title:"637 二叉树的层平均值",slug:"_637-二叉树的层平均值",normalizedTitle:"637 二叉树的层平均值",charIndex:5956},{level:4,title:"116 填充每个节点的下一个右侧节点指针",slug:"_116-填充每个节点的下一个右侧节点指针",normalizedTitle:"116 填充每个节点的下一个右侧节点指针",charIndex:6929},{level:4,title:"111 二叉树的最小深度",slug:"_111-二叉树的最小深度",normalizedTitle:"111 二叉树的最小深度",charIndex:8265},{level:4,title:"257 二叉树的所有路径",slug:"_257-二叉树的所有路径",normalizedTitle:"257 二叉树的所有路径",charIndex:9287}],headersStr:"04 树结构广度优先搜索 广度优先搜索简介 102 二叉树的层序遍历 107 二叉树的层序遍历 II 429 N 叉树的层序遍历 199 二叉树的右视图 515 在每个树行中找最大值 637 二叉树的层平均值 116 填充每个节点的下一个右侧节点指针 111 二叉树的最小深度 257 二叉树的所有路径",content:"# 04 树结构广度优先搜索\n\n\n# 广度优先搜索简介\n\n广度优先搜索（breadth-first search，BFS）不同与深度优先搜索，它是一层层进行遍历的，因 此需要用先入先出的队列而非先入后出的栈进行遍历。由于是按层次进行遍历，广度优先搜索时按照广的方向进行遍历的，也常常用来处理最短路径等问题。\n\n考虑如下一颗简单的树。我们从 0 号节点开始遍历，假如遍历顺序是从左子节点到右子节点，那么按照优先向着“广”的方向前进的策略，队列顶端的元素变化过程为 [0]->[1->2]->[3]，其中方括号代表每一层的元素。\n\n\n\n树结构深度优先搜索编码模板：\n\nvoid bfs(TreeNode* root) {\n    queue<TreeNode*> queue;\n    queue.push(root);\n    while (!queue.isEmpty()) {\n        auto node = queue.front();\n        queue.pop();\n        cout<<node->val;\n        if (node->left != null) {\n            queue.push(node->left);\n        }\n        if (node->right != null) {\n            queue.push(node->right);\n        }\n    }\n}\n\n\n# 102 二叉树的层序遍历\n\n给定一个二叉树，请返回其按 层序遍历 得到的节点值。\n\n输入一个二叉树，输出一个二维数组表示二叉树的层序遍历结果。\n\n输入：[3,9,20,null,null,15,7]\n    3\n   / \\\n  9  20\n    /  \\\n   15   7\n输出:[[3],[9,20],[15,7]]\n\n\n解析：\n\n通常使用广度优先搜索进行层次遍历，使用一个队列存储当前层的所有节点。\n\n在开始遍历一层的节点时，当前队列中的节点数就是当前层的节点数。\n\n只要控制遍历这么多节点数，每遍历一个当前层的节点，将其出队列同时将其子节点入队列。\n\n通过这种操作就能保证每次遍历的队列中都是当前层的节点，达到逐层遍历的目的。\n\nclass Solution {\npublic:\n    vector<vector<int>> levelOrder(TreeNode* root) {\n        vector<vector<int>> ans;\n        if(!root){\n            return ans;\n        }\n        queue<TreeNode*> queue;\n        queue.push(root);\n        while(!queue.empty()){\n            int len = queue.size();\n            vector<int> levelNode;\n            // 逐层将下一层节点压入队列，保证队列中始终为同一层的节点\n            for(int i=0;i<len;++i){\n                auto node = queue.front();\n                queue.pop();\n                // 记录同一层节点值\n                levelNode.push_back(node->val);\n                if(node->left){\n                    queue.push(node->left);\n                }\n                if(node->right){\n                    queue.push(node->right);\n                }\n            }\n            // 将一层遍历结果加入结果集\n            ans.push_back(levelNode);\n        }\n        return ans;\n    }\n}; \n\n\n# 107 二叉树的层序遍历 II\n\n给定一个二叉树，请返回其节点值自底向上的 层序遍历 结果。\n\n输入一个二叉树，输出一个二维数组表示二叉树的层序遍历结果。\n\n输入：[3,9,20,null,null,15,7]\n    3\n   / \\\n  9  20\n    /  \\\n   15   7\n输出:[[15,7],[9,20],[3]]\n\n\n解析：\n\n本题与102 二叉树的层序遍历几乎没有差别。唯一的区别是本题要求从下到上输出每一层的节点值，所以只要对102题的过程稍作修改即可：在遍历完一层节点之后，将存储该层节点值的列表添加到结果列表的头部。\n\n在C++实现中，我们将102题的结果，使用reverse()方法将结果翻转即可。\n\nclass Solution {\npublic:\n    vector<vector<int>> levelOrderBottom(TreeNode* root) {\n        vector<vector<int>> ans;\n        if(!root){\n            return ans;\n        }\n        queue<TreeNode*> queue;\n        queue.push(root);\n        while(!queue.empty()){\n            int len = queue.size();\n            vector<int> levelNode;\n            for(int i=0;i<len;++i){\n                auto node = queue.front();\n                queue.pop();\n                levelNode.push_back(node->val);\n                if(node->left){\n                    queue.push(node->left);\n                }\n                if(node->right){\n                    queue.push(node->right);\n                }\n            }\n            ans.push_back(levelNode);\n        }\n        // 反转层次遍历结果\n        reverse(ans.begin(),ans.end());\n        return ans;\n    }\n};\n\n\n# 429 N 叉树的层序遍历\n\n给定一个 N 叉树，请返回其按 层序遍历 得到的节点值。\n\n输入一个 N 叉树，输出一个二维数组表示 N 叉树的层序遍历结果。\n\n输入：root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]\n输出：[[1],[2,3,4,5],[6,7,8,9,10],[11,12,13],[14]]\n\n\n解析：\n\n本题与102 二叉树的层序遍历的思路一致，区别在于 N 叉树每个非叶子节点有多个子节点，但是本质上并没有什么差别。在二叉树的广度优先遍历中，我们使用两个if语句判断是否存在左右节点；在 N 叉树中我们只需要使用一个循环判断存在的所有子节点即可。\n\nclass Solution {\npublic:\n    vector<vector<int>> levelOrder(Node* root) {\n        vector<vector<int>> ans;\n        if(!root){\n            return ans;\n        }\n        queue<Node*> queue;\n        queue.push(root);\n        while(!queue.empty()){\n            int len = queue.size();\n            vector<int> levelNode;\n            for(int i=0;i<len;++i){\n                auto node = queue.front();\n                queue.pop();\n                levelNode.push_back(node->val);\n                for(auto ch_node:node->children){\n                    queue.push(ch_node);\n                }\n            }\n            ans.push_back(levelNode);\n        }\n        return ans;\n    }\n};\n\n\n# 199 二叉树的右视图\n\n给定一个二叉树的 根节点 root，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。\n\n输入一个二叉树，输出一个数组表示从右侧所能看到的节点值。\n\n输入: [1,2,3,null,5,null,4]\n输出: [1,3,4]\n\n\n解析：\n\n本题也是二叉树层次遍历的一种应用，所谓的右视图其实就是层次遍历中每一层的最右侧元素构成的。所以我们还是使用层次遍历，在每一层的遍历过程中，保留最右侧元素值。\n\nclass Solution {\npublic:\n    vector<int> rightSideView(TreeNode* root) {\n        vector<int> ans;\n        if(!root){\n            return ans;\n        }\n        queue<TreeNode*> queue;\n        queue.push(root);\n        while(!queue.empty()){\n            int len = queue.size();\n            int rsh_node;\n            for(int i=0;i<len;++i){\n                auto node = queue.front();\n                queue.pop();\n                rsh_node = node->val;\n                if(node->left){\n                    queue.push(node->left);\n                }\n                if(node->right){\n                    queue.push(node->right);\n                }\n            }\n            ans.push_back(rsh_node);\n        }\n        return ans;\n    }\n};\n\n\n# 515 在每个树行中找最大值\n\n给定一棵二叉树的根节点 root ，找出该二叉树中每一层的最大值。\n\n输入一个二叉树，输出一个数组表示二叉树每层的最大值。\n\n输入: root = [1,3,2,5,3,null,9]\n输出: [1,3,9]\n解释:\n          1\n         / \\\n        3   2\n       / \\   \\  \n      5   3   9 \n\n\n解析：\n\n本题还是使用广度优先搜索实现层次遍历，在每一层遍历中记录该层最大值即可。\n\nclass Solution {\npublic:\n    vector<int> largestValues(TreeNode* root) {\n        vector<int> ans;\n        if(!root){\n            return ans;\n        }\n        queue<TreeNode*> queue;\n        queue.push(root);\n        while(!queue.empty()){\n            int len = queue.size();\n            int maxElem = INT_MIN;\n            for(int i=0;i<len;++i){\n                auto node = queue.front();\n                queue.pop();\n                maxElem = max(maxElem,node->val);\n                if(node->left){\n                    queue.push(node->left);\n                }\n                if(node->right){\n                    queue.push(node->right);\n                }\n            }\n            ans.push_back(maxElem);\n        }\n        return ans;\n    }\n};\n\n\n# 637 二叉树的层平均值\n\n给定一个非空二叉树, 返回一个由每层节点平均值组成的数组。\n\n输入一个二叉树，输出一个数组表示二叉树每层的平均值。\n\n输入：\n    3\n   / \\\n  9  20\n    /  \\\n   15   7\n输出：[3, 14.5, 11]\n解释：第 0 层的平均值是 3 ,  第1层是 14.5 , 第2层是 11 。因此返回 [3, 14.5, 11] 。\n\n\n解析：\n\n本题还是使用广度优先搜索实现层次遍历，在每一层遍历中记录该层所有节点值之和并计算平均值即可。\n\nclass Solution {\npublic:\n    vector<double> averageOfLevels(TreeNode* root) {\n        vector<double> ans;\n        if(!root){\n            return ans;\n        }\n        queue<TreeNode*> queue;\n        queue.push(root);\n        while(!queue.empty()){\n           int len = queue.size();\n           double sum = 0;\n           for(int i=0;i<len;++i){\n               auto node = queue.front();\n               queue.pop();\n               sum += node->val;\n               if(node->left){\n                   queue.push(node->left);\n               }\n               if(node->right){\n                   queue.push(node->right);\n               }\n           }\n           ans.push_back(sum/len);\n        }\n        return ans;\n    }\n};\n\n\n# 116 填充每个节点的下一个右侧节点指针\n\n给定一个 完美二叉树 ，其所有叶子节点都在同一层，每个父节点都有两个子节点。填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。\n\n输入一个二叉树，输出一个填充next指针后的图。\n\n输入：root = [1,2,3,4,5,6,7]\n输出：[1,#,2,3,#,4,5,6,7,#]\n解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。序列化的输出按层序遍历排列，同一层节点由 next 指针连接，'#' 标志着每一层的结束。\n\n\n解析：\n\n本题我们也使用对二叉树进行层次遍历的方式解决，在层次遍历的过程中将我们将二叉树每一层的节点拿出来遍历并连接。\n\n层次遍历基于广度优先搜索，它与广度优先搜索的不同之处在于，广度优先搜索每次只会取出一个节点来拓展，而层次遍历会每次将队列中的所有元素都拿出来拓展，这样能保证每次从队列中拿出来遍历的元素都是属于同一层的。\n\n通过层序遍历我们可以获取二叉树每一层的节点，剩下的工作就是在每一层的遍历过程中修改每个节点的 next 指针，将队头节点的next指向到下一任队头；同时将当前层的左右节点压入队列，拓展下一层的新队列。\n\n本题层序遍历的思路不要求二叉树是完美二叉树，所以本题代码可以直接用于117 填充每个节点的下一个右侧节点指针 II\n\nclass Solution {\npublic:\n    Node* connect(Node* root) {\n       if(!root){\n           return nullptr;\n       } \n       queue<Node*> queue;\n       queue.push(root);\n       while(!queue.empty()){\n           int len = queue.size();\n           for(int i=0;i<len;++i){\n               auto node = queue.front();\n               queue.pop();\n               // 队头出队列之后，将其next指向当前队头\n               if(i<len-1){\n                   node->next = queue.front();\n               }\n               if(node->left){\n                   queue.push(node->left);\n               }\n               if(node->right){\n                   queue.push(node->right);\n               }\n           }\n       }\n       return root;\n    }\n};\n\n\n# 111 二叉树的最小深度\n\n给定一个二叉树，找出其最小深度。最小深度是从根节点到最近叶子节点的最短路径上的节点数量。\n\n输入一个二叉树，输出一个整数表示最小深度。\n\n输入：root = [3,9,20,null,null,15,7]\n     3\n    / \\\n   9  20\n      / \\\n     15  7\n输出：2\n\n\n解析：\n\n深度问题使用深度优先搜索可以更加方便的解决，但是本题求的是最小深度，所以用广度优先搜索在一定程度上可以带来更高的效率。\n\n我们仍用自上而下层次遍历的方式计算最小深度，当某一层中出现了没有叶子节点的节点值返回当前深度即为最小深度。\n\nclass Solution {\npublic:\n    int minDepth(TreeNode* root) {\n        int ans = 0;\n        if(!root){\n            return ans;\n        }\n        queue<TreeNode*> queue;\n        queue.push(root);\n        while(!queue.empty()){\n            ++ans;\n            int len = queue.size();\n            for(int i=0;i<len;++i){\n                auto node = queue.front();\n                queue.pop();\n                if(!node->left && !node->right){\n                    return ans;\n                }\n                if(node->left){\n                    queue.push(node->left);\n                }\n                if(node->right){\n                    queue.push(node->right);\n                }\n            }\n        }\n        return ans;\n    }\n};\n\n\n# 257 二叉树的所有路径",normalizedContent:"# 04 树结构广度优先搜索\n\n\n# 广度优先搜索简介\n\n广度优先搜索（breadth-first search，bfs）不同与深度优先搜索，它是一层层进行遍历的，因 此需要用先入先出的队列而非先入后出的栈进行遍历。由于是按层次进行遍历，广度优先搜索时按照广的方向进行遍历的，也常常用来处理最短路径等问题。\n\n考虑如下一颗简单的树。我们从 0 号节点开始遍历，假如遍历顺序是从左子节点到右子节点，那么按照优先向着“广”的方向前进的策略，队列顶端的元素变化过程为 [0]->[1->2]->[3]，其中方括号代表每一层的元素。\n\n\n\n树结构深度优先搜索编码模板：\n\nvoid bfs(treenode* root) {\n    queue<treenode*> queue;\n    queue.push(root);\n    while (!queue.isempty()) {\n        auto node = queue.front();\n        queue.pop();\n        cout<<node->val;\n        if (node->left != null) {\n            queue.push(node->left);\n        }\n        if (node->right != null) {\n            queue.push(node->right);\n        }\n    }\n}\n\n\n# 102 二叉树的层序遍历\n\n给定一个二叉树，请返回其按 层序遍历 得到的节点值。\n\n输入一个二叉树，输出一个二维数组表示二叉树的层序遍历结果。\n\n输入：[3,9,20,null,null,15,7]\n    3\n   / \\\n  9  20\n    /  \\\n   15   7\n输出:[[3],[9,20],[15,7]]\n\n\n解析：\n\n通常使用广度优先搜索进行层次遍历，使用一个队列存储当前层的所有节点。\n\n在开始遍历一层的节点时，当前队列中的节点数就是当前层的节点数。\n\n只要控制遍历这么多节点数，每遍历一个当前层的节点，将其出队列同时将其子节点入队列。\n\n通过这种操作就能保证每次遍历的队列中都是当前层的节点，达到逐层遍历的目的。\n\nclass solution {\npublic:\n    vector<vector<int>> levelorder(treenode* root) {\n        vector<vector<int>> ans;\n        if(!root){\n            return ans;\n        }\n        queue<treenode*> queue;\n        queue.push(root);\n        while(!queue.empty()){\n            int len = queue.size();\n            vector<int> levelnode;\n            // 逐层将下一层节点压入队列，保证队列中始终为同一层的节点\n            for(int i=0;i<len;++i){\n                auto node = queue.front();\n                queue.pop();\n                // 记录同一层节点值\n                levelnode.push_back(node->val);\n                if(node->left){\n                    queue.push(node->left);\n                }\n                if(node->right){\n                    queue.push(node->right);\n                }\n            }\n            // 将一层遍历结果加入结果集\n            ans.push_back(levelnode);\n        }\n        return ans;\n    }\n}; \n\n\n# 107 二叉树的层序遍历 ii\n\n给定一个二叉树，请返回其节点值自底向上的 层序遍历 结果。\n\n输入一个二叉树，输出一个二维数组表示二叉树的层序遍历结果。\n\n输入：[3,9,20,null,null,15,7]\n    3\n   / \\\n  9  20\n    /  \\\n   15   7\n输出:[[15,7],[9,20],[3]]\n\n\n解析：\n\n本题与102 二叉树的层序遍历几乎没有差别。唯一的区别是本题要求从下到上输出每一层的节点值，所以只要对102题的过程稍作修改即可：在遍历完一层节点之后，将存储该层节点值的列表添加到结果列表的头部。\n\n在c++实现中，我们将102题的结果，使用reverse()方法将结果翻转即可。\n\nclass solution {\npublic:\n    vector<vector<int>> levelorderbottom(treenode* root) {\n        vector<vector<int>> ans;\n        if(!root){\n            return ans;\n        }\n        queue<treenode*> queue;\n        queue.push(root);\n        while(!queue.empty()){\n            int len = queue.size();\n            vector<int> levelnode;\n            for(int i=0;i<len;++i){\n                auto node = queue.front();\n                queue.pop();\n                levelnode.push_back(node->val);\n                if(node->left){\n                    queue.push(node->left);\n                }\n                if(node->right){\n                    queue.push(node->right);\n                }\n            }\n            ans.push_back(levelnode);\n        }\n        // 反转层次遍历结果\n        reverse(ans.begin(),ans.end());\n        return ans;\n    }\n};\n\n\n# 429 n 叉树的层序遍历\n\n给定一个 n 叉树，请返回其按 层序遍历 得到的节点值。\n\n输入一个 n 叉树，输出一个二维数组表示 n 叉树的层序遍历结果。\n\n输入：root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]\n输出：[[1],[2,3,4,5],[6,7,8,9,10],[11,12,13],[14]]\n\n\n解析：\n\n本题与102 二叉树的层序遍历的思路一致，区别在于 n 叉树每个非叶子节点有多个子节点，但是本质上并没有什么差别。在二叉树的广度优先遍历中，我们使用两个if语句判断是否存在左右节点；在 n 叉树中我们只需要使用一个循环判断存在的所有子节点即可。\n\nclass solution {\npublic:\n    vector<vector<int>> levelorder(node* root) {\n        vector<vector<int>> ans;\n        if(!root){\n            return ans;\n        }\n        queue<node*> queue;\n        queue.push(root);\n        while(!queue.empty()){\n            int len = queue.size();\n            vector<int> levelnode;\n            for(int i=0;i<len;++i){\n                auto node = queue.front();\n                queue.pop();\n                levelnode.push_back(node->val);\n                for(auto ch_node:node->children){\n                    queue.push(ch_node);\n                }\n            }\n            ans.push_back(levelnode);\n        }\n        return ans;\n    }\n};\n\n\n# 199 二叉树的右视图\n\n给定一个二叉树的 根节点 root，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。\n\n输入一个二叉树，输出一个数组表示从右侧所能看到的节点值。\n\n输入: [1,2,3,null,5,null,4]\n输出: [1,3,4]\n\n\n解析：\n\n本题也是二叉树层次遍历的一种应用，所谓的右视图其实就是层次遍历中每一层的最右侧元素构成的。所以我们还是使用层次遍历，在每一层的遍历过程中，保留最右侧元素值。\n\nclass solution {\npublic:\n    vector<int> rightsideview(treenode* root) {\n        vector<int> ans;\n        if(!root){\n            return ans;\n        }\n        queue<treenode*> queue;\n        queue.push(root);\n        while(!queue.empty()){\n            int len = queue.size();\n            int rsh_node;\n            for(int i=0;i<len;++i){\n                auto node = queue.front();\n                queue.pop();\n                rsh_node = node->val;\n                if(node->left){\n                    queue.push(node->left);\n                }\n                if(node->right){\n                    queue.push(node->right);\n                }\n            }\n            ans.push_back(rsh_node);\n        }\n        return ans;\n    }\n};\n\n\n# 515 在每个树行中找最大值\n\n给定一棵二叉树的根节点 root ，找出该二叉树中每一层的最大值。\n\n输入一个二叉树，输出一个数组表示二叉树每层的最大值。\n\n输入: root = [1,3,2,5,3,null,9]\n输出: [1,3,9]\n解释:\n          1\n         / \\\n        3   2\n       / \\   \\  \n      5   3   9 \n\n\n解析：\n\n本题还是使用广度优先搜索实现层次遍历，在每一层遍历中记录该层最大值即可。\n\nclass solution {\npublic:\n    vector<int> largestvalues(treenode* root) {\n        vector<int> ans;\n        if(!root){\n            return ans;\n        }\n        queue<treenode*> queue;\n        queue.push(root);\n        while(!queue.empty()){\n            int len = queue.size();\n            int maxelem = int_min;\n            for(int i=0;i<len;++i){\n                auto node = queue.front();\n                queue.pop();\n                maxelem = max(maxelem,node->val);\n                if(node->left){\n                    queue.push(node->left);\n                }\n                if(node->right){\n                    queue.push(node->right);\n                }\n            }\n            ans.push_back(maxelem);\n        }\n        return ans;\n    }\n};\n\n\n# 637 二叉树的层平均值\n\n给定一个非空二叉树, 返回一个由每层节点平均值组成的数组。\n\n输入一个二叉树，输出一个数组表示二叉树每层的平均值。\n\n输入：\n    3\n   / \\\n  9  20\n    /  \\\n   15   7\n输出：[3, 14.5, 11]\n解释：第 0 层的平均值是 3 ,  第1层是 14.5 , 第2层是 11 。因此返回 [3, 14.5, 11] 。\n\n\n解析：\n\n本题还是使用广度优先搜索实现层次遍历，在每一层遍历中记录该层所有节点值之和并计算平均值即可。\n\nclass solution {\npublic:\n    vector<double> averageoflevels(treenode* root) {\n        vector<double> ans;\n        if(!root){\n            return ans;\n        }\n        queue<treenode*> queue;\n        queue.push(root);\n        while(!queue.empty()){\n           int len = queue.size();\n           double sum = 0;\n           for(int i=0;i<len;++i){\n               auto node = queue.front();\n               queue.pop();\n               sum += node->val;\n               if(node->left){\n                   queue.push(node->left);\n               }\n               if(node->right){\n                   queue.push(node->right);\n               }\n           }\n           ans.push_back(sum/len);\n        }\n        return ans;\n    }\n};\n\n\n# 116 填充每个节点的下一个右侧节点指针\n\n给定一个 完美二叉树 ，其所有叶子节点都在同一层，每个父节点都有两个子节点。填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 null。\n\n输入一个二叉树，输出一个填充next指针后的图。\n\n输入：root = [1,2,3,4,5,6,7]\n输出：[1,#,2,3,#,4,5,6,7,#]\n解释：给定二叉树如图 a 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 b 所示。序列化的输出按层序遍历排列，同一层节点由 next 指针连接，'#' 标志着每一层的结束。\n\n\n解析：\n\n本题我们也使用对二叉树进行层次遍历的方式解决，在层次遍历的过程中将我们将二叉树每一层的节点拿出来遍历并连接。\n\n层次遍历基于广度优先搜索，它与广度优先搜索的不同之处在于，广度优先搜索每次只会取出一个节点来拓展，而层次遍历会每次将队列中的所有元素都拿出来拓展，这样能保证每次从队列中拿出来遍历的元素都是属于同一层的。\n\n通过层序遍历我们可以获取二叉树每一层的节点，剩下的工作就是在每一层的遍历过程中修改每个节点的 next 指针，将队头节点的next指向到下一任队头；同时将当前层的左右节点压入队列，拓展下一层的新队列。\n\n本题层序遍历的思路不要求二叉树是完美二叉树，所以本题代码可以直接用于117 填充每个节点的下一个右侧节点指针 ii\n\nclass solution {\npublic:\n    node* connect(node* root) {\n       if(!root){\n           return nullptr;\n       } \n       queue<node*> queue;\n       queue.push(root);\n       while(!queue.empty()){\n           int len = queue.size();\n           for(int i=0;i<len;++i){\n               auto node = queue.front();\n               queue.pop();\n               // 队头出队列之后，将其next指向当前队头\n               if(i<len-1){\n                   node->next = queue.front();\n               }\n               if(node->left){\n                   queue.push(node->left);\n               }\n               if(node->right){\n                   queue.push(node->right);\n               }\n           }\n       }\n       return root;\n    }\n};\n\n\n# 111 二叉树的最小深度\n\n给定一个二叉树，找出其最小深度。最小深度是从根节点到最近叶子节点的最短路径上的节点数量。\n\n输入一个二叉树，输出一个整数表示最小深度。\n\n输入：root = [3,9,20,null,null,15,7]\n     3\n    / \\\n   9  20\n      / \\\n     15  7\n输出：2\n\n\n解析：\n\n深度问题使用深度优先搜索可以更加方便的解决，但是本题求的是最小深度，所以用广度优先搜索在一定程度上可以带来更高的效率。\n\n我们仍用自上而下层次遍历的方式计算最小深度，当某一层中出现了没有叶子节点的节点值返回当前深度即为最小深度。\n\nclass solution {\npublic:\n    int mindepth(treenode* root) {\n        int ans = 0;\n        if(!root){\n            return ans;\n        }\n        queue<treenode*> queue;\n        queue.push(root);\n        while(!queue.empty()){\n            ++ans;\n            int len = queue.size();\n            for(int i=0;i<len;++i){\n                auto node = queue.front();\n                queue.pop();\n                if(!node->left && !node->right){\n                    return ans;\n                }\n                if(node->left){\n                    queue.push(node->left);\n                }\n                if(node->right){\n                    queue.push(node->right);\n                }\n            }\n        }\n        return ans;\n    }\n};\n\n\n# 257 二叉树的所有路径",charsets:{cjk:!0},lastUpdated:"2023/11/19, 12:55:48",lastUpdatedTimestamp:1700369748e3},{title:"04图结构深度优先搜索",frontmatter:{title:"04图结构深度优先搜索",date:"2023-03-24T18:39:49.000Z",permalink:"/pages/13d287/"},regularPath:"/03.LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/01.%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/04.%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/04.%E5%9B%BE%E7%BB%93%E6%9E%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2.html",relativePath:"03.LeetCode刷题笔记/01.基础算法/04.优先搜索/04.图结构深度优先搜索.md",key:"v-45d40013",path:"/pages/13d287/",headers:[{level:2,title:"02 图结构深度优先搜索",slug:"_02-图结构深度优先搜索",normalizedTitle:"02 图结构深度优先搜索",charIndex:2},{level:3,title:"深度优先搜索简介",slug:"深度优先搜索简介",normalizedTitle:"深度优先搜索简介",charIndex:19},{level:4,title:"547 省份数量",slug:"_547-省份数量",normalizedTitle:"547 省份数量",charIndex:552}],headersStr:"02 图结构深度优先搜索 深度优先搜索简介 547 省份数量",content:"# 02 图结构深度优先搜索\n\n\n# 深度优先搜索简介\n\n深度优先搜索（depth-first seach，DFS）在搜索到一个新的节点时，立即对该新节点进行遍历；因此遍历需要用先入后出的栈来实现，也可以通过与栈等价的递归来实现。\n\n对于树结构而言，由于总是对新节点调用遍历，因此看起来是向着 深 的方向前进，或者说是垂直方向。考虑如下一颗简单的树，由4 个节点构成共三层，其 DFS 过程如下图所示：\n\n\n\n图通常有两种表示方法。假设图中一共有 n 个节点、m 条边。\n\n第一种表示方法是邻接矩阵（adjacency matrix）：我们可以建立一个 n × n 的矩阵 G，如果第 i 个节点连向第 j 个节点，则 G[i][j]= 1，反之为 0；如果图是无向的，则这个矩阵一定是对称矩阵，即 G[i][j] = G[j][i]。\n\n第二种表示方法是邻接链表（adjacency list）：我们可以建立一个大小为 n 的数组，每个位置 i 储存一个数组 或者链表，表示第 i 个节点连向的其它节点。\n\n邻接矩阵空间开销比邻接链表大，但是邻接链表不支持快速查找 i 和 j 是否相连，因此两种表示方法可以根据题目需要适当选择。除此之外，我们也可以直接用一个 m × 2 的矩阵储存所有的边。\n\n# 547 省份数量\n\n给定一个二维的 0-1 矩阵，如果第 (i, j) 位置是 1，则表示第 i 城市和第 j 城市相连。已知连接关系是可以传递的，即如果城市 a 与城市 b 直接相连，且城市 b 与城市 c 直接相连，那么城市 a 与城市 c 间接相连。一组直接或间接相连的城市通同属于一个省份。求一共有多少个省份。\n\n输入是一个二维数组，输出是一个整数，表示省份数量。因为城市连接关系具有对称性，该二维数组为对称矩阵。同时，因为自己与自己相连，对角线上的值全部为 1。\n\n\n\n输入：isConnected = [[1,1,0],[1,1,0],[0,0,1]]\n输出：2\n\n\n解析：\n\n本题和200 岛屿数量题本质上是同一道题。\n\n对于题目 200，二维矩阵也是一种图，其表示方法是：每个位置代表一个节点，每个节点与上下左右四个节点相邻。而在本题里面，则是图的邻接矩阵表示：每一行（列）表示一个节点，它的每列（行）表示是否存在一个相邻节点。\n\n因此题目 200 拥有 m × n 个节点，每个节点有 4 条边；而本题拥有 n 个节点，每个节点最多有 n 条边，表示和所有城市都相连，最少可以有 1 条边，表示自己与自己相连。所以这道题与题目 200 本质上是同一道题：搜索图中省份数量和搜索二维矩阵中的岛屿数量。\n\n所以我们仍然使用一个主函数和一个辅函数配合解决本题，主函数用于遍历所有的搜索位置，判断是否满足开始搜索的条件，如果可以即在辅函数中进行搜索。与二维数组情况不同的是，在主函数中我们要设置一个数组用于记录节点（城市）是否已经被访问过；辅函数中我们不再仅仅四向遍历而是要搜索所有与当前节点相连的节点，并递归搜索所有相连的点。\n\nclass Solution {\npublic:\n    void dfs(vector<vector<int>>& isConnected, int i, vector<bool>& visited){\n        if(visited[i]) return;\n        visited[i] = true;\n        for(int j=0;j<visited.size();++j){\n            if(isConnected[i][j]==1 && !visited[j]){\n                dfs(isConnected,j,visited);\n            }\n        }\n    }\n\n    int findCircleNum(vector<vector<int>>& isConnected) {\n        if(isConnected.empty() || isConnected[0].empty()){\n            return 0;\n        }\n        vector<bool> visited(isConnected.size(),false);\n        int ans = 0;\n        for(int i=0;i<visited.size();++i){\n            if(!visited[i]){\n                dfs(isConnected,i,visited);\n                ++ans;\n            }\n        }\n        return ans;\n    }\n};\n",normalizedContent:"# 02 图结构深度优先搜索\n\n\n# 深度优先搜索简介\n\n深度优先搜索（depth-first seach，dfs）在搜索到一个新的节点时，立即对该新节点进行遍历；因此遍历需要用先入后出的栈来实现，也可以通过与栈等价的递归来实现。\n\n对于树结构而言，由于总是对新节点调用遍历，因此看起来是向着 深 的方向前进，或者说是垂直方向。考虑如下一颗简单的树，由4 个节点构成共三层，其 dfs 过程如下图所示：\n\n\n\n图通常有两种表示方法。假设图中一共有 n 个节点、m 条边。\n\n第一种表示方法是邻接矩阵（adjacency matrix）：我们可以建立一个 n × n 的矩阵 g，如果第 i 个节点连向第 j 个节点，则 g[i][j]= 1，反之为 0；如果图是无向的，则这个矩阵一定是对称矩阵，即 g[i][j] = g[j][i]。\n\n第二种表示方法是邻接链表（adjacency list）：我们可以建立一个大小为 n 的数组，每个位置 i 储存一个数组 或者链表，表示第 i 个节点连向的其它节点。\n\n邻接矩阵空间开销比邻接链表大，但是邻接链表不支持快速查找 i 和 j 是否相连，因此两种表示方法可以根据题目需要适当选择。除此之外，我们也可以直接用一个 m × 2 的矩阵储存所有的边。\n\n# 547 省份数量\n\n给定一个二维的 0-1 矩阵，如果第 (i, j) 位置是 1，则表示第 i 城市和第 j 城市相连。已知连接关系是可以传递的，即如果城市 a 与城市 b 直接相连，且城市 b 与城市 c 直接相连，那么城市 a 与城市 c 间接相连。一组直接或间接相连的城市通同属于一个省份。求一共有多少个省份。\n\n输入是一个二维数组，输出是一个整数，表示省份数量。因为城市连接关系具有对称性，该二维数组为对称矩阵。同时，因为自己与自己相连，对角线上的值全部为 1。\n\n\n\n输入：isconnected = [[1,1,0],[1,1,0],[0,0,1]]\n输出：2\n\n\n解析：\n\n本题和200 岛屿数量题本质上是同一道题。\n\n对于题目 200，二维矩阵也是一种图，其表示方法是：每个位置代表一个节点，每个节点与上下左右四个节点相邻。而在本题里面，则是图的邻接矩阵表示：每一行（列）表示一个节点，它的每列（行）表示是否存在一个相邻节点。\n\n因此题目 200 拥有 m × n 个节点，每个节点有 4 条边；而本题拥有 n 个节点，每个节点最多有 n 条边，表示和所有城市都相连，最少可以有 1 条边，表示自己与自己相连。所以这道题与题目 200 本质上是同一道题：搜索图中省份数量和搜索二维矩阵中的岛屿数量。\n\n所以我们仍然使用一个主函数和一个辅函数配合解决本题，主函数用于遍历所有的搜索位置，判断是否满足开始搜索的条件，如果可以即在辅函数中进行搜索。与二维数组情况不同的是，在主函数中我们要设置一个数组用于记录节点（城市）是否已经被访问过；辅函数中我们不再仅仅四向遍历而是要搜索所有与当前节点相连的节点，并递归搜索所有相连的点。\n\nclass solution {\npublic:\n    void dfs(vector<vector<int>>& isconnected, int i, vector<bool>& visited){\n        if(visited[i]) return;\n        visited[i] = true;\n        for(int j=0;j<visited.size();++j){\n            if(isconnected[i][j]==1 && !visited[j]){\n                dfs(isconnected,j,visited);\n            }\n        }\n    }\n\n    int findcirclenum(vector<vector<int>>& isconnected) {\n        if(isconnected.empty() || isconnected[0].empty()){\n            return 0;\n        }\n        vector<bool> visited(isconnected.size(),false);\n        int ans = 0;\n        for(int i=0;i<visited.size();++i){\n            if(!visited[i]){\n                dfs(isconnected,i,visited);\n                ++ans;\n            }\n        }\n        return ans;\n    }\n};\n",charsets:{cjk:!0},lastUpdated:"2023/11/19, 12:55:48",lastUpdatedTimestamp:1700369748e3},{title:"FirstSearch",frontmatter:{title:"FirstSearch",date:"2023-03-24T18:39:49.000Z",permalink:"/pages/b6a984/"},regularPath:"/03.LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/01.%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/04.%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/FirstSearch.html",relativePath:"03.LeetCode刷题笔记/01.基础算法/04.优先搜索/FirstSearch.md",key:"v-c166e812",path:"/pages/b6a984/",headers:[{level:2,title:"LeetCode刷题笔记 优先搜索",slug:"leetcode刷题笔记-优先搜索",normalizedTitle:"leetcode刷题笔记 优先搜索",charIndex:2},{level:3,title:"优先搜索",slug:"优先搜索",normalizedTitle:"优先搜索",charIndex:15},{level:3,title:"递归 回溯 DFS 的区别",slug:"递归-回溯-dfs-的区别",normalizedTitle:"递归 回溯 dfs 的区别",charIndex:1098},{level:4,title:"递归是一种算法结构，DFS是一种搜索（方法）工具，回溯是一种算法思想。",slug:"递归是一种算法结构-dfs是一种搜索-方法-工具-回溯是一种算法思想。",normalizedTitle:"递归是一种算法结构，dfs是一种搜索（方法）工具，回溯是一种算法思想。",charIndex:1115}],headersStr:"LeetCode刷题笔记 优先搜索 优先搜索 递归 回溯 DFS 的区别 递归是一种算法结构，DFS是一种搜索（方法）工具，回溯是一种算法思想。",content:"# LeetCode刷题笔记 优先搜索\n\n\n# 优先搜索\n\nDFS（深度优先搜索）和 BFS（广度优先搜索）就像孪生兄弟，提到一个总是想起另一个。然而在实际使用中，我们用 DFS 的时候远远多于 BFS。那么，是不是 BFS 就没有什么用呢？\n\n如果我们使用 DFS/BFS 只是为了遍历一棵树、一张图上的所有结点的话，那么 DFS 和 BFS 的能力没什么差别，我们当然更倾向于更方便写、空间复杂度更低的 DFS 遍历。不过，某些使用场景是 DFS 做不到的，只能使用 BFS 遍历。这就是本文要介绍的两个场景：「层序遍历」、「最短路径」。\n\nBFS 的使用场景：层序遍历、最短路径问题\n\n可以看到，「BFS 遍历」、「层序遍历」、「最短路径」实际上是递进的关系。在 BFS 遍历的基础上区分遍历的每一层，就得到了层序遍历。在层序遍历的基础上记录层数，就得到了最短路径。\n\nBFS 遍历是一类很值得反复体会和练习的题目。一方面，BFS 遍历是一个经典的基础算法，需要重点掌握。另一方面，我们需要能根据题意分析出题目是要求最短路径，知道是要做 BFS 遍历。\n\n本文讲解的只是两道非常典型的例题。LeetCode 中还有许多层序遍历和最短路径的题目\n\n层序遍历的一些变种题目：\n\nLeetCode 103. Binary Tree Zigzag Level Order Traversal 之字形层序遍历 LeetCode 199. Binary Tree Right Side View 找每一层的最右结点 LeetCode 515. Find Largest Value in Each Tree Row 计算每一层的最大值 LeetCode 637. Average of Levels in Binary Tree 计算每一层的平均值 对于最短路径问题，还有两道题目也是求网格结构中的最短路径，和我们讲解的距离岛屿的最远距离非常类似：\n\nLeetCode 542. 01 Matrix LeetCode 994. Rotting Oranges\n\n还有一道在真正的图结构中求最短路径的问题：\n\nLeetCode 310. Minimum Height Trees\n\n作者：nettee 链接：https://leetcode-cn.com/problems/binary-tree-level-order-traversal/solution/bfs-de-shi-yong-chang-jing-zong-jie-ceng-xu-bian-l/ 来源：力扣（LeetCode）\n\n\n# 递归 回溯 DFS 的区别\n\n# 递归是一种算法结构，DFS是一种搜索（方法）工具，回溯是一种算法思想。\n\n1.在函数中调用函数本身来解决子问题以达到解决原问题的方法就叫递归\n\n对于一个可以分解的问题，子问题与原问题处理过程完全相同，区别只在于数据规模，可以用递归来解。。\n\n2.回溯就是通过不同的尝试来搜索问题的解。\n\n有点类似于穷举（搜索全部解空间），但是和穷举不同的是回溯会“剪枝”，对已经知道错误的结果没必要再枚举接下来的答案了。\n\n3.回溯搜索是深度优先搜索（DFS）的一种情况\n\n对于某一个搜索树来说（搜索树是起记录路径和状态判断的作用），回溯和DFS，其主要的区别是，回溯法在求解过程中不保留完整的树结构（剪枝），而深度优先搜索则记下完整的搜索树。 为了减少存储空间，在深度优先搜索中，用标志的方法记录访问过的状态，这种处理方法使得深度优先搜索法与回溯法没什么区别了。\n\n如何理解回溯和递归以及DFS\n\nDFS 、动态规划、回溯法、递归之间的关系是什么？",normalizedContent:"# leetcode刷题笔记 优先搜索\n\n\n# 优先搜索\n\ndfs（深度优先搜索）和 bfs（广度优先搜索）就像孪生兄弟，提到一个总是想起另一个。然而在实际使用中，我们用 dfs 的时候远远多于 bfs。那么，是不是 bfs 就没有什么用呢？\n\n如果我们使用 dfs/bfs 只是为了遍历一棵树、一张图上的所有结点的话，那么 dfs 和 bfs 的能力没什么差别，我们当然更倾向于更方便写、空间复杂度更低的 dfs 遍历。不过，某些使用场景是 dfs 做不到的，只能使用 bfs 遍历。这就是本文要介绍的两个场景：「层序遍历」、「最短路径」。\n\nbfs 的使用场景：层序遍历、最短路径问题\n\n可以看到，「bfs 遍历」、「层序遍历」、「最短路径」实际上是递进的关系。在 bfs 遍历的基础上区分遍历的每一层，就得到了层序遍历。在层序遍历的基础上记录层数，就得到了最短路径。\n\nbfs 遍历是一类很值得反复体会和练习的题目。一方面，bfs 遍历是一个经典的基础算法，需要重点掌握。另一方面，我们需要能根据题意分析出题目是要求最短路径，知道是要做 bfs 遍历。\n\n本文讲解的只是两道非常典型的例题。leetcode 中还有许多层序遍历和最短路径的题目\n\n层序遍历的一些变种题目：\n\nleetcode 103. binary tree zigzag level order traversal 之字形层序遍历 leetcode 199. binary tree right side view 找每一层的最右结点 leetcode 515. find largest value in each tree row 计算每一层的最大值 leetcode 637. average of levels in binary tree 计算每一层的平均值 对于最短路径问题，还有两道题目也是求网格结构中的最短路径，和我们讲解的距离岛屿的最远距离非常类似：\n\nleetcode 542. 01 matrix leetcode 994. rotting oranges\n\n还有一道在真正的图结构中求最短路径的问题：\n\nleetcode 310. minimum height trees\n\n作者：nettee 链接：https://leetcode-cn.com/problems/binary-tree-level-order-traversal/solution/bfs-de-shi-yong-chang-jing-zong-jie-ceng-xu-bian-l/ 来源：力扣（leetcode）\n\n\n# 递归 回溯 dfs 的区别\n\n# 递归是一种算法结构，dfs是一种搜索（方法）工具，回溯是一种算法思想。\n\n1.在函数中调用函数本身来解决子问题以达到解决原问题的方法就叫递归\n\n对于一个可以分解的问题，子问题与原问题处理过程完全相同，区别只在于数据规模，可以用递归来解。。\n\n2.回溯就是通过不同的尝试来搜索问题的解。\n\n有点类似于穷举（搜索全部解空间），但是和穷举不同的是回溯会“剪枝”，对已经知道错误的结果没必要再枚举接下来的答案了。\n\n3.回溯搜索是深度优先搜索（dfs）的一种情况\n\n对于某一个搜索树来说（搜索树是起记录路径和状态判断的作用），回溯和dfs，其主要的区别是，回溯法在求解过程中不保留完整的树结构（剪枝），而深度优先搜索则记下完整的搜索树。 为了减少存储空间，在深度优先搜索中，用标志的方法记录访问过的状态，这种处理方法使得深度优先搜索法与回溯法没什么区别了。\n\n如何理解回溯和递归以及dfs\n\ndfs 、动态规划、回溯法、递归之间的关系是什么？",charsets:{cjk:!0},lastUpdated:"2023/11/19, 12:55:48",lastUpdatedTimestamp:1700369748e3},{title:"01递归",frontmatter:{title:"01递归",date:"2023-03-24T18:39:48.000Z",permalink:"/pages/9c7a53/"},regularPath:"/03.LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/01.%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/05.%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/01.%E9%80%92%E5%BD%92.html",relativePath:"03.LeetCode刷题笔记/01.基础算法/05.回溯算法/01.递归.md",key:"v-1b6e1506",path:"/pages/9c7a53/",headers:[{level:2,title:"01 递归",slug:"_01-递归",normalizedTitle:"01 递归",charIndex:2},{level:3,title:"递归的基本概念",slug:"递归的基本概念",normalizedTitle:"递归的基本概念",charIndex:12},{level:4,title:"面试题 08.06. 汉诺塔问题",slug:"面试题-08-06-汉诺塔问题",normalizedTitle:"面试题 08.06. 汉诺塔问题",charIndex:601},{level:4,title:"509 斐波那契数",slug:"_509-斐波那契数",normalizedTitle:"509 斐波那契数",charIndex:1559},{level:4,title:"70 爬楼梯",slug:"_70-爬楼梯",normalizedTitle:"70 爬楼梯",charIndex:2235}],headersStr:"01 递归 递归的基本概念 面试题 08.06. 汉诺塔问题 509 斐波那契数 70 爬楼梯",content:"# 01 递归\n\n\n# 递归的基本概念\n\n递归作为一种算法结构是指在函数的定义中调用函数自身，一个经典的例子就是用递归函数求阶乘\n\nint factorial(int n){\n    if(n == 0){\n        return 1;\n    }else{\n        return n * factorial(n-1);\n    }\n}\n\n\n从上例可以看出递归的基本思想就是把规模大的问题拆解为规模小的相同的子问题来解决，且在这个不断拆解为更小问题的过程中有一个临界点，即问题拆解的终止条件。当达到临界点时，从被拆解的最小问题的解开始对战栈式地返回答案，累积得到原问题的解。\n\n所以在递归函数实现时，包含了两部分，一个是递归主体，另一个是终止条件：\n\n * 递归主体：因为大问题和小问题是一样的问题，因此大问题的解决方法和小问题的解决方法也是同一个方法这就是递归主体。一般情况下，递归主体就是一个递推公式，该递推公式来自将大问题拆解为小问题的规律。\n * 终止条件：这种函数调用它自身的情况，必须有明确的终止条件，否则就会导致无限递归。而终止条件就是问题的平凡解，即问题的最简单情况。\n\n总的来说，递归问题的求解关键在于找出问题转化的递推公式和终止条件。\n\n递归的作用：\n\n * 替代多重循环\n * 用于解决本来就是用递归形式定义的问题\n * 将问题分解为规模更小的子问题进行求解\n\n# 面试题 08.06. 汉诺塔问题\n\n有一个梵塔，塔内有三个座 A 、 B 、 C，A 座上有 N 个盘子，盘子大小不等，大的在下，小的在上。 现在想把这 N 个盘子从 A 座移到 C 座，但每次只能允许移动一个盘子，并且在移动过程中， 3 个座上的盘子始终保持大盘在下，小盘在上 。 在移动过程中可以利用 B 座。\n\n\n\n输入三个数组，输出一个数组表示移动结果\n\n>  输入：A = [2, 1, 0], B = [], C = []\n>  输出：C = [2, 1, 0]\n\n解析：\n\n汉诺塔问题是经典的递归问题，本题的初始情况：所有的圆盘按大小顺序堆放在 A 上，最大的在底部；移动规则：允许圆盘一次从一个木桩移动到另一个，大盘不能放在小盘的上面；要达到的最终目标：以最少的移动次数将所有圆盘从 A 转移到 C。\n\n分析本题的递推规律：先将 n-1 个盘子从 A 移动到中转 B，再将最大的一个盘子移动到 C，然后将 n-1 个盘子从 B 移动到 C。即将规模为 N 的大问题，转化为规模为 N-1 的子问题，直到最终转化为 1 的平凡解。\n\n递归的终止条件为：A 只有一个盘子，直接将它从 A 移动到 C\n\nclass Solution {\npublic:\n    void rec(int n, vector<int>& A, vector<int>& B, vector<int>& C){\n        // 终止条件\n        if(n==1){\n            C.push_back(A.back());\n            A.pop_back();\n            return;\n        }\n        // 递推公式\n        rec(n-1,A,C,B);\n        C.push_back(A.back());\n        A.pop_back();\n        rec(n-1,B,A,C);\n    }\n\n    void hanota(vector<int>& A, vector<int>& B, vector<int>& C) {\n        rec(A.size(),A,B,C);\n    }\n};\n\n\n# 509 斐波那契数\n\n斐波那契数，通常用 F(n) 表示，形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是：\n\n> F(0) = 0，F(1) = 1\n> F(n) = F(n - 1) + F(n - 2)，其中 n > 1\n\n现给定 n，请计算 F(n)\n\n输入一个整数，输出一个整数表示斐波那契数\n\n> 输入：2\n> 输出：1\n> 解释：F(2) = F(1) + F(0) = 1 + 0 = 1\n\n解析：\n\n斐波那契数列（Fibonacci sequence），又称黄金分割数列，0,1,1,2,3,5,8,13,21,34,……，其递归公式为:\n\n> F(0) = 0，F(1) = 1\n> F(n) = F(n - 1) + F(n - 2)，其中 n > 1\n\n更加直观的理解斐波那契数列如下图所示：\n\n我们可以直接根据斐波那契数列的递推公式得出递归主体和终止条件：\n\n * 终止条件：F(0) = 0，F(1) = 1\n * 递归主体：F(n) = F(n - 1) + F(n - 2)\n\nclass Solution {\npublic:\n    int fib(int n) {\n        if(n==0){\n            return 0;\n        }\n        if(n==1){\n            return 1;\n        }\n        return fib(n-1)+fib(n-2);\n    }\n};\n\n\n# 70 爬楼梯\n\n某人正在爬楼梯，需要 n 阶才能到达楼顶。每次可以爬 1 或 2 个台阶，请计算有多少种不同的方法可以爬到楼顶。\n\n输入一个整数 n，输出一个整数表示爬到楼顶的方法数。\n\n> 输入： 3\n> 输出： 3\n> 解释： 有三种方法可以爬到楼顶。\n> 1.  1 阶 + 1 阶 + 1 阶\n> 2.  1 阶 + 2 阶\n> 3.  2 阶 + 1 阶\n\n解析：\n\n本题可以转化为斐波那契数列问题。\n\n首先我们考虑爬楼梯的终止条件。本题可以有多种终止条件，n<0 时没有台阶可走，n=0 时需要返回上一步移动的结果；n=1 时只剩下一种移动方式；n=2 时有 1,1 和 2 两种移动方式。所以本题的终止条件可以为如下三种情况：\n\n * n < 0, return 0; n = 0, return 1;\n * n = 0, return 1; n = 1, return 1;\n * n = 1, return 1; n = 2, return 2;\n\n接着我们考虑爬楼梯的递推规律：先考虑规模为 N 的大问题，N 阶楼梯的走法等于第一次走一步和走两步之后规模为 N-1 和 N-2 两个子问题的走法之和。即 ( n 阶楼梯的走法) = (走一级台阶之后，n-1 级台阶的走法) + (走两级台阶之后，n-2 级台阶的走法)，形式化表达 f(n) = f(n-1) + f(n-2)。\n\nclass Solution {\npublic:\n    int climbStairs(int n) {\n        if(n==1){\n            return 1;\n        }\n        if(n==2){\n            return 2;\n        }\n\n        return climbStairs(n-1) + climbStairs(n-2);\n    }\n};\n\n\n需要注意的是，LeetCode 中本题不能直接使用递归求解，会超出时间限制，使用动态规划的方式求解。\n\nclass Solution {\npublic:\n    int climbStairs(int n) {\n        // 初始条件 只走一步\n        int r = 1, s = 0, t = 0;\n        for(int i=1;i<=n;++i){\n            s = t;\n            t = r;\n            r = s + t;\n        }\n        return r;\n    }\n};\n",normalizedContent:"# 01 递归\n\n\n# 递归的基本概念\n\n递归作为一种算法结构是指在函数的定义中调用函数自身，一个经典的例子就是用递归函数求阶乘\n\nint factorial(int n){\n    if(n == 0){\n        return 1;\n    }else{\n        return n * factorial(n-1);\n    }\n}\n\n\n从上例可以看出递归的基本思想就是把规模大的问题拆解为规模小的相同的子问题来解决，且在这个不断拆解为更小问题的过程中有一个临界点，即问题拆解的终止条件。当达到临界点时，从被拆解的最小问题的解开始对战栈式地返回答案，累积得到原问题的解。\n\n所以在递归函数实现时，包含了两部分，一个是递归主体，另一个是终止条件：\n\n * 递归主体：因为大问题和小问题是一样的问题，因此大问题的解决方法和小问题的解决方法也是同一个方法这就是递归主体。一般情况下，递归主体就是一个递推公式，该递推公式来自将大问题拆解为小问题的规律。\n * 终止条件：这种函数调用它自身的情况，必须有明确的终止条件，否则就会导致无限递归。而终止条件就是问题的平凡解，即问题的最简单情况。\n\n总的来说，递归问题的求解关键在于找出问题转化的递推公式和终止条件。\n\n递归的作用：\n\n * 替代多重循环\n * 用于解决本来就是用递归形式定义的问题\n * 将问题分解为规模更小的子问题进行求解\n\n# 面试题 08.06. 汉诺塔问题\n\n有一个梵塔，塔内有三个座 a 、 b 、 c，a 座上有 n 个盘子，盘子大小不等，大的在下，小的在上。 现在想把这 n 个盘子从 a 座移到 c 座，但每次只能允许移动一个盘子，并且在移动过程中， 3 个座上的盘子始终保持大盘在下，小盘在上 。 在移动过程中可以利用 b 座。\n\n\n\n输入三个数组，输出一个数组表示移动结果\n\n>  输入：a = [2, 1, 0], b = [], c = []\n>  输出：c = [2, 1, 0]\n\n解析：\n\n汉诺塔问题是经典的递归问题，本题的初始情况：所有的圆盘按大小顺序堆放在 a 上，最大的在底部；移动规则：允许圆盘一次从一个木桩移动到另一个，大盘不能放在小盘的上面；要达到的最终目标：以最少的移动次数将所有圆盘从 a 转移到 c。\n\n分析本题的递推规律：先将 n-1 个盘子从 a 移动到中转 b，再将最大的一个盘子移动到 c，然后将 n-1 个盘子从 b 移动到 c。即将规模为 n 的大问题，转化为规模为 n-1 的子问题，直到最终转化为 1 的平凡解。\n\n递归的终止条件为：a 只有一个盘子，直接将它从 a 移动到 c\n\nclass solution {\npublic:\n    void rec(int n, vector<int>& a, vector<int>& b, vector<int>& c){\n        // 终止条件\n        if(n==1){\n            c.push_back(a.back());\n            a.pop_back();\n            return;\n        }\n        // 递推公式\n        rec(n-1,a,c,b);\n        c.push_back(a.back());\n        a.pop_back();\n        rec(n-1,b,a,c);\n    }\n\n    void hanota(vector<int>& a, vector<int>& b, vector<int>& c) {\n        rec(a.size(),a,b,c);\n    }\n};\n\n\n# 509 斐波那契数\n\n斐波那契数，通常用 f(n) 表示，形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是：\n\n> f(0) = 0，f(1) = 1\n> f(n) = f(n - 1) + f(n - 2)，其中 n > 1\n\n现给定 n，请计算 f(n)\n\n输入一个整数，输出一个整数表示斐波那契数\n\n> 输入：2\n> 输出：1\n> 解释：f(2) = f(1) + f(0) = 1 + 0 = 1\n\n解析：\n\n斐波那契数列（fibonacci sequence），又称黄金分割数列，0,1,1,2,3,5,8,13,21,34,……，其递归公式为:\n\n> f(0) = 0，f(1) = 1\n> f(n) = f(n - 1) + f(n - 2)，其中 n > 1\n\n更加直观的理解斐波那契数列如下图所示：\n\n我们可以直接根据斐波那契数列的递推公式得出递归主体和终止条件：\n\n * 终止条件：f(0) = 0，f(1) = 1\n * 递归主体：f(n) = f(n - 1) + f(n - 2)\n\nclass solution {\npublic:\n    int fib(int n) {\n        if(n==0){\n            return 0;\n        }\n        if(n==1){\n            return 1;\n        }\n        return fib(n-1)+fib(n-2);\n    }\n};\n\n\n# 70 爬楼梯\n\n某人正在爬楼梯，需要 n 阶才能到达楼顶。每次可以爬 1 或 2 个台阶，请计算有多少种不同的方法可以爬到楼顶。\n\n输入一个整数 n，输出一个整数表示爬到楼顶的方法数。\n\n> 输入： 3\n> 输出： 3\n> 解释： 有三种方法可以爬到楼顶。\n> 1.  1 阶 + 1 阶 + 1 阶\n> 2.  1 阶 + 2 阶\n> 3.  2 阶 + 1 阶\n\n解析：\n\n本题可以转化为斐波那契数列问题。\n\n首先我们考虑爬楼梯的终止条件。本题可以有多种终止条件，n<0 时没有台阶可走，n=0 时需要返回上一步移动的结果；n=1 时只剩下一种移动方式；n=2 时有 1,1 和 2 两种移动方式。所以本题的终止条件可以为如下三种情况：\n\n * n < 0, return 0; n = 0, return 1;\n * n = 0, return 1; n = 1, return 1;\n * n = 1, return 1; n = 2, return 2;\n\n接着我们考虑爬楼梯的递推规律：先考虑规模为 n 的大问题，n 阶楼梯的走法等于第一次走一步和走两步之后规模为 n-1 和 n-2 两个子问题的走法之和。即 ( n 阶楼梯的走法) = (走一级台阶之后，n-1 级台阶的走法) + (走两级台阶之后，n-2 级台阶的走法)，形式化表达 f(n) = f(n-1) + f(n-2)。\n\nclass solution {\npublic:\n    int climbstairs(int n) {\n        if(n==1){\n            return 1;\n        }\n        if(n==2){\n            return 2;\n        }\n\n        return climbstairs(n-1) + climbstairs(n-2);\n    }\n};\n\n\n需要注意的是，leetcode 中本题不能直接使用递归求解，会超出时间限制，使用动态规划的方式求解。\n\nclass solution {\npublic:\n    int climbstairs(int n) {\n        // 初始条件 只走一步\n        int r = 1, s = 0, t = 0;\n        for(int i=1;i<=n;++i){\n            s = t;\n            t = r;\n            r = s + t;\n        }\n        return r;\n    }\n};\n",charsets:{cjk:!0},lastUpdated:"2023/11/19, 12:55:48",lastUpdatedTimestamp:1700369748e3},{title:"05网格结构广度优先搜索",frontmatter:{title:"05网格结构广度优先搜索",date:"2023-03-24T18:39:49.000Z",permalink:"/pages/3cb71c/"},regularPath:"/03.LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/01.%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/04.%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/05.%E7%BD%91%E6%A0%BC%E7%BB%93%E6%9E%84%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2.html",relativePath:"03.LeetCode刷题笔记/01.基础算法/04.优先搜索/05.网格结构广度优先搜索.md",key:"v-bbc963f8",path:"/pages/3cb71c/",headers:[{level:2,title:"05 网格结构广度优先搜索",slug:"_05-网格结构广度优先搜索",normalizedTitle:"05 网格结构广度优先搜索",charIndex:2},{level:3,title:"广度优先搜索简介",slug:"广度优先搜索简介",normalizedTitle:"广度优先搜索简介",charIndex:20},{level:4,title:"542 0-1 矩阵",slug:"_542-0-1-矩阵",normalizedTitle:"542 0-1 矩阵",charIndex:814},{level:4,title:"130 被围绕的区域",slug:"_130-被围绕的区域",normalizedTitle:"130 被围绕的区域",charIndex:828},{level:4,title:"934 最短的桥",slug:"_934-最短的桥",normalizedTitle:"934 最短的桥",charIndex:842},{level:4,title:"126 单词接龙 II",slug:"_126-单词接龙-ii",normalizedTitle:"126 单词接龙 ii",charIndex:854},{level:4,title:"994 腐烂的橘子",slug:"_994-腐烂的橘子",normalizedTitle:"994 腐烂的橘子",charIndex:869}],headersStr:"05 网格结构广度优先搜索 广度优先搜索简介 542 0-1 矩阵 130 被围绕的区域 934 最短的桥 126 单词接龙 II 994 腐烂的橘子",content:"# 05 网格结构广度优先搜索\n\n\n# 广度优先搜索简介\n\n深度优先搜索（depth-first seach，DFS）在搜索到一个新的节点时，立即对该新节点进行遍历；因此遍历需要用先入后出的栈来实现，也可以通过与栈等价的递归来实现。\n\n二维数组深度优先搜索的一般写法：\n\n一般来说，深度优先搜索类型的题可以分为主函数和辅函数，主函数用于遍历所有的搜索位置，判断是否满足开始搜索的条件，如果可以即在辅函数中进行搜索。\n\n辅函数负责实现深度优先搜索过程。这一过程可以使用递归调用调用实现；当然，我们也可以使用栈（stack）实现深度优先搜索，与使用队列 （queue）实现广度优先搜索类比。但因为栈与递归的调用原理相同，而递归相对便于实现，因此刷题时推荐使用递归式写法，可以将深度优先搜索与回溯算法进行类比。不过在实际工程上，直接使用栈可能才是最好的选择，一是因为便于理解，二是更不易出现递归栈满的情况。\n\n在辅函数里，一个一定要注意的点是辅函数内递归搜索时，对矩阵边界条件的判定。边界判定一般有两种写法：一种是先判定是否越界，只有在合法的情况下才进行下一步搜索（即判断放在调用递归函数前）；另一种是不管三七二十一先进行下一步搜索，待下一步搜索开始时再判断是否合法（即判断放在辅函数第一行）。两种方法任选一种符合自身代码习惯的写法即可。\n\n二维数组四向遍历小技巧：对于四个方向的遍历，可以创造一个数组 direction = [-1, 0, 1, 0, -1]，每相邻两位即为上下左右四个方向之一，即：\n\n * 左移 x+=direction[0]; y+=direction[1]；\n * 上移 x+=direction[1]; y+=direction[2]；\n * 右移 x+=direction[2]; y+=direction[3]；\n * 下移 x+=direction[3]; y+=direction[4]；\n\n# 542 0-1 矩阵\n\n# 130 被围绕的区域\n\n# 934 最短的桥\n\n# 126 单词接龙 II\n\n# 994 腐烂的橘子",normalizedContent:"# 05 网格结构广度优先搜索\n\n\n# 广度优先搜索简介\n\n深度优先搜索（depth-first seach，dfs）在搜索到一个新的节点时，立即对该新节点进行遍历；因此遍历需要用先入后出的栈来实现，也可以通过与栈等价的递归来实现。\n\n二维数组深度优先搜索的一般写法：\n\n一般来说，深度优先搜索类型的题可以分为主函数和辅函数，主函数用于遍历所有的搜索位置，判断是否满足开始搜索的条件，如果可以即在辅函数中进行搜索。\n\n辅函数负责实现深度优先搜索过程。这一过程可以使用递归调用调用实现；当然，我们也可以使用栈（stack）实现深度优先搜索，与使用队列 （queue）实现广度优先搜索类比。但因为栈与递归的调用原理相同，而递归相对便于实现，因此刷题时推荐使用递归式写法，可以将深度优先搜索与回溯算法进行类比。不过在实际工程上，直接使用栈可能才是最好的选择，一是因为便于理解，二是更不易出现递归栈满的情况。\n\n在辅函数里，一个一定要注意的点是辅函数内递归搜索时，对矩阵边界条件的判定。边界判定一般有两种写法：一种是先判定是否越界，只有在合法的情况下才进行下一步搜索（即判断放在调用递归函数前）；另一种是不管三七二十一先进行下一步搜索，待下一步搜索开始时再判断是否合法（即判断放在辅函数第一行）。两种方法任选一种符合自身代码习惯的写法即可。\n\n二维数组四向遍历小技巧：对于四个方向的遍历，可以创造一个数组 direction = [-1, 0, 1, 0, -1]，每相邻两位即为上下左右四个方向之一，即：\n\n * 左移 x+=direction[0]; y+=direction[1]；\n * 上移 x+=direction[1]; y+=direction[2]；\n * 右移 x+=direction[2]; y+=direction[3]；\n * 下移 x+=direction[3]; y+=direction[4]；\n\n# 542 0-1 矩阵\n\n# 130 被围绕的区域\n\n# 934 最短的桥\n\n# 126 单词接龙 ii\n\n# 994 腐烂的橘子",charsets:{cjk:!0},lastUpdated:"2023/11/19, 12:55:48",lastUpdatedTimestamp:1700369748e3},{title:"02 子集问题",frontmatter:{title:"02 子集问题",date:"2023-03-24T18:39:48.000Z",permalink:"/pages/cbe7a5/"},regularPath:"/03.LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/01.%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/05.%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/02.%E5%AD%90%E9%9B%86%E9%97%AE%E9%A2%98.html",relativePath:"03.LeetCode刷题笔记/01.基础算法/05.回溯算法/02.子集问题.md",key:"v-19942982",path:"/pages/cbe7a5/",headers:[{level:2,title:"LeetCode刷题笔记 回溯算法",slug:"leetcode刷题笔记-回溯算法",normalizedTitle:"leetcode刷题笔记 回溯算法",charIndex:2},{level:4,title:"78 子集",slug:"_78-子集",normalizedTitle:"78 子集",charIndex:23},{level:4,title:"90 子集 II",slug:"_90-子集-ii",normalizedTitle:"90 子集 ii",charIndex:684}],headersStr:"LeetCode刷题笔记 回溯算法 78 子集 90 子集 II",content:"# LeetCode刷题笔记 回溯算法\n\n# 78 子集\n\n给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。\n\n解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。\n\n> 输入：nums = [1,2,3]\n> 输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]\n\n解析：\n\nclass Solution {\npublic:\n    void bt(vector<int>& nums, int start, vector<int>& track, vector<vector<int>>& ans){\n        ans.push_back(track);\n        for(int i=start;i<nums.size();++i){\n            track.push_back(nums[i]);\n            bt(nums,i+1,track,ans);\n            track.pop_back();\n        }\n        return;\n    }\n\n    vector<vector<int>> subsets(vector<int>& nums) {\n        vector<int> track;\n        vector<vector<int>> ans;\n        bt(nums,0,track,ans);\n        return ans; \n    }\n};\n\n\n# 90 子集 II\n\n给你一个整数数组 nums ，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。\n\n解集 不能 包含重复的子集。返回的解集中，子集可以按 任意顺序 排列。\n\n> 输入：nums = [1,2,2]\n> 输出：[[],[1],[1,2],[1,2,2],[2],[2,2]]\n\n解析：\n\nclass Solution {\npublic:\n    void bt(vector<int>& nums, int start, vector<int>& track, vector<vector<int>>& ans, vector<bool>& visited){\n        ans.push_back(track);\n        for(int i=start;i<nums.size();++i){\n            if(i>start&&nums[i]==nums[i-1]&&!visited[i-1]){\n                continue;\n            }\n            track.push_back(nums[i]);\n            visited[i] = true;\n            bt(nums,i+1,track,ans,visited);\n            visited[i] = false;\n            track.pop_back();\n        }\n        return;\n    }\n\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\n        vector<int> track;\n        vector<vector<int>> ans;\n        // 重复元素判断是否使用过，同一子集中可以重复使用，不同子集中不行，不然出现重复子集\n        vector<bool> visited(nums.size(),false);\n        // 去重要排序，不然不容易识别重复元素\n        sort(nums.begin(),nums.end());\n        bt(nums,0,track,ans,visited);\n        return ans;\n    }\n};\n",normalizedContent:"# leetcode刷题笔记 回溯算法\n\n# 78 子集\n\n给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。\n\n解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。\n\n> 输入：nums = [1,2,3]\n> 输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]\n\n解析：\n\nclass solution {\npublic:\n    void bt(vector<int>& nums, int start, vector<int>& track, vector<vector<int>>& ans){\n        ans.push_back(track);\n        for(int i=start;i<nums.size();++i){\n            track.push_back(nums[i]);\n            bt(nums,i+1,track,ans);\n            track.pop_back();\n        }\n        return;\n    }\n\n    vector<vector<int>> subsets(vector<int>& nums) {\n        vector<int> track;\n        vector<vector<int>> ans;\n        bt(nums,0,track,ans);\n        return ans; \n    }\n};\n\n\n# 90 子集 ii\n\n给你一个整数数组 nums ，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。\n\n解集 不能 包含重复的子集。返回的解集中，子集可以按 任意顺序 排列。\n\n> 输入：nums = [1,2,2]\n> 输出：[[],[1],[1,2],[1,2,2],[2],[2,2]]\n\n解析：\n\nclass solution {\npublic:\n    void bt(vector<int>& nums, int start, vector<int>& track, vector<vector<int>>& ans, vector<bool>& visited){\n        ans.push_back(track);\n        for(int i=start;i<nums.size();++i){\n            if(i>start&&nums[i]==nums[i-1]&&!visited[i-1]){\n                continue;\n            }\n            track.push_back(nums[i]);\n            visited[i] = true;\n            bt(nums,i+1,track,ans,visited);\n            visited[i] = false;\n            track.pop_back();\n        }\n        return;\n    }\n\n    vector<vector<int>> subsetswithdup(vector<int>& nums) {\n        vector<int> track;\n        vector<vector<int>> ans;\n        // 重复元素判断是否使用过，同一子集中可以重复使用，不同子集中不行，不然出现重复子集\n        vector<bool> visited(nums.size(),false);\n        // 去重要排序，不然不容易识别重复元素\n        sort(nums.begin(),nums.end());\n        bt(nums,0,track,ans,visited);\n        return ans;\n    }\n};\n",charsets:{cjk:!0},lastUpdated:"2023/11/19, 12:55:48",lastUpdatedTimestamp:1700369748e3},{title:"07图结构广度优先搜索",frontmatter:{title:"07图结构广度优先搜索",date:"2023-03-24T18:39:49.000Z",permalink:"/pages/4da67f/"},regularPath:"/03.LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/01.%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/04.%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/07.%E5%9B%BE%E7%BB%93%E6%9E%84%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2.html",relativePath:"03.LeetCode刷题笔记/01.基础算法/04.优先搜索/07.图结构广度优先搜索.md",key:"v-a1dd7d26",path:"/pages/4da67f/",headers:[{level:4,title:"547 省份数量",slug:"_547-省份数量",normalizedTitle:"547 省份数量",charIndex:2},{level:4,title:"310 最小高度树",slug:"_310-最小高度树",normalizedTitle:"310 最小高度树",charIndex:14}],headersStr:"547 省份数量 310 最小高度树",content:"# 547 省份数量\n\n# 310 最小高度树",normalizedContent:"# 547 省份数量\n\n# 310 最小高度树",charsets:{cjk:!0},lastUpdated:"2023/11/19, 12:55:48",lastUpdatedTimestamp:1700369748e3},{title:"05 回溯搜索问题",frontmatter:{title:"05 回溯搜索问题",date:"2023-03-24T18:39:48.000Z",permalink:"/pages/e9a845/"},regularPath:"/03.LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/01.%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/05.%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/05.%E5%9B%9E%E6%BA%AF%E6%90%9C%E7%B4%A2%E9%97%AE%E9%A2%98.html",relativePath:"03.LeetCode刷题笔记/01.基础算法/05.回溯算法/05.回溯搜索问题.md",key:"v-23bee3d7",path:"/pages/e9a845/",headers:[{level:2,title:"LeetCode刷题笔记 回溯算法",slug:"leetcode刷题笔记-回溯算法",normalizedTitle:"leetcode刷题笔记 回溯算法",charIndex:2},{level:4,title:"面试题 08.12 八皇后",slug:"面试题-08-12-八皇后",normalizedTitle:"面试题 08.12 八皇后",charIndex:23}],headersStr:"LeetCode刷题笔记 回溯算法 面试题 08.12 八皇后",content:'# LeetCode刷题笔记 回溯算法\n\n# 面试题 08.12 八皇后\n\n设计一种算法，打印 N 皇后在 N × N 棋盘上的各种摆法，其中每个皇后都不同行、不同列，也不在对角线上。这里的“对角线”指的是所有的对角线，不只是平分整个棋盘的那两条对角线。\n\n> 输入：4 输出：[[".Q..","...Q","Q...","..Q."],["..Q.","Q...","...Q",".Q.."]] 解释: 4 皇后问题存在如下两个不同的解法。 [ [".Q..", // 解法 1 "...Q", "Q...", "..Q."],\n> \n> ["..Q.", // 解法 2 "Q...", "...Q", ".Q.."] ]\n\n解析：\n\nclass Solution {\nprivate:\nvector<vector<string>> result;\n// n 为输入的棋盘大小\n// row 是当前递归到棋盘的第几行了\nvoid backtracking(int n, int row, vector<string>& chessboard) {\n    if (row == n) {\n        result.push_back(chessboard);\n        return;\n    }\n    for (int col = 0; col < n; col++) {\n        if (isValid(row, col, chessboard, n)) { // 验证合法就可以放\n            chessboard[row][col] = \'Q\'; // 放置皇后\n            backtracking(n, row + 1, chessboard);\n            chessboard[row][col] = \'.\'; // 回溯，撤销皇后\n        }\n    }\n}\nbool isValid(int row, int col, vector<string>& chessboard, int n) {\n    int count = 0;\n    // 检查列\n    for (int i = 0; i < row; i++) { // 这是一个剪枝\n        if (chessboard[i][col] == \'Q\') {\n            return false;\n        }\n    }\n    // 检查 45度角是否有皇后\n    for (int i = row - 1, j = col - 1; i >=0 && j >= 0; i--, j--) {\n        if (chessboard[i][j] == \'Q\') {\n            return false;\n        }\n    }\n    // 检查 135度角是否有皇后\n    for(int i = row - 1, j = col + 1; i >= 0 && j < n; i--, j++) {\n        if (chessboard[i][j] == \'Q\') {\n            return false;\n        }\n    }\n    return true;\n}\npublic:\n    vector<vector<string>> solveNQueens(int n) {\n        result.clear();\n        std::vector<std::string> chessboard(n, std::string(n, \'.\'));\n        backtracking(n, 0, chessboard);\n        return result;\n    }\n};\n',normalizedContent:'# leetcode刷题笔记 回溯算法\n\n# 面试题 08.12 八皇后\n\n设计一种算法，打印 n 皇后在 n × n 棋盘上的各种摆法，其中每个皇后都不同行、不同列，也不在对角线上。这里的“对角线”指的是所有的对角线，不只是平分整个棋盘的那两条对角线。\n\n> 输入：4 输出：[[".q..","...q","q...","..q."],["..q.","q...","...q",".q.."]] 解释: 4 皇后问题存在如下两个不同的解法。 [ [".q..", // 解法 1 "...q", "q...", "..q."],\n> \n> ["..q.", // 解法 2 "q...", "...q", ".q.."] ]\n\n解析：\n\nclass solution {\nprivate:\nvector<vector<string>> result;\n// n 为输入的棋盘大小\n// row 是当前递归到棋盘的第几行了\nvoid backtracking(int n, int row, vector<string>& chessboard) {\n    if (row == n) {\n        result.push_back(chessboard);\n        return;\n    }\n    for (int col = 0; col < n; col++) {\n        if (isvalid(row, col, chessboard, n)) { // 验证合法就可以放\n            chessboard[row][col] = \'q\'; // 放置皇后\n            backtracking(n, row + 1, chessboard);\n            chessboard[row][col] = \'.\'; // 回溯，撤销皇后\n        }\n    }\n}\nbool isvalid(int row, int col, vector<string>& chessboard, int n) {\n    int count = 0;\n    // 检查列\n    for (int i = 0; i < row; i++) { // 这是一个剪枝\n        if (chessboard[i][col] == \'q\') {\n            return false;\n        }\n    }\n    // 检查 45度角是否有皇后\n    for (int i = row - 1, j = col - 1; i >=0 && j >= 0; i--, j--) {\n        if (chessboard[i][j] == \'q\') {\n            return false;\n        }\n    }\n    // 检查 135度角是否有皇后\n    for(int i = row - 1, j = col + 1; i >= 0 && j < n; i--, j++) {\n        if (chessboard[i][j] == \'q\') {\n            return false;\n        }\n    }\n    return true;\n}\npublic:\n    vector<vector<string>> solvenqueens(int n) {\n        result.clear();\n        std::vector<std::string> chessboard(n, std::string(n, \'.\'));\n        backtracking(n, 0, chessboard);\n        return result;\n    }\n};\n',charsets:{cjk:!0},lastUpdated:"2023/11/19, 12:55:48",lastUpdatedTimestamp:1700369748e3},{title:"04 组合问题",frontmatter:{title:"04 组合问题",date:"2023-03-24T18:39:48.000Z",permalink:"/pages/21e47b/"},regularPath:"/03.LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/01.%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/05.%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/04.%E7%BB%84%E5%90%88%E9%97%AE%E9%A2%98.html",relativePath:"03.LeetCode刷题笔记/01.基础算法/05.回溯算法/04.组合问题.md",key:"v-373e1bea",path:"/pages/21e47b/",headers:[{level:2,title:"LeetCode刷题笔记 回溯算法",slug:"leetcode刷题笔记-回溯算法",normalizedTitle:"leetcode刷题笔记 回溯算法",charIndex:2},{level:4,title:"77 组合",slug:"_77-组合",normalizedTitle:"77 组合",charIndex:23},{level:4,title:"39 组合总和",slug:"_39-组合总和",normalizedTitle:"39 组合总和",charIndex:708},{level:4,title:"40 组合总和 II",slug:"_40-组合总和-ii",normalizedTitle:"40 组合总和 ii",charIndex:1810}],headersStr:"LeetCode刷题笔记 回溯算法 77 组合 39 组合总和 40 组合总和 II",content:"# LeetCode刷题笔记 回溯算法\n\n# 77 组合\n\n给定两个整数 n 和 k，返回范围 [1, n] 中所有可能的 k 个数的组合。\n\n你可以按 任何顺序 返回答案。\n\n> 输入：n = 4, k = 2\n> 输出：\n> [\n>  [2,4],\n>  [3,4],\n>  [2,3],\n>  [1,2],\n>  [1,3],\n>  [1,4],\n> ]\n\n解析：\n\nclass Solution {\npublic:\n    void bt(int n, int k, int start, vector<int>& track, vector<vector<int>>& ans){\n        if(track.size()==k){\n            ans.push_back(track);\n            return;\n        }\n        for(int i=start;i<=n;++i){\n            track.push_back(i);\n            bt(n,k,i+1,track,ans);\n            track.pop_back();\n        }\n    }\n\n    vector<vector<int>> combine(int n, int k) {\n        vector<int> track;\n        vector<vector<int>> ans;\n        bt(n,k,1,track,ans);\n        return ans;\n    }\n};\n\n\n# 39 组合总和\n\n给你一个 无重复元素 的整数数组 candidates 和一个目标整数 target ，找出 candidates 中可以使数字和为目标数 target 的 所有 不同组合 ，并以列表形式返回。你可以按 任意顺序 返回这些组合。\n\ncandidates 中的 同一个 数字可以 无限制重复被选取 。如果至少一个数字的被选数量不同，则两种组合是不同的。\n\n对于给定的输入，保证和为 target 的不同组合数少于 150 个。\n\n> 输入：candidates = [2,3,6,7], target = 7 输出：[[2,2,3],[7]] 解释：2 和 3 可以形成一组候选，2 + 2 + 3 = 7 。注意 2 可以使用多次。7 也是一个候选， 7 = 7 。仅有这两种组合。\n\n解析：\n\nclass Solution {\npublic:\n    void bt(vector<int> candidates, int target, int start, vector<int>& track, vector<vector<int>>& ans){\n        // 超出总和减枝\n        if(target < 0){\n            return;\n        }\n        if(target==0){\n            ans.push_back(track);\n            return;\n        }\n        for(int i=start;i<candidates.size();++i){\n            track.push_back(candidates[i]);\n            bt(candidates,target-candidates[i],i,track,ans); // start 仍从 i 开始重复使用元素\n            track.pop_back();\n        }\n        return;\n    }\n\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\n        vector<int> track;\n        vector<vector<int>> ans;\n        bt(candidates,target,0,track,ans);\n        return ans;\n    }\n};\n\n\n# 40 组合总和 II\n\n给定一个候选人编号的集合 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。\n\ncandidates 中的每个数字在每个组合中只能使用 一次 ，解集不能包含重复的组合\n\n> 输入: candidates = [10,1,2,7,6,1,5], target = 8, 输出: [ [1,1,6], [1,2,5], [1,7], [2,6] ]\n\n解析：\n\nclass Solution {\npublic:\n    void bt(vector<int>& candidates, int target, int start, vector<int>& track, vector<vector<int>>& ans, vector<bool>& visited){\n        if(target < 0){\n            return;\n        }\n        if(target==0){\n            ans.push_back(track);\n            return;\n        }\n        for(int i=start;i<candidates.size();++i){\n            if(i>start && candidates[i] == candidates[i-1] && !visited[i-1]){\n                continue;\n            }\n            track.push_back(candidates[i]);\n            visited[i] = true;\n            bt(candidates,target-candidates[i],i+1,track,ans,visited); // 元素不可重复利用，使用下一个即i+1\n            visited[i] = false;\n            track.pop_back();\n        }\n        return;\n    }\n\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\n        vector<int> track;\n        vector<vector<int>> ans;\n        vector<bool> visited(candidates.size(),false);\n        sort(candidates.begin(),candidates.end());\n        bt(candidates,target,0,track,ans,visited);\n        return ans;\n    }\n};\n",normalizedContent:"# leetcode刷题笔记 回溯算法\n\n# 77 组合\n\n给定两个整数 n 和 k，返回范围 [1, n] 中所有可能的 k 个数的组合。\n\n你可以按 任何顺序 返回答案。\n\n> 输入：n = 4, k = 2\n> 输出：\n> [\n>  [2,4],\n>  [3,4],\n>  [2,3],\n>  [1,2],\n>  [1,3],\n>  [1,4],\n> ]\n\n解析：\n\nclass solution {\npublic:\n    void bt(int n, int k, int start, vector<int>& track, vector<vector<int>>& ans){\n        if(track.size()==k){\n            ans.push_back(track);\n            return;\n        }\n        for(int i=start;i<=n;++i){\n            track.push_back(i);\n            bt(n,k,i+1,track,ans);\n            track.pop_back();\n        }\n    }\n\n    vector<vector<int>> combine(int n, int k) {\n        vector<int> track;\n        vector<vector<int>> ans;\n        bt(n,k,1,track,ans);\n        return ans;\n    }\n};\n\n\n# 39 组合总和\n\n给你一个 无重复元素 的整数数组 candidates 和一个目标整数 target ，找出 candidates 中可以使数字和为目标数 target 的 所有 不同组合 ，并以列表形式返回。你可以按 任意顺序 返回这些组合。\n\ncandidates 中的 同一个 数字可以 无限制重复被选取 。如果至少一个数字的被选数量不同，则两种组合是不同的。\n\n对于给定的输入，保证和为 target 的不同组合数少于 150 个。\n\n> 输入：candidates = [2,3,6,7], target = 7 输出：[[2,2,3],[7]] 解释：2 和 3 可以形成一组候选，2 + 2 + 3 = 7 。注意 2 可以使用多次。7 也是一个候选， 7 = 7 。仅有这两种组合。\n\n解析：\n\nclass solution {\npublic:\n    void bt(vector<int> candidates, int target, int start, vector<int>& track, vector<vector<int>>& ans){\n        // 超出总和减枝\n        if(target < 0){\n            return;\n        }\n        if(target==0){\n            ans.push_back(track);\n            return;\n        }\n        for(int i=start;i<candidates.size();++i){\n            track.push_back(candidates[i]);\n            bt(candidates,target-candidates[i],i,track,ans); // start 仍从 i 开始重复使用元素\n            track.pop_back();\n        }\n        return;\n    }\n\n    vector<vector<int>> combinationsum(vector<int>& candidates, int target) {\n        vector<int> track;\n        vector<vector<int>> ans;\n        bt(candidates,target,0,track,ans);\n        return ans;\n    }\n};\n\n\n# 40 组合总和 ii\n\n给定一个候选人编号的集合 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。\n\ncandidates 中的每个数字在每个组合中只能使用 一次 ，解集不能包含重复的组合\n\n> 输入: candidates = [10,1,2,7,6,1,5], target = 8, 输出: [ [1,1,6], [1,2,5], [1,7], [2,6] ]\n\n解析：\n\nclass solution {\npublic:\n    void bt(vector<int>& candidates, int target, int start, vector<int>& track, vector<vector<int>>& ans, vector<bool>& visited){\n        if(target < 0){\n            return;\n        }\n        if(target==0){\n            ans.push_back(track);\n            return;\n        }\n        for(int i=start;i<candidates.size();++i){\n            if(i>start && candidates[i] == candidates[i-1] && !visited[i-1]){\n                continue;\n            }\n            track.push_back(candidates[i]);\n            visited[i] = true;\n            bt(candidates,target-candidates[i],i+1,track,ans,visited); // 元素不可重复利用，使用下一个即i+1\n            visited[i] = false;\n            track.pop_back();\n        }\n        return;\n    }\n\n    vector<vector<int>> combinationsum2(vector<int>& candidates, int target) {\n        vector<int> track;\n        vector<vector<int>> ans;\n        vector<bool> visited(candidates.size(),false);\n        sort(candidates.begin(),candidates.end());\n        bt(candidates,target,0,track,ans,visited);\n        return ans;\n    }\n};\n",charsets:{cjk:!0},lastUpdated:"2023/11/19, 12:55:48",lastUpdatedTimestamp:1700369748e3},{title:"03 全排列问题",frontmatter:{title:"03 全排列问题",date:"2023-03-24T18:39:48.000Z",permalink:"/pages/71f066/"},regularPath:"/03.LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/01.%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/05.%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/03.%E5%85%A8%E6%8E%92%E5%88%97%E9%97%AE%E9%A2%98.html",relativePath:"03.LeetCode刷题笔记/01.基础算法/05.回溯算法/03.全排列问题.md",key:"v-7596a1ba",path:"/pages/71f066/",headers:[{level:2,title:"LeetCode刷题笔记 回溯算法",slug:"leetcode刷题笔记-回溯算法",normalizedTitle:"leetcode刷题笔记 回溯算法",charIndex:2},{level:4,title:"46 全排列",slug:"_46-全排列",normalizedTitle:"46 全排列",charIndex:23},{level:4,title:"47 全排列 II",slug:"_47-全排列-ii",normalizedTitle:"47 全排列 ii",charIndex:686},{level:4,title:"剑指 Offer 38 字符串的排列",slug:"剑指-offer-38-字符串的排列",normalizedTitle:"剑指 offer 38 字符串的排列",charIndex:1471}],headersStr:"LeetCode刷题笔记 回溯算法 46 全排列 47 全排列 II 剑指 Offer 38 字符串的排列",content:'# LeetCode刷题笔记 回溯算法\n\n# 46 全排列\n\n给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。\n\n> 输入：nums = [1,2,3]\n> 输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n\n解析：\n\nclass Solution {\npublic:\n    void bt(vector<int>& nums, int level, vector<vector<int>>& ans){\n        if(level==nums.size()-1){\n            ans.push_back(nums);\n            return;\n        }\n        for(int i=level;i<nums.size();++i){\n            swap(nums[i],nums[level]);\n            bt(nums,level+1,ans);\n            swap(nums[i],nums[level]);\n        }\n        return;\n    }\n\n    vector<vector<int>> permute(vector<int>& nums) {\n        vector<vector<int>> ans;\n        bt(nums,0,ans);\n        return ans;\n    }\n};\n\n\n# 47 全排列 II\n\n给定一个可包含重复数字的序列 nums ，按任意顺序 返回所有不重复的全排列。\n\n> 输入：nums = [1,1,2]\n> 输出：\n> [[1,1,2],\n>  [1,2,1],\n>  [2,1,1]]\n\n解析：\n\nclass Solution {\npublic:\n    void bt(vector<int>& nums, int level, vector<vector<int>>& ans){\n        if(level==nums.size()-1){\n            ans.push_back(nums);\n            return;\n        }\n        for(int i=level;i<nums.size();++i){\n            sort(nums.begin()+level,nums.end());\n            if(i>level && nums[i]==nums[i-1]){\n                continue;\n            }\n            swap(nums[i],nums[level]);\n            bt(nums,level+1,ans);\n            swap(nums[i],nums[level]);\n        }\n        return;\n    }\n\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\n        vector<vector<int>> ans;\n        bt(nums,0,ans);\n        return ans;\n    }\n};\n\n\n# 剑指 Offer 38 字符串的排列\n\n输入一个字符串，打印出该字符串中字符的所有排列。\n\n你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。\n\n> 输入：s = "abc"\n> 输出：["abc","acb","bac","bca","cab","cba"]\n\n解析：\n\nclass Solution {\npublic:\n    void bt(string s, int level, vector<string>& ans){\n        if(level == s.length()-1){\n            ans.push_back(s);\n            return;\n        }\n        unordered_set<char> set;\n        for(int i=level;i<s.length();++i){\n            if(set.count(s[i])){\n                continue;\n            }\n            set.insert(s[i]);\n            swap(s[i],s[level]);\n            bt(s,level+1,ans);\n            swap(s[i],s[level]);\n        }\n        return;\n    }\n\n    vector<string> permutation(string s) {\n        vector<string> ans;\n        bt(s,0,ans);\n        return ans;\n    }\n};\n',normalizedContent:'# leetcode刷题笔记 回溯算法\n\n# 46 全排列\n\n给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。\n\n> 输入：nums = [1,2,3]\n> 输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n\n解析：\n\nclass solution {\npublic:\n    void bt(vector<int>& nums, int level, vector<vector<int>>& ans){\n        if(level==nums.size()-1){\n            ans.push_back(nums);\n            return;\n        }\n        for(int i=level;i<nums.size();++i){\n            swap(nums[i],nums[level]);\n            bt(nums,level+1,ans);\n            swap(nums[i],nums[level]);\n        }\n        return;\n    }\n\n    vector<vector<int>> permute(vector<int>& nums) {\n        vector<vector<int>> ans;\n        bt(nums,0,ans);\n        return ans;\n    }\n};\n\n\n# 47 全排列 ii\n\n给定一个可包含重复数字的序列 nums ，按任意顺序 返回所有不重复的全排列。\n\n> 输入：nums = [1,1,2]\n> 输出：\n> [[1,1,2],\n>  [1,2,1],\n>  [2,1,1]]\n\n解析：\n\nclass solution {\npublic:\n    void bt(vector<int>& nums, int level, vector<vector<int>>& ans){\n        if(level==nums.size()-1){\n            ans.push_back(nums);\n            return;\n        }\n        for(int i=level;i<nums.size();++i){\n            sort(nums.begin()+level,nums.end());\n            if(i>level && nums[i]==nums[i-1]){\n                continue;\n            }\n            swap(nums[i],nums[level]);\n            bt(nums,level+1,ans);\n            swap(nums[i],nums[level]);\n        }\n        return;\n    }\n\n    vector<vector<int>> permuteunique(vector<int>& nums) {\n        vector<vector<int>> ans;\n        bt(nums,0,ans);\n        return ans;\n    }\n};\n\n\n# 剑指 offer 38 字符串的排列\n\n输入一个字符串，打印出该字符串中字符的所有排列。\n\n你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。\n\n> 输入：s = "abc"\n> 输出：["abc","acb","bac","bca","cab","cba"]\n\n解析：\n\nclass solution {\npublic:\n    void bt(string s, int level, vector<string>& ans){\n        if(level == s.length()-1){\n            ans.push_back(s);\n            return;\n        }\n        unordered_set<char> set;\n        for(int i=level;i<s.length();++i){\n            if(set.count(s[i])){\n                continue;\n            }\n            set.insert(s[i]);\n            swap(s[i],s[level]);\n            bt(s,level+1,ans);\n            swap(s[i],s[level]);\n        }\n        return;\n    }\n\n    vector<string> permutation(string s) {\n        vector<string> ans;\n        bt(s,0,ans);\n        return ans;\n    }\n};\n',charsets:{cjk:!0},lastUpdated:"2023/11/19, 12:55:48",lastUpdatedTimestamp:1700369748e3},{title:"01数组",frontmatter:{title:"01数组",date:"2023-03-24T18:39:49.000Z",permalink:"/pages/e3b123/"},regularPath:"/03.LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/02.%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/01.%E7%BA%BF%E6%80%A7%E8%A1%A8%E4%B8%8E%E5%93%88%E5%B8%8C%E8%A1%A8/01.%E6%95%B0%E7%BB%84.html",relativePath:"03.LeetCode刷题笔记/02.基础数据结构/01.线性表与哈希表/01.数组.md",key:"v-d7b3967a",path:"/pages/e3b123/",headers:[{level:2,title:"01 数组",slug:"_01-数组",normalizedTitle:"01 数组",charIndex:2},{level:3,title:"STL 容器",slug:"stl-容器",normalizedTitle:"stl 容器",charIndex:12},{level:3,title:"一维数组",slug:"一维数组",normalizedTitle:"一维数组",charIndex:1141},{level:4,title:"448 找到所有数组中消失的数字",slug:"_448-找到所有数组中消失的数字",normalizedTitle:"448 找到所有数组中消失的数字",charIndex:1149},{level:4,title:"769 最多能完成排序的块",slug:"_769-最多能完成排序的块",normalizedTitle:"769 最多能完成排序的块",charIndex:2052},{level:3,title:"二维数组",slug:"二维数组",normalizedTitle:"二维数组",charIndex:2820},{level:4,title:"48 旋转图像",slug:"_48-旋转图像",normalizedTitle:"48 旋转图像",charIndex:2828},{level:4,title:"566 重塑矩阵",slug:"_566-重塑矩阵",normalizedTitle:"566 重塑矩阵",charIndex:3885},{level:4,title:"240 搜索二维矩阵 II",slug:"_240-搜索二维矩阵-ii",normalizedTitle:"240 搜索二维矩阵 ii",charIndex:4771}],headersStr:"01 数组 STL 容器 一维数组 448 找到所有数组中消失的数字 769 最多能完成排序的块 二维数组 48 旋转图像 566 重塑矩阵 240 搜索二维矩阵 II",content:"# 01 数组\n\n\n# STL 容器\n\n容器是可容纳各种数据类型（基本数据类型、对象等）的通用数据结构，都是类模板，分为三种类型：\n\n * 顺序容器：vector, deque, list\n * 关联容器：set, multiset, map, multimap\n * 容器适配器：stack, queue, priority_queue\n\n顺序容器：\n\n顺序容器是非排序的，而且其元素的插入位置与元素自身的值无关，数组便于查找，链表便于操作。\n\n * vector #include <vector> 一维动态数组：其元素在内存中是连续存放的，随机存取任何元素都可以在常数时间内完成，在该容器的尾部增删元素也几乎能够在常熟时间内完成具有较好的性能。\n * deque #include <deque> 双向队列：其元素在内存中是连续存放的，随机存取任何元素都可以在常数时间内完成，在该容器的两端增删元素也几乎能够在常熟时间内完成具有较好的性能。\n * list #include <list> 双向链表：其元素在内存中是不连续存放的，不支持随机存取，在该容器的任何位置增删元素几乎都能够在常熟时间内完成具有较好的性能。\n\n关联容器：\n\n关联容器的元素是排序的，插入元素需要根据相应的排序规则来确定插入位置的，在查找时具有较好的性能。关联容器通常使用平衡二叉树实现，其插入和检索的时间都是 $O(log(N))$ 。\n\n * set/multiset #include <set> 集合：set 集合中不允许存在相同的元素，multiset 集合中允许存在相同的元素。\n * map/multimap #include <map> 键值对集合：map 和 set 的不同在于前者存放的元素有且仅有两个成员变量 (first,second)，一个名为 first，另一个名为 second ，first 的值用来对整体元素进行从小到大的排序，并可以通过 first 快速检索元素。和 multiset 类似 multimap 和 map 的区别中允许存在相同 first 值的元素。\n\n容器适配器：\n\n * stack #include <stack> 栈：栈是项都有限序列，并满足序列中被删除、检索和修改的项都只能是最近插入序列的项，即栈顶的项。满足后进先出规则\n * queue #include <queue> 队列：（入队）插入只允许在尾部进行，（出队）删除、检索和修改只允许在头部进行。满足先进先出规则\n * priority_queue #include <queue> 优先级队列：优先级最高的元素总是第一个出队列\n\n更多关于C++ STL的内容请移步到此博文\n\n\n# 一维数组\n\n# 448 找到所有数组中消失的数字\n\n给定一个长度为 n 的数组，其中包含范围为 1 到 n 的整数，有些整数重复了多次，有些整数没有出现，求 1 到 n 中没有出现过的整数。\n\n输入是一个一维整数数组，输出也是一个一维整数数组，表示输入数组内没出现过的数字。\n\n> 输入：nums = [4,3,2,7,8,2,3,1]\n> 输出：[5,6]\n\n解析：\n\n利用数组这种数据结构建立长度为 n 的标记数组，每一个标记表示对应位置的元素是否出现过。然后遍历一遍 nums 根据其元素情况修改标记数组对应元素。完成一遍遍历之后，标记数组中就已经记录了 nums 中所有元素出现情况，最后在遍历一遍标记数组就可以得到没出现的元素了。\n\n数组     [1,2,3,4,5,6,7,8]\nnums   [4,3,2,7,8,2,3,1]\nmask   [T,T,T,T,F,F,T,T]\n\nclass Solution {\npublic:\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\n        int len = nums.size();\n        // 记录nums中元素存在情况\n        vector<bool> mask(len,true);\n        for(const auto num: nums){\n            mask[num-1] = false;\n        }\n        // 找出不存在的元素\n        vector<int> ans;\n        for(int i=0;i<len;++i){\n            if(mask[i]){\n                ans.push_back(i+1);\n            }\n        }\n        return ans;\n    }\n};\n\n\n进一步地，可以直接对原数组进行标记：把重复出现的数字在原数组出现的位置设为负数，最后仍然为正数的位置即为没有出现过的数。\n\n# 769 最多能完成排序的块\n\n给定一个含有 0 到 n 整数的数组，每个整数只出现一次，求这个数组最多可以分割成多少个子数组，使得对每个子数组进行增序排序后，原数组也是增序的。\n\n输入一个一维整数数组，输出一个整数，表示最多的分割数。\n\n> 输入: arr = [1,0,2,3,4] 输出: 4 解释: 可以把它分成两块，例如 [1, 0], [2, 3, 4]。然而，分成 [1, 0], [2], [3], [4] 可以得到最多的块数。\n\n解析：\n\n从左往右遍历，同时记录当前的最大值，每当当前最大值等于数组位置时，我们可以多一次分割。\n\n为什么可以通过这个算法解决问题呢？\n\n如果当前最大值大于数组位置，则说明右边一定有小于数组位置的数字，需要把它也加入待排序的子数组；又因为数组只包含不重复的 0 到 n，所以当前最大值一定不会小于数组位置。所以每当当前最大值等于数组位置时，假设为 p，我们可以成功完成一次分割，并且其与上一次分割位置 q 之间的值一定是 q + 1 到 p 的所有数字。\n\nclass Solution {\npublic:\n    int maxChunksToSorted(vector<int>& arr) {\n        int cur_max = INT_MIN;\n        int ans = 0;\n        for(int i=0;i<arr.size();++i){\n            cur_max = max(cur_max,arr[i]);\n            if(cur_max == i){\n                ++ans;\n            }\n        }\n        return ans;\n    }\n};\n\n\n\n# 二维数组\n\n# 48 旋转图像\n\n给定一个 n × n 的矩阵，在尽量不创建额外储存空间的情况下，求它顺时针旋转 90 度的结果，且必须在原矩阵上修改（in-place）。\n\n输入和输出都是一个二维整数矩阵。\n\n> 输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]\n> 输出：[[7,4,1],[8,5,2],[9,6,3]]\n\n解析：\n\n本题可以每次只考虑矩阵一圈中的 4 个间隔90度的元素的旋转情况，设置两层循环：外层循环用于一圈一圈的遍历矩阵，内循环用于旋转一圈上的元素。\n\n旋转公式主要与遍历的当前圈层相关，例如，矩阵长度len = n + 1，则第 i 圈中与[i][j]参与旋转的其他3个元素分别为[j][n-j], [n-i][n-j], [n-j][i] 他们的旋转公式为：\n\n// 以下图示例中的 2,8,15,9 为例\ntemp = matrix[j][n-i]; // 8\nmatrix[j][n-i] = matrix[i][j]; // 2\nmatrix[i][j] = matrix[n-j][i]; // 9\nmatrix[n-j][i] = matrix[n-i][n-j]; // 15\nmatrix[n-i][n-j] = temp;\n// 经过上述旋转得到 9,2,8,15\n\n\nclass Solution {\npublic:\n    void rotate(vector<vector<int>>& matrix) {\n        int n = matrix.size() - 1;\n        for(int i=0;i<=n/2;++i){\n            // 子矩阵的第一个元素是[i][n-i],最后一个元素是[n-i][n-i]\n            for(int j=i;j<n-i;++j){\n                int tmp = matrix[j][n-i];\n                matrix[j][n-i] = matrix[i][j];\n                matrix[i][j] = matrix[n-j][i];\n                matrix[n-j][i] = matrix[n-i][n-j];\n                matrix[n-i][n-j] = tmp;\n            }\n        }\n    }\n};\n\n\n# 566 重塑矩阵\n\n给定一个由二维数组 mat 表示的 m x n 矩阵，以及两个正整数 r 和 c ，分别表示想要的重构的矩阵的行数和列数。重构后的矩阵需要将原始矩阵的所有元素以相同的行遍历顺序填充。如果参数不合理直接返回原数组。\n\n输入一个二维数组，输出一个根据题目要去重塑后的二维数组\n\n> 输入：mat = [[1,2],[3,4]], r = 2, c = 4\n> 输出：[[1,2],[3,4]]\n\n解析：\n\n本题可以利用二维矩阵可以映射为一维矩阵的特点解决，例如一个 m x n 的二维矩阵可以映射成一个长度为m*n 的一维数组，其元素映射关系为：array[i] = matrix[i/n][i%n]。根据这种映射关系，又可以将一维矩阵映射为二维矩阵。\n\n所以本题的解法就是将一个 m x n 的二维矩阵映射成一个一维数组，再将这个一维数组映射成一个 r x c 的二维矩阵。\n\nclass Solution {\npublic:\n    vector<vector<int>> matrixReshape(vector<vector<int>>& mat, int r, int c) {\n        int m = mat.size(), n = mat[0].size();\n        if(m==0 || n==0){\n            return {{}};\n        }\n        // 不合理的参数直接返回原矩阵\n        if( r*c != m*n){\n            return mat;\n        }\n        // 一维数组到二维的映射\n        vector<vector<int>> ans(r,vector<int>(c));\n        for(int i=0;i<m*n;++i){\n            ans[i/c][i%c] = mat[i/n][i%n];\n        }\n        return ans;\n    }\n};\n\n\n# 240 搜索二维矩阵 II\n\n给定一个二维矩阵，已知每行和每列都是增序的，尝试设计一个快速搜索一个数字是否在矩阵中存在的算法。\n\n输入是一个二维整数矩阵，和一个待搜索整数。输出是一个布尔值，表示这个整数是否存在于矩阵中。\n\n> 输入：matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 5 输出：true\n\n解析：\n\n本题可以利用矩阵中元素的增序快速缩减搜索空间，每一行是增序的，每一列是增序的。\n\n那么我们从矩阵的右上角开始查找：\n\n * 如果当前值大于目标值那么就直接排除了当前列，向左移动一位\n * 如果当前值小于搜索值，由于我们已经搜索了当前行当前值右侧的所有元素，其左侧的值均小于当前值，因此可以直接排除当前行，向下移动一位\n * 如果最终移动到左下角时仍没有找到目标值，则说明待搜索值不存在于矩阵中\n\nclass Solution {\npublic:\n    bool searchMatrix_2(vector<vector<int>>& matrix, int target) {\n        if(matrix.empty()||matrix[0].empty()){\n            return false;\n        }\n        int m = matrix.size(), n = matrix[0].size();\n        int i = 0, j = n-1;\n        while(i<m && j>=0){\n            if(matrix[i][j] == target){\n                return true;\n            }else if(matrix[i][j] > target){\n                // 大于目标值向左移动一步\n                --j;\n            }else{\n                // 小于目标值向下移动一步\n                ++i;\n            }\n        }\n        return false;\n    }\n};\n",normalizedContent:"# 01 数组\n\n\n# stl 容器\n\n容器是可容纳各种数据类型（基本数据类型、对象等）的通用数据结构，都是类模板，分为三种类型：\n\n * 顺序容器：vector, deque, list\n * 关联容器：set, multiset, map, multimap\n * 容器适配器：stack, queue, priority_queue\n\n顺序容器：\n\n顺序容器是非排序的，而且其元素的插入位置与元素自身的值无关，数组便于查找，链表便于操作。\n\n * vector #include <vector> 一维动态数组：其元素在内存中是连续存放的，随机存取任何元素都可以在常数时间内完成，在该容器的尾部增删元素也几乎能够在常熟时间内完成具有较好的性能。\n * deque #include <deque> 双向队列：其元素在内存中是连续存放的，随机存取任何元素都可以在常数时间内完成，在该容器的两端增删元素也几乎能够在常熟时间内完成具有较好的性能。\n * list #include <list> 双向链表：其元素在内存中是不连续存放的，不支持随机存取，在该容器的任何位置增删元素几乎都能够在常熟时间内完成具有较好的性能。\n\n关联容器：\n\n关联容器的元素是排序的，插入元素需要根据相应的排序规则来确定插入位置的，在查找时具有较好的性能。关联容器通常使用平衡二叉树实现，其插入和检索的时间都是 $o(log(n))$ 。\n\n * set/multiset #include <set> 集合：set 集合中不允许存在相同的元素，multiset 集合中允许存在相同的元素。\n * map/multimap #include <map> 键值对集合：map 和 set 的不同在于前者存放的元素有且仅有两个成员变量 (first,second)，一个名为 first，另一个名为 second ，first 的值用来对整体元素进行从小到大的排序，并可以通过 first 快速检索元素。和 multiset 类似 multimap 和 map 的区别中允许存在相同 first 值的元素。\n\n容器适配器：\n\n * stack #include <stack> 栈：栈是项都有限序列，并满足序列中被删除、检索和修改的项都只能是最近插入序列的项，即栈顶的项。满足后进先出规则\n * queue #include <queue> 队列：（入队）插入只允许在尾部进行，（出队）删除、检索和修改只允许在头部进行。满足先进先出规则\n * priority_queue #include <queue> 优先级队列：优先级最高的元素总是第一个出队列\n\n更多关于c++ stl的内容请移步到此博文\n\n\n# 一维数组\n\n# 448 找到所有数组中消失的数字\n\n给定一个长度为 n 的数组，其中包含范围为 1 到 n 的整数，有些整数重复了多次，有些整数没有出现，求 1 到 n 中没有出现过的整数。\n\n输入是一个一维整数数组，输出也是一个一维整数数组，表示输入数组内没出现过的数字。\n\n> 输入：nums = [4,3,2,7,8,2,3,1]\n> 输出：[5,6]\n\n解析：\n\n利用数组这种数据结构建立长度为 n 的标记数组，每一个标记表示对应位置的元素是否出现过。然后遍历一遍 nums 根据其元素情况修改标记数组对应元素。完成一遍遍历之后，标记数组中就已经记录了 nums 中所有元素出现情况，最后在遍历一遍标记数组就可以得到没出现的元素了。\n\n数组     [1,2,3,4,5,6,7,8]\nnums   [4,3,2,7,8,2,3,1]\nmask   [t,t,t,t,f,f,t,t]\n\nclass solution {\npublic:\n    vector<int> finddisappearednumbers(vector<int>& nums) {\n        int len = nums.size();\n        // 记录nums中元素存在情况\n        vector<bool> mask(len,true);\n        for(const auto num: nums){\n            mask[num-1] = false;\n        }\n        // 找出不存在的元素\n        vector<int> ans;\n        for(int i=0;i<len;++i){\n            if(mask[i]){\n                ans.push_back(i+1);\n            }\n        }\n        return ans;\n    }\n};\n\n\n进一步地，可以直接对原数组进行标记：把重复出现的数字在原数组出现的位置设为负数，最后仍然为正数的位置即为没有出现过的数。\n\n# 769 最多能完成排序的块\n\n给定一个含有 0 到 n 整数的数组，每个整数只出现一次，求这个数组最多可以分割成多少个子数组，使得对每个子数组进行增序排序后，原数组也是增序的。\n\n输入一个一维整数数组，输出一个整数，表示最多的分割数。\n\n> 输入: arr = [1,0,2,3,4] 输出: 4 解释: 可以把它分成两块，例如 [1, 0], [2, 3, 4]。然而，分成 [1, 0], [2], [3], [4] 可以得到最多的块数。\n\n解析：\n\n从左往右遍历，同时记录当前的最大值，每当当前最大值等于数组位置时，我们可以多一次分割。\n\n为什么可以通过这个算法解决问题呢？\n\n如果当前最大值大于数组位置，则说明右边一定有小于数组位置的数字，需要把它也加入待排序的子数组；又因为数组只包含不重复的 0 到 n，所以当前最大值一定不会小于数组位置。所以每当当前最大值等于数组位置时，假设为 p，我们可以成功完成一次分割，并且其与上一次分割位置 q 之间的值一定是 q + 1 到 p 的所有数字。\n\nclass solution {\npublic:\n    int maxchunkstosorted(vector<int>& arr) {\n        int cur_max = int_min;\n        int ans = 0;\n        for(int i=0;i<arr.size();++i){\n            cur_max = max(cur_max,arr[i]);\n            if(cur_max == i){\n                ++ans;\n            }\n        }\n        return ans;\n    }\n};\n\n\n\n# 二维数组\n\n# 48 旋转图像\n\n给定一个 n × n 的矩阵，在尽量不创建额外储存空间的情况下，求它顺时针旋转 90 度的结果，且必须在原矩阵上修改（in-place）。\n\n输入和输出都是一个二维整数矩阵。\n\n> 输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]\n> 输出：[[7,4,1],[8,5,2],[9,6,3]]\n\n解析：\n\n本题可以每次只考虑矩阵一圈中的 4 个间隔90度的元素的旋转情况，设置两层循环：外层循环用于一圈一圈的遍历矩阵，内循环用于旋转一圈上的元素。\n\n旋转公式主要与遍历的当前圈层相关，例如，矩阵长度len = n + 1，则第 i 圈中与[i][j]参与旋转的其他3个元素分别为[j][n-j], [n-i][n-j], [n-j][i] 他们的旋转公式为：\n\n// 以下图示例中的 2,8,15,9 为例\ntemp = matrix[j][n-i]; // 8\nmatrix[j][n-i] = matrix[i][j]; // 2\nmatrix[i][j] = matrix[n-j][i]; // 9\nmatrix[n-j][i] = matrix[n-i][n-j]; // 15\nmatrix[n-i][n-j] = temp;\n// 经过上述旋转得到 9,2,8,15\n\n\nclass solution {\npublic:\n    void rotate(vector<vector<int>>& matrix) {\n        int n = matrix.size() - 1;\n        for(int i=0;i<=n/2;++i){\n            // 子矩阵的第一个元素是[i][n-i],最后一个元素是[n-i][n-i]\n            for(int j=i;j<n-i;++j){\n                int tmp = matrix[j][n-i];\n                matrix[j][n-i] = matrix[i][j];\n                matrix[i][j] = matrix[n-j][i];\n                matrix[n-j][i] = matrix[n-i][n-j];\n                matrix[n-i][n-j] = tmp;\n            }\n        }\n    }\n};\n\n\n# 566 重塑矩阵\n\n给定一个由二维数组 mat 表示的 m x n 矩阵，以及两个正整数 r 和 c ，分别表示想要的重构的矩阵的行数和列数。重构后的矩阵需要将原始矩阵的所有元素以相同的行遍历顺序填充。如果参数不合理直接返回原数组。\n\n输入一个二维数组，输出一个根据题目要去重塑后的二维数组\n\n> 输入：mat = [[1,2],[3,4]], r = 2, c = 4\n> 输出：[[1,2],[3,4]]\n\n解析：\n\n本题可以利用二维矩阵可以映射为一维矩阵的特点解决，例如一个 m x n 的二维矩阵可以映射成一个长度为m*n 的一维数组，其元素映射关系为：array[i] = matrix[i/n][i%n]。根据这种映射关系，又可以将一维矩阵映射为二维矩阵。\n\n所以本题的解法就是将一个 m x n 的二维矩阵映射成一个一维数组，再将这个一维数组映射成一个 r x c 的二维矩阵。\n\nclass solution {\npublic:\n    vector<vector<int>> matrixreshape(vector<vector<int>>& mat, int r, int c) {\n        int m = mat.size(), n = mat[0].size();\n        if(m==0 || n==0){\n            return {{}};\n        }\n        // 不合理的参数直接返回原矩阵\n        if( r*c != m*n){\n            return mat;\n        }\n        // 一维数组到二维的映射\n        vector<vector<int>> ans(r,vector<int>(c));\n        for(int i=0;i<m*n;++i){\n            ans[i/c][i%c] = mat[i/n][i%n];\n        }\n        return ans;\n    }\n};\n\n\n# 240 搜索二维矩阵 ii\n\n给定一个二维矩阵，已知每行和每列都是增序的，尝试设计一个快速搜索一个数字是否在矩阵中存在的算法。\n\n输入是一个二维整数矩阵，和一个待搜索整数。输出是一个布尔值，表示这个整数是否存在于矩阵中。\n\n> 输入：matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 5 输出：true\n\n解析：\n\n本题可以利用矩阵中元素的增序快速缩减搜索空间，每一行是增序的，每一列是增序的。\n\n那么我们从矩阵的右上角开始查找：\n\n * 如果当前值大于目标值那么就直接排除了当前列，向左移动一位\n * 如果当前值小于搜索值，由于我们已经搜索了当前行当前值右侧的所有元素，其左侧的值均小于当前值，因此可以直接排除当前行，向下移动一位\n * 如果最终移动到左下角时仍没有找到目标值，则说明待搜索值不存在于矩阵中\n\nclass solution {\npublic:\n    bool searchmatrix_2(vector<vector<int>>& matrix, int target) {\n        if(matrix.empty()||matrix[0].empty()){\n            return false;\n        }\n        int m = matrix.size(), n = matrix[0].size();\n        int i = 0, j = n-1;\n        while(i<m && j>=0){\n            if(matrix[i][j] == target){\n                return true;\n            }else if(matrix[i][j] > target){\n                // 大于目标值向左移动一步\n                --j;\n            }else{\n                // 小于目标值向下移动一步\n                ++i;\n            }\n        }\n        return false;\n    }\n};\n",charsets:{cjk:!0},lastUpdated:"2023/11/19, 12:55:48",lastUpdatedTimestamp:1700369748e3},{title:"Backtrack",frontmatter:{title:"Backtrack",date:"2023-03-24T18:39:48.000Z",permalink:"/pages/c428b1/"},regularPath:"/03.LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/01.%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/05.%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/Backtrack.html",relativePath:"03.LeetCode刷题笔记/01.基础算法/05.回溯算法/Backtrack.md",key:"v-55610c8f",path:"/pages/c428b1/",headers:[{level:2,title:"LeetCode刷题笔记 回溯算法",slug:"leetcode刷题笔记-回溯算法",normalizedTitle:"leetcode刷题笔记 回溯算法",charIndex:2},{level:3,title:"回溯算法简介",slug:"回溯算法简介",normalizedTitle:"回溯算法简介",charIndex:24},{level:4,title:"递归是一种算法结构，DFS是一种搜索（方法）工具，回溯是一种算法思想。",slug:"递归是一种算法结构-dfs是一种搜索-方法-工具-回溯是一种算法思想。",normalizedTitle:"递归是一种算法结构，dfs是一种搜索（方法）工具，回溯是一种算法思想。",charIndex:49},{level:3,title:"回溯算法的代码模板",slug:"回溯算法的代码模板",normalizedTitle:"回溯算法的代码模板",charIndex:428}],headersStr:"LeetCode刷题笔记 回溯算法 回溯算法简介 递归是一种算法结构，DFS是一种搜索（方法）工具，回溯是一种算法思想。 回溯算法的代码模板",content:"# LeetCode刷题笔记 回溯算法\n\n\n# 回溯算法简介\n\n递归 回溯 DFS 的区别\n\n# 递归是一种算法结构，DFS是一种搜索（方法）工具，回溯是一种算法思想。\n\n1.在函数中调用函数本身来解决子问题以达到解决原问题的方法就叫递归\n\n对于一个可以分解的问题，子问题与原问题处理过程完全相同，区别只在于数据规模，可以用递归来解。。\n\n2.回溯就是通过不同的尝试来搜索问题的解。\n\n有点类似于穷举（搜索全部解空间），但是和穷举不同的是回溯会“剪枝”，对已经知道错误的结果没必要再枚举接下来的答案了。\n\n3.回溯搜索是深度优先搜索（DFS）的一种情况\n\n对于某一个搜索树来说（搜索树是起记录路径和状态判断的作用），回溯和DFS，其主要的区别是，回溯法在求解过程中不保留完整的树结构（剪枝），而深度优先搜索则记下完整的搜索树。 为了减少存储空间，在深度优先搜索中，用标志的方法记录访问过的状态，这种处理方法使得深度优先搜索法与回溯法没什么区别了。\n\n\n# 回溯算法的代码模板\n\nresult = []\nvoid backtrack(路径, 选择列表):\n    if 满足结束条件:\n        result.add(路径)\n        return\n\n    for 选择 in 选择列表:\n        做选择\n        backtrack(路径, 选择列表)\n        撤销选择\n\n\n如何理解回溯和递归以及DFS\n\nDFS 、动态规划、回溯法、递归之间的关系是什么？\n\n回溯法套路模板 刷通leetcode\n\nC++ 总结了回溯问题类型 带你搞懂回溯算法(大量例题)",normalizedContent:"# leetcode刷题笔记 回溯算法\n\n\n# 回溯算法简介\n\n递归 回溯 dfs 的区别\n\n# 递归是一种算法结构，dfs是一种搜索（方法）工具，回溯是一种算法思想。\n\n1.在函数中调用函数本身来解决子问题以达到解决原问题的方法就叫递归\n\n对于一个可以分解的问题，子问题与原问题处理过程完全相同，区别只在于数据规模，可以用递归来解。。\n\n2.回溯就是通过不同的尝试来搜索问题的解。\n\n有点类似于穷举（搜索全部解空间），但是和穷举不同的是回溯会“剪枝”，对已经知道错误的结果没必要再枚举接下来的答案了。\n\n3.回溯搜索是深度优先搜索（dfs）的一种情况\n\n对于某一个搜索树来说（搜索树是起记录路径和状态判断的作用），回溯和dfs，其主要的区别是，回溯法在求解过程中不保留完整的树结构（剪枝），而深度优先搜索则记下完整的搜索树。 为了减少存储空间，在深度优先搜索中，用标志的方法记录访问过的状态，这种处理方法使得深度优先搜索法与回溯法没什么区别了。\n\n\n# 回溯算法的代码模板\n\nresult = []\nvoid backtrack(路径, 选择列表):\n    if 满足结束条件:\n        result.add(路径)\n        return\n\n    for 选择 in 选择列表:\n        做选择\n        backtrack(路径, 选择列表)\n        撤销选择\n\n\n如何理解回溯和递归以及dfs\n\ndfs 、动态规划、回溯法、递归之间的关系是什么？\n\n回溯法套路模板 刷通leetcode\n\nc++ 总结了回溯问题类型 带你搞懂回溯算法(大量例题)",charsets:{cjk:!0},lastUpdated:"2023/11/19, 12:55:48",lastUpdatedTimestamp:1700369748e3},{title:"02栈和队列",frontmatter:{title:"02栈和队列",date:"2023-03-24T18:39:49.000Z",permalink:"/pages/c3fc14/"},regularPath:"/03.LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/02.%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/01.%E7%BA%BF%E6%80%A7%E8%A1%A8%E4%B8%8E%E5%93%88%E5%B8%8C%E8%A1%A8/02.%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97.html",relativePath:"03.LeetCode刷题笔记/02.基础数据结构/01.线性表与哈希表/02.栈和队列.md",key:"v-044a4948",path:"/pages/c3fc14/",headers:[{level:2,title:"02 栈和队列",slug:"_02-栈和队列",normalizedTitle:"02 栈和队列",charIndex:2},{level:4,title:"232 用栈实现队列",slug:"_232-用栈实现队列",normalizedTitle:"232 用栈实现队列",charIndex:13},{level:4,title:"225 用队列实现栈",slug:"_225-用队列实现栈",normalizedTitle:"225 用队列实现栈",charIndex:1098},{level:4,title:"155 最小栈",slug:"_155-最小栈",normalizedTitle:"155 最小栈",charIndex:2082},{level:4,title:"20 有效的括号",slug:"_20-有效的括号",normalizedTitle:"20 有效的括号",charIndex:2893}],headersStr:"02 栈和队列 232 用栈实现队列 225 用队列实现栈 155 最小栈 20 有效的括号",content:"# 02 栈和队列\n\n# 232 用栈实现队列\n\n尝试使用栈（stack）来实现队列（queue）。\n\n实现 MyQueue 类：\n\n> void push(int x) 将元素 x 推到队列的末尾 int pop() 从队列的开头移除并返回元素 int peek() 返回队列开头的元素 boolean empty() 如果队列为空，返回 true ；否则，返回 false\n\n解析：\n\n本题可以使用两个方向相反的栈实现一个队列如下图所示，其中箭头表示元素 pop 方向\n\n\n\n使用两个栈的目的是：为了达到先入先出的效果，需要有一个栈用来翻转输入到栈中数组元素的顺序。这个翻转过程既可以在插入时完成，也可以在取值时完成。\n\n在输入时进行反转：当所有元素都压栈进入 in 栈之后，将所有元素先入后出地压入 out 栈翻转数组。\n\n在取值时进行反转：每次取值时，如果out非空则直接取栈顶；如果 out 栈为空，先将 in 栈中的元素全部先入后出压入 out 栈中，再从 out 栈中出栈元素。\n\nclass MyQueue {\n\nprivate:\n    // < out | in <\n    stack<int> out;\n    stack<int> in;\n\npublic:\n    MyQueue() {}\n    \n    void push(int x) {\n        in.push(x);\n    }\n\n    void connectOutIn(){\n        if(out.empty()){\n            while(!in.empty()){\n                int tail = in.top();\n                in.pop();\n                out.push(tail);\n            }\n        }\n    }\n    \n    int pop() {\n        connectOutIn();\n        int tail = out.top();\n        out.pop();\n        return tail;\n    }\n    \n    int peek() {\n        connectOutIn();\n        return out.top();\n    }\n    \n    bool empty() {\n        return out.empty()&&in.empty(); \n    }\n};\n\n\n# 225 用队列实现栈\n\n尝试使用队列（queue）来实现栈（stack）。\n\n实现 MyStack 类：\n\n> void push(int x) 将元素 x 压入栈顶。 int pop() 移除并返回栈顶元素。 int top() 返回栈顶元素。 boolean empty() 如果栈是空的，返回 true ；否则，返回 false 。\n\n解析：\n\n本题可以使用两个队列，主队列 q1 和辅助队列 q2，q1 保存当前所有元素，q2 用来在压入新元素时将该元素 q1 中已存在的元素之前。核心思想就是将新元素放到就元素之前形成先入后出。\n\n主要考虑压入新元素的过程：\n\n * 有新元素要入栈，现将该元素压入辅助队列 q2\n * 将 q1 中的所有元素依次压入已经压入新元素的 q2 中，翻转出队列顺序\n * 将 q2 中的所有元素按次序压入到 q1 中，这一过程也可以直接使用 swap 交换\n * 完成新元素压入操作\n\nclass MyStack {\n\nprivate:\n    queue<int> q1;\n    queue<int> q2;\npublic:\n    MyStack() {\n\n    }\n    \n    void push(int x) {\n        q2.push(x);\n        while(!q1.empty()){\n            q2.push(q1.front());\n            q1.pop();\n        }\n        // swap(q1,q2);\n        while(!q2.empty()){\n            q1.push(q2.front());\n            q2.pop();\n        }\n    }\n    \n    int pop() {\n        int val = q1.front();\n        q1.pop();\n        return val;\n    }\n    \n    int top() {\n        return q1.front();\n    }\n    \n    bool empty() {\n        return q1.empty();\n    }\n};\n\n\n# 155 最小栈\n\n设计一个最小栈，除了需要支持常规栈的操作外，还需要支持在 O(1) 时间内查询栈内最小值的功能。\n\n> push(x) —— 将元素 x 推入栈中。 pop() —— 删除栈顶的元素。 top() —— 获取栈顶元素。 getMin() —— 检索栈中的最小元素。\n\n解析：\n\n一种简单的思路是建立一个记录栈内当前最小值的辅助栈：每次插入原栈时，都向辅助栈插入一次原栈里当前所有值的最小值，即为辅助栈栈顶和待插入值中较小的那一个；每次从原栈里取出数字时，同样取出新栈的栈顶。\n\nclass MinStack {\n\nprivate:\n    stack<int> s, min_s;\n\npublic:\n    MinStack() {\n        min_s.push(INT_MAX);\n    }\n    \n    void push(int val) {\n        min_s.push(min(min_s.top(),val));\n        s.push(val);\n    }\n    \n    void pop() {\n        min_s.pop();\n        s.pop();\n    }\n    \n    int top() {\n        return s.top();\n    }\n    \n    int getMin() {\n        return min_s.top();\n    }\n};\n\n\n采用上述策略简化了判断，但是每次都要插入和取出，提高了时间复杂度。可以增加判断条件，减少辅助栈插入取出的操作：每当在原栈里插入一个数字时，若该数字小于等于辅助栈栈顶，则表示这个数字在原栈里是最小值，我们将其同时插入辅助栈内。每当从原栈里取出一个数字时，若该数字等于辅助栈栈顶，则表示这个数是原栈里的最小值之一，同时取出辅助栈栈顶的值。\n\n# 20 有效的括号\n\n给定一个只由左右原括号、花括号和方括号组成的字符串，求这个字符串是否合法。合法的定义是每一个类型的左括号都有一个右括号一一对应，且括号内的字符串也满足此要求。\n\n输入是一个字符串，输出是一个布尔值，表示字符串是否合法。\n\n> 输入：s = \"()[]{}\"\n> 输出：true\n\n解析：\n\n括号匹配是典型的使用栈来解决的问题。从左往右遍历，每当遇到左括号便放入栈内，遇到右括号则判断其和栈顶的括号是否是统一类型，是则从栈内取出左括号，否则说明字符串不合法。\n\nclass Solution {\npublic:\n    bool isValid(string s) {\n        stack<char> st;\n        for(const auto c: s){\n            if(c=='(' || c=='[' || c=='{'){\n                st.push(c);\n            }else{\n                if(st.empty()){\n                    return false;\n                }\n                if(c==')' && st.top()=='('){\n                    st.pop();\n                }else if(c==']' && st.top()=='['){\n                    st.pop();\n                }else if(c=='}' && st.top()=='{'){\n                    st.pop();\n                }else{\n                    return false;\n                }\n            }\n        }\n        return st.empty();\n    }\n};\n",normalizedContent:"# 02 栈和队列\n\n# 232 用栈实现队列\n\n尝试使用栈（stack）来实现队列（queue）。\n\n实现 myqueue 类：\n\n> void push(int x) 将元素 x 推到队列的末尾 int pop() 从队列的开头移除并返回元素 int peek() 返回队列开头的元素 boolean empty() 如果队列为空，返回 true ；否则，返回 false\n\n解析：\n\n本题可以使用两个方向相反的栈实现一个队列如下图所示，其中箭头表示元素 pop 方向\n\n\n\n使用两个栈的目的是：为了达到先入先出的效果，需要有一个栈用来翻转输入到栈中数组元素的顺序。这个翻转过程既可以在插入时完成，也可以在取值时完成。\n\n在输入时进行反转：当所有元素都压栈进入 in 栈之后，将所有元素先入后出地压入 out 栈翻转数组。\n\n在取值时进行反转：每次取值时，如果out非空则直接取栈顶；如果 out 栈为空，先将 in 栈中的元素全部先入后出压入 out 栈中，再从 out 栈中出栈元素。\n\nclass myqueue {\n\nprivate:\n    // < out | in <\n    stack<int> out;\n    stack<int> in;\n\npublic:\n    myqueue() {}\n    \n    void push(int x) {\n        in.push(x);\n    }\n\n    void connectoutin(){\n        if(out.empty()){\n            while(!in.empty()){\n                int tail = in.top();\n                in.pop();\n                out.push(tail);\n            }\n        }\n    }\n    \n    int pop() {\n        connectoutin();\n        int tail = out.top();\n        out.pop();\n        return tail;\n    }\n    \n    int peek() {\n        connectoutin();\n        return out.top();\n    }\n    \n    bool empty() {\n        return out.empty()&&in.empty(); \n    }\n};\n\n\n# 225 用队列实现栈\n\n尝试使用队列（queue）来实现栈（stack）。\n\n实现 mystack 类：\n\n> void push(int x) 将元素 x 压入栈顶。 int pop() 移除并返回栈顶元素。 int top() 返回栈顶元素。 boolean empty() 如果栈是空的，返回 true ；否则，返回 false 。\n\n解析：\n\n本题可以使用两个队列，主队列 q1 和辅助队列 q2，q1 保存当前所有元素，q2 用来在压入新元素时将该元素 q1 中已存在的元素之前。核心思想就是将新元素放到就元素之前形成先入后出。\n\n主要考虑压入新元素的过程：\n\n * 有新元素要入栈，现将该元素压入辅助队列 q2\n * 将 q1 中的所有元素依次压入已经压入新元素的 q2 中，翻转出队列顺序\n * 将 q2 中的所有元素按次序压入到 q1 中，这一过程也可以直接使用 swap 交换\n * 完成新元素压入操作\n\nclass mystack {\n\nprivate:\n    queue<int> q1;\n    queue<int> q2;\npublic:\n    mystack() {\n\n    }\n    \n    void push(int x) {\n        q2.push(x);\n        while(!q1.empty()){\n            q2.push(q1.front());\n            q1.pop();\n        }\n        // swap(q1,q2);\n        while(!q2.empty()){\n            q1.push(q2.front());\n            q2.pop();\n        }\n    }\n    \n    int pop() {\n        int val = q1.front();\n        q1.pop();\n        return val;\n    }\n    \n    int top() {\n        return q1.front();\n    }\n    \n    bool empty() {\n        return q1.empty();\n    }\n};\n\n\n# 155 最小栈\n\n设计一个最小栈，除了需要支持常规栈的操作外，还需要支持在 o(1) 时间内查询栈内最小值的功能。\n\n> push(x) —— 将元素 x 推入栈中。 pop() —— 删除栈顶的元素。 top() —— 获取栈顶元素。 getmin() —— 检索栈中的最小元素。\n\n解析：\n\n一种简单的思路是建立一个记录栈内当前最小值的辅助栈：每次插入原栈时，都向辅助栈插入一次原栈里当前所有值的最小值，即为辅助栈栈顶和待插入值中较小的那一个；每次从原栈里取出数字时，同样取出新栈的栈顶。\n\nclass minstack {\n\nprivate:\n    stack<int> s, min_s;\n\npublic:\n    minstack() {\n        min_s.push(int_max);\n    }\n    \n    void push(int val) {\n        min_s.push(min(min_s.top(),val));\n        s.push(val);\n    }\n    \n    void pop() {\n        min_s.pop();\n        s.pop();\n    }\n    \n    int top() {\n        return s.top();\n    }\n    \n    int getmin() {\n        return min_s.top();\n    }\n};\n\n\n采用上述策略简化了判断，但是每次都要插入和取出，提高了时间复杂度。可以增加判断条件，减少辅助栈插入取出的操作：每当在原栈里插入一个数字时，若该数字小于等于辅助栈栈顶，则表示这个数字在原栈里是最小值，我们将其同时插入辅助栈内。每当从原栈里取出一个数字时，若该数字等于辅助栈栈顶，则表示这个数是原栈里的最小值之一，同时取出辅助栈栈顶的值。\n\n# 20 有效的括号\n\n给定一个只由左右原括号、花括号和方括号组成的字符串，求这个字符串是否合法。合法的定义是每一个类型的左括号都有一个右括号一一对应，且括号内的字符串也满足此要求。\n\n输入是一个字符串，输出是一个布尔值，表示字符串是否合法。\n\n> 输入：s = \"()[]{}\"\n> 输出：true\n\n解析：\n\n括号匹配是典型的使用栈来解决的问题。从左往右遍历，每当遇到左括号便放入栈内，遇到右括号则判断其和栈顶的括号是否是统一类型，是则从栈内取出左括号，否则说明字符串不合法。\n\nclass solution {\npublic:\n    bool isvalid(string s) {\n        stack<char> st;\n        for(const auto c: s){\n            if(c=='(' || c=='[' || c=='{'){\n                st.push(c);\n            }else{\n                if(st.empty()){\n                    return false;\n                }\n                if(c==')' && st.top()=='('){\n                    st.pop();\n                }else if(c==']' && st.top()=='['){\n                    st.pop();\n                }else if(c=='}' && st.top()=='{'){\n                    st.pop();\n                }else{\n                    return false;\n                }\n            }\n        }\n        return st.empty();\n    }\n};\n",charsets:{cjk:!0},lastUpdated:"2023/11/19, 12:55:48",lastUpdatedTimestamp:1700369748e3},{title:"04优先队列",frontmatter:{title:"04优先队列",date:"2023-03-24T18:39:49.000Z",permalink:"/pages/366d13/"},regularPath:"/03.LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/02.%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/01.%E7%BA%BF%E6%80%A7%E8%A1%A8%E4%B8%8E%E5%93%88%E5%B8%8C%E8%A1%A8/04.%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97.html",relativePath:"03.LeetCode刷题笔记/02.基础数据结构/01.线性表与哈希表/04.优先队列.md",key:"v-2ded1aae",path:"/pages/366d13/",headers:[{level:2,title:"04 优先队列",slug:"_04-优先队列",normalizedTitle:"04 优先队列",charIndex:2},{level:4,title:"23. 合并K个升序链表",slug:"_23-合并k个升序链表",normalizedTitle:"23. 合并k个升序链表",charIndex:1136},{level:4,title:"218 天际线问题",slug:"_218-天际线问题",normalizedTitle:"218 天际线问题",charIndex:4630},{level:4,title:"870 优势洗牌",slug:"_870-优势洗牌",normalizedTitle:"870 优势洗牌",charIndex:6030},{level:4,title:"912 排序数组",slug:"_912-排序数组",normalizedTitle:"912 排序数组",charIndex:7686}],headersStr:"04 优先队列 23. 合并K个升序链表 218 天际线问题 870 优势洗牌 912 排序数组",content:"# 04 优先队列\n\n优先队列（priority queue）可以在 O(1) 时间内获得最大值，并且可以在 O(log n) 时间内取出最大值或插入任意值。\n\n优先队列常常用堆（heap）来实现。堆是一个完全二叉树，其每个节点的值总是大于等于子节点的值。实际实现堆时，我们通常用一个数组而不是用指针建立一个树。这是因为堆是完全二叉树，所以用数组表示时，位置 i 的节点的父节点位置一定为 i/2，而它的两个子节点的位置又一定分别为 2i 和 2i+1。\n\n以下是堆的实现方法，其中最核心的两个操作是上浮和下沉：如果一个节点比父节点大，那么需要交换这个两个节点；交换后还可能比它新的父节点大，因此需要不断地进行比较和交换操作，我们称之为上浮；类似地，如果一个节点比父节小，也需要不断地向下进行比较和交换操作，我们称之为下沉。如果一个节点有两个子节点，我们总是交换最大的子节点。\n\nvector<int> heap;\n// 获得最大值\nvoid top() {\n\treturn heap[0];\n}\n// 插入任意值：把新的数字放在最后一位，然后上浮\nvoid push(int k) {\n\theap.push_back(k);\n\tswim(heap.size() - 1);\n}\n// 删除最大值：把最后一个数字挪到开头，然后下沉\nvoid pop() {\n\theap[0] = heap.back();\n\theap.pop_back();\n\tsink(0);\n}\n// 上浮\nvoid swim(int pos) {\n\twhile (pos > 1 && heap[pos/2] < heap[pos])) {\n\t\tswap(heap[pos/2], heap[pos]);\n\t\tpos /= 2;\n\t}\n}\n// 下沉\nvoid sink(int pos) {\n\twhile (2 * pos <= N) {\n\t\tint i = 2 * pos;\n\t\tif (i < N && heap[i] < heap[i+1]){\n            ++i;\n        }\n\t\tif (heap[pos] >= heap[i]){\n            break;\n        } \n\t\tswap(heap[pos], heap[i]);\n\t\tpos = i;\n\t}\n}\n\n\n通过将算法中的大于号和小于号互换，我们也可以得到一个快速获得最小值的优先队列。0\n\n另外，正如我们在 STL 章节提到的那样，如果我们需要在维持大小关系的同时，还需要支持查找任意值、删除任意值、维护所有数字的大小关系等操作，可以考虑使用 set 或 map 来代替优先队列。\n\n# 23. 合并K个升序链表\n\n给定一个链表数组，每个链表都已经按升序排列。请将所有链表合并到一个升序链表中，返回合并后的链表。\n\n输入是一个一维数组，每个位置存储链表的头节点；输出是一条链表。\n\n> 输入：lists = [[1,4,5],[1,3,4],[2,6]] 输出：[1,1,2,3,4,4,5,6] 解释：链表数组：[1->4->5, 1->3->4, 2->6] 将它们合并到一个有序链表中得到：1->1->2->3->4->4->5->6\n\n解析：\n\n本题我们可以采用STL中的容器适配器 priority_queue，把所有的链表存储在一个优先队列中，每次提取所有链表头部节点值最小的那个节点，直到所有链表都被提取完为止。\n\n需要注意的是 priority_queue 默认的元素比较方法是less<T>，即默认为最大值元素在前面的最大堆，维持着递增关系。如果我们想要获取最小的节点值，则需要实现一个最小堆，因此比较函数应该维持递减关系。实现侧策略就是使用函数对象，自定义 priority_queue 的元素比较方法，在该函数对象中重载 operator() ，使用大于号而不是等增关系时的小于号进行比较。\n\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\n\nstruct MyCompare{\n    bool operator() (ListNode* a, ListNode* b){\n        return a->val > b->val;\n    }\n};\n\nclass Solution {\npublic:\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\n        if(lists.empty()) return nullptr;\n        // 自定义优先队列的元素比较方法 MyCompare\n        priority_queue<ListNode*, vector<ListNode*>, MyCompare> pq;\n        // 将lists都压入到优先队列中，保持递减关系\n        for(const auto list: lists){\n            if(list){\n                pq.push(list);\n            }\n        }\n        // 每次取出所有链表中头部节点最小的那个节点加入结果链表\n        ListNode head; ListNode* tail = &head;\n        while(!pq.empty()){\n            // 取出所有链表中的最小头节点并加入 结果链表\n            tail->next = pq.top();\n            pq.pop();\n            tail = tail->next;\n            // 加入后，将其 next 节点作为当前链表的新头节点加入优先队列\n            if(tail->next){\n                pq.push(tail->next);\n            }\n        }\n        return head.next;\n    }\n};\n\n\n本题也可以采用归并排序的思想，将链表两两合并。\n\n根据分治策略，首先要将 k 个链表分割，使用递归的方法将链表分割为两两一组。然后将在同一个组的链表合并。\n\n合并两个有序链表可以通过如下操作实现：\n\n * 首先需要一个变量 head 来保存合并之后链表的头部，在整个链表合并完之后，返回 head 的下一位置即可。\n * 需要一个指针 tail 来记录下一个插入位置的前一个位置，以及两个指针 aPtr 和 bPtr 来记录 a 和 b 未合并部分的第一位，即通过尾插法构建新链表\n * 当 aPtr 和 bPtr 都不为空的时候，取 val 熟悉较小的合并；如果 aPtr 为空，则把整个 bPtr 以及后面的元素全部合并；bPtr 为空时同理。\n\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n\n    ListNode* mergeTowList(ListNode* a, ListNode* b){\n        if(!a || !b) return a?a:b;\n        // 变量 head 来保存合并之后链表的头部\n        ListNode head;\n        ListNode* tail = &head;\n        ListNode* aPtr = a;\n        ListNode* bPtr = b;\n        while(aPtr && bPtr){\n            if(aPtr->val <= bPtr->val){\n                tail->next = aPtr;\n                aPtr = aPtr->next;\n            }else{\n                tail->next = bPtr;\n                bPtr = bPtr->next;\n            }\n            tail = tail->next;\n        }\n        // 循环结束 aPtr 和 bPtr 其中一个为空，直接将非空的添加到链表\n        if(aPtr){\n            tail->next = aPtr;\n        }else{\n            tail->next = bPtr;\n        }\n        return head.next;\n    }\n\n    ListNode* merge(vector<ListNode*>& lists, int lsh, int rsh){\n        if(lsh == rsh){\n            return lists[lsh];\n        }\n        if(lsh > rsh){\n            return nullptr;\n        }\n        int mid = (lsh + rsh) >> 1;\n        ListNode* lshList = merge(lists,lsh,mid);\n        ListNode* rshList = merge(lists,mid+1,rsh);\n        return mergeTowList(lshList,rshList);\n    }\n\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\n        return merge(lists,0,lists.size()-1);\n    }\n};\n\n\n# 218 天际线问题\n\n给定建筑物的起止位置和高度，返回建筑物轮廓（天际线）的拐点。\n\n输入是一个二维整数数组，表示每个建筑物的 [左端, 右端, 高度]；输出是一个二维整数数组，表示每个拐点的横纵坐标。\n\n\n\n> 输入：buildings = [[2,9,10],[3,7,15],[5,12,12],[15,20,10],[19,24,8]] 输出：[[2,10],[3,15],[7,12],[12,0],[15,10],[20,8],[24,0]] 解释：图 A 显示输入的所有建筑物的位置和高度，图 B 显示由这些建筑物形成的天际线。图 B 中的红点表示输出列表中的关键点。\n\n解析：\n\n本题没搞懂，有待再理解\n\n我们可以使用优先队列储存每个建筑物的高度和右端（这里使用 pair，其默认比较函数是先比较第一个值，如果相等则再比较第二个值），从而获取目前会拔高天际线、且妨碍到前一个建筑物（的右端端点）的下一个建筑物。\n\nclass Solution {\npublic:\n    vector<vector<int>> getSkyline(vector<vector<int>>& buildings) {\n        vector<vector<int>> ans;\n        priority_queue<pair<int,int>> heap;\n        int i = 0;\n        int len = buildings.size();\n        int cur_x, cur_h;\n        while(i<len || !heap.empty()){\n            if(heap.empty() || i<len && buildings[i][0] <= heap.top().second){\n                cur_x = buildings[i][0];\n                while(i<len && cur_x==buildings[i][0]){\n                    heap.emplace(buildings[i][2], buildings[i][1]);\n                    ++i;\n                }\n            }else{\n                cur_x = heap.top().second;\n                while(!heap.empty() && cur_x >= heap.top().second){\n                    heap.pop();\n                }\n            }\n            cur_h = (heap.empty())?0:heap.top().first;\n            if(ans.empty() || cur_h != ans.back()[1]){\n                ans.push_back({cur_x,cur_h});\n            }\n        }\n        return ans;\n    }\n};\n\n\n# 870 优势洗牌\n\n给定两个大小相等的数组 A 和 B，A 相对于 B 的优势可以用满足 A[i] > B[i] 的索引 i 的数目来描述。\n\n返回 A 的任意排列，使其相对于 B 的优势最大化。\n\n> 输入：A = [12,24,8,32], B = [13,25,32,11]\n> 输出：[24,32,8,12]\n\n解析：\n\n本题采用田忌赛马的策略，如果 A 中有元素比 B 的大，那么用最大的那个值取对应B中的元素；如果A中没有元素比当前B大，那么用最小的 A 对应该元素。\n\n我们采用优先队列保存 B 中的元素值和原先位置，并维持递减顺序。将 A 中元素按递增排序，然后遍历优先队列中的 B 元素。因为B采用优先队列保存，所以取出的总是当前B的最大元素，如果 A 中存在比该元素还大的值，则取 A 的当前最大值即排序后数组末尾元素放在该元素的原先位置；不存在就用 A 中的最小元素即排序后数组第一个元素放在该元素的原先位置。\n\n例如A = [12,24,8,32], B = [13,25,32,11]，对A排序，对B用优先队列存储元素值和原先位置有A = [8,12,24,32], B = [{32,2},{25,1},{13,0},{11,3}]，结果形成过程如下：\n\nSORT_A         PRIORITY_QUEUE_B                RESULT_A\n[8,12,24,32]   [{32,2},{25,1},{13,0},{11,3}]   [0,0,0,0]\n[12,24,32]     [{25,1},{13,0},{11,3}]          [0,0,8,0]\n[12,24]        [{13,0},{11,3}]                 [0,32,8,0]\n[12]           [{11,3}]                        [24,32,8,0]\n[]             [{}]                            [24,32,8,12]\n\nclass Solution {\npublic:\n    vector<int> advantageCount(vector<int>& nums1, vector<int>& nums2) {\n        vector<int> ans(nums1.size());\n        // A 排序\n        sort(nums1.begin(),nums1.end());\n        // B 用优先队列保存\n        priority_queue<pair<int,int>> pq;\n        for(int i=0;i<nums2.size();++i){\n            pq.push(make_pair(nums2[i],i));\n        }\n        // 逐个比较优先队列中的元素，根据大取大、小取小的原则洗牌A的元素\n        int head = 0, tail = nums1.size()-1;\n        while(!pq.empty()){\n            int num = pq.top().first;\n            int index = pq.top().second;\n            pq.pop();\n            if(nums1[tail]>num){\n                ans[index] = nums1[tail--];\n            }else{\n                ans[index] = nums1[head++];\n            }\n        }\n        return ans;\n    }\n};\n\n\n# 912 排序数组\n\n给你一个整数数组 nums，请你将该数组升序排列。\n\n> 输入：nums = [5,2,3,1]\n> 输出：[1,2,3,5]\n\n解析：\n\n堆排序\n\n",normalizedContent:"# 04 优先队列\n\n优先队列（priority queue）可以在 o(1) 时间内获得最大值，并且可以在 o(log n) 时间内取出最大值或插入任意值。\n\n优先队列常常用堆（heap）来实现。堆是一个完全二叉树，其每个节点的值总是大于等于子节点的值。实际实现堆时，我们通常用一个数组而不是用指针建立一个树。这是因为堆是完全二叉树，所以用数组表示时，位置 i 的节点的父节点位置一定为 i/2，而它的两个子节点的位置又一定分别为 2i 和 2i+1。\n\n以下是堆的实现方法，其中最核心的两个操作是上浮和下沉：如果一个节点比父节点大，那么需要交换这个两个节点；交换后还可能比它新的父节点大，因此需要不断地进行比较和交换操作，我们称之为上浮；类似地，如果一个节点比父节小，也需要不断地向下进行比较和交换操作，我们称之为下沉。如果一个节点有两个子节点，我们总是交换最大的子节点。\n\nvector<int> heap;\n// 获得最大值\nvoid top() {\n\treturn heap[0];\n}\n// 插入任意值：把新的数字放在最后一位，然后上浮\nvoid push(int k) {\n\theap.push_back(k);\n\tswim(heap.size() - 1);\n}\n// 删除最大值：把最后一个数字挪到开头，然后下沉\nvoid pop() {\n\theap[0] = heap.back();\n\theap.pop_back();\n\tsink(0);\n}\n// 上浮\nvoid swim(int pos) {\n\twhile (pos > 1 && heap[pos/2] < heap[pos])) {\n\t\tswap(heap[pos/2], heap[pos]);\n\t\tpos /= 2;\n\t}\n}\n// 下沉\nvoid sink(int pos) {\n\twhile (2 * pos <= n) {\n\t\tint i = 2 * pos;\n\t\tif (i < n && heap[i] < heap[i+1]){\n            ++i;\n        }\n\t\tif (heap[pos] >= heap[i]){\n            break;\n        } \n\t\tswap(heap[pos], heap[i]);\n\t\tpos = i;\n\t}\n}\n\n\n通过将算法中的大于号和小于号互换，我们也可以得到一个快速获得最小值的优先队列。0\n\n另外，正如我们在 stl 章节提到的那样，如果我们需要在维持大小关系的同时，还需要支持查找任意值、删除任意值、维护所有数字的大小关系等操作，可以考虑使用 set 或 map 来代替优先队列。\n\n# 23. 合并k个升序链表\n\n给定一个链表数组，每个链表都已经按升序排列。请将所有链表合并到一个升序链表中，返回合并后的链表。\n\n输入是一个一维数组，每个位置存储链表的头节点；输出是一条链表。\n\n> 输入：lists = [[1,4,5],[1,3,4],[2,6]] 输出：[1,1,2,3,4,4,5,6] 解释：链表数组：[1->4->5, 1->3->4, 2->6] 将它们合并到一个有序链表中得到：1->1->2->3->4->4->5->6\n\n解析：\n\n本题我们可以采用stl中的容器适配器 priority_queue，把所有的链表存储在一个优先队列中，每次提取所有链表头部节点值最小的那个节点，直到所有链表都被提取完为止。\n\n需要注意的是 priority_queue 默认的元素比较方法是less<t>，即默认为最大值元素在前面的最大堆，维持着递增关系。如果我们想要获取最小的节点值，则需要实现一个最小堆，因此比较函数应该维持递减关系。实现侧策略就是使用函数对象，自定义 priority_queue 的元素比较方法，在该函数对象中重载 operator() ，使用大于号而不是等增关系时的小于号进行比较。\n\n/**\n * definition for singly-linked list.\n * struct listnode {\n *     int val;\n *     listnode *next;\n *     listnode() : val(0), next(nullptr) {}\n *     listnode(int x) : val(x), next(nullptr) {}\n *     listnode(int x, listnode *next) : val(x), next(next) {}\n * };\n */\n\nstruct mycompare{\n    bool operator() (listnode* a, listnode* b){\n        return a->val > b->val;\n    }\n};\n\nclass solution {\npublic:\n    listnode* mergeklists(vector<listnode*>& lists) {\n        if(lists.empty()) return nullptr;\n        // 自定义优先队列的元素比较方法 mycompare\n        priority_queue<listnode*, vector<listnode*>, mycompare> pq;\n        // 将lists都压入到优先队列中，保持递减关系\n        for(const auto list: lists){\n            if(list){\n                pq.push(list);\n            }\n        }\n        // 每次取出所有链表中头部节点最小的那个节点加入结果链表\n        listnode head; listnode* tail = &head;\n        while(!pq.empty()){\n            // 取出所有链表中的最小头节点并加入 结果链表\n            tail->next = pq.top();\n            pq.pop();\n            tail = tail->next;\n            // 加入后，将其 next 节点作为当前链表的新头节点加入优先队列\n            if(tail->next){\n                pq.push(tail->next);\n            }\n        }\n        return head.next;\n    }\n};\n\n\n本题也可以采用归并排序的思想，将链表两两合并。\n\n根据分治策略，首先要将 k 个链表分割，使用递归的方法将链表分割为两两一组。然后将在同一个组的链表合并。\n\n合并两个有序链表可以通过如下操作实现：\n\n * 首先需要一个变量 head 来保存合并之后链表的头部，在整个链表合并完之后，返回 head 的下一位置即可。\n * 需要一个指针 tail 来记录下一个插入位置的前一个位置，以及两个指针 aptr 和 bptr 来记录 a 和 b 未合并部分的第一位，即通过尾插法构建新链表\n * 当 aptr 和 bptr 都不为空的时候，取 val 熟悉较小的合并；如果 aptr 为空，则把整个 bptr 以及后面的元素全部合并；bptr 为空时同理。\n\n/**\n * definition for singly-linked list.\n * struct listnode {\n *     int val;\n *     listnode *next;\n *     listnode() : val(0), next(nullptr) {}\n *     listnode(int x) : val(x), next(nullptr) {}\n *     listnode(int x, listnode *next) : val(x), next(next) {}\n * };\n */\nclass solution {\npublic:\n\n    listnode* mergetowlist(listnode* a, listnode* b){\n        if(!a || !b) return a?a:b;\n        // 变量 head 来保存合并之后链表的头部\n        listnode head;\n        listnode* tail = &head;\n        listnode* aptr = a;\n        listnode* bptr = b;\n        while(aptr && bptr){\n            if(aptr->val <= bptr->val){\n                tail->next = aptr;\n                aptr = aptr->next;\n            }else{\n                tail->next = bptr;\n                bptr = bptr->next;\n            }\n            tail = tail->next;\n        }\n        // 循环结束 aptr 和 bptr 其中一个为空，直接将非空的添加到链表\n        if(aptr){\n            tail->next = aptr;\n        }else{\n            tail->next = bptr;\n        }\n        return head.next;\n    }\n\n    listnode* merge(vector<listnode*>& lists, int lsh, int rsh){\n        if(lsh == rsh){\n            return lists[lsh];\n        }\n        if(lsh > rsh){\n            return nullptr;\n        }\n        int mid = (lsh + rsh) >> 1;\n        listnode* lshlist = merge(lists,lsh,mid);\n        listnode* rshlist = merge(lists,mid+1,rsh);\n        return mergetowlist(lshlist,rshlist);\n    }\n\n    listnode* mergeklists(vector<listnode*>& lists) {\n        return merge(lists,0,lists.size()-1);\n    }\n};\n\n\n# 218 天际线问题\n\n给定建筑物的起止位置和高度，返回建筑物轮廓（天际线）的拐点。\n\n输入是一个二维整数数组，表示每个建筑物的 [左端, 右端, 高度]；输出是一个二维整数数组，表示每个拐点的横纵坐标。\n\n\n\n> 输入：buildings = [[2,9,10],[3,7,15],[5,12,12],[15,20,10],[19,24,8]] 输出：[[2,10],[3,15],[7,12],[12,0],[15,10],[20,8],[24,0]] 解释：图 a 显示输入的所有建筑物的位置和高度，图 b 显示由这些建筑物形成的天际线。图 b 中的红点表示输出列表中的关键点。\n\n解析：\n\n本题没搞懂，有待再理解\n\n我们可以使用优先队列储存每个建筑物的高度和右端（这里使用 pair，其默认比较函数是先比较第一个值，如果相等则再比较第二个值），从而获取目前会拔高天际线、且妨碍到前一个建筑物（的右端端点）的下一个建筑物。\n\nclass solution {\npublic:\n    vector<vector<int>> getskyline(vector<vector<int>>& buildings) {\n        vector<vector<int>> ans;\n        priority_queue<pair<int,int>> heap;\n        int i = 0;\n        int len = buildings.size();\n        int cur_x, cur_h;\n        while(i<len || !heap.empty()){\n            if(heap.empty() || i<len && buildings[i][0] <= heap.top().second){\n                cur_x = buildings[i][0];\n                while(i<len && cur_x==buildings[i][0]){\n                    heap.emplace(buildings[i][2], buildings[i][1]);\n                    ++i;\n                }\n            }else{\n                cur_x = heap.top().second;\n                while(!heap.empty() && cur_x >= heap.top().second){\n                    heap.pop();\n                }\n            }\n            cur_h = (heap.empty())?0:heap.top().first;\n            if(ans.empty() || cur_h != ans.back()[1]){\n                ans.push_back({cur_x,cur_h});\n            }\n        }\n        return ans;\n    }\n};\n\n\n# 870 优势洗牌\n\n给定两个大小相等的数组 a 和 b，a 相对于 b 的优势可以用满足 a[i] > b[i] 的索引 i 的数目来描述。\n\n返回 a 的任意排列，使其相对于 b 的优势最大化。\n\n> 输入：a = [12,24,8,32], b = [13,25,32,11]\n> 输出：[24,32,8,12]\n\n解析：\n\n本题采用田忌赛马的策略，如果 a 中有元素比 b 的大，那么用最大的那个值取对应b中的元素；如果a中没有元素比当前b大，那么用最小的 a 对应该元素。\n\n我们采用优先队列保存 b 中的元素值和原先位置，并维持递减顺序。将 a 中元素按递增排序，然后遍历优先队列中的 b 元素。因为b采用优先队列保存，所以取出的总是当前b的最大元素，如果 a 中存在比该元素还大的值，则取 a 的当前最大值即排序后数组末尾元素放在该元素的原先位置；不存在就用 a 中的最小元素即排序后数组第一个元素放在该元素的原先位置。\n\n例如a = [12,24,8,32], b = [13,25,32,11]，对a排序，对b用优先队列存储元素值和原先位置有a = [8,12,24,32], b = [{32,2},{25,1},{13,0},{11,3}]，结果形成过程如下：\n\nsort_a         priority_queue_b                result_a\n[8,12,24,32]   [{32,2},{25,1},{13,0},{11,3}]   [0,0,0,0]\n[12,24,32]     [{25,1},{13,0},{11,3}]          [0,0,8,0]\n[12,24]        [{13,0},{11,3}]                 [0,32,8,0]\n[12]           [{11,3}]                        [24,32,8,0]\n[]             [{}]                            [24,32,8,12]\n\nclass solution {\npublic:\n    vector<int> advantagecount(vector<int>& nums1, vector<int>& nums2) {\n        vector<int> ans(nums1.size());\n        // a 排序\n        sort(nums1.begin(),nums1.end());\n        // b 用优先队列保存\n        priority_queue<pair<int,int>> pq;\n        for(int i=0;i<nums2.size();++i){\n            pq.push(make_pair(nums2[i],i));\n        }\n        // 逐个比较优先队列中的元素，根据大取大、小取小的原则洗牌a的元素\n        int head = 0, tail = nums1.size()-1;\n        while(!pq.empty()){\n            int num = pq.top().first;\n            int index = pq.top().second;\n            pq.pop();\n            if(nums1[tail]>num){\n                ans[index] = nums1[tail--];\n            }else{\n                ans[index] = nums1[head++];\n            }\n        }\n        return ans;\n    }\n};\n\n\n# 912 排序数组\n\n给你一个整数数组 nums，请你将该数组升序排列。\n\n> 输入：nums = [5,2,3,1]\n> 输出：[1,2,3,5]\n\n解析：\n\n堆排序\n\n",charsets:{cjk:!0},lastUpdated:"2023/11/19, 12:55:48",lastUpdatedTimestamp:1700369748e3},{title:"03单调栈",frontmatter:{title:"03单调栈",date:"2023-03-24T18:39:49.000Z",permalink:"/pages/45a757/"},regularPath:"/03.LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/02.%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/01.%E7%BA%BF%E6%80%A7%E8%A1%A8%E4%B8%8E%E5%93%88%E5%B8%8C%E8%A1%A8/03.%E5%8D%95%E8%B0%83%E6%A0%88.html",relativePath:"03.LeetCode刷题笔记/02.基础数据结构/01.线性表与哈希表/03.单调栈.md",key:"v-510b3c03",path:"/pages/45a757/",headers:[{level:2,title:"03 单调栈",slug:"_03-单调栈",normalizedTitle:"03 单调栈",charIndex:2},{level:4,title:"739 每日温度",slug:"_739-每日温度",normalizedTitle:"739 每日温度",charIndex:60},{level:4,title:"503 下一个更大元素 II",slug:"_503-下一个更大元素-ii",normalizedTitle:"503 下一个更大元素 ii",charIndex:1260},{level:4,title:"42 接雨水",slug:"_42-接雨水",normalizedTitle:"42 接雨水",charIndex:2478},{level:4,title:"84 柱状图中最大的矩形",slug:"_84-柱状图中最大的矩形",normalizedTitle:"84 柱状图中最大的矩形",charIndex:2671},{level:4,title:"85 最大矩形",slug:"_85-最大矩形",normalizedTitle:"85 最大矩形",charIndex:3649}],headersStr:"03 单调栈 739 每日温度 503 下一个更大元素 II 42 接雨水 84 柱状图中最大的矩形 85 最大矩形",content:'# 03 单调栈\n\n单调栈通过维持栈内值的单调递增（递减）性，在整体 O(n) 的时间内处理需要大小比较的问题。\n\n# 739 每日温度\n\n给定每天的温度，求对于每一天需要等几天才可以等到更暖和的一天。如果该天之后不存在更暖和的天气，则记为 0。\n\n输入是一个一维整数数组，输出是同样长度的整数数组，表示对于每天需要等待多少天。\n\n> 输入: temperatures = [73,74,75,71,69,72,76,73]\n> 输出: [1,1,4,2,1,1,0,0]\n\n解析：\n\n本题可以通过维持一个单调递减的栈，表示每天的温度；而本题要求的是当前温度到更高温度的天数差，所以栈中的元素表示的是温度对应的日期，即温度在数组中的位置。单调递减的栈，所以栈顶表示的是栈内最低温度的日期。\n\n从左向右遍历数组，对于日期 p ，如果 p 对应的温度高于栈顶的日期 q 对应的温度，则遇到了更暖和的一天，将 q 出栈并记录天数差为 p - q；如果 p 对应的温度低于栈顶的日期 q 对应的温度，或者栈为空，则将 p 压入栈中，然后继续考虑下一天的情况。\n\n遍历完数组之后，栈内剩余的日期对应的温度都是递减的，说明他们之后不存在更暖和的天气。\n\nclass Solution {\npublic:\n    vector<int> dailyTemperatures(vector<int>& temperatures) {\n        stack<int> s;\n        int len = temperatures.size();\n        vector<int> ans(len);\n        for(int i=0;i<len;++i){\n            // 出栈栈内低于当前日期温度的日期，并计算天数差\n            while(!s.empty()){\n                int preTemp = temperatures[s.top()];\n                // 如果栈顶日期温度大于当前日期温度，停止出栈\n                if(preTemp >= temperatures[i]){\n                    break;\n                }\n                ans[s.top()] = i - s.top();\n                s.pop();\n            }\n            s.push(i);\n        }\n        // 遍历完成之后，还未出栈的日期之后没有更高的温度\n        while(!s.empty()){\n            ans[s.top()] = 0;\n            s.pop();\n        }\n        return ans;\n    }\n};\n\n\n# 503 下一个更大元素 II\n\n给定一个循环数组（最后一个元素的下一个元素是数组的第一个元素），输出每个元素的下一个更大元素。如果不存在，则输出 -1。\n\n输入是一个一维整数数组，输出是同样长度的整数数组，表示对于原数组每位置的数下一个更大元素。\n\n> 输入: [1,2,1] 输出: [2,-1,2] 解释: 第一个 1 的下一个更大的数是 2；数字 2 找不到下一个更大的数； 第二个 1 的下一个最大的数需要循环搜索，结果也是 2。\n\n解析：\n\n和每日温度相似，本题也可以通过维持一个单调递减的栈，表示原数组元素位置。\n\n本题和739 每日温度的区别在于本题待遍历的数组是一个循环数组，遍历循环数组的常用方式是将这个循环的圈拉直，即复制该序列的前 n-1 个元素拼接在原序列的后面。即用一个原数组的拷贝与其自身拼接成一个数组，例如将ABCDEF循环数组拉直有ABCDEFABCDEF，就有了A到A、B倒B……F到F的循环。\n\n更简单可以避免增加空间开销，直接可以用模运算遍历数组，例如长度为 n 的循环数组元素表示为array[i%n]\n\n按照上述循环数组遍历方法，从左向右遍历，对于当前位置 p，如果 p 对应的元素值大于单调栈栈顶 q 对应的元素值，则 q 遇到的更大值，在 q 位置保留 p 对应的值。如果栈为空，或者p 对应的元素值小于单调栈栈顶 q 对应的元素值，则将 p 压入栈，然后考虑下一个元素。\n\n遍历完数组之后，栈内剩余的位置对应的元素值都是递减的，说明他们之后不存在更大的元素。\n\nclass Solution {\npublic:\n    vector<int> nextGreaterElements(vector<int>& nums) {\n        stack<int> s;\n        int len = nums.size();\n        // ans都初始化成 -1 就不用再去考虑没有出栈的元素了\n        vector<int> ans(len,-1);\n        for(int i=0;i<2*len-1;++i){\n            while(!s.empty()){\n                int preVal = nums[s.top()%len];\n                if(preVal >= nums[i%len]){\n                    break;\n                }\n                ans[s.top()%len] = nums[i%len];\n                s.pop();\n            }\n            s.push(i);\n        }\n        return ans;\n    }\n};\n\n\n# 42 接雨水\n\n给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。\n\n\n\n> 输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]\n> 输出：6\n> 解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 \n\n解析:\n\n# 84 柱状图中最大的矩形\n\n给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。\n\n求在该柱状图中，能够勾勒出来的矩形的最大面积。\n\n\n\n> 输入：heights = [2,1,5,6,2,3]\n> 输出：10\n> 解释：最大的矩形为图中红色区域，面积为 10\n\n解析:\n\nclass Solution {\npublic:\n    int largestRectangleArea(vector<int>& heights) {\n        stack<int> st;\n        int n = heights.size();\n        vector<int> left(n), right(n);\n        for(int i=0;i<n;++i){\n            while(!st.empty() && heights[st.top()] >= heights[i]){\n                st.pop();\n            }\n            left[i] = st.empty()?-1:st.top(); // -1 作为哨兵\n            st.push(i);\n        }\n\n        st = stack<int>();\n        for(int i=n-1;i>=0;--i){\n            while(!st.empty() && heights[st.top()] >= heights[i]){\n                st.pop();\n            }\n            right[i] = st.empty()?n:st.top(); // n 作为哨兵\n            st.push(i);\n        }\n\n        int ans = 0;\n        for(int i=0;i<n;++i){\n            ans = max(ans,(right[i]-left[i]-1)*heights[i]); // 面积=宽X高\n        }\n        return ans;\n    }\n};\n\n\n# 85 最大矩形\n\n给定一个仅包含 0 和 1 、大小为 rows x cols 的二维二进制矩阵，找出只包含 1 的最大矩形，并返回其面积。\n\n\n\n> 输入：matrix = [["1","0","1","0","0"],["1","0","1","1","1"],["1","1","1","1","1"],["1","0","0","1","0"]]\n> 输出：6\n> 解释：最大矩形如上图所示。\n\n解析:\n\nclass Solution {\npublic:\n    int maximalRectangle(vector<vector<char>>& matrix) {\n        int m = matrix.size(), n = matrix[0].size();\n        if(m==0 || n==0){\n            return 0;\n        }\n        \n        vector<vector<int>> left(m,vector<int>(n,0));\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (matrix[i][j] == \'1\') {\n                    left[i][j] = (j == 0 ? 0: left[i][j - 1]) + 1;\n                }\n            }\n        }\n\n        int ans = 0;\n        for(int j=0;j<n;++j){\n            stack<int> st;\n            vector<int> up(m), down(m);\n            for(int i=0;i<m;++i){\n                while(!st.empty() && left[st.top()][j] >= left[i][j]){\n                    st.pop();\n                }\n                up[i] = st.empty()?-1:st.top();\n                st.push(i);\n            }\n\n            st = stack<int>();\n            for(int i=m-1;i>=0;--i){\n                while(!st.empty() && left[st.top()][j] >= left[i][j]){\n                    st.pop();\n                }\n                down[i] = st.empty()?m:st.top();\n                st.push(i);\n            }\n\n            for(int i=0;i<m;++i){\n                int height = down[i] - up[i] - 1;\n                ans = max(ans,height*left[i][j]);\n            }\n        }\n\n        return ans;\n    }\n};\n',normalizedContent:'# 03 单调栈\n\n单调栈通过维持栈内值的单调递增（递减）性，在整体 o(n) 的时间内处理需要大小比较的问题。\n\n# 739 每日温度\n\n给定每天的温度，求对于每一天需要等几天才可以等到更暖和的一天。如果该天之后不存在更暖和的天气，则记为 0。\n\n输入是一个一维整数数组，输出是同样长度的整数数组，表示对于每天需要等待多少天。\n\n> 输入: temperatures = [73,74,75,71,69,72,76,73]\n> 输出: [1,1,4,2,1,1,0,0]\n\n解析：\n\n本题可以通过维持一个单调递减的栈，表示每天的温度；而本题要求的是当前温度到更高温度的天数差，所以栈中的元素表示的是温度对应的日期，即温度在数组中的位置。单调递减的栈，所以栈顶表示的是栈内最低温度的日期。\n\n从左向右遍历数组，对于日期 p ，如果 p 对应的温度高于栈顶的日期 q 对应的温度，则遇到了更暖和的一天，将 q 出栈并记录天数差为 p - q；如果 p 对应的温度低于栈顶的日期 q 对应的温度，或者栈为空，则将 p 压入栈中，然后继续考虑下一天的情况。\n\n遍历完数组之后，栈内剩余的日期对应的温度都是递减的，说明他们之后不存在更暖和的天气。\n\nclass solution {\npublic:\n    vector<int> dailytemperatures(vector<int>& temperatures) {\n        stack<int> s;\n        int len = temperatures.size();\n        vector<int> ans(len);\n        for(int i=0;i<len;++i){\n            // 出栈栈内低于当前日期温度的日期，并计算天数差\n            while(!s.empty()){\n                int pretemp = temperatures[s.top()];\n                // 如果栈顶日期温度大于当前日期温度，停止出栈\n                if(pretemp >= temperatures[i]){\n                    break;\n                }\n                ans[s.top()] = i - s.top();\n                s.pop();\n            }\n            s.push(i);\n        }\n        // 遍历完成之后，还未出栈的日期之后没有更高的温度\n        while(!s.empty()){\n            ans[s.top()] = 0;\n            s.pop();\n        }\n        return ans;\n    }\n};\n\n\n# 503 下一个更大元素 ii\n\n给定一个循环数组（最后一个元素的下一个元素是数组的第一个元素），输出每个元素的下一个更大元素。如果不存在，则输出 -1。\n\n输入是一个一维整数数组，输出是同样长度的整数数组，表示对于原数组每位置的数下一个更大元素。\n\n> 输入: [1,2,1] 输出: [2,-1,2] 解释: 第一个 1 的下一个更大的数是 2；数字 2 找不到下一个更大的数； 第二个 1 的下一个最大的数需要循环搜索，结果也是 2。\n\n解析：\n\n和每日温度相似，本题也可以通过维持一个单调递减的栈，表示原数组元素位置。\n\n本题和739 每日温度的区别在于本题待遍历的数组是一个循环数组，遍历循环数组的常用方式是将这个循环的圈拉直，即复制该序列的前 n-1 个元素拼接在原序列的后面。即用一个原数组的拷贝与其自身拼接成一个数组，例如将abcdef循环数组拉直有abcdefabcdef，就有了a到a、b倒b……f到f的循环。\n\n更简单可以避免增加空间开销，直接可以用模运算遍历数组，例如长度为 n 的循环数组元素表示为array[i%n]\n\n按照上述循环数组遍历方法，从左向右遍历，对于当前位置 p，如果 p 对应的元素值大于单调栈栈顶 q 对应的元素值，则 q 遇到的更大值，在 q 位置保留 p 对应的值。如果栈为空，或者p 对应的元素值小于单调栈栈顶 q 对应的元素值，则将 p 压入栈，然后考虑下一个元素。\n\n遍历完数组之后，栈内剩余的位置对应的元素值都是递减的，说明他们之后不存在更大的元素。\n\nclass solution {\npublic:\n    vector<int> nextgreaterelements(vector<int>& nums) {\n        stack<int> s;\n        int len = nums.size();\n        // ans都初始化成 -1 就不用再去考虑没有出栈的元素了\n        vector<int> ans(len,-1);\n        for(int i=0;i<2*len-1;++i){\n            while(!s.empty()){\n                int preval = nums[s.top()%len];\n                if(preval >= nums[i%len]){\n                    break;\n                }\n                ans[s.top()%len] = nums[i%len];\n                s.pop();\n            }\n            s.push(i);\n        }\n        return ans;\n    }\n};\n\n\n# 42 接雨水\n\n给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。\n\n\n\n> 输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]\n> 输出：6\n> 解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 \n\n解析:\n\n# 84 柱状图中最大的矩形\n\n给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。\n\n求在该柱状图中，能够勾勒出来的矩形的最大面积。\n\n\n\n> 输入：heights = [2,1,5,6,2,3]\n> 输出：10\n> 解释：最大的矩形为图中红色区域，面积为 10\n\n解析:\n\nclass solution {\npublic:\n    int largestrectanglearea(vector<int>& heights) {\n        stack<int> st;\n        int n = heights.size();\n        vector<int> left(n), right(n);\n        for(int i=0;i<n;++i){\n            while(!st.empty() && heights[st.top()] >= heights[i]){\n                st.pop();\n            }\n            left[i] = st.empty()?-1:st.top(); // -1 作为哨兵\n            st.push(i);\n        }\n\n        st = stack<int>();\n        for(int i=n-1;i>=0;--i){\n            while(!st.empty() && heights[st.top()] >= heights[i]){\n                st.pop();\n            }\n            right[i] = st.empty()?n:st.top(); // n 作为哨兵\n            st.push(i);\n        }\n\n        int ans = 0;\n        for(int i=0;i<n;++i){\n            ans = max(ans,(right[i]-left[i]-1)*heights[i]); // 面积=宽x高\n        }\n        return ans;\n    }\n};\n\n\n# 85 最大矩形\n\n给定一个仅包含 0 和 1 、大小为 rows x cols 的二维二进制矩阵，找出只包含 1 的最大矩形，并返回其面积。\n\n\n\n> 输入：matrix = [["1","0","1","0","0"],["1","0","1","1","1"],["1","1","1","1","1"],["1","0","0","1","0"]]\n> 输出：6\n> 解释：最大矩形如上图所示。\n\n解析:\n\nclass solution {\npublic:\n    int maximalrectangle(vector<vector<char>>& matrix) {\n        int m = matrix.size(), n = matrix[0].size();\n        if(m==0 || n==0){\n            return 0;\n        }\n        \n        vector<vector<int>> left(m,vector<int>(n,0));\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (matrix[i][j] == \'1\') {\n                    left[i][j] = (j == 0 ? 0: left[i][j - 1]) + 1;\n                }\n            }\n        }\n\n        int ans = 0;\n        for(int j=0;j<n;++j){\n            stack<int> st;\n            vector<int> up(m), down(m);\n            for(int i=0;i<m;++i){\n                while(!st.empty() && left[st.top()][j] >= left[i][j]){\n                    st.pop();\n                }\n                up[i] = st.empty()?-1:st.top();\n                st.push(i);\n            }\n\n            st = stack<int>();\n            for(int i=m-1;i>=0;--i){\n                while(!st.empty() && left[st.top()][j] >= left[i][j]){\n                    st.pop();\n                }\n                down[i] = st.empty()?m:st.top();\n                st.push(i);\n            }\n\n            for(int i=0;i<m;++i){\n                int height = down[i] - up[i] - 1;\n                ans = max(ans,height*left[i][j]);\n            }\n        }\n\n        return ans;\n    }\n};\n',charsets:{cjk:!0},lastUpdated:"2023/11/19, 12:55:48",lastUpdatedTimestamp:1700369748e3},{title:"05双端队列",frontmatter:{title:"05双端队列",date:"2023-03-24T18:39:49.000Z",permalink:"/pages/dfe85c/"},regularPath:"/03.LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/02.%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/01.%E7%BA%BF%E6%80%A7%E8%A1%A8%E4%B8%8E%E5%93%88%E5%B8%8C%E8%A1%A8/05.%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97.html",relativePath:"03.LeetCode刷题笔记/02.基础数据结构/01.线性表与哈希表/05.双端队列.md",key:"v-5d57353a",path:"/pages/dfe85c/",headers:[{level:2,title:"05 双端队列",slug:"_05-双端队列",normalizedTitle:"05 双端队列",charIndex:2}],headersStr:"05 双端队列",content:"# 05 双端队列",normalizedContent:"# 05 双端队列",charsets:{cjk:!0},lastUpdated:"2023/11/19, 12:55:48",lastUpdatedTimestamp:1700369748e3},{title:"06哈希表",frontmatter:{title:"06哈希表",date:"2023-03-24T18:39:49.000Z",permalink:"/pages/d9969b/"},regularPath:"/03.LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/02.%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/01.%E7%BA%BF%E6%80%A7%E8%A1%A8%E4%B8%8E%E5%93%88%E5%B8%8C%E8%A1%A8/06.%E5%93%88%E5%B8%8C%E8%A1%A8.html",relativePath:"03.LeetCode刷题笔记/02.基础数据结构/01.线性表与哈希表/06.哈希表.md",key:"v-660c2778",path:"/pages/d9969b/",headers:[{level:2,title:"06 哈希表",slug:"_06-哈希表",normalizedTitle:"06 哈希表",charIndex:2},{level:4,title:"1 两数之和",slug:"_1-两数之和",normalizedTitle:"1 两数之和",charIndex:1516},{level:4,title:"217 存在重复元素",slug:"_217-存在重复元素",normalizedTitle:"217 存在重复元素",charIndex:2299},{level:4,title:"287 寻找重复数",slug:"_287-寻找重复数",normalizedTitle:"287 寻找重复数",charIndex:2797},{level:4,title:"128 最长连续序列",slug:"_128-最长连续序列",normalizedTitle:"128 最长连续序列",charIndex:3349},{level:4,title:"594 最长和谐子序列",slug:"_594-最长和谐子序列",normalizedTitle:"594 最长和谐子序列",charIndex:4238},{level:4,title:"697 数组的度",slug:"_697-数组的度",normalizedTitle:"697 数组的度",charIndex:5136},{level:4,title:"149 直线上最多的点数",slug:"_149-直线上最多的点数",normalizedTitle:"149 直线上最多的点数",charIndex:6375}],headersStr:"06 哈希表 1 两数之和 217 存在重复元素 287 寻找重复数 128 最长连续序列 594 最长和谐子序列 697 数组的度 149 直线上最多的点数",content:"# 06 哈希表\n\n哈希表，又称散列表，使用 O(n) 空间复杂度存储数据，通过哈希函数映射位置，从而实现近似 O(1) 时间复杂度的插入、查找、删除等操作。 C++ 中的哈希集合为 unordered_set，可以查找元素是否在集合中。如果需要同时存储键和值，则需要用 unordered_map，可以用来统计频率，记录内容等等。如果元素有穷，并且范围不大，那么可以用一个固定大小的数组来存储或统计元素。例如我们需要统计一个字符串中所有字母的出现次数，则可以用一个长度为 26 的数组来进行统计，其哈希函数即为字母在字母表的位置，这样空间复杂度就可以降低为常数。 一个简单的哈希表的实现如下：\n\ntemplate <typename T>\nclass HashTable {\nprivate:\n    vector<list<T>> hash_table;\n    // 哈希函数\n    int myhash(const T & obj) const {\n    \treturn hash(obj, hash_table.size());\n    }\n    \npublic:\n\t// size最好是质数\n\tHashTable(int size=31) {\n        hash_table.reserve(size);\n        hash_table.resize(size);\n    }\n\t~HashTable() {}\n\t// 查找哈希表是否存在该值\n    bool contains(const T & obj) {\n        int hash_value = myhash(obj);\n        const list<T> & slot = hash_table[hash_value];\n        std::list<T>::const_iterator it = slot.cbegin();\n        for (; it != slot.cend() && *it != obj; ++it);\n        return it != slot.cend();\n    }\n    // 插入值\n    bool insert(const T & obj) {\n        if (contains(obj)) {\n        \treturn false;\n    \t}\n        int hash_value = myhash(obj);\n        std::list<T> & slot = hash_table[hash_value];\n        slot.push_front(obj);\n        return true;\n\t}\n\t// 删除值\n    bool remove(const T & obj) {\n        list<T> & slot = hash_table[myhash(obj)];\n        auto it = find(slot.begin(), slot.end(), obj);\n        if (it == slot.end()) {\n        \treturn false;\n        }\n\t\tslot.erase(it);\n\t\treturn true;\n\t}\n};\n// 一个简单的对整数实现的哈希函数\nint hash(const int & key, const int &tableSize) {\n\treturn key % tableSize;\n}\n\n\n# 1 两数之和\n\n给定一个整数数组，已知有且只有两个数的和等于给定值，求这两个数的位置。\n\n输入一个一维整数数组和一个目标值，输出是一个大小为 2 的一维数组，表示满足条件的两个数字的位置。\n\n> 输入：nums = [2,7,11,15], target = 9 输出：[0,1] 解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。\n\n解析：\n\n可以利用哈希表存储遍历过的值以及它们的位置，每次遍历到位置 i 的时候，查找哈希表里是否存在 target - nums[i]，若存在，则说明这两个值的和为 target。\n\nclass Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int,int> hash;\n        vector<int> ans;\n        for(int i=0;i<nums.size();++i){\n            int num = nums[i];\n            auto pNum = hash.find(target-num);\n            if(pNum != hash.end()){\n                ans.push_back(i);\n                ans.push_back(pNum->second);\n                break;\n            }else{\n                hash[num] = i;\n            }\n        }\n        return ans;\n    }\n};\n\n\n# 217 存在重复元素\n\n给定一个整数数组，判断是否存在重复元素。\n\n输入一个一维整数数组，输出是一个布尔值表示数组中是否存在重复元素。\n\n> 输入: [1,2,3,4]\n> 输出: false\n\n解析：\n\n哈希表可以用于去重复，可以快速判断是否存在重复元素。\n\n遍历数组将所有元素都插入哈希表中，插入之前判断元素是否已经存在，如果存在则直接返回 true，遍历全部数组之后没有发现重复元素则返回 false。\n\nclass Solution {\npublic:\n    bool containsDuplicate(vector<int>& nums) {\n        unordered_set<int> hash;\n        for(const auto num: nums){\n            if(hash.count(num)){\n                return true;\n            }\n            hash.insert(num);\n        }\n        return false;\n    }\n};\n\n\n# 287 寻找重复数\n\n给定一个包含 n + 1 个整数的数组 nums ，其数字都在 1 到 n 之间（包括 1 和 n），假设 nums 只有一个重复的整数 ，找出这个重复的数 。\n\n输入一个一维整数数组，输出是一个整数表示数组中存在重复的元素。\n\n> 输入：nums = [1,3,4,2,2]\n> 输出：2\n\n解析：\n\n本题和217 存在重复元素题相似，使用哈希表可以快速判断是否存在重复元素。\n\n遍历数组将所有元素都插入哈希表中，插入之前判断元素是否已经存在，如果存在则直接返回该值，遍历全部数组之后没有发现重复元素，则数组不存在重复元素。\n\nclass Solution {\npublic:\n    int findDuplicate(vector<int>& nums) {\n        unordered_set<int> hash;\n        for(auto num: nums){\n            if(hash.count(num)){\n                return num;\n            }\n            hash.insert(num);\n        }\n        return 0;\n    }\n};\n\n\n# 128 最长连续序列\n\n给定一个整数数组，求这个数组中的数字可以组成的最长连续序列有多长。\n\n输入一个整数数组，输出一个整数，表示连续序列的长度。\n\n> 输入：nums = [100,4,200,1,3,2]\n> 输出：4\n> 解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。\n\n解析：\n\n本题可以把所有数字放到一个哈希表，然后不断地从哈希表中任意取一个值，如果该值的前驱 elem - 1 不存在那么当前元素是新的序列起点，以当前值 elem 为起点向后枚举寻找连续序列。\n\n假设一次枚举的连续序列最后一个值为 last，那么该连续序列的长度为 last-elem+1。通过一遍遍历寻找数组中的所有连续序列，并不断更新最长序列长度。\n\nclass Solution {\npublic:\n    int longestConsecutive(vector<int>& nums) {\n        unordered_set<int> hash;\n        for(const auto& num: nums){\n            hash.insert(num);\n        }\n        int ans = 0;\n        for(const auto elem: hash){\n            // 如果 elem - 1 不存在那么当前元素是新的序列起点\n            if(hash.find(elem-1)==hash.end()){\n                int cur = elem;\n                while(hash.find(cur+1)!=hash.end()){\n                    ++cur;\n                }\n                ans = max(ans,cur-elem+1);\n            }\n        }\n        return ans;\n    }\n};\n\n\n# 594 最长和谐子序列\n\n和谐数组是指一个数组里元素的最大值和最小值之间的差别 正好是 1 。现在，给定一个整数数组 nums ，在所有可能的子序列中找到最长的和谐子序列的长度。\n\n输入一个整数数组，输出一个整数，表示和谐子序列的长度。\n\n> 输入：nums = [1,3,2,2,5,2,3,7]\n> 输出：5\n> 解释：最长的和谐子序列是 [3,2,2,2,3]\n\n解析：\n\n本题的思路和128 最长连续序列一样，甚至更加简单，因为只需要考虑由两个相差为 1 的元素组成的子序列。\n\n同样的建立一个哈希表用于统计不同值在数组中的频数，然后遍历哈希表找到相差为 1 的元素统计他们频数之和选取最大值。同样的，我们只需要考虑 elem + 1，而不需要回过头来考虑 elem - 1，因为之前的值已经考虑了，不需要重复考虑。\n\nclass Solution {\npublic:\n    int findLHS(vector<int>& nums) {\n        unordered_map<int,int> hash;\n        // 统计频数\n        for(const auto num: nums){\n            if(hash.find(num)==hash.end()){\n                hash[num] = 1;\n            }else{\n                ++hash[num];\n            }\n        }\n        // 计算最长和谐子序列\n        int ans = 0;\n        for(const auto [elem,cnt]: hash){\n            if(hash.find(elem+1)!=hash.end()){\n                ans = max(ans,cnt+hash[elem+1]);\n            }\n        }\n        return ans;\n    }\n};\n\n\n# 697 数组的度\n\n给定一个非空数组 nums，在 nums 中找到与 nums 拥有相同大小的度的最短连续子数组，返回其长度。组的度的定义是指数组里任一元素出现频数的最大值。\n\n输入一个整数数组，输出一个整数，表示与数组度一致的最短子序列长度。\n\n> 输入：[1, 2, 2, 3, 1] 输出：2 解释：输入数组的度是2，因为元素1和2的出现频数最大，均为2. 连续子数组里面拥有相同度的有如下所示: [1, 2, 2, 3, 1], [1, 2, 2, 3], [2, 2, 3, 1], [1, 2, 2], [2, 2, 3], [2, 2] 最短连续子数组[2, 2]的长度为2，所以返回2.\n\n解析：\n\n本题可以直接使用哈希表统计数组中元素出现的频次，并记录每个元素第一次出现和最后一次出现的位置。找出出现频次最高的元素，它第一次出现到最后一次出现两个位置之间的子序列就是与数组度一致的最短子序列。需要注意的是，要考虑到频次最高的元素可能存在多个相同的情况，这时保存他们之中序列长度最短的情况。\n\nclass Solution {\npublic:\n    int findShortestSubArray(vector<int>& nums) {\n        unordered_map<int, vector<int>> hash;\n        for(int i=0;i<nums.size();++i){\n            int num = nums[i];\n            if(hash.find(num)==hash.end()){\n                // 这里用列表初始化，如果直接使用索引访问会出错，应为未初始化vector\n                hash[num] = {1,i,i};\n            }else{\n                hash[num][0]++;\n                hash[num][2] = i;\n            }\n        }\n\n        int maxCnt = 0;\n        int ans = 0;\n        for(const auto [num, vec]: hash){\n            if(maxCnt < vec[0]){\n                maxCnt = vec[0];\n                ans = vec[2] - vec[1] + 1;\n            }else if(maxCnt == vec[0]){\n                ans = min(ans,vec[2] - vec[1] + 1);\n            }\n        }\n        return ans;\n    }\n};\n\n\n# 149 直线上最多的点数\n\n给定一些二维坐标中的点，求同一条线上最多由多少点。\n\n输入是一个二维整数数组，表示每个点的横纵坐标；输出是一个整数，表示满足条件的最多点数。\n\n> 输入：points = [[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]\n> 输出：4\n> 解释：样例中，y = 5 − x 上有[[3,2],[4,1],[2,3],[1,4]]四个点。\n\n解析：\n\n本题可以建立一个哈希表，统计同一斜率的点一共有多少个。因为：一条线可以由一个点和斜率唯一确定。另外需要考虑到斜率不存在和重复坐标的情况。\n\n采用双重循环遍历每一个点与其他点的斜率，外循环遍历所有点，内循环统计斜率相同的点的个数。在遍历每个点时，对于数组中位置 i 的点，我们只需要考虑 i 之后的点即可，因为 i 之前的点已经考虑过 i 了。\n\n首先我们要考虑斜率不存在的情况，即点的 x 坐标相同；如果不仅 x 坐标相同，y 坐标也相同，那么这两个点为重复坐标。\n\n然后，考虑一般情况，即斜率存在的情况，只需要逐个遍历，计算两点之间的斜率并保存到哈希表中即可。\n\n最后根据一次遍历的结果计算与当前点有关的直线中最多点数的直线。\n\nclass Solution {\npublic:\n    int maxPoints(vector<vector<int>>& points) {\n        unordered_map<double,int> hash;\n        int ans = 0;\n        for(int i=0;i<points.size();++i){\n            int same_x = 1, same = 1;\n            for(int j = i+1;j<points.size();++j){\n                // 斜率不存在的情况\n                if(points[i][0] == points[j][0]){\n                    ++same_x;\n                    // 两个点为重复坐标\n                    if(points[i][1] == points[j][1]){\n                        ++same;\n                    }\n                }else{\n                    // 一般情况\n                    double dy = points[j][1] - points[i][1];\n                    double dx = points[j][0] - points[i][0];\n                    ++hash[dy/dx];\n                }\n            }\n\n            // 与(i,j)相关斜率不存在的直线\n            ans = max(ans,same_x);\n            // 与(i,j)相关哈希表中保存的斜率存在的直线\n            for(const auto [rate,count]: hash){\n                ans = max(ans,same+count);\n            }\n            hash.clear();\n        }\n        return ans;\n    }\n};\n",normalizedContent:"# 06 哈希表\n\n哈希表，又称散列表，使用 o(n) 空间复杂度存储数据，通过哈希函数映射位置，从而实现近似 o(1) 时间复杂度的插入、查找、删除等操作。 c++ 中的哈希集合为 unordered_set，可以查找元素是否在集合中。如果需要同时存储键和值，则需要用 unordered_map，可以用来统计频率，记录内容等等。如果元素有穷，并且范围不大，那么可以用一个固定大小的数组来存储或统计元素。例如我们需要统计一个字符串中所有字母的出现次数，则可以用一个长度为 26 的数组来进行统计，其哈希函数即为字母在字母表的位置，这样空间复杂度就可以降低为常数。 一个简单的哈希表的实现如下：\n\ntemplate <typename t>\nclass hashtable {\nprivate:\n    vector<list<t>> hash_table;\n    // 哈希函数\n    int myhash(const t & obj) const {\n    \treturn hash(obj, hash_table.size());\n    }\n    \npublic:\n\t// size最好是质数\n\thashtable(int size=31) {\n        hash_table.reserve(size);\n        hash_table.resize(size);\n    }\n\t~hashtable() {}\n\t// 查找哈希表是否存在该值\n    bool contains(const t & obj) {\n        int hash_value = myhash(obj);\n        const list<t> & slot = hash_table[hash_value];\n        std::list<t>::const_iterator it = slot.cbegin();\n        for (; it != slot.cend() && *it != obj; ++it);\n        return it != slot.cend();\n    }\n    // 插入值\n    bool insert(const t & obj) {\n        if (contains(obj)) {\n        \treturn false;\n    \t}\n        int hash_value = myhash(obj);\n        std::list<t> & slot = hash_table[hash_value];\n        slot.push_front(obj);\n        return true;\n\t}\n\t// 删除值\n    bool remove(const t & obj) {\n        list<t> & slot = hash_table[myhash(obj)];\n        auto it = find(slot.begin(), slot.end(), obj);\n        if (it == slot.end()) {\n        \treturn false;\n        }\n\t\tslot.erase(it);\n\t\treturn true;\n\t}\n};\n// 一个简单的对整数实现的哈希函数\nint hash(const int & key, const int &tablesize) {\n\treturn key % tablesize;\n}\n\n\n# 1 两数之和\n\n给定一个整数数组，已知有且只有两个数的和等于给定值，求这两个数的位置。\n\n输入一个一维整数数组和一个目标值，输出是一个大小为 2 的一维数组，表示满足条件的两个数字的位置。\n\n> 输入：nums = [2,7,11,15], target = 9 输出：[0,1] 解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。\n\n解析：\n\n可以利用哈希表存储遍历过的值以及它们的位置，每次遍历到位置 i 的时候，查找哈希表里是否存在 target - nums[i]，若存在，则说明这两个值的和为 target。\n\nclass solution {\npublic:\n    vector<int> twosum(vector<int>& nums, int target) {\n        unordered_map<int,int> hash;\n        vector<int> ans;\n        for(int i=0;i<nums.size();++i){\n            int num = nums[i];\n            auto pnum = hash.find(target-num);\n            if(pnum != hash.end()){\n                ans.push_back(i);\n                ans.push_back(pnum->second);\n                break;\n            }else{\n                hash[num] = i;\n            }\n        }\n        return ans;\n    }\n};\n\n\n# 217 存在重复元素\n\n给定一个整数数组，判断是否存在重复元素。\n\n输入一个一维整数数组，输出是一个布尔值表示数组中是否存在重复元素。\n\n> 输入: [1,2,3,4]\n> 输出: false\n\n解析：\n\n哈希表可以用于去重复，可以快速判断是否存在重复元素。\n\n遍历数组将所有元素都插入哈希表中，插入之前判断元素是否已经存在，如果存在则直接返回 true，遍历全部数组之后没有发现重复元素则返回 false。\n\nclass solution {\npublic:\n    bool containsduplicate(vector<int>& nums) {\n        unordered_set<int> hash;\n        for(const auto num: nums){\n            if(hash.count(num)){\n                return true;\n            }\n            hash.insert(num);\n        }\n        return false;\n    }\n};\n\n\n# 287 寻找重复数\n\n给定一个包含 n + 1 个整数的数组 nums ，其数字都在 1 到 n 之间（包括 1 和 n），假设 nums 只有一个重复的整数 ，找出这个重复的数 。\n\n输入一个一维整数数组，输出是一个整数表示数组中存在重复的元素。\n\n> 输入：nums = [1,3,4,2,2]\n> 输出：2\n\n解析：\n\n本题和217 存在重复元素题相似，使用哈希表可以快速判断是否存在重复元素。\n\n遍历数组将所有元素都插入哈希表中，插入之前判断元素是否已经存在，如果存在则直接返回该值，遍历全部数组之后没有发现重复元素，则数组不存在重复元素。\n\nclass solution {\npublic:\n    int findduplicate(vector<int>& nums) {\n        unordered_set<int> hash;\n        for(auto num: nums){\n            if(hash.count(num)){\n                return num;\n            }\n            hash.insert(num);\n        }\n        return 0;\n    }\n};\n\n\n# 128 最长连续序列\n\n给定一个整数数组，求这个数组中的数字可以组成的最长连续序列有多长。\n\n输入一个整数数组，输出一个整数，表示连续序列的长度。\n\n> 输入：nums = [100,4,200,1,3,2]\n> 输出：4\n> 解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。\n\n解析：\n\n本题可以把所有数字放到一个哈希表，然后不断地从哈希表中任意取一个值，如果该值的前驱 elem - 1 不存在那么当前元素是新的序列起点，以当前值 elem 为起点向后枚举寻找连续序列。\n\n假设一次枚举的连续序列最后一个值为 last，那么该连续序列的长度为 last-elem+1。通过一遍遍历寻找数组中的所有连续序列，并不断更新最长序列长度。\n\nclass solution {\npublic:\n    int longestconsecutive(vector<int>& nums) {\n        unordered_set<int> hash;\n        for(const auto& num: nums){\n            hash.insert(num);\n        }\n        int ans = 0;\n        for(const auto elem: hash){\n            // 如果 elem - 1 不存在那么当前元素是新的序列起点\n            if(hash.find(elem-1)==hash.end()){\n                int cur = elem;\n                while(hash.find(cur+1)!=hash.end()){\n                    ++cur;\n                }\n                ans = max(ans,cur-elem+1);\n            }\n        }\n        return ans;\n    }\n};\n\n\n# 594 最长和谐子序列\n\n和谐数组是指一个数组里元素的最大值和最小值之间的差别 正好是 1 。现在，给定一个整数数组 nums ，在所有可能的子序列中找到最长的和谐子序列的长度。\n\n输入一个整数数组，输出一个整数，表示和谐子序列的长度。\n\n> 输入：nums = [1,3,2,2,5,2,3,7]\n> 输出：5\n> 解释：最长的和谐子序列是 [3,2,2,2,3]\n\n解析：\n\n本题的思路和128 最长连续序列一样，甚至更加简单，因为只需要考虑由两个相差为 1 的元素组成的子序列。\n\n同样的建立一个哈希表用于统计不同值在数组中的频数，然后遍历哈希表找到相差为 1 的元素统计他们频数之和选取最大值。同样的，我们只需要考虑 elem + 1，而不需要回过头来考虑 elem - 1，因为之前的值已经考虑了，不需要重复考虑。\n\nclass solution {\npublic:\n    int findlhs(vector<int>& nums) {\n        unordered_map<int,int> hash;\n        // 统计频数\n        for(const auto num: nums){\n            if(hash.find(num)==hash.end()){\n                hash[num] = 1;\n            }else{\n                ++hash[num];\n            }\n        }\n        // 计算最长和谐子序列\n        int ans = 0;\n        for(const auto [elem,cnt]: hash){\n            if(hash.find(elem+1)!=hash.end()){\n                ans = max(ans,cnt+hash[elem+1]);\n            }\n        }\n        return ans;\n    }\n};\n\n\n# 697 数组的度\n\n给定一个非空数组 nums，在 nums 中找到与 nums 拥有相同大小的度的最短连续子数组，返回其长度。组的度的定义是指数组里任一元素出现频数的最大值。\n\n输入一个整数数组，输出一个整数，表示与数组度一致的最短子序列长度。\n\n> 输入：[1, 2, 2, 3, 1] 输出：2 解释：输入数组的度是2，因为元素1和2的出现频数最大，均为2. 连续子数组里面拥有相同度的有如下所示: [1, 2, 2, 3, 1], [1, 2, 2, 3], [2, 2, 3, 1], [1, 2, 2], [2, 2, 3], [2, 2] 最短连续子数组[2, 2]的长度为2，所以返回2.\n\n解析：\n\n本题可以直接使用哈希表统计数组中元素出现的频次，并记录每个元素第一次出现和最后一次出现的位置。找出出现频次最高的元素，它第一次出现到最后一次出现两个位置之间的子序列就是与数组度一致的最短子序列。需要注意的是，要考虑到频次最高的元素可能存在多个相同的情况，这时保存他们之中序列长度最短的情况。\n\nclass solution {\npublic:\n    int findshortestsubarray(vector<int>& nums) {\n        unordered_map<int, vector<int>> hash;\n        for(int i=0;i<nums.size();++i){\n            int num = nums[i];\n            if(hash.find(num)==hash.end()){\n                // 这里用列表初始化，如果直接使用索引访问会出错，应为未初始化vector\n                hash[num] = {1,i,i};\n            }else{\n                hash[num][0]++;\n                hash[num][2] = i;\n            }\n        }\n\n        int maxcnt = 0;\n        int ans = 0;\n        for(const auto [num, vec]: hash){\n            if(maxcnt < vec[0]){\n                maxcnt = vec[0];\n                ans = vec[2] - vec[1] + 1;\n            }else if(maxcnt == vec[0]){\n                ans = min(ans,vec[2] - vec[1] + 1);\n            }\n        }\n        return ans;\n    }\n};\n\n\n# 149 直线上最多的点数\n\n给定一些二维坐标中的点，求同一条线上最多由多少点。\n\n输入是一个二维整数数组，表示每个点的横纵坐标；输出是一个整数，表示满足条件的最多点数。\n\n> 输入：points = [[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]\n> 输出：4\n> 解释：样例中，y = 5 − x 上有[[3,2],[4,1],[2,3],[1,4]]四个点。\n\n解析：\n\n本题可以建立一个哈希表，统计同一斜率的点一共有多少个。因为：一条线可以由一个点和斜率唯一确定。另外需要考虑到斜率不存在和重复坐标的情况。\n\n采用双重循环遍历每一个点与其他点的斜率，外循环遍历所有点，内循环统计斜率相同的点的个数。在遍历每个点时，对于数组中位置 i 的点，我们只需要考虑 i 之后的点即可，因为 i 之前的点已经考虑过 i 了。\n\n首先我们要考虑斜率不存在的情况，即点的 x 坐标相同；如果不仅 x 坐标相同，y 坐标也相同，那么这两个点为重复坐标。\n\n然后，考虑一般情况，即斜率存在的情况，只需要逐个遍历，计算两点之间的斜率并保存到哈希表中即可。\n\n最后根据一次遍历的结果计算与当前点有关的直线中最多点数的直线。\n\nclass solution {\npublic:\n    int maxpoints(vector<vector<int>>& points) {\n        unordered_map<double,int> hash;\n        int ans = 0;\n        for(int i=0;i<points.size();++i){\n            int same_x = 1, same = 1;\n            for(int j = i+1;j<points.size();++j){\n                // 斜率不存在的情况\n                if(points[i][0] == points[j][0]){\n                    ++same_x;\n                    // 两个点为重复坐标\n                    if(points[i][1] == points[j][1]){\n                        ++same;\n                    }\n                }else{\n                    // 一般情况\n                    double dy = points[j][1] - points[i][1];\n                    double dx = points[j][0] - points[i][0];\n                    ++hash[dy/dx];\n                }\n            }\n\n            // 与(i,j)相关斜率不存在的直线\n            ans = max(ans,same_x);\n            // 与(i,j)相关哈希表中保存的斜率存在的直线\n            for(const auto [rate,count]: hash){\n                ans = max(ans,same+count);\n            }\n            hash.clear();\n        }\n        return ans;\n    }\n};\n",charsets:{cjk:!0},lastUpdated:"2023/11/19, 12:55:48",lastUpdatedTimestamp:1700369748e3},{title:"07多重集合",frontmatter:{title:"07多重集合",date:"2023-03-24T18:39:49.000Z",permalink:"/pages/52cdea/"},regularPath:"/03.LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/02.%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/01.%E7%BA%BF%E6%80%A7%E8%A1%A8%E4%B8%8E%E5%93%88%E5%B8%8C%E8%A1%A8/07.%E5%A4%9A%E9%87%8D%E9%9B%86%E5%90%88.html",relativePath:"03.LeetCode刷题笔记/02.基础数据结构/01.线性表与哈希表/07.多重集合.md",key:"v-1e4a90e6",path:"/pages/52cdea/",headers:[{level:2,title:"07 多重集合",slug:"_07-多重集合",normalizedTitle:"07 多重集合",charIndex:2},{level:4,title:"332 重新安排行程",slug:"_332-重新安排行程",normalizedTitle:"332 重新安排行程",charIndex:13}],headersStr:"07 多重集合 332 重新安排行程",content:'# 07 多重集合\n\n# 332 重新安排行程\n\n给定一个人坐过的一些飞机的起止机场，已知这个人从 JFK 起飞，那么这个人是按什么顺序飞的；如果存在多种可能性，返回字母序最小的那种。\n\n输入是一个二维字符串数组，表示多个起止机场对子；输出是一个一维字符串数组，表示飞行顺序。\n\n> 输入：tickets = [["JFK","SFO"],["JFK","ATL"],["SFO","ATL"],["ATL","JFK"],["ATL","SFO"]] 输出：["JFK","ATL","JFK","SFO","ATL","SFO"] 解释：另一种有效的行程是 ["JFK","SFO","ATL","JFK","ATL","SFO"] ，但是它字典排序更大更靠后。\n\n解析：\n\n本题可以使用哈希表记录机票的起飞机场和落地机场，由于可能存在多个不同落地机场，所以需要使用集合来存储。又由于可能存在重复路线，所以要保存落地机场的重复值，且要求结果的返回顺序是按照最小字母序，刚好可以使用多重集合 multiset，不仅可以存储重复值，而且多重集合的默认元素保存顺序是递增的，例如"SFO","ATL","JFK" 在多重集合中的保存顺序是 "ATL","JFK","SFO"。上例子的哈希表保存结果为：\n\nHASH_KEY   HASH_VALUE\nJFK        {ATL, SFO}\nSFO        {ATL}\nATL        {JFK, SFO}\n\n保存好起飞机场和落地机场的关系后，我们使用栈来恢复一条完整的从最终落地机场到达起始机场的路线。从起始机场开始，按照转移顺序将机场逐个压入栈。取当前栈顶作为下一个落地机场，如果栈顶为空则说明到达一个终点，将其加入结果。如果不为空，则将其作为起飞机场对应的第一个落地机场入栈并移除。完成上述过程就恢复出了一条从终点到起点的飞行路线。上例恢复的路线为JFK->ATL->JFK->SFO->ATL->SFO\n\nclass Solution {\npublic:\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\n        // 构建哈希表多重集合，保存起飞机场对应的落地机场\n        unordered_map<string, multiset<string>> hash;\n        for(const auto ticket: tickets){\n            hash[ticket[0]].insert(ticket[1]);\n        }\n        // 使用栈恢复从终点到达起点的逆向路线\n        vector<string> ans;\n        stack<string> st;\n        st.push("JFK");\n        while(!st.empty()){\n            string end = st.top();\n            // 当前机场对应的落地机场为空，说明他是一个终点\n            if(hash[end].empty()){\n                ans.push_back(end);\n                st.pop();\n            }else{\n                st.push(*hash[end].begin());\n                hash[end].erase(hash[end].begin());\n            }\n        }\n        reverse(ans.begin(),ans.end());\n        return ans;\n    }\n};\n',normalizedContent:'# 07 多重集合\n\n# 332 重新安排行程\n\n给定一个人坐过的一些飞机的起止机场，已知这个人从 jfk 起飞，那么这个人是按什么顺序飞的；如果存在多种可能性，返回字母序最小的那种。\n\n输入是一个二维字符串数组，表示多个起止机场对子；输出是一个一维字符串数组，表示飞行顺序。\n\n> 输入：tickets = [["jfk","sfo"],["jfk","atl"],["sfo","atl"],["atl","jfk"],["atl","sfo"]] 输出：["jfk","atl","jfk","sfo","atl","sfo"] 解释：另一种有效的行程是 ["jfk","sfo","atl","jfk","atl","sfo"] ，但是它字典排序更大更靠后。\n\n解析：\n\n本题可以使用哈希表记录机票的起飞机场和落地机场，由于可能存在多个不同落地机场，所以需要使用集合来存储。又由于可能存在重复路线，所以要保存落地机场的重复值，且要求结果的返回顺序是按照最小字母序，刚好可以使用多重集合 multiset，不仅可以存储重复值，而且多重集合的默认元素保存顺序是递增的，例如"sfo","atl","jfk" 在多重集合中的保存顺序是 "atl","jfk","sfo"。上例子的哈希表保存结果为：\n\nhash_key   hash_value\njfk        {atl, sfo}\nsfo        {atl}\natl        {jfk, sfo}\n\n保存好起飞机场和落地机场的关系后，我们使用栈来恢复一条完整的从最终落地机场到达起始机场的路线。从起始机场开始，按照转移顺序将机场逐个压入栈。取当前栈顶作为下一个落地机场，如果栈顶为空则说明到达一个终点，将其加入结果。如果不为空，则将其作为起飞机场对应的第一个落地机场入栈并移除。完成上述过程就恢复出了一条从终点到起点的飞行路线。上例恢复的路线为jfk->atl->jfk->sfo->atl->sfo\n\nclass solution {\npublic:\n    vector<string> finditinerary(vector<vector<string>>& tickets) {\n        // 构建哈希表多重集合，保存起飞机场对应的落地机场\n        unordered_map<string, multiset<string>> hash;\n        for(const auto ticket: tickets){\n            hash[ticket[0]].insert(ticket[1]);\n        }\n        // 使用栈恢复从终点到达起点的逆向路线\n        vector<string> ans;\n        stack<string> st;\n        st.push("jfk");\n        while(!st.empty()){\n            string end = st.top();\n            // 当前机场对应的落地机场为空，说明他是一个终点\n            if(hash[end].empty()){\n                ans.push_back(end);\n                st.pop();\n            }else{\n                st.push(*hash[end].begin());\n                hash[end].erase(hash[end].begin());\n            }\n        }\n        reverse(ans.begin(),ans.end());\n        return ans;\n    }\n};\n',charsets:{cjk:!0},lastUpdated:"2023/11/19, 12:55:48",lastUpdatedTimestamp:1700369748e3},{title:"09数据结构设计",frontmatter:{title:"09数据结构设计",date:"2023-03-24T18:39:49.000Z",permalink:"/pages/7a84c5/"},regularPath:"/03.LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/02.%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/01.%E7%BA%BF%E6%80%A7%E8%A1%A8%E4%B8%8E%E5%93%88%E5%B8%8C%E8%A1%A8/09.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1.html",relativePath:"03.LeetCode刷题笔记/02.基础数据结构/01.线性表与哈希表/09.数据结构设计.md",key:"v-8a647390",path:"/pages/7a84c5/",headers:[{level:2,title:"09 数据结构设计",slug:"_09-数据结构设计",normalizedTitle:"09 数据结构设计",charIndex:2},{level:4,title:"232 用栈实现队列",slug:"_232-用栈实现队列",normalizedTitle:"232 用栈实现队列",charIndex:32},{level:4,title:"225 用队列实现栈",slug:"_225-用队列实现栈",normalizedTitle:"225 用队列实现栈",charIndex:1117},{level:4,title:"155 最小栈",slug:"_155-最小栈",normalizedTitle:"155 最小栈",charIndex:2101},{level:4,title:"380 O(1) 时间插入、删除和获取随机元素",slug:"_380-o-1-时间插入、删除和获取随机元素",normalizedTitle:"380 o(1) 时间插入、删除和获取随机元素",charIndex:2912},{level:4,title:"146 LRU 缓存",slug:"_146-lru-缓存",normalizedTitle:"146 lru 缓存",charIndex:3817}],headersStr:"09 数据结构设计 232 用栈实现队列 225 用队列实现栈 155 最小栈 380 O(1) 时间插入、删除和获取随机元素 146 LRU 缓存",content:"# 09 数据结构设计\n\n考察多个数据结构的灵活组合使用\n\n# 232 用栈实现队列\n\n尝试使用栈（stack）来实现队列（queue）。\n\n实现 MyQueue 类：\n\n> void push(int x) 将元素 x 推到队列的末尾 int pop() 从队列的开头移除并返回元素 int peek() 返回队列开头的元素 boolean empty() 如果队列为空，返回 true ；否则，返回 false\n\n解析：\n\n本题可以使用两个方向相反的栈实现一个队列如下图所示，其中箭头表示元素 pop 方向\n\n\n\n使用两个栈的目的是：为了达到先入先出的效果，需要有一个栈用来翻转输入到栈中数组元素的顺序。这个翻转过程既可以在插入时完成，也可以在取值时完成。\n\n在输入时进行反转：当所有元素都压栈进入 in 栈之后，将所有元素先入后出地压入 out 栈翻转数组。\n\n在取值时进行反转：每次取值时，如果out非空则直接取栈顶；如果 out 栈为空，先将 in 栈中的元素全部先入后出压入 out 栈中，再从 out 栈中出栈元素。\n\nclass MyQueue {\n\nprivate:\n    // < out | in <\n    stack<int> out;\n    stack<int> in;\n\npublic:\n    MyQueue() {}\n    \n    void push(int x) {\n        in.push(x);\n    }\n\n    void connectOutIn(){\n        if(out.empty()){\n            while(!in.empty()){\n                int tail = in.top();\n                in.pop();\n                out.push(tail);\n            }\n        }\n    }\n    \n    int pop() {\n        connectOutIn();\n        int tail = out.top();\n        out.pop();\n        return tail;\n    }\n    \n    int peek() {\n        connectOutIn();\n        return out.top();\n    }\n    \n    bool empty() {\n        return out.empty()&&in.empty(); \n    }\n};\n\n\n# 225 用队列实现栈\n\n尝试使用队列（queue）来实现栈（stack）。\n\n实现 MyStack 类：\n\n> void push(int x) 将元素 x 压入栈顶。 int pop() 移除并返回栈顶元素。 int top() 返回栈顶元素。 boolean empty() 如果栈是空的，返回 true ；否则，返回 false 。\n\n解析：\n\n本题可以使用两个队列，主队列 q1 和辅助队列 q2，q1 保存当前所有元素，q2 用来在压入新元素时将该元素 q1 中已存在的元素之前。核心思想就是将新元素放到就元素之前形成先入后出。\n\n主要考虑压入新元素的过程：\n\n * 有新元素要入栈，现将该元素压入辅助队列 q2\n * 将 q1 中的所有元素依次压入已经压入新元素的 q2 中，翻转出队列顺序\n * 将 q2 中的所有元素按次序压入到 q1 中，这一过程也可以直接使用 swap 交换\n * 完成新元素压入操作\n\nclass MyStack {\n\nprivate:\n    queue<int> q1;\n    queue<int> q2;\npublic:\n    MyStack() {\n\n    }\n    \n    void push(int x) {\n        q2.push(x);\n        while(!q1.empty()){\n            q2.push(q1.front());\n            q1.pop();\n        }\n        // swap(q1,q2);\n        while(!q2.empty()){\n            q1.push(q2.front());\n            q2.pop();\n        }\n    }\n    \n    int pop() {\n        int val = q1.front();\n        q1.pop();\n        return val;\n    }\n    \n    int top() {\n        return q1.front();\n    }\n    \n    bool empty() {\n        return q1.empty();\n    }\n};\n\n\n# 155 最小栈\n\n设计一个最小栈，除了需要支持常规栈的操作外，还需要支持在 O(1) 时间内查询栈内最小值的功能。\n\n> push(x) —— 将元素 x 推入栈中。 pop() —— 删除栈顶的元素。 top() —— 获取栈顶元素。 getMin() —— 检索栈中的最小元素。\n\n解析：\n\n一种简单的思路是建立一个记录栈内当前最小值的辅助栈：每次插入原栈时，都向辅助栈插入一次原栈里当前所有值的最小值，即为辅助栈栈顶和待插入值中较小的那一个；每次从原栈里取出数字时，同样取出新栈的栈顶。\n\nclass MinStack {\n\nprivate:\n    stack<int> s, min_s;\n\npublic:\n    MinStack() {\n        min_s.push(INT_MAX);\n    }\n    \n    void push(int val) {\n        min_s.push(min(min_s.top(),val));\n        s.push(val);\n    }\n    \n    void pop() {\n        min_s.pop();\n        s.pop();\n    }\n    \n    int top() {\n        return s.top();\n    }\n    \n    int getMin() {\n        return min_s.top();\n    }\n};\n\n\n采用上述策略简化了判断，但是每次都要插入和取出，提高了时间复杂度。可以增加判断条件，减少辅助栈插入取出的操作：每当在原栈里插入一个数字时，若该数字小于等于辅助栈栈顶，则表示这个数字在原栈里是最小值，我们将其同时插入辅助栈内。每当从原栈里取出一个数字时，若该数字等于辅助栈栈顶，则表示这个数是原栈里的最小值之一，同时取出辅助栈栈顶的值。\n\n# 380 O(1) 时间插入、删除和获取随机元素\n\n设计一个支持在平均 时间复杂度 O(1) 下，执行以下操作的数据结构：\n\n> insert(val)：当元素 val 不存在时返回 true ，并向集合中插入该项，否则返回 false 。 remove(val)：当元素 val 存在时返回 true ，并从集合中移除该项，否则返回 false 。 getRandom：随机返回现有集合中的一项。每个元素应该有 相同的概率 被返回。\n\n解析：\n\nclass RandomizedSet {\n    unordered_map<int,int> hash;\n    vector<int> vec;\npublic:\n    RandomizedSet() {\n        \n    }\n    \n    bool insert(int val) {\n        if(hash.find(val)!=hash.end()){\n            return false;\n        }\n        hash[val] = vec.size();\n        vec.push_back(val);\n        return true;\n    }\n    \n    bool remove(int val) {\n        if(hash.find(val)==hash.end()){\n            return false;\n        }\n        int pos = hash[val];\n        hash[vec.back()] = pos;\n        hash.erase(val);\n        swap(vec[pos],vec[vec.size()-1]);\n        vec.pop_back();\n        return true;\n    }\n    \n    int getRandom() {\n        return vec[rand()%vec.size()];\n    }\n};\n\n\n# 146 LRU 缓存\n\n请你设计并实现一个满足 LRU (最近最少使用) 缓存 约束的数据结构。\n\n实现 LRUCache 类：\n\n> LRUCache(int capacity) 以 正整数 作为容量 capacity 初始化 LRU 缓存\n> \n> int get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。\n> \n> void put(int key, int value) 如果关键字 key 已经存在，则变更其数据值 value ；如果不存在，则向缓存中插入该组 key-value 。如果插入操作导致关键字数量超过 capacity ，则应该 逐出 最久未使用的关键字。\n\n函数 get 和 put 必须以 O(1) 的平均时间复杂度运行。\n\n解析：\n\n首先要想好用哪几个数据结构。这里我们采用3个数据类型 ：int 记录最大容量、list<pair<int,int>>双向链表记录<键，值>，unordered_map<int, list<pair<int,int>>::iterator> 记录每个键对应的<键，值>在双向链表中的位置。\n\n我们在获取数据时，首先使用unordered_map判断有没有该数据。其次，通过unordered_map的值，获取链表位置，获得键对应的值。最后，更新该<键，值>到list的头部，因为只要使用了，就得更新到最近的位置。\n\n在插入的时候，首先unordered_map判断有没有该数据，有则更新键值，并且更新<键，值>在list中的位置。若没有，则使用 int 判断链表容量是不是满了，若果满了，则删除链表最后一个元素，还要删除unordered_map中的索引。再更新list和unordered_map。\n\nclass LRUCache {\n    int cap;\n    // list<int,int> lruList;\n    // unordered_map<int, pair<int,int>::iterator> hash;\n    list<pair<int,int>> lruList;\n    unordered_map<int, list<pair<int,int>>::iterator> hash;\npublic:\n    LRUCache(int capacity) {\n        cap = capacity;\n    }\n    \n    int get(int key) {\n        if(hash.find(key)!=hash.end()){\n            // auto *node = hash[key];\n            auto node = *hash[key]; // *iterator 方位迭代器指向的元素\n            // lruList.erase(node);\n            lruList.erase(hash[key]); // erase输入参数是迭代器不是值\n            lruList.push_front(node);\n            hash[key] = lruList.begin();\n            return node.second;\n        }\n        return -1;\n    }\n    \n    void put(int key, int value) {\n        if(hash.find(key)!=hash.end()){\n            // auto *node = hash[key];\n            auto node = *hash[key]; // *iterator 方位迭代器指向的元素\n            // lruList.erase(node);\n            lruList.erase(hash[key]); // erase输入参数是迭代器不是值\n            node.second = value;\n            lruList.push_front(node);\n            hash[key] = lruList.begin();\n        }else{\n            if(lruList.size() >= cap){\n                hash.erase(lruList.back().first);\n                lruList.pop_back();\n            }\n            lruList.push_front(make_pair(key,value));\n            hash[key] = lruList.begin();\n        }\n    }\n};\n",normalizedContent:"# 09 数据结构设计\n\n考察多个数据结构的灵活组合使用\n\n# 232 用栈实现队列\n\n尝试使用栈（stack）来实现队列（queue）。\n\n实现 myqueue 类：\n\n> void push(int x) 将元素 x 推到队列的末尾 int pop() 从队列的开头移除并返回元素 int peek() 返回队列开头的元素 boolean empty() 如果队列为空，返回 true ；否则，返回 false\n\n解析：\n\n本题可以使用两个方向相反的栈实现一个队列如下图所示，其中箭头表示元素 pop 方向\n\n\n\n使用两个栈的目的是：为了达到先入先出的效果，需要有一个栈用来翻转输入到栈中数组元素的顺序。这个翻转过程既可以在插入时完成，也可以在取值时完成。\n\n在输入时进行反转：当所有元素都压栈进入 in 栈之后，将所有元素先入后出地压入 out 栈翻转数组。\n\n在取值时进行反转：每次取值时，如果out非空则直接取栈顶；如果 out 栈为空，先将 in 栈中的元素全部先入后出压入 out 栈中，再从 out 栈中出栈元素。\n\nclass myqueue {\n\nprivate:\n    // < out | in <\n    stack<int> out;\n    stack<int> in;\n\npublic:\n    myqueue() {}\n    \n    void push(int x) {\n        in.push(x);\n    }\n\n    void connectoutin(){\n        if(out.empty()){\n            while(!in.empty()){\n                int tail = in.top();\n                in.pop();\n                out.push(tail);\n            }\n        }\n    }\n    \n    int pop() {\n        connectoutin();\n        int tail = out.top();\n        out.pop();\n        return tail;\n    }\n    \n    int peek() {\n        connectoutin();\n        return out.top();\n    }\n    \n    bool empty() {\n        return out.empty()&&in.empty(); \n    }\n};\n\n\n# 225 用队列实现栈\n\n尝试使用队列（queue）来实现栈（stack）。\n\n实现 mystack 类：\n\n> void push(int x) 将元素 x 压入栈顶。 int pop() 移除并返回栈顶元素。 int top() 返回栈顶元素。 boolean empty() 如果栈是空的，返回 true ；否则，返回 false 。\n\n解析：\n\n本题可以使用两个队列，主队列 q1 和辅助队列 q2，q1 保存当前所有元素，q2 用来在压入新元素时将该元素 q1 中已存在的元素之前。核心思想就是将新元素放到就元素之前形成先入后出。\n\n主要考虑压入新元素的过程：\n\n * 有新元素要入栈，现将该元素压入辅助队列 q2\n * 将 q1 中的所有元素依次压入已经压入新元素的 q2 中，翻转出队列顺序\n * 将 q2 中的所有元素按次序压入到 q1 中，这一过程也可以直接使用 swap 交换\n * 完成新元素压入操作\n\nclass mystack {\n\nprivate:\n    queue<int> q1;\n    queue<int> q2;\npublic:\n    mystack() {\n\n    }\n    \n    void push(int x) {\n        q2.push(x);\n        while(!q1.empty()){\n            q2.push(q1.front());\n            q1.pop();\n        }\n        // swap(q1,q2);\n        while(!q2.empty()){\n            q1.push(q2.front());\n            q2.pop();\n        }\n    }\n    \n    int pop() {\n        int val = q1.front();\n        q1.pop();\n        return val;\n    }\n    \n    int top() {\n        return q1.front();\n    }\n    \n    bool empty() {\n        return q1.empty();\n    }\n};\n\n\n# 155 最小栈\n\n设计一个最小栈，除了需要支持常规栈的操作外，还需要支持在 o(1) 时间内查询栈内最小值的功能。\n\n> push(x) —— 将元素 x 推入栈中。 pop() —— 删除栈顶的元素。 top() —— 获取栈顶元素。 getmin() —— 检索栈中的最小元素。\n\n解析：\n\n一种简单的思路是建立一个记录栈内当前最小值的辅助栈：每次插入原栈时，都向辅助栈插入一次原栈里当前所有值的最小值，即为辅助栈栈顶和待插入值中较小的那一个；每次从原栈里取出数字时，同样取出新栈的栈顶。\n\nclass minstack {\n\nprivate:\n    stack<int> s, min_s;\n\npublic:\n    minstack() {\n        min_s.push(int_max);\n    }\n    \n    void push(int val) {\n        min_s.push(min(min_s.top(),val));\n        s.push(val);\n    }\n    \n    void pop() {\n        min_s.pop();\n        s.pop();\n    }\n    \n    int top() {\n        return s.top();\n    }\n    \n    int getmin() {\n        return min_s.top();\n    }\n};\n\n\n采用上述策略简化了判断，但是每次都要插入和取出，提高了时间复杂度。可以增加判断条件，减少辅助栈插入取出的操作：每当在原栈里插入一个数字时，若该数字小于等于辅助栈栈顶，则表示这个数字在原栈里是最小值，我们将其同时插入辅助栈内。每当从原栈里取出一个数字时，若该数字等于辅助栈栈顶，则表示这个数是原栈里的最小值之一，同时取出辅助栈栈顶的值。\n\n# 380 o(1) 时间插入、删除和获取随机元素\n\n设计一个支持在平均 时间复杂度 o(1) 下，执行以下操作的数据结构：\n\n> insert(val)：当元素 val 不存在时返回 true ，并向集合中插入该项，否则返回 false 。 remove(val)：当元素 val 存在时返回 true ，并从集合中移除该项，否则返回 false 。 getrandom：随机返回现有集合中的一项。每个元素应该有 相同的概率 被返回。\n\n解析：\n\nclass randomizedset {\n    unordered_map<int,int> hash;\n    vector<int> vec;\npublic:\n    randomizedset() {\n        \n    }\n    \n    bool insert(int val) {\n        if(hash.find(val)!=hash.end()){\n            return false;\n        }\n        hash[val] = vec.size();\n        vec.push_back(val);\n        return true;\n    }\n    \n    bool remove(int val) {\n        if(hash.find(val)==hash.end()){\n            return false;\n        }\n        int pos = hash[val];\n        hash[vec.back()] = pos;\n        hash.erase(val);\n        swap(vec[pos],vec[vec.size()-1]);\n        vec.pop_back();\n        return true;\n    }\n    \n    int getrandom() {\n        return vec[rand()%vec.size()];\n    }\n};\n\n\n# 146 lru 缓存\n\n请你设计并实现一个满足 lru (最近最少使用) 缓存 约束的数据结构。\n\n实现 lrucache 类：\n\n> lrucache(int capacity) 以 正整数 作为容量 capacity 初始化 lru 缓存\n> \n> int get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。\n> \n> void put(int key, int value) 如果关键字 key 已经存在，则变更其数据值 value ；如果不存在，则向缓存中插入该组 key-value 。如果插入操作导致关键字数量超过 capacity ，则应该 逐出 最久未使用的关键字。\n\n函数 get 和 put 必须以 o(1) 的平均时间复杂度运行。\n\n解析：\n\n首先要想好用哪几个数据结构。这里我们采用3个数据类型 ：int 记录最大容量、list<pair<int,int>>双向链表记录<键，值>，unordered_map<int, list<pair<int,int>>::iterator> 记录每个键对应的<键，值>在双向链表中的位置。\n\n我们在获取数据时，首先使用unordered_map判断有没有该数据。其次，通过unordered_map的值，获取链表位置，获得键对应的值。最后，更新该<键，值>到list的头部，因为只要使用了，就得更新到最近的位置。\n\n在插入的时候，首先unordered_map判断有没有该数据，有则更新键值，并且更新<键，值>在list中的位置。若没有，则使用 int 判断链表容量是不是满了，若果满了，则删除链表最后一个元素，还要删除unordered_map中的索引。再更新list和unordered_map。\n\nclass lrucache {\n    int cap;\n    // list<int,int> lrulist;\n    // unordered_map<int, pair<int,int>::iterator> hash;\n    list<pair<int,int>> lrulist;\n    unordered_map<int, list<pair<int,int>>::iterator> hash;\npublic:\n    lrucache(int capacity) {\n        cap = capacity;\n    }\n    \n    int get(int key) {\n        if(hash.find(key)!=hash.end()){\n            // auto *node = hash[key];\n            auto node = *hash[key]; // *iterator 方位迭代器指向的元素\n            // lrulist.erase(node);\n            lrulist.erase(hash[key]); // erase输入参数是迭代器不是值\n            lrulist.push_front(node);\n            hash[key] = lrulist.begin();\n            return node.second;\n        }\n        return -1;\n    }\n    \n    void put(int key, int value) {\n        if(hash.find(key)!=hash.end()){\n            // auto *node = hash[key];\n            auto node = *hash[key]; // *iterator 方位迭代器指向的元素\n            // lrulist.erase(node);\n            lrulist.erase(hash[key]); // erase输入参数是迭代器不是值\n            node.second = value;\n            lrulist.push_front(node);\n            hash[key] = lrulist.begin();\n        }else{\n            if(lrulist.size() >= cap){\n                hash.erase(lrulist.back().first);\n                lrulist.pop_back();\n            }\n            lrulist.push_front(make_pair(key,value));\n            hash[key] = lrulist.begin();\n        }\n    }\n};\n",charsets:{cjk:!0},lastUpdated:"2023/11/19, 12:55:48",lastUpdatedTimestamp:1700369748e3},{title:"08前缀和",frontmatter:{title:"08前缀和",date:"2023-03-24T18:39:49.000Z",permalink:"/pages/45a8d1/"},regularPath:"/03.LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/02.%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/01.%E7%BA%BF%E6%80%A7%E8%A1%A8%E4%B8%8E%E5%93%88%E5%B8%8C%E8%A1%A8/08.%E5%89%8D%E7%BC%80%E5%92%8C.html",relativePath:"03.LeetCode刷题笔记/02.基础数据结构/01.线性表与哈希表/08.前缀和.md",key:"v-40025290",path:"/pages/45a8d1/",headers:[{level:2,title:"08 区域和检索 前缀和",slug:"_08-区域和检索-前缀和",normalizedTitle:"08 区域和检索 前缀和",charIndex:2},{level:4,title:"303 区域和检索",slug:"_303-区域和检索",normalizedTitle:"303 区域和检索",charIndex:138},{level:4,title:"304 二维区域和检索",slug:"_304-二维区域和检索",normalizedTitle:"304 二维区域和检索",charIndex:1131},{level:4,title:"307. 区域和检索 - 数组可修改",slug:"_307-区域和检索-数组可修改",normalizedTitle:"307. 区域和检索 - 数组可修改",charIndex:2845},{level:4,title:"560 和为 K 的子数组",slug:"_560-和为-k-的子数组",normalizedTitle:"560 和为 k 的子数组",charIndex:2874},{level:4,title:"724 寻找数组的中心下标",slug:"_724-寻找数组的中心下标",normalizedTitle:"724 寻找数组的中心下标",charIndex:3486},{level:4,title:"238 除自身以外数组的乘积",slug:"_238-除自身以外数组的乘积",normalizedTitle:"238 除自身以外数组的乘积",charIndex:4586}],headersStr:"08 区域和检索 前缀和 303 区域和检索 304 二维区域和检索 307. 区域和检索 - 数组可修改 560 和为 K 的子数组 724 寻找数组的中心下标 238 除自身以外数组的乘积",content:'# 08 区域和检索 前缀和\n\n一维的前缀和，二维的积分图，都是把每个位置之前的一维线段或二维矩形预先存储，方便加速计算。如果需要对前缀和或积分图的值做寻址，则要存在哈希表里；如果要对每个位置记录前缀和或积分图的值，则可以储存到一维或二维数组里，也常常伴随着动态规划。\n\n# 303 区域和检索\n\n设计一个类，使得其能够快速查询给定整数数组 nums中，求数组从索引 i 到 j（i ≤ j）范围内元素的总和，包含 i、j两点。\n\nNumArray 类的调用样例：\n\n> 输入：["NumArray", "sumRange", "sumRange", "sumRange"] [[[-2, 0, 3, -5, 2, -1]], [0, 2], [2, 5], [0, 5]]\n> \n> 输出：[null, 1, -1, -3]\n> \n> 解释： NumArray numArray = new NumArray([-2, 0, 3, -5, 2, -1]); numArray.sumRange(0, 2); // return 1 ((-2) + 0 + 3) numArray.sumRange(2, 5); // return -1 (3 + (-5) + 2 + (-1)) numArray.sumRange(0, 5); // return -3 ((-2) + 0 + 3 + (-5) + 2 + (-1))\n\n解析：\n\n对于一维的数组，我们可以使用前缀和来解决此类问题。先建立一个与数组 nums 长度相同的新数组 psum，表示 nums 每个位置之前前所有数字的和。psum 数组可以通过 C++ 自带的 partial_sum 函数建立，也可以直接遍历一遍 nums 数组，并利用状态转移方程 psum[i] = psum[i-1] + nums[i] 完成统计。如果我们需要获得位置 i 和 j 之间的数字和，只需计算 psum[j+1] - psum[i] 即可。\n\nclass NumArray {\n    vector<int> psum;\npublic:\n    NumArray(vector<int>& nums) {\n        psum.resize(nums.size()+1);\n        partial_sum(nums.begin(),nums.end(),psum.begin()+1);\n    }\n    \n    int sumRange(int left, int right) {\n        return psum[right+1]-psum[left];\n    }\n};\n\n\n# 304 二维区域和检索\n\n设计一个类，使得其能够快速查询给定矩阵中，任意两个位置包围的长方形中所有数字的和。计算其子矩形范围内元素的总和，该子矩阵的 左上角 为 (row1, col1) ，右下角 为 (row2, col2) 。\n\nNumMatrix 类的调用样例。其中 sumRegion 函数的四个输入分别是第一个点的横、纵坐标，和第二个点的横、纵坐标。\n\n> 输入: ["NumMatrix","sumRegion","sumRegion","sumRegion"] [[[[3,0,1,4,2],[5,6,3,2,1],[1,2,0,1,5],[4,1,0,1,7],[1,0,3,0,5]]],[2,1,4,3],[1,1,2,2],[1,2,2,4]]\n> \n> 输出: [null, 8, 11, 12]\n> \n> 解释: NumMatrix numMatrix = new NumMatrix([[3,0,1,4,2],[5,6,3,2,1],[1,2,0,1,5],[4,1,0,1,7],[1,0,3,0,5]]]); numMatrix.sumRegion(2, 1, 4, 3); // return 8 (红色矩形框的元素总和) numMatrix.sumRegion(1, 1, 2, 2); // return 11 (绿色矩形框的元素总和) numMatrix.sumRegion(1, 2, 2, 4); // return 12 (蓝色矩形框的元素总和)\n\n解析：\n\n类似于前缀和，我们可以把这种思想拓展到二维，即积分图（image integral）。我们可以先建立一个 intergral 矩阵，intergral[i][j] 表示以位置 (0, 0) 为左上角、位置 (i, j) 为右下角的长方形中所有数字的和。 如下图所示，我们可以用动态规划来计算 integral 矩阵：intergral[i][j] = matrix[i-1][j-1] + integral[i-1][j] + integral[i][j-1] - integral[i-1][j-1]，即当前坐标的数字 + 上面长方形的数字和 + 左边长方形的数字和 - 上面长方形和左边长方形重合面积（即左上一格的长方形）中的数字和。\n\n如下图所示，假设我们要查询长方形 E 的数字和，因为 E = D − B − C + A，我们发现 E 其实可以由四个位置的积分图结果进行加减运算得到。因此这个算法在预处理时的时间复杂度为 O(mn)，而在查询时的时间复杂度仅为 O(1)。\n\nclass NumMatrix {\n    vector<vector<int>> integral;\npublic:\n    NumMatrix(vector<vector<int>>& matrix) {\n        int m = matrix.size(), n = matrix[0].size();\n        integral = vector<vector<int>>(m+1,vector<int>(n+1));\n        for(int i=1;i<=m;++i){\n            for(int j=1;j<=n;++j){\n                integral[i][j] = matrix[i-1][j-1] + integral[i-1][j] + integral[i][j-1] - integral[i-1][j-1];\n            }\n        }\n    }\n    \n    int sumRegion(int row1, int col1, int row2, int col2) {\n        return integral[row2+1][col2+1] - integral[row1][col2+1] - integral[row2+1][col1] + integral[row1][col1];\n    }\n};\n\n\n# 307. 区域和检索 - 数组可修改\n\n线段树求解\n\n# 560 和为 K 的子数组\n\n给定一个数组，寻找和为 k 的连续区间个数。\n\n输入一个一维整数数组和一个整数值 k；输出一个整数，表示满足条件的连续区间个数。\n\n> 输入：nums = [1,2,3], k = 3\n> 输出：2\n\n解析：\n\n本题同样是利用前缀和，不同的是这里我们使用一个哈希表 hashmap，其键是前缀和，而值是该前缀和出现的次数。在我们遍历到位置 i 时，假设当前的前缀和是 psum，那么 hashmap[psum-k] 即为以当前位置结尾、满足条件的区间个数。\n\nclass Solution {\npublic:\n    int subarraySum(vector<int>& nums, int k) {\n        int n = nums.size();\n        unordered_map<int,int> hash;\n        int psum = 0;\n        hash[0] = 1; // 初始情况\n        int ans = 0;\n        for(auto num: nums){\n            psum += num;\n            ans += hash[psum-k];\n            ++hash[psum];\n        }\n        return ans;\n    }\n};\n\n\n# 724 寻找数组的中心下标\n\n给定一个整数数组 nums ，请计算数组的 中心下标 。\n\n数组 中心下标 是数组的一个下标，其左侧所有元素相加的和等于右侧所有元素相加的和。\n\n> 输入：nums = [1, 7, 3, 6, 5, 6]\n> 输出：3\n> 解释：中心下标是 3 。\n> 左侧数之和 sum = nums[0] + nums[1] + nums[2] = 1 + 7 + 3 = 11 ，\n> 右侧数之和 sum = nums[4] + nums[5] = 5 + 6 = 11 ，二者相等。\n\n解析：\n\n方法一\n\nclass Solution {\npublic:\n    int pivotIndex(vector<int>& nums) {\n        int n = nums.size();\n        vector<int> L(n);\n        for(int i=1;i<n;++i){\n            L[i] = L[i-1] + nums[i-1];\n        }\n        vector<int> R(n);\n        for(int i=n-2;i>=0;--i){\n            R[i] = R[i+1] + nums[i+1];\n        }\n        for(int i=0;i<n;++i){\n            if(L[i]==R[i]){\n                return i;\n            }\n        }\n        return -1;\n    }\n};\n\n\n方法二\n\nclass Solution {\npublic:\n    int pivotIndex(vector<int>& nums) {\n        // 计算数组和\n        int total = accumulate(nums.begin(),nums.end(),0);\n        int sum = 0;\n        for(int i=0;i<nums.size();++i){\n            if(2*sum+nums[i]==total){ // 当前前缀和的两倍+当前值 == 数组和 那么当前位置为中心下标\n                return i;\n            }\n            sum += nums[i];\n        }\n        return -1;\n    }\n};\n\n\n# 238 除自身以外数组的乘积\n\n给定一个整数数组 nums，返回 数组 answer ，其中 answer[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积 。\n\n题目数据 保证 数组 nums 之中任意元素的全部前缀元素和后缀的乘积都在 32 位 整数范围内。\n\n> 输入: nums = [-1,1,0,-3,3]\n> 输出: [0,0,9,0,0]\n\n解析：\n\nclass Solution {\npublic:\n    vector<int> productExceptSelf(vector<int>& nums) {\n        int n = nums.size();\n        vector<int> LP(n), RP(n);\n        // 记录所有元素的左侧累积\n        LP[0] = 1;\n        for(int i=1;i<n;++i){\n            LP[i] = nums[i-1]*LP[i-1];\n        }\n        // 记录所有元素的右侧累积\n        RP[n-1] = 1;\n        for(int i=n-2;i>=0;--i){\n            RP[i] = nums[i+1]*RP[i+1];\n        }\n\n        // 左右累积相乘得到除自身之外的累积\n        vector<int> ans;\n        for(int i=0;i<n;++i){\n            ans.push_back(LP[i]*RP[i]);\n        }\n        return ans;\n    }\n};\n',normalizedContent:'# 08 区域和检索 前缀和\n\n一维的前缀和，二维的积分图，都是把每个位置之前的一维线段或二维矩形预先存储，方便加速计算。如果需要对前缀和或积分图的值做寻址，则要存在哈希表里；如果要对每个位置记录前缀和或积分图的值，则可以储存到一维或二维数组里，也常常伴随着动态规划。\n\n# 303 区域和检索\n\n设计一个类，使得其能够快速查询给定整数数组 nums中，求数组从索引 i 到 j（i ≤ j）范围内元素的总和，包含 i、j两点。\n\nnumarray 类的调用样例：\n\n> 输入：["numarray", "sumrange", "sumrange", "sumrange"] [[[-2, 0, 3, -5, 2, -1]], [0, 2], [2, 5], [0, 5]]\n> \n> 输出：[null, 1, -1, -3]\n> \n> 解释： numarray numarray = new numarray([-2, 0, 3, -5, 2, -1]); numarray.sumrange(0, 2); // return 1 ((-2) + 0 + 3) numarray.sumrange(2, 5); // return -1 (3 + (-5) + 2 + (-1)) numarray.sumrange(0, 5); // return -3 ((-2) + 0 + 3 + (-5) + 2 + (-1))\n\n解析：\n\n对于一维的数组，我们可以使用前缀和来解决此类问题。先建立一个与数组 nums 长度相同的新数组 psum，表示 nums 每个位置之前前所有数字的和。psum 数组可以通过 c++ 自带的 partial_sum 函数建立，也可以直接遍历一遍 nums 数组，并利用状态转移方程 psum[i] = psum[i-1] + nums[i] 完成统计。如果我们需要获得位置 i 和 j 之间的数字和，只需计算 psum[j+1] - psum[i] 即可。\n\nclass numarray {\n    vector<int> psum;\npublic:\n    numarray(vector<int>& nums) {\n        psum.resize(nums.size()+1);\n        partial_sum(nums.begin(),nums.end(),psum.begin()+1);\n    }\n    \n    int sumrange(int left, int right) {\n        return psum[right+1]-psum[left];\n    }\n};\n\n\n# 304 二维区域和检索\n\n设计一个类，使得其能够快速查询给定矩阵中，任意两个位置包围的长方形中所有数字的和。计算其子矩形范围内元素的总和，该子矩阵的 左上角 为 (row1, col1) ，右下角 为 (row2, col2) 。\n\nnummatrix 类的调用样例。其中 sumregion 函数的四个输入分别是第一个点的横、纵坐标，和第二个点的横、纵坐标。\n\n> 输入: ["nummatrix","sumregion","sumregion","sumregion"] [[[[3,0,1,4,2],[5,6,3,2,1],[1,2,0,1,5],[4,1,0,1,7],[1,0,3,0,5]]],[2,1,4,3],[1,1,2,2],[1,2,2,4]]\n> \n> 输出: [null, 8, 11, 12]\n> \n> 解释: nummatrix nummatrix = new nummatrix([[3,0,1,4,2],[5,6,3,2,1],[1,2,0,1,5],[4,1,0,1,7],[1,0,3,0,5]]]); nummatrix.sumregion(2, 1, 4, 3); // return 8 (红色矩形框的元素总和) nummatrix.sumregion(1, 1, 2, 2); // return 11 (绿色矩形框的元素总和) nummatrix.sumregion(1, 2, 2, 4); // return 12 (蓝色矩形框的元素总和)\n\n解析：\n\n类似于前缀和，我们可以把这种思想拓展到二维，即积分图（image integral）。我们可以先建立一个 intergral 矩阵，intergral[i][j] 表示以位置 (0, 0) 为左上角、位置 (i, j) 为右下角的长方形中所有数字的和。 如下图所示，我们可以用动态规划来计算 integral 矩阵：intergral[i][j] = matrix[i-1][j-1] + integral[i-1][j] + integral[i][j-1] - integral[i-1][j-1]，即当前坐标的数字 + 上面长方形的数字和 + 左边长方形的数字和 - 上面长方形和左边长方形重合面积（即左上一格的长方形）中的数字和。\n\n如下图所示，假设我们要查询长方形 e 的数字和，因为 e = d − b − c + a，我们发现 e 其实可以由四个位置的积分图结果进行加减运算得到。因此这个算法在预处理时的时间复杂度为 o(mn)，而在查询时的时间复杂度仅为 o(1)。\n\nclass nummatrix {\n    vector<vector<int>> integral;\npublic:\n    nummatrix(vector<vector<int>>& matrix) {\n        int m = matrix.size(), n = matrix[0].size();\n        integral = vector<vector<int>>(m+1,vector<int>(n+1));\n        for(int i=1;i<=m;++i){\n            for(int j=1;j<=n;++j){\n                integral[i][j] = matrix[i-1][j-1] + integral[i-1][j] + integral[i][j-1] - integral[i-1][j-1];\n            }\n        }\n    }\n    \n    int sumregion(int row1, int col1, int row2, int col2) {\n        return integral[row2+1][col2+1] - integral[row1][col2+1] - integral[row2+1][col1] + integral[row1][col1];\n    }\n};\n\n\n# 307. 区域和检索 - 数组可修改\n\n线段树求解\n\n# 560 和为 k 的子数组\n\n给定一个数组，寻找和为 k 的连续区间个数。\n\n输入一个一维整数数组和一个整数值 k；输出一个整数，表示满足条件的连续区间个数。\n\n> 输入：nums = [1,2,3], k = 3\n> 输出：2\n\n解析：\n\n本题同样是利用前缀和，不同的是这里我们使用一个哈希表 hashmap，其键是前缀和，而值是该前缀和出现的次数。在我们遍历到位置 i 时，假设当前的前缀和是 psum，那么 hashmap[psum-k] 即为以当前位置结尾、满足条件的区间个数。\n\nclass solution {\npublic:\n    int subarraysum(vector<int>& nums, int k) {\n        int n = nums.size();\n        unordered_map<int,int> hash;\n        int psum = 0;\n        hash[0] = 1; // 初始情况\n        int ans = 0;\n        for(auto num: nums){\n            psum += num;\n            ans += hash[psum-k];\n            ++hash[psum];\n        }\n        return ans;\n    }\n};\n\n\n# 724 寻找数组的中心下标\n\n给定一个整数数组 nums ，请计算数组的 中心下标 。\n\n数组 中心下标 是数组的一个下标，其左侧所有元素相加的和等于右侧所有元素相加的和。\n\n> 输入：nums = [1, 7, 3, 6, 5, 6]\n> 输出：3\n> 解释：中心下标是 3 。\n> 左侧数之和 sum = nums[0] + nums[1] + nums[2] = 1 + 7 + 3 = 11 ，\n> 右侧数之和 sum = nums[4] + nums[5] = 5 + 6 = 11 ，二者相等。\n\n解析：\n\n方法一\n\nclass solution {\npublic:\n    int pivotindex(vector<int>& nums) {\n        int n = nums.size();\n        vector<int> l(n);\n        for(int i=1;i<n;++i){\n            l[i] = l[i-1] + nums[i-1];\n        }\n        vector<int> r(n);\n        for(int i=n-2;i>=0;--i){\n            r[i] = r[i+1] + nums[i+1];\n        }\n        for(int i=0;i<n;++i){\n            if(l[i]==r[i]){\n                return i;\n            }\n        }\n        return -1;\n    }\n};\n\n\n方法二\n\nclass solution {\npublic:\n    int pivotindex(vector<int>& nums) {\n        // 计算数组和\n        int total = accumulate(nums.begin(),nums.end(),0);\n        int sum = 0;\n        for(int i=0;i<nums.size();++i){\n            if(2*sum+nums[i]==total){ // 当前前缀和的两倍+当前值 == 数组和 那么当前位置为中心下标\n                return i;\n            }\n            sum += nums[i];\n        }\n        return -1;\n    }\n};\n\n\n# 238 除自身以外数组的乘积\n\n给定一个整数数组 nums，返回 数组 answer ，其中 answer[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积 。\n\n题目数据 保证 数组 nums 之中任意元素的全部前缀元素和后缀的乘积都在 32 位 整数范围内。\n\n> 输入: nums = [-1,1,0,-3,3]\n> 输出: [0,0,9,0,0]\n\n解析：\n\nclass solution {\npublic:\n    vector<int> productexceptself(vector<int>& nums) {\n        int n = nums.size();\n        vector<int> lp(n), rp(n);\n        // 记录所有元素的左侧累积\n        lp[0] = 1;\n        for(int i=1;i<n;++i){\n            lp[i] = nums[i-1]*lp[i-1];\n        }\n        // 记录所有元素的右侧累积\n        rp[n-1] = 1;\n        for(int i=n-2;i>=0;--i){\n            rp[i] = nums[i+1]*rp[i+1];\n        }\n\n        // 左右累积相乘得到除自身之外的累积\n        vector<int> ans;\n        for(int i=0;i<n;++i){\n            ans.push_back(lp[i]*rp[i]);\n        }\n        return ans;\n    }\n};\n',charsets:{cjk:!0},lastUpdated:"2023/11/19, 12:55:48",lastUpdatedTimestamp:1700369748e3},{title:"STL",frontmatter:{title:"STL",date:"2023-03-24T18:39:49.000Z",permalink:"/pages/d4f794/"},regularPath:"/03.LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/02.%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/01.%E7%BA%BF%E6%80%A7%E8%A1%A8%E4%B8%8E%E5%93%88%E5%B8%8C%E8%A1%A8/STL.html",relativePath:"03.LeetCode刷题笔记/02.基础数据结构/01.线性表与哈希表/STL.md",key:"v-56fb6266",path:"/pages/d4f794/",headers:[{level:2,title:"LeetCode刷题笔记 数据结构",slug:"leetcode刷题笔记-数据结构",normalizedTitle:"leetcode刷题笔记 数据结构",charIndex:2},{level:3,title:"STL 容器",slug:"stl-容器",normalizedTitle:"stl 容器",charIndex:24},{level:3,title:"01 数组",slug:"_01-数组",normalizedTitle:"01 数组",charIndex:1153},{level:4,title:"448 找到所有数组中消失的数字",slug:"_448-找到所有数组中消失的数字",normalizedTitle:"448 找到所有数组中消失的数字",charIndex:1162},{level:4,title:"48 旋转图像",slug:"_48-旋转图像",normalizedTitle:"48 旋转图像",charIndex:2065},{level:4,title:"240 搜索二维矩阵 II",slug:"_240-搜索二维矩阵-ii",normalizedTitle:"240 搜索二维矩阵 ii",charIndex:3122},{level:4,title:"769 最多能完成排序的块",slug:"_769-最多能完成排序的块",normalizedTitle:"769 最多能完成排序的块",charIndex:4130}],headersStr:"LeetCode刷题笔记 数据结构 STL 容器 01 数组 448 找到所有数组中消失的数字 48 旋转图像 240 搜索二维矩阵 II 769 最多能完成排序的块",content:"# LeetCode刷题笔记 数据结构\n\n\n# STL 容器\n\n容器是可容纳各种数据类型（基本数据类型、对象等）的通用数据结构，都是类模板，分为三种类型：\n\n * 顺序容器：vector, deque, list\n * 关联容器：set, multiset, map, multimap\n * 容器适配器：stack, queue, priority_queue\n\n顺序容器：\n\n顺序容器是非排序的，而且其元素的插入位置与元素自身的值无关，数组便于查找，链表便于操作。\n\n * vector #include <vector> 一维动态数组：其元素在内存中是连续存放的，随机存取任何元素都可以在常数时间内完成，在该容器的尾部增删元素也几乎能够在常熟时间内完成具有较好的性能。\n * deque #include <deque> 双向队列：其元素在内存中是连续存放的，随机存取任何元素都可以在常数时间内完成，在该容器的两端增删元素也几乎能够在常熟时间内完成具有较好的性能。\n * list #include <list> 双向链表：其元素在内存中是不连续存放的，不支持随机存取，在该容器的任何位置增删元素几乎都能够在常熟时间内完成具有较好的性能。\n\n关联容器：\n\n关联容器的元素是排序的，插入元素需要根据相应的排序规则来确定插入位置的，在查找时具有较好的性能。关联容器通常使用平衡二叉树实现，其插入和检索的时间都是 $O(log(N))$ 。\n\n * set/multiset #include <set> 集合：set 集合中不允许存在相同的元素，multiset 集合中允许存在相同的元素。\n * map/multimap #include <map> 键值对集合：map 和 set 的不同在于前者存放的元素有且仅有两个成员变量 (first,second)，一个名为 first，另一个名为 second ，first 的值用来对整体元素进行从小到大的排序，并可以通过 first 快速检索元素。和 multiset 类似 multimap 和 map 的区别中允许存在相同 first 值的元素。\n\n容器适配器：\n\n * stack #include <stack> 栈：栈是项都有限序列，并满足序列中被删除、检索和修改的项都只能是最近插入序列的项，即栈顶的项。满足后进先出规则\n * queue #include <queue> 队列：（入队）插入只允许在尾部进行，（出队）删除、检索和修改只允许在头部进行。满足先进先出规则\n * priority_queue #include <queue> 优先级队列：优先级最高的元素总是第一个出队列\n\n更多关于C++ STL的内容请移步到此博文\n\n\n# 01 数组\n\n# 448 找到所有数组中消失的数字\n\n给定一个长度为 n 的数组，其中包含范围为 1 到 n 的整数，有些整数重复了多次，有些整数没有出现，求 1 到 n 中没有出现过的整数。\n\n输入是一个一维整数数组，输出也是一个一维整数数组，表示输入数组内没出现过的数字。\n\n> 输入：nums = [4,3,2,7,8,2,3,1]\n> 输出：[5,6]\n\n解析：\n\n利用数组这种数据结构建立长度为 n 的标记数组，每一个标记表示对应位置的元素是否出现过。然后遍历一遍 nums 根据其元素情况修改标记数组对应元素。完成一遍遍历之后，标记数组中就已经记录了 nums 中所有元素出现情况，最后在遍历一遍标记数组就可以得到没出现的元素了。\n\n数组     [1,2,3,4,5,6,7,8]\nnums   [4,3,2,7,8,2,3,1]\nmask   [T,T,T,T,F,F,T,T]\n\nclass Solution {\npublic:\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\n        int len = nums.size();\n        // 记录nums中元素存在情况\n        vector<bool> mask(len,true);\n        for(const auto num: nums){\n            mask[num-1] = false;\n        }\n        // 找出不存在的元素\n        vector<int> ans;\n        for(int i=0;i<len;++i){\n            if(mask[i]){\n                ans.push_back(i+1);\n            }\n        }\n        return ans;\n    }\n};\n\n\n进一步地，可以直接对原数组进行标记：把重复出现的数字在原数组出现的位置设为负数，最后仍然为正数的位置即为没有出现过的数。\n\n# 48 旋转图像\n\n给定一个 n × n 的矩阵，在尽量不创建额外储存空间的情况下，求它顺时针旋转 90 度的结果，且必须在原矩阵上修改（in-place）。\n\n输入和输出都是一个二维整数矩阵。\n\n> 输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]\n> 输出：[[7,4,1],[8,5,2],[9,6,3]]\n\n解析：\n\n本题可以每次只考虑矩阵一圈中的 4 个间隔90度的元素的旋转情况，设置两层循环：外层循环用于一圈一圈的遍历矩阵，内循环用于旋转一圈上的元素。\n\n旋转公式主要与遍历的当前圈层相关，例如，矩阵长度len = n + 1，则第 i 圈中与[i][j]参与旋转的其他3个元素分别为[j][n-j], [n-i][n-j], [n-j][i] 他们的旋转公式为：\n\n// 以下图示例中的 2,8,15,9 为例\ntemp = matrix[j][n-i]; // 8\nmatrix[j][n-i] = matrix[i][j]; // 2\nmatrix[i][j] = matrix[n-j][i]; // 9\nmatrix[n-j][i] = matrix[n-i][n-j]; // 15\nmatrix[n-i][n-j] = temp;\n// 经过上述旋转得到 9,2,8,15\n\n\nclass Solution {\npublic:\n    void rotate(vector<vector<int>>& matrix) {\n        int n = matrix.size() - 1;\n        for(int i=0;i<=n/2;++i){\n            // 子矩阵的第一个元素是[i][n-i],最后一个元素是[n-i][n-i]\n            for(int j=i;j<n-i;++j){\n                int tmp = matrix[j][n-i];\n                matrix[j][n-i] = matrix[i][j];\n                matrix[i][j] = matrix[n-j][i];\n                matrix[n-j][i] = matrix[n-i][n-j];\n                matrix[n-i][n-j] = tmp;\n            }\n        }\n    }\n};\n\n\n# 240 搜索二维矩阵 II\n\n给定一个二维矩阵，已知每行和每列都是增序的，尝试设计一个快速搜索一个数字是否在矩阵中存在的算法。\n\n输入是一个二维整数矩阵，和一个待搜索整数。输出是一个布尔值，表示这个整数是否存在于矩阵中。\n\n> 输入：matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 5 输出：true\n\n解析：\n\n本题可以利用矩阵中元素的增序快速缩减搜索空间，每一行是增序的，每一列是增序的。\n\n那么我们从矩阵的右上角开始查找：\n\n * 如果当前值大于目标值那么就直接排除了当前列，向左移动一位\n * 如果当前值小于搜索值，由于我们已经搜索了当前行当前值右侧的所有元素，其左侧的值均小于当前值，因此可以直接排除当前行，向下移动一位\n * 如果最终移动到左下角时仍没有找到目标值，则说明待搜索值不存在于矩阵中\n\nclass Solution {\npublic:\n    bool searchMatrix_2(vector<vector<int>>& matrix, int target) {\n        if(matrix.empty()||matrix[0].empty()){\n            return false;\n        }\n        int m = matrix.size(), n = matrix[0].size();\n        int i = 0, j = n-1;\n        while(i<m && j>=0){\n            if(matrix[i][j] == target){\n                return true;\n            }else if(matrix[i][j] > target){\n                // 大于目标值向左移动一步\n                --j;\n            }else{\n                // 小于目标值向下移动一步\n                ++i;\n            }\n        }\n        return false;\n    }\n};\n\n\n# 769 最多能完成排序的块\n\n给定一个含有 0 到 n 整数的数组，每个整数只出现一次，求这个数组最多可以分割成多少个子数组，使得对每个子数组进行增序排序后，原数组也是增序的。\n\n输入一个一维整数数组，输出一个整数，表示最多的分割数。\n\n> 输入: arr = [1,0,2,3,4] 输出: 4 解释: 可以把它分成两块，例如 [1, 0], [2, 3, 4]。然而，分成 [1, 0], [2], [3], [4] 可以得到最多的块数。\n\n解析：\n\n从左往右遍历，同时记录当前的最大值，每当当前最大值等于数组位置时，我们可以多一次分割。\n\n为什么可以通过这个算法解决问题呢？\n\n如果当前最大值大于数组位置，则说明右边一定有小于数组位置的数字，需要把它也加入待排序的子数组；又因为数组只包含不重复的 0 到 n，所以当前最大值一定不会小于数组位置。所以每当当前最大值等于数组位置时，假设为 p，我们可以成功完成一次分割，并且其与上一次分割位置 q 之间的值一定是 q + 1 到 p 的所有数字。\n\nclass Solution {\npublic:\n    int maxChunksToSorted(vector<int>& arr) {\n        int cur_max = INT_MIN;\n        int ans = 0;\n        for(int i=0;i<arr.size();++i){\n            cur_max = max(cur_max,arr[i]);\n            if(cur_max == i){\n                ++ans;\n            }\n        }\n        return ans;\n    }\n};\n",normalizedContent:"# leetcode刷题笔记 数据结构\n\n\n# stl 容器\n\n容器是可容纳各种数据类型（基本数据类型、对象等）的通用数据结构，都是类模板，分为三种类型：\n\n * 顺序容器：vector, deque, list\n * 关联容器：set, multiset, map, multimap\n * 容器适配器：stack, queue, priority_queue\n\n顺序容器：\n\n顺序容器是非排序的，而且其元素的插入位置与元素自身的值无关，数组便于查找，链表便于操作。\n\n * vector #include <vector> 一维动态数组：其元素在内存中是连续存放的，随机存取任何元素都可以在常数时间内完成，在该容器的尾部增删元素也几乎能够在常熟时间内完成具有较好的性能。\n * deque #include <deque> 双向队列：其元素在内存中是连续存放的，随机存取任何元素都可以在常数时间内完成，在该容器的两端增删元素也几乎能够在常熟时间内完成具有较好的性能。\n * list #include <list> 双向链表：其元素在内存中是不连续存放的，不支持随机存取，在该容器的任何位置增删元素几乎都能够在常熟时间内完成具有较好的性能。\n\n关联容器：\n\n关联容器的元素是排序的，插入元素需要根据相应的排序规则来确定插入位置的，在查找时具有较好的性能。关联容器通常使用平衡二叉树实现，其插入和检索的时间都是 $o(log(n))$ 。\n\n * set/multiset #include <set> 集合：set 集合中不允许存在相同的元素，multiset 集合中允许存在相同的元素。\n * map/multimap #include <map> 键值对集合：map 和 set 的不同在于前者存放的元素有且仅有两个成员变量 (first,second)，一个名为 first，另一个名为 second ，first 的值用来对整体元素进行从小到大的排序，并可以通过 first 快速检索元素。和 multiset 类似 multimap 和 map 的区别中允许存在相同 first 值的元素。\n\n容器适配器：\n\n * stack #include <stack> 栈：栈是项都有限序列，并满足序列中被删除、检索和修改的项都只能是最近插入序列的项，即栈顶的项。满足后进先出规则\n * queue #include <queue> 队列：（入队）插入只允许在尾部进行，（出队）删除、检索和修改只允许在头部进行。满足先进先出规则\n * priority_queue #include <queue> 优先级队列：优先级最高的元素总是第一个出队列\n\n更多关于c++ stl的内容请移步到此博文\n\n\n# 01 数组\n\n# 448 找到所有数组中消失的数字\n\n给定一个长度为 n 的数组，其中包含范围为 1 到 n 的整数，有些整数重复了多次，有些整数没有出现，求 1 到 n 中没有出现过的整数。\n\n输入是一个一维整数数组，输出也是一个一维整数数组，表示输入数组内没出现过的数字。\n\n> 输入：nums = [4,3,2,7,8,2,3,1]\n> 输出：[5,6]\n\n解析：\n\n利用数组这种数据结构建立长度为 n 的标记数组，每一个标记表示对应位置的元素是否出现过。然后遍历一遍 nums 根据其元素情况修改标记数组对应元素。完成一遍遍历之后，标记数组中就已经记录了 nums 中所有元素出现情况，最后在遍历一遍标记数组就可以得到没出现的元素了。\n\n数组     [1,2,3,4,5,6,7,8]\nnums   [4,3,2,7,8,2,3,1]\nmask   [t,t,t,t,f,f,t,t]\n\nclass solution {\npublic:\n    vector<int> finddisappearednumbers(vector<int>& nums) {\n        int len = nums.size();\n        // 记录nums中元素存在情况\n        vector<bool> mask(len,true);\n        for(const auto num: nums){\n            mask[num-1] = false;\n        }\n        // 找出不存在的元素\n        vector<int> ans;\n        for(int i=0;i<len;++i){\n            if(mask[i]){\n                ans.push_back(i+1);\n            }\n        }\n        return ans;\n    }\n};\n\n\n进一步地，可以直接对原数组进行标记：把重复出现的数字在原数组出现的位置设为负数，最后仍然为正数的位置即为没有出现过的数。\n\n# 48 旋转图像\n\n给定一个 n × n 的矩阵，在尽量不创建额外储存空间的情况下，求它顺时针旋转 90 度的结果，且必须在原矩阵上修改（in-place）。\n\n输入和输出都是一个二维整数矩阵。\n\n> 输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]\n> 输出：[[7,4,1],[8,5,2],[9,6,3]]\n\n解析：\n\n本题可以每次只考虑矩阵一圈中的 4 个间隔90度的元素的旋转情况，设置两层循环：外层循环用于一圈一圈的遍历矩阵，内循环用于旋转一圈上的元素。\n\n旋转公式主要与遍历的当前圈层相关，例如，矩阵长度len = n + 1，则第 i 圈中与[i][j]参与旋转的其他3个元素分别为[j][n-j], [n-i][n-j], [n-j][i] 他们的旋转公式为：\n\n// 以下图示例中的 2,8,15,9 为例\ntemp = matrix[j][n-i]; // 8\nmatrix[j][n-i] = matrix[i][j]; // 2\nmatrix[i][j] = matrix[n-j][i]; // 9\nmatrix[n-j][i] = matrix[n-i][n-j]; // 15\nmatrix[n-i][n-j] = temp;\n// 经过上述旋转得到 9,2,8,15\n\n\nclass solution {\npublic:\n    void rotate(vector<vector<int>>& matrix) {\n        int n = matrix.size() - 1;\n        for(int i=0;i<=n/2;++i){\n            // 子矩阵的第一个元素是[i][n-i],最后一个元素是[n-i][n-i]\n            for(int j=i;j<n-i;++j){\n                int tmp = matrix[j][n-i];\n                matrix[j][n-i] = matrix[i][j];\n                matrix[i][j] = matrix[n-j][i];\n                matrix[n-j][i] = matrix[n-i][n-j];\n                matrix[n-i][n-j] = tmp;\n            }\n        }\n    }\n};\n\n\n# 240 搜索二维矩阵 ii\n\n给定一个二维矩阵，已知每行和每列都是增序的，尝试设计一个快速搜索一个数字是否在矩阵中存在的算法。\n\n输入是一个二维整数矩阵，和一个待搜索整数。输出是一个布尔值，表示这个整数是否存在于矩阵中。\n\n> 输入：matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 5 输出：true\n\n解析：\n\n本题可以利用矩阵中元素的增序快速缩减搜索空间，每一行是增序的，每一列是增序的。\n\n那么我们从矩阵的右上角开始查找：\n\n * 如果当前值大于目标值那么就直接排除了当前列，向左移动一位\n * 如果当前值小于搜索值，由于我们已经搜索了当前行当前值右侧的所有元素，其左侧的值均小于当前值，因此可以直接排除当前行，向下移动一位\n * 如果最终移动到左下角时仍没有找到目标值，则说明待搜索值不存在于矩阵中\n\nclass solution {\npublic:\n    bool searchmatrix_2(vector<vector<int>>& matrix, int target) {\n        if(matrix.empty()||matrix[0].empty()){\n            return false;\n        }\n        int m = matrix.size(), n = matrix[0].size();\n        int i = 0, j = n-1;\n        while(i<m && j>=0){\n            if(matrix[i][j] == target){\n                return true;\n            }else if(matrix[i][j] > target){\n                // 大于目标值向左移动一步\n                --j;\n            }else{\n                // 小于目标值向下移动一步\n                ++i;\n            }\n        }\n        return false;\n    }\n};\n\n\n# 769 最多能完成排序的块\n\n给定一个含有 0 到 n 整数的数组，每个整数只出现一次，求这个数组最多可以分割成多少个子数组，使得对每个子数组进行增序排序后，原数组也是增序的。\n\n输入一个一维整数数组，输出一个整数，表示最多的分割数。\n\n> 输入: arr = [1,0,2,3,4] 输出: 4 解释: 可以把它分成两块，例如 [1, 0], [2, 3, 4]。然而，分成 [1, 0], [2], [3], [4] 可以得到最多的块数。\n\n解析：\n\n从左往右遍历，同时记录当前的最大值，每当当前最大值等于数组位置时，我们可以多一次分割。\n\n为什么可以通过这个算法解决问题呢？\n\n如果当前最大值大于数组位置，则说明右边一定有小于数组位置的数字，需要把它也加入待排序的子数组；又因为数组只包含不重复的 0 到 n，所以当前最大值一定不会小于数组位置。所以每当当前最大值等于数组位置时，假设为 p，我们可以成功完成一次分割，并且其与上一次分割位置 q 之间的值一定是 q + 1 到 p 的所有数字。\n\nclass solution {\npublic:\n    int maxchunkstosorted(vector<int>& arr) {\n        int cur_max = int_min;\n        int ans = 0;\n        for(int i=0;i<arr.size();++i){\n            cur_max = max(cur_max,arr[i]);\n            if(cur_max == i){\n                ++ans;\n            }\n        }\n        return ans;\n    }\n};\n",charsets:{cjk:!0},lastUpdated:"2023/11/19, 12:55:48",lastUpdatedTimestamp:1700369748e3},{title:"01字符串比较",frontmatter:{title:"01字符串比较",date:"2023-03-24T18:39:49.000Z",permalink:"/pages/5f258c/"},regularPath:"/03.LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/02.%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/02.%E5%AD%97%E7%AC%A6%E4%B8%B2/01.%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%AF%94%E8%BE%83.html",relativePath:"03.LeetCode刷题笔记/02.基础数据结构/02.字符串/01.字符串比较.md",key:"v-3cef2a45",path:"/pages/5f258c/",headers:[{level:3,title:"01 字符串比较",slug:"_01-字符串比较",normalizedTitle:"01 字符串比较",charIndex:2},{level:4,title:"242 有效的字母异位词",slug:"_242-有效的字母异位词",normalizedTitle:"242 有效的字母异位词",charIndex:14},{level:4,title:"205 同构字符串",slug:"_205-同构字符串",normalizedTitle:"205 同构字符串",charIndex:739},{level:4,title:"696 计数二进制子串",slug:"_696-计数二进制子串",normalizedTitle:"696 计数二进制子串",charIndex:1737},{level:4,title:"3 无重复字符的最长子串",slug:"_3-无重复字符的最长子串",normalizedTitle:"3 无重复字符的最长子串",charIndex:2502}],headersStr:"01 字符串比较 242 有效的字母异位词 205 同构字符串 696 计数二进制子串 3 无重复字符的最长子串",content:'# 01 字符串比较\n\n# 242 有效的字母异位词\n\n判断两个字符串包含的字符是否完全相同。\n\n输入两个字符串，输出一个布尔值，表示两个字符串是否满足条件。\n\n> 输入: s = "anagram", t = "nagaram"\n> 输出: true\n\n解析：\n\n可以利用哈希表或者数组统计两个数组中每个数字出现的频次，若频次相同，则说明它们包含的字符完全相同。\n\n为了降低空间复杂度，我们可以仅采用一个哈希表或数组记录 S 中字符的频次，然后减去 T 中对应字符出现的频次，如果最终该频次为 0 则该字符在 S 和 T 中个数相等，如果最终S和T所有字符频次都想等那么他们是异位词。这种方式避免了单独再开辟一个空间取存储 T 中字符的频次。\n\nclass Solution {\npublic:\n    bool isAnagram(string s, string t) {\n        if(s.length()!=t.length()) return false;\n        unordered_map<char,int> s_cnt;\n        for(int i=0;i<s.length();++i){\n            ++s_cnt[s[i]];\n            --s_cnt[t[i]];\n        }\n\n        for(const auto [h_key,h_val]: s_cnt){\n            if(h_val){\n                return false;\n            }\n        }\n        return true;\n    }\n};\n\n\n# 205 同构字符串\n\n判断两个字符串是否同构。同构的定义是，可以通过把一个字符串的某些相同的字符转换成另一些相同的字符，使得两个字符串相同，且两种不同的字符不能够被转换成同一种字符。\n\n输入两个字符串，输出一个布尔值，表示两个字符串是否满足条件。\n\n> 输入：s = "egg", t = "add"\n> 输出：true\n> 输入：s = "foo", t = "bar"\n> 输出：false\n\n解析：\n\n本题可以通过哈希表记录两个字符串每种字符第一次出现的位置，如果两个字符串中相同位置的字符与它们第一次出现的位置一样，那么这两个字符串同构。如果他们第一次出现的位置一样，那么说明当前两个字符的对应关系是正确的；如果不一样，说明当前两个字符的对应关系是错误的，不满足异构。\n\nclass Solution {\npublic:\n    bool isIsomorphic(string s, string t) {\n        if(s.length()!=t.length()) return false;\n        unordered_map<char,int> s_first_in;\n        unordered_map<char,int> t_first_in;\n        for(int i=1;i<s.length();++i){\n            if(s_first_in.find(s[i]) == s_first_in.end()){\n                s_first_in[s[i]] = i;\n            }\n            if(t_first_in.find(t[i]) == t_first_in.end()){\n                t_first_in[t[i]] = i;\n            }\n        }\n        for(int i=0;i<s.length();++i){\n            if(s_first_in[s[i]] != t_first_in[t[i]]){\n                return false;\n            }\n        }\n        return true;\n    }\n};\n\n\n# 696 计数二进制子串\n\n给定一个 0-1 字符串，求有多少非空子字符串的 0 和 1 数量相同。\n\n输入是一个字符串，输出一个整数，表示满足条件的子字符串的数量。\n\n> 输入: "00110011" 输出: 6 解释: 有6个子串具有相同数量的连续1和0：“0011”，“01”，“1100”，“10”，“0011” 和 “01”。\n\n解析：\n\n从左往右遍历数组，记录和当前位置数字相同且连续的长度，以及其之前连续的不同数字的长度。举例来说，对于 00110 的最后一位，我们记录的相同数字长度是 1，因为只有一个连续 0；我们记录的不同数字长度是 2，因为在 0 之前有两个连续的 1。若不同数字的连续长度大于等于当前数字的连续长度，则说明存在一个且只存在一个以当前数字结尾的满足条件的子字符串。\n\nclass Solution {\npublic:\n    int countBinarySubstrings(string s) {\n        int pre = 0, cur = 1, count = 0;\n        for (int i = 1; i < s.length(); ++i) {\n            if (s[i] == s[i-1]) {\n                ++cur;\n            } else {\n                pre = cur;\n                cur = 1;\n            }\n            if (pre >= cur) {\n                ++count;\n            }\n        }\n        return count;\n    }\n};\n\n\n# 3 无重复字符的最长子串\n\n给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。\n\n输入一个字符串，输出一个整数表示不含重复字符的最长子串的长度\n\n> 输入: s = "abcabcbb"\n> 输出: 3 \n> 解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。\n\n解析：\n\n除了使用滑动窗口，本题也可以使用一个较为暴力的方法，就是在所有子串中检查是否存在重复字符。使用两层循环，外循环遍历所有子串，内循环使用哈希表检验子串中是否存在重复字符，一旦出现重复字符终止循环并记录该子串的长度。\n\nclass Solution {\npublic:\n    int lengthOfLongestSubstring(string s) {\n        int n = s.length();\n        int ans = 0;\n        for(int i=0;i<n;++i){\n            unordered_set<char> hash;\n            int j;\n            for(j=i;j<n;++j){\n                if(hash.find(s[j])!=hash.end()){\n                    break;\n                }\n                hash.insert(s[j]);\n            }\n            ans = max(ans,j-i);\n            hash.clear();\n        }\n        return ans;\n    }\n};\n',normalizedContent:'# 01 字符串比较\n\n# 242 有效的字母异位词\n\n判断两个字符串包含的字符是否完全相同。\n\n输入两个字符串，输出一个布尔值，表示两个字符串是否满足条件。\n\n> 输入: s = "anagram", t = "nagaram"\n> 输出: true\n\n解析：\n\n可以利用哈希表或者数组统计两个数组中每个数字出现的频次，若频次相同，则说明它们包含的字符完全相同。\n\n为了降低空间复杂度，我们可以仅采用一个哈希表或数组记录 s 中字符的频次，然后减去 t 中对应字符出现的频次，如果最终该频次为 0 则该字符在 s 和 t 中个数相等，如果最终s和t所有字符频次都想等那么他们是异位词。这种方式避免了单独再开辟一个空间取存储 t 中字符的频次。\n\nclass solution {\npublic:\n    bool isanagram(string s, string t) {\n        if(s.length()!=t.length()) return false;\n        unordered_map<char,int> s_cnt;\n        for(int i=0;i<s.length();++i){\n            ++s_cnt[s[i]];\n            --s_cnt[t[i]];\n        }\n\n        for(const auto [h_key,h_val]: s_cnt){\n            if(h_val){\n                return false;\n            }\n        }\n        return true;\n    }\n};\n\n\n# 205 同构字符串\n\n判断两个字符串是否同构。同构的定义是，可以通过把一个字符串的某些相同的字符转换成另一些相同的字符，使得两个字符串相同，且两种不同的字符不能够被转换成同一种字符。\n\n输入两个字符串，输出一个布尔值，表示两个字符串是否满足条件。\n\n> 输入：s = "egg", t = "add"\n> 输出：true\n> 输入：s = "foo", t = "bar"\n> 输出：false\n\n解析：\n\n本题可以通过哈希表记录两个字符串每种字符第一次出现的位置，如果两个字符串中相同位置的字符与它们第一次出现的位置一样，那么这两个字符串同构。如果他们第一次出现的位置一样，那么说明当前两个字符的对应关系是正确的；如果不一样，说明当前两个字符的对应关系是错误的，不满足异构。\n\nclass solution {\npublic:\n    bool isisomorphic(string s, string t) {\n        if(s.length()!=t.length()) return false;\n        unordered_map<char,int> s_first_in;\n        unordered_map<char,int> t_first_in;\n        for(int i=1;i<s.length();++i){\n            if(s_first_in.find(s[i]) == s_first_in.end()){\n                s_first_in[s[i]] = i;\n            }\n            if(t_first_in.find(t[i]) == t_first_in.end()){\n                t_first_in[t[i]] = i;\n            }\n        }\n        for(int i=0;i<s.length();++i){\n            if(s_first_in[s[i]] != t_first_in[t[i]]){\n                return false;\n            }\n        }\n        return true;\n    }\n};\n\n\n# 696 计数二进制子串\n\n给定一个 0-1 字符串，求有多少非空子字符串的 0 和 1 数量相同。\n\n输入是一个字符串，输出一个整数，表示满足条件的子字符串的数量。\n\n> 输入: "00110011" 输出: 6 解释: 有6个子串具有相同数量的连续1和0：“0011”，“01”，“1100”，“10”，“0011” 和 “01”。\n\n解析：\n\n从左往右遍历数组，记录和当前位置数字相同且连续的长度，以及其之前连续的不同数字的长度。举例来说，对于 00110 的最后一位，我们记录的相同数字长度是 1，因为只有一个连续 0；我们记录的不同数字长度是 2，因为在 0 之前有两个连续的 1。若不同数字的连续长度大于等于当前数字的连续长度，则说明存在一个且只存在一个以当前数字结尾的满足条件的子字符串。\n\nclass solution {\npublic:\n    int countbinarysubstrings(string s) {\n        int pre = 0, cur = 1, count = 0;\n        for (int i = 1; i < s.length(); ++i) {\n            if (s[i] == s[i-1]) {\n                ++cur;\n            } else {\n                pre = cur;\n                cur = 1;\n            }\n            if (pre >= cur) {\n                ++count;\n            }\n        }\n        return count;\n    }\n};\n\n\n# 3 无重复字符的最长子串\n\n给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。\n\n输入一个字符串，输出一个整数表示不含重复字符的最长子串的长度\n\n> 输入: s = "abcabcbb"\n> 输出: 3 \n> 解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。\n\n解析：\n\n除了使用滑动窗口，本题也可以使用一个较为暴力的方法，就是在所有子串中检查是否存在重复字符。使用两层循环，外循环遍历所有子串，内循环使用哈希表检验子串中是否存在重复字符，一旦出现重复字符终止循环并记录该子串的长度。\n\nclass solution {\npublic:\n    int lengthoflongestsubstring(string s) {\n        int n = s.length();\n        int ans = 0;\n        for(int i=0;i<n;++i){\n            unordered_set<char> hash;\n            int j;\n            for(j=i;j<n;++j){\n                if(hash.find(s[j])!=hash.end()){\n                    break;\n                }\n                hash.insert(s[j]);\n            }\n            ans = max(ans,j-i);\n            hash.clear();\n        }\n        return ans;\n    }\n};\n',charsets:{cjk:!0},lastUpdated:"2023/11/19, 12:55:48",lastUpdatedTimestamp:1700369748e3},{title:"02回文字符串",frontmatter:{title:"02回文字符串",date:"2023-03-24T18:39:49.000Z",permalink:"/pages/8a4607/"},regularPath:"/03.LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/02.%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/02.%E5%AD%97%E7%AC%A6%E4%B8%B2/02.%E5%9B%9E%E6%96%87%E5%AD%97%E7%AC%A6%E4%B8%B2.html",relativePath:"03.LeetCode刷题笔记/02.基础数据结构/02.字符串/02.回文字符串.md",key:"v-5911eb5e",path:"/pages/8a4607/",headers:[{level:2,title:"02 回文字符串",slug:"_02-回文字符串",normalizedTitle:"02 回文字符串",charIndex:2},{level:4,title:"125 验证回文串",slug:"_125-验证回文串",normalizedTitle:"125 验证回文串",charIndex:14},{level:4,title:"680 验证回文字符串 Ⅱ",slug:"_680-验证回文字符串-ii",normalizedTitle:"680 验证回文字符串 ⅱ",charIndex:837},{level:4,title:"647 回文子串",slug:"_647-回文子串",normalizedTitle:"647 回文子串",charIndex:1779},{level:4,title:"409 最长回文串",slug:"_409-最长回文串",normalizedTitle:"409 最长回文串",charIndex:2593},{level:4,title:"5 最长回文子串",slug:"_5-最长回文子串",normalizedTitle:"5 最长回文子串",charIndex:3317}],headersStr:"02 回文字符串 125 验证回文串 680 验证回文字符串 Ⅱ 647 回文子串 409 最长回文串 5 最长回文子串",content:'# 02 回文字符串\n\n# 125 验证回文串\n\n给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。\n\n输入一个字符串，输出一个布尔值表示该字符串是否为回文串\n\n> 输入: "A man, a plan, a canal: Panama"\n> 输出: true\n> 解释："amanaplanacanalpanama" 是回文串\n\n解析：\n\n回文串一般都可以采用双指针从两头向中间检验，或者采用中心扩展法从中间向两头验证是否为回文串。\n\n本题可以采用双指针的策略，从字符串首尾两端逐个字符检验。但是本题中给出的字符串有许多非字母字符，可以用一个新字符串保存原字符串中的所有字母小写形式，然后对其使用双指针方法验证。\n\nclass Solution {\npublic:\n    bool isPalindrome(string s) {\n        // 筛选出字母内容\n        string sgood;\n        for (char ch: s) {\n            if (isalnum(ch)) {\n                sgood += tolower(ch);\n            }\n        }\n        // 双指针验证回文串\n        int n = sgood.size();\n        int left = 0, right = n - 1;\n        while (left < right) {\n           if (sgood[left] != sgood[right]) {\n                return false;\n            }\n            ++left;\n            --right;\n        }\n        return true;\n    }\n};\n\n\n# 680 验证回文字符串 Ⅱ\n\n给定一个非空字符串 s，最多删除一个字符。判断是否能成为回文字符串。\n\n输入一个字符串，输出一个布尔值表示该字符串是否能通过删除操作构成回文串\n\n> 输入: s = "abca"\n> 输出: true\n> 解释: 你可以删除c字符。\n\n解析：\n\n本题采用双指针的方法检验回文串，两个指针分别指向字符串的头和尾，逐一比较两个指针指向的元素。当出现两个指针指向的字符不想等的情况时分别检验将头指针指向的元素删除和将尾指针指向的元素删除两种情况下继续比较字符，是否仍然可以构成回文串。\n\nclass Solution {\npublic:\n    bool subPalindrome(string s, int head, int tail){\n        for(;head<tail;++head,--tail){\n            if(s[head]!=s[tail]){\n                return false;\n            }\n        }\n        return true;\n    }\n\n    bool validPalindrome(string s) {\n        int head = 0, tail = s.size()-1;\n        while(head<tail){\n            if(s[head]==s[tail]){\n                ++head;\n                --tail;\n            }else{\n                if( subPalindrome(s,head,tail-1)||subPalindrome(s,head+1,tail)){\n                    return true;\n                }else{\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n};\n\n\n# 647 回文子串\n\n给定一个字符串，求其有多少个回文子字符串。回文的定义是左右对称。\n\n输入是一个字符串，输出一个整数，表示回文子字符串的数量。\n\n> 输入：s = "aaa"\n> 输出：6\n> 解释：6个回文子串: "a", "a", "a", "aa", "aa", "aaa"\n\n解析：\n\n本题采用中心扩展法，可以从字符串的每个位置开始，向左向右延长，判断存在多少以当前位置为中轴的回文子字符串。中心扩展法：枚举每一个可能的回文中心，然后用两个指针分别向左右两边拓展，当两个指针指向的元素相同的时候就拓展，否则停止拓展。枚举过程中要区分子串的长度为偶数情况和奇数情况。\n\nclass Solution {\npublic:\n    int countCurSub(string s, int lsh, int rsh){\n        int count = 0;\n        while(lsh>=0 && rsh<s.length() && s[lsh]==s[rsh]){\n            --lsh;\n            ++rsh;\n            ++count;\n        }\n        return count;\n    }\n\n    int countSubstrings(string s) {\n        int ans = 0;\n        for(int i=0;i<s.length();++i){\n            // 长度为奇数的回文子串\n            ans += countCurSub(s,i,i);\n            // 长度为偶数的回文子串\n            ans += countCurSub(s,i,i+1);\n        }\n        return ans;\n    }\n};\n\n\n# 409 最长回文串\n\n给定一个包含大写字母和小写字母的字符串，找到通过这些字母构造成的最长的回文串。\n\n输入一个字符串，输出一个整数表示可组成的最长回文串长度\n\n> 输入: "abccccdd"\n> 输出: 7\n> 解释: 可以构造的最长的回文串是"dccaccd", 它的长度是 7。\n\n解析：\n\n本题采用哈希表辅助统计给出字符串中每个字符频次，频次为偶数的可以全部加入构成回文串，频次为奇数的减去一个剩下的也可以加入构成回文串。需要注意的是如果有奇数频次的字符，那么构成的回文串总长可以为奇数，该字符可以出现在回文串中心。\n\nclass Solution {\npublic:\n    int longestPalindrome(string s) {\n        unordered_map<char,int> chCnt;\n        for(const auto ch: s){\n            ++chCnt[ch];\n        }\n        bool hasOdd = false;\n        int ans = 0;\n        for(const auto [key,cnt]: chCnt){\n            if(cnt&1){\n                ans+=(cnt-1);\n                hasOdd = true;\n            }else{\n                ans+=cnt;\n            }\n        }\n        return hasOdd?ans+1:ans;\n    }\n};\n\n\n# 5 最长回文子串\n\n给定一个字符串 s，找到 s 中最长的回文子串。\n\n输入一个字符串，输出一个字符串表示最长回文子串\n\n> 输入：s = "babad"\n> 输出："bab"\n> 解释："aba" 同样是符合题意的答案。\n\n解析：\n\n本题和647 回文子串相似，可以采用中心扩展法寻找最长回文子串。分别考虑子串长度为奇数和偶数的情况，奇数的中心只有一个，偶数长度的中心为 i 和 i+1；以此中心使用两个指针分别向左向右扩展，逐一比较两个指针指向元素的值是否相等；出现不等情况时，使用一个pair对象返回已经检验的回文子串的起始位置和结束位置。\n\n遍历所有回文子串，比较子串的长度，不断更新较长回文子串的起始和结束位置，最终使用substr()方法切片获得最长回文子串。\n\nclass Solution {\npublic:\n    pair<int,int> subStr(string s, int lsh, int rsh){\n        while(lsh>=0 && rsh<s.length() &&s[lsh]==s[rsh]){\n            --lsh;\n            ++rsh;\n        }\n        return {lsh+1,rsh-1};\n    }\n\n    string longestPalindrome(string s) {\n        int start = 0, end=0;\n        for(int i=0; i<s.length();++i){\n            pair<int,int> oddStr = subStr(s,i,i);\n            pair<int,int> evenStr = subStr(s,i,i+1);\n            if(oddStr.second-oddStr.first > end-start){\n                start = oddStr.first;\n                end = oddStr.second;\n            }\n            if(evenStr.second-evenStr.first > end-start){\n                start = evenStr.first;\n                end = evenStr.second;\n            }\n        }\n        return s.substr(start,end-start+1);\n    }\n};\n',normalizedContent:'# 02 回文字符串\n\n# 125 验证回文串\n\n给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。\n\n输入一个字符串，输出一个布尔值表示该字符串是否为回文串\n\n> 输入: "a man, a plan, a canal: panama"\n> 输出: true\n> 解释："amanaplanacanalpanama" 是回文串\n\n解析：\n\n回文串一般都可以采用双指针从两头向中间检验，或者采用中心扩展法从中间向两头验证是否为回文串。\n\n本题可以采用双指针的策略，从字符串首尾两端逐个字符检验。但是本题中给出的字符串有许多非字母字符，可以用一个新字符串保存原字符串中的所有字母小写形式，然后对其使用双指针方法验证。\n\nclass solution {\npublic:\n    bool ispalindrome(string s) {\n        // 筛选出字母内容\n        string sgood;\n        for (char ch: s) {\n            if (isalnum(ch)) {\n                sgood += tolower(ch);\n            }\n        }\n        // 双指针验证回文串\n        int n = sgood.size();\n        int left = 0, right = n - 1;\n        while (left < right) {\n           if (sgood[left] != sgood[right]) {\n                return false;\n            }\n            ++left;\n            --right;\n        }\n        return true;\n    }\n};\n\n\n# 680 验证回文字符串 ⅱ\n\n给定一个非空字符串 s，最多删除一个字符。判断是否能成为回文字符串。\n\n输入一个字符串，输出一个布尔值表示该字符串是否能通过删除操作构成回文串\n\n> 输入: s = "abca"\n> 输出: true\n> 解释: 你可以删除c字符。\n\n解析：\n\n本题采用双指针的方法检验回文串，两个指针分别指向字符串的头和尾，逐一比较两个指针指向的元素。当出现两个指针指向的字符不想等的情况时分别检验将头指针指向的元素删除和将尾指针指向的元素删除两种情况下继续比较字符，是否仍然可以构成回文串。\n\nclass solution {\npublic:\n    bool subpalindrome(string s, int head, int tail){\n        for(;head<tail;++head,--tail){\n            if(s[head]!=s[tail]){\n                return false;\n            }\n        }\n        return true;\n    }\n\n    bool validpalindrome(string s) {\n        int head = 0, tail = s.size()-1;\n        while(head<tail){\n            if(s[head]==s[tail]){\n                ++head;\n                --tail;\n            }else{\n                if( subpalindrome(s,head,tail-1)||subpalindrome(s,head+1,tail)){\n                    return true;\n                }else{\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n};\n\n\n# 647 回文子串\n\n给定一个字符串，求其有多少个回文子字符串。回文的定义是左右对称。\n\n输入是一个字符串，输出一个整数，表示回文子字符串的数量。\n\n> 输入：s = "aaa"\n> 输出：6\n> 解释：6个回文子串: "a", "a", "a", "aa", "aa", "aaa"\n\n解析：\n\n本题采用中心扩展法，可以从字符串的每个位置开始，向左向右延长，判断存在多少以当前位置为中轴的回文子字符串。中心扩展法：枚举每一个可能的回文中心，然后用两个指针分别向左右两边拓展，当两个指针指向的元素相同的时候就拓展，否则停止拓展。枚举过程中要区分子串的长度为偶数情况和奇数情况。\n\nclass solution {\npublic:\n    int countcursub(string s, int lsh, int rsh){\n        int count = 0;\n        while(lsh>=0 && rsh<s.length() && s[lsh]==s[rsh]){\n            --lsh;\n            ++rsh;\n            ++count;\n        }\n        return count;\n    }\n\n    int countsubstrings(string s) {\n        int ans = 0;\n        for(int i=0;i<s.length();++i){\n            // 长度为奇数的回文子串\n            ans += countcursub(s,i,i);\n            // 长度为偶数的回文子串\n            ans += countcursub(s,i,i+1);\n        }\n        return ans;\n    }\n};\n\n\n# 409 最长回文串\n\n给定一个包含大写字母和小写字母的字符串，找到通过这些字母构造成的最长的回文串。\n\n输入一个字符串，输出一个整数表示可组成的最长回文串长度\n\n> 输入: "abccccdd"\n> 输出: 7\n> 解释: 可以构造的最长的回文串是"dccaccd", 它的长度是 7。\n\n解析：\n\n本题采用哈希表辅助统计给出字符串中每个字符频次，频次为偶数的可以全部加入构成回文串，频次为奇数的减去一个剩下的也可以加入构成回文串。需要注意的是如果有奇数频次的字符，那么构成的回文串总长可以为奇数，该字符可以出现在回文串中心。\n\nclass solution {\npublic:\n    int longestpalindrome(string s) {\n        unordered_map<char,int> chcnt;\n        for(const auto ch: s){\n            ++chcnt[ch];\n        }\n        bool hasodd = false;\n        int ans = 0;\n        for(const auto [key,cnt]: chcnt){\n            if(cnt&1){\n                ans+=(cnt-1);\n                hasodd = true;\n            }else{\n                ans+=cnt;\n            }\n        }\n        return hasodd?ans+1:ans;\n    }\n};\n\n\n# 5 最长回文子串\n\n给定一个字符串 s，找到 s 中最长的回文子串。\n\n输入一个字符串，输出一个字符串表示最长回文子串\n\n> 输入：s = "babad"\n> 输出："bab"\n> 解释："aba" 同样是符合题意的答案。\n\n解析：\n\n本题和647 回文子串相似，可以采用中心扩展法寻找最长回文子串。分别考虑子串长度为奇数和偶数的情况，奇数的中心只有一个，偶数长度的中心为 i 和 i+1；以此中心使用两个指针分别向左向右扩展，逐一比较两个指针指向元素的值是否相等；出现不等情况时，使用一个pair对象返回已经检验的回文子串的起始位置和结束位置。\n\n遍历所有回文子串，比较子串的长度，不断更新较长回文子串的起始和结束位置，最终使用substr()方法切片获得最长回文子串。\n\nclass solution {\npublic:\n    pair<int,int> substr(string s, int lsh, int rsh){\n        while(lsh>=0 && rsh<s.length() &&s[lsh]==s[rsh]){\n            --lsh;\n            ++rsh;\n        }\n        return {lsh+1,rsh-1};\n    }\n\n    string longestpalindrome(string s) {\n        int start = 0, end=0;\n        for(int i=0; i<s.length();++i){\n            pair<int,int> oddstr = substr(s,i,i);\n            pair<int,int> evenstr = substr(s,i,i+1);\n            if(oddstr.second-oddstr.first > end-start){\n                start = oddstr.first;\n                end = oddstr.second;\n            }\n            if(evenstr.second-evenstr.first > end-start){\n                start = evenstr.first;\n                end = evenstr.second;\n            }\n        }\n        return s.substr(start,end-start+1);\n    }\n};\n',charsets:{cjk:!0},lastUpdated:"2023/11/19, 12:55:48",lastUpdatedTimestamp:1700369748e3},{title:"03字符串匹配",frontmatter:{title:"03字符串匹配",date:"2023-03-24T18:39:49.000Z",permalink:"/pages/d0219a/"},regularPath:"/03.LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/02.%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/02.%E5%AD%97%E7%AC%A6%E4%B8%B2/03.%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D.html",relativePath:"03.LeetCode刷题笔记/02.基础数据结构/02.字符串/03.字符串匹配.md",key:"v-ca702032",path:"/pages/d0219a/",headers:[{level:2,title:"03 字符串匹配",slug:"_03-字符串匹配",normalizedTitle:"03 字符串匹配",charIndex:2},{level:4,title:"28 实现 strStr()",slug:"_28-实现-strstr",normalizedTitle:"28 实现 strstr()",charIndex:14}],headersStr:"03 字符串匹配 28 实现 strStr()",content:'# 03 字符串匹配\n\n# 28 实现 strStr()\n\n判断一个字符串是不是另一个字符串的子字符串，并返回其位置。\n\n输入一个母字符串和一个子字符串，输出一个整数，表示子字符串在母字符串的位置，若不存在则返回-1。\n\n> 输入：haystack = "hello", needle = "ll"\n> 输出：2\n\n解析：\n\n解决本题一种简单的思路是暴力匹配：首先将子串和母串左端对齐；然后逐个比较对应的字符，如果发现不匹配则将子串开始匹配位置相对于母串后移动一位，同时将比较指针回溯到子串头部；重复匹配过程，直到找到对应子串，不存在则返回 -1。\n\nclass Solution {\npublic:\n    int strStr(string haystack, string needle) {\n        int m = haystack.length(), n = needle.length();\n        for(int i=0;i+n<=m;++i){\n            bool flag = true;\n            for(int j=0;j<n;++j){\n                if(haystack[j+i]!=needle[j]){\n                    flag = false;\n                    break;\n                }\n            }\n            if(flag){\n                return i;\n            }\n        }\n        return -1;\n    }\n};\n\n\n上述方法的比较指针不断回溯的过程会增加时间复杂度，一种优化方法就是 KMP 算法。KMP 算法的核心思想就是通过寻找已匹配部分子串中的相同前后缀，在遇到字符不匹配的情况时，直接将子串从前缀部分移动到后缀，避免比较指针直接回溯到子串头部。\n\n如下例所示，母串和子串在第 8 个字符出现不匹配，下一步匹配操作：如果使用暴力匹配则是将匹配指针回溯到子串头部并往后移动一位再次寻找与母串左端对齐；如果使用KMP算法，可以看到子串已经匹配的相同最长前后缀为ABC，直接将整个子串从前缀位置移动到后缀，一次性移动四位，避免比较指针从头再开始匹配。\n\n原串             暴力匹配           KMP 算法\nABCFABCFABCA   ABCFABCFABCA   ABCFABCFABCA\nABCFABCA       0ABCFABCA      0000ABCFABCA\n\nKMP 算法的关键是在子串中找到最长前后缀，这里可以采用动态规划的思想：\n\n设置状态：构建一个数组 next[i]表示子串中对应位置 i 之前的部分串中最长前后缀的长度。\n\n状态转移方程：对于位置 i，如果下一位前后缀相同，更新相同最大前后缀的长度；如果下一位不同，则将向前回溯。\n\n初始情况：如果仅有一个字符不存在前后缀，next[0]=-1 。前缀指针从 -1 位置开始，后缀指针从 1 位置开始遍历子串。\n\n// 计算前缀表 next\nvoid getNext(string needle, vector<int>& next){\n    int head = -1;\n    next[0] = -1;\n    for(int tail = 1; tail<needle.length();++tail){\n        // 如果下一位不同，往前回溯，回溯到没有前缀为止(head=-1)\n        while(head>-1 && needle[head+1]!=needle[tail]){\n            head = next[head];\n        }\n        // 如果下一位相同，更新相同的最大前缀和最大后缀长，同时移动前缀指针\n        if(needle[head+1]==needle[tail]){\n            ++head;\n        }\n        next[head] = head;\n    }\n}\n\n\n一个上述计算ABCFABCA前缀表的例子：\n\nNEXT 索引   部分子串       最长前缀最后一个元素的位置 NEXT[I]\n0         A          -1\n1         AB         -1\n2         ABC        -1\n3         ABCF       -1\n4         ABCFA      0\n5         ABCFAB     1\n6         ABCFABC    2\n7         ABCFABCA   2\n\nclass Solution {\npublic:\n\t// 计算前缀表 next\n    void getNext(string needle, vector<int>& next){\n        int head = -1;\n        next[0] = -1;\n        for(int tail=1;tail<needle.length();++tail){\n            // 如果下一位不同，往前回溯，回溯到没有前缀为止(head=-1)\n            while(head>-1 && needle[head+1]!=needle[tail]){\n                head = next[head];\n            }\n            if(needle[head+1]==needle[tail]){\n                ++head;\n            }\n            next[tail] = head;\n        }\n    }\n\n    int strStr(string haystack, string needle) {\n        int cur = -1;\n        int m = haystack.size(), n = needle.size();\n        // 子串为空返回 0 \n        if(n==0) return 0;\n        // 获取前缀表\n        vector<int> next(n,-1);\n        getNext(needle,next);\n        for(int i=0;i<m;++i){\n            while(cur>-1 && haystack[i]!=needle[cur+1]){\n                cur = next[cur];\n            }\n            if(haystack[i]==needle[cur+1]){\n                ++cur;\n            }\n            // 说明=cur移动到needle的最末端，此时i也指向母串中匹配子串的最后一个位置，返回此时匹配子串最左端的位置\n            if(cur == n-1){\n                return i - cur;\n            }\n        }\n        return -1;\n    }\n};\n',normalizedContent:'# 03 字符串匹配\n\n# 28 实现 strstr()\n\n判断一个字符串是不是另一个字符串的子字符串，并返回其位置。\n\n输入一个母字符串和一个子字符串，输出一个整数，表示子字符串在母字符串的位置，若不存在则返回-1。\n\n> 输入：haystack = "hello", needle = "ll"\n> 输出：2\n\n解析：\n\n解决本题一种简单的思路是暴力匹配：首先将子串和母串左端对齐；然后逐个比较对应的字符，如果发现不匹配则将子串开始匹配位置相对于母串后移动一位，同时将比较指针回溯到子串头部；重复匹配过程，直到找到对应子串，不存在则返回 -1。\n\nclass solution {\npublic:\n    int strstr(string haystack, string needle) {\n        int m = haystack.length(), n = needle.length();\n        for(int i=0;i+n<=m;++i){\n            bool flag = true;\n            for(int j=0;j<n;++j){\n                if(haystack[j+i]!=needle[j]){\n                    flag = false;\n                    break;\n                }\n            }\n            if(flag){\n                return i;\n            }\n        }\n        return -1;\n    }\n};\n\n\n上述方法的比较指针不断回溯的过程会增加时间复杂度，一种优化方法就是 kmp 算法。kmp 算法的核心思想就是通过寻找已匹配部分子串中的相同前后缀，在遇到字符不匹配的情况时，直接将子串从前缀部分移动到后缀，避免比较指针直接回溯到子串头部。\n\n如下例所示，母串和子串在第 8 个字符出现不匹配，下一步匹配操作：如果使用暴力匹配则是将匹配指针回溯到子串头部并往后移动一位再次寻找与母串左端对齐；如果使用kmp算法，可以看到子串已经匹配的相同最长前后缀为abc，直接将整个子串从前缀位置移动到后缀，一次性移动四位，避免比较指针从头再开始匹配。\n\n原串             暴力匹配           kmp 算法\nabcfabcfabca   abcfabcfabca   abcfabcfabca\nabcfabca       0abcfabca      0000abcfabca\n\nkmp 算法的关键是在子串中找到最长前后缀，这里可以采用动态规划的思想：\n\n设置状态：构建一个数组 next[i]表示子串中对应位置 i 之前的部分串中最长前后缀的长度。\n\n状态转移方程：对于位置 i，如果下一位前后缀相同，更新相同最大前后缀的长度；如果下一位不同，则将向前回溯。\n\n初始情况：如果仅有一个字符不存在前后缀，next[0]=-1 。前缀指针从 -1 位置开始，后缀指针从 1 位置开始遍历子串。\n\n// 计算前缀表 next\nvoid getnext(string needle, vector<int>& next){\n    int head = -1;\n    next[0] = -1;\n    for(int tail = 1; tail<needle.length();++tail){\n        // 如果下一位不同，往前回溯，回溯到没有前缀为止(head=-1)\n        while(head>-1 && needle[head+1]!=needle[tail]){\n            head = next[head];\n        }\n        // 如果下一位相同，更新相同的最大前缀和最大后缀长，同时移动前缀指针\n        if(needle[head+1]==needle[tail]){\n            ++head;\n        }\n        next[head] = head;\n    }\n}\n\n\n一个上述计算abcfabca前缀表的例子：\n\nnext 索引   部分子串       最长前缀最后一个元素的位置 next[i]\n0         a          -1\n1         ab         -1\n2         abc        -1\n3         abcf       -1\n4         abcfa      0\n5         abcfab     1\n6         abcfabc    2\n7         abcfabca   2\n\nclass solution {\npublic:\n\t// 计算前缀表 next\n    void getnext(string needle, vector<int>& next){\n        int head = -1;\n        next[0] = -1;\n        for(int tail=1;tail<needle.length();++tail){\n            // 如果下一位不同，往前回溯，回溯到没有前缀为止(head=-1)\n            while(head>-1 && needle[head+1]!=needle[tail]){\n                head = next[head];\n            }\n            if(needle[head+1]==needle[tail]){\n                ++head;\n            }\n            next[tail] = head;\n        }\n    }\n\n    int strstr(string haystack, string needle) {\n        int cur = -1;\n        int m = haystack.size(), n = needle.size();\n        // 子串为空返回 0 \n        if(n==0) return 0;\n        // 获取前缀表\n        vector<int> next(n,-1);\n        getnext(needle,next);\n        for(int i=0;i<m;++i){\n            while(cur>-1 && haystack[i]!=needle[cur+1]){\n                cur = next[cur];\n            }\n            if(haystack[i]==needle[cur+1]){\n                ++cur;\n            }\n            // 说明=cur移动到needle的最末端，此时i也指向母串中匹配子串的最后一个位置，返回此时匹配子串最左端的位置\n            if(cur == n-1){\n                return i - cur;\n            }\n        }\n        return -1;\n    }\n};\n',charsets:{cjk:!0},lastUpdated:"2023/11/19, 12:55:48",lastUpdatedTimestamp:1700369748e3},{title:"04字符串算术表达式",frontmatter:{title:"04字符串算术表达式",date:"2023-03-24T18:39:49.000Z",permalink:"/pages/9ad0e3/"},regularPath:"/03.LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/02.%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/02.%E5%AD%97%E7%AC%A6%E4%B8%B2/04.%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%AE%97%E6%9C%AF%E8%A1%A8%E8%BE%BE%E5%BC%8F.html",relativePath:"03.LeetCode刷题笔记/02.基础数据结构/02.字符串/04.字符串算术表达式.md",key:"v-4c5a063e",path:"/pages/9ad0e3/",headers:[{level:2,title:"04 字符串算术表达式",slug:"_04-字符串算术表达式",normalizedTitle:"04 字符串算术表达式",charIndex:2},{level:4,title:"227 基本计算器 II",slug:"_227-基本计算器-ii",normalizedTitle:"227 基本计算器 ii",charIndex:17}],headersStr:"04 字符串算术表达式 227 基本计算器 II",content:"# 04 字符串算术表达式\n\n# 227 基本计算器 II",normalizedContent:"# 04 字符串算术表达式\n\n# 227 基本计算器 ii",charsets:{cjk:!0},lastUpdated:"2023/11/19, 12:55:48",lastUpdatedTimestamp:1700369748e3},{title:"01链表基础操作",frontmatter:{title:"01链表基础操作",date:"2023-03-24T18:39:49.000Z",permalink:"/pages/1b79f3/"},regularPath:"/03.LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/02.%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/03.%E5%8D%95%E9%93%BE%E8%A1%A8/01.%E9%93%BE%E8%A1%A8%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C.html",relativePath:"03.LeetCode刷题笔记/02.基础数据结构/03.单链表/01.链表基础操作.md",key:"v-9ff0e312",path:"/pages/1b79f3/",headers:[{level:2,title:"01 链表基础操作",slug:"_01-链表基础操作",normalizedTitle:"01 链表基础操作",charIndex:2},{level:4,title:"206 反转链表",slug:"_206-反转链表",normalizedTitle:"206 反转链表",charIndex:713},{level:4,title:"83 删除排序链表中的重复元素",slug:"_83-删除排序链表中的重复元素",normalizedTitle:"83 删除排序链表中的重复元素",charIndex:2195},{level:4,title:"328 奇偶链表",slug:"_328-奇偶链表",normalizedTitle:"328 奇偶链表",charIndex:3064},{level:4,title:"24 两两交换链表中的节点",slug:"_24-两两交换链表中的节点",normalizedTitle:"24 两两交换链表中的节点",charIndex:4360},{level:4,title:"21 合并两个有序链表",slug:"_21-合并两个有序链表",normalizedTitle:"21 合并两个有序链表",charIndex:5838},{level:4,title:"148 排序链表",slug:"_148-排序链表",normalizedTitle:"148 排序链表",charIndex:8214}],headersStr:"01 链表基础操作 206 反转链表 83 删除排序链表中的重复元素 328 奇偶链表 24 两两交换链表中的节点 21 合并两个有序链表 148 排序链表",content:"# 01 链表基础操作\n\n链表是由节点和指针构成的数据结构，每个节点存有一个值，和一个指向下一个节点的指针，因此很多链表问题可以用递归来处理。不同于数组，链表并不能直接获取任意节点的值，必须要通过指针找到该节点后才能获取其值。同理，在未遍历到链表结尾时，我们也无法知道链表的长度，除非依赖其他数据结构储存长度。链表一般表示方法如下。\n\nstruct ListNode {\n    int val;\n    ListNode *next;\n    ListNode(int x) : val(x), next(nullptr) {}\n};\n\n// 在节点 a->b 中插入 c 插入操作\nListNode *p = a;\nc->next = b;\np->next = c;\np = c;\n// 从链表 a->c->b 中删除节点 c\nListNode *p = c;\nc = c->next;\na->next = c;\ndelete(p);\n// 交换链表 a->c->b->d 中的 c 和 b 节点\na->next = b; // a 指向 b\nc->next = b->next; // c 指向 d\nb->next = c; // b 指向 c\n\n\n由于在进行链表操作时，尤其是删除节点时，经常会因为对当前节点进行操作而导致内存或指针出现问题。有两个小技巧可以解决这个问题：\n\n * 一是尽量处理当前节点的下一个节点而非当前节点本身\n * 二是建立一个虚拟节点 (dummy node)，使其指向当前链表的头节点，这样即使原链表所有节点全被删除，也会有一个 dummy 存在，返回 dummy->next 即可。\n\n# 206 反转链表\n\n翻转一个链表。\n\n输入一个链表，输出该链表翻转后的结果。\n\n> 输入：head = [1,2,3,4,5]\n> 输出：[5,4,3,2,1]\n\n解析：\n\n反转链表需要建立一个指向头节点的虚拟节点 prev，使用头节点的反转操作与其他节点保持一致。另外需要注意的是节点 next 指向改变的顺序，首先需要保存当前节点的 next 指向，然后修改其 next 指向为前一节点，最后移动指向前驱节点和当前节点的指针，完成一次反转操作。重复该操作，直至所有节点完成反转。\n\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* next = head;\n        while(head){\n            next = head->next;\n            head->next = prev;\n            prev = head;\n            head = next;\n        }\n        return prev;\n    }\n};\n\n\n本题也可以采用递归解决，终止条件为当前节点为空说明链表遍历完成。\n\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* reverseListRec(ListNode* head, ListNode* prev){\n        if(!head){\n            return prev;\n        }\n        ListNode* next = head->next;\n        head->next = prev;\n        return reverseListRec(next,head);\n    }\n\n    ListNode* reverseList(ListNode* head) {\n        return reverseListRec(head,nullptr);\n    }\n};\n\n\n# 83 删除排序链表中的重复元素\n\n给定一个按升序排列的链表，删除其中所有重复的元素\n\n输入一个链表，输出该链表删除重复元素后的结果\n\n> 输入：head = [1,1,2,3,3]\n> 输出：[1,2,3]\n\n解析：\n\n本题的本质上就是简单的链表删除节点操作，注意回收内存空间。\n\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* deleteDuplicates(ListNode* head) {\n        if(!head || !head->next){\n            return head;\n        }\n        ListNode *cur = head;\n        while(cur->next){\n            if(cur->val == cur->next->val){\n                ListNode *p = cur->next;\n                cur->next = p->next;\n                delete(p);\n            }else{\n                cur = cur->next;\n            }\n        }\n        return head;\n    }\n};\n\n\n# 328 奇偶链表\n\n给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。\n\n输入一个链表，输出链表根据节点编号奇偶性重新组织后的结果\n\n> 输入: 2->1->3->5->6->4->7->NULL \n> 输出: 2->3->6->7->1->5->4->NULL\n\n解析：\n\n本题并不复杂，只需要将奇偶编号的节点分开再合并即可。\n\n首先，将第一个节点作为奇数编号链表的头节点，第二个节点作为偶数编号链表的头节点\n\n然后，分别定义两个指针指向奇链表和偶链表的尾部，在原链表中：奇数编号节点的next就是偶数编号的节点，同样偶数编号节点的next就是奇数编号节点。\n\n所以一个奇偶链表的构造操作例子如下：\n\n// 原链表\n1  2  3  4\na->b->c->d\n// 构造过程\nListNode *odd = a, *even = b; // 将 a 作为奇链表的头节点， b 作为偶链表的头节点，odd指向奇链表尾部，even指向偶链表尾部\nodd->next = even->next; // a 指向 c\nodd = odd->next; // odd 指向 c\neven->next = odd->next; // b 指向 d\neven = even->next; // even 指向 d\n\n\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* oddEvenList(ListNode* head) {\n        if(!head || !head->next){\n            return head;\n        }\n        ListNode *evenHead = head->next;\n        ListNode *odd = head, *even = head->next;\n        while(even && even->next){\n            odd->next = even->next;\n            odd = odd->next;\n            even->next = odd->next;\n            even = even->next;\n        }\n        odd->next = evenHead;\n        return head;\n    }\n};\n\n\n# 24 两两交换链表中的节点\n\n给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。\n\n输入一个链表，输出该链表交换后的结果。\n\n> 输入：head = [1,2,3,4]\n> 输出：[2,1,4,3]\n\n解析：\n\n本题的关键就是不要把指针指向搞混，要注意两个相邻节点交换中指针的变换顺序\n\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        ListNode *p = head, *s = nullptr;\n        if(p && p->next){\n            s = p->next;\n            p->next = s->next;\n            s->next = p;\n            head = s;\n            while(p->next&& p->next->next){\n                s = p->next->next;\n                p->next->next = s->next; \n                s->next = p->next;\n                p->next = s;\n                p = s->next;\n            }\n        }\n        return head;\n    }\n};\n\n\n采用递归更好理解本题，用 head 表示原始链表的头节点，新的链表的第二个节点，用 newHead 表示新的链表的头节点，原始链表的第二个节点，则原始链表中的其余节点的头节点是 newHead->next。令 head->next = swapPairs(newHead->next)，表示将其余节点进行两两交换，交换后的新的头节点为 head 的下一个节点。然后令 newHead->next = head，即完成了所有节点的交换。最后返回新的链表的头节点 newHead。\n\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        if (head == nullptr || head->next == nullptr) {\n            return head;\n        }\n        ListNode* newHead = head->next;\n        head->next = swapPairs(newHead->next);\n        newHead->next = head;\n        return newHead;\n    }\n};\n\n\n# 21 合并两个有序链表\n\n给定两个增序的链表，试将其合并成一个增序的链表。\n\n输入两个链表，输出一个链表，表示两个链表合并的结果。\n\n> 输入：l1 = [1,2,4], l2 = [1,3,4]\n> 输出：[1,1,2,3,4,4]\n\n解析：\n\n本题可以采用双指针求解，首先建立一个虚拟指针 dummy，其next指向合并后链表的头节点。用两个指针分别指向两个链表，逐个比较节点值大小插入合并链表。\n\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {\n        if(!l1 || !l2){\n            return l1?l1:l2;\n        }\n        ListNode dummy;\n        ListNode* cur = &dummy;\n        ListNode* p1 = l1;\n        ListNode* p2 = l2;\n        while(p1&&p2){\n            if(p1->val < p2->val){\n                cur->next = p1;\n                p1 = p1->next;\n            }else{\n                cur->next = p2;\n                p2 = p2->next;\n            }\n            cur = cur->next;\n        }\n        cur->next = p1?p1:p2;\n        return dummy.next;\n    }\n};\n\n\n本题也可以采用递归实现，将两个链表头部值较小的一个节点与剩下元素的 merge 操作结果合并。\n\nclass Solution {\npublic:\n    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {\n        if(!l1 || !l2){\n            return l1?l1:l2;\n        }\n\n        if(l1->val > l2->val){\n            l2->next = mergeTwoLists(l1,l2->next);\n            return l2;\n        }\n        l1->next = mergeTwoLists(l1->next,l2);\n        return l1;\n    }\n};\n\n\n本题也可以采用STL中的容器适配器 priority_queue，把两个链表头节点存储在一个优先队列中，每次提取头节点值较小的那个节点，直到两个链表都被提取完为止。\n\n需要注意的是 priority_queue 默认的元素比较方法是less<T>，即默认为最大值元素在前面的最大堆，维持着递减关系。如果我们想要获取最小的节点值，则需要实现一个最小堆，因此比较函数应该维持递增关系。实现侧策略就是使用函数对象，自定义 priority_queue 的元素比较方法，在该函数对象中重载 operator() ，使用大于号而不是等减关系时的小于号进行比较。\n\nstruct myCompare{\n    bool operator()(ListNode* a, ListNode* b){\n        return a->val > b->val;\n    }\n};\n\nclass Solution {\npublic:\n    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {\n        if(!l1 || !l2){\n            return l1?l1:l2;\n        }\n        priority_queue<ListNode*, vector<ListNode*>, myCompare> pq;\n        pq.push(l1);\n        pq.push(l2);\n        ListNode dummy;\n        ListNode* cur = &dummy;\n        while(!pq.empty()){\n            cur->next = pq.top();\n            pq.pop();\n            cur = cur->next;\n            if(cur->next){\n                pq.push(cur->next);\n            }\n        }\n        return dummy.next;\n    }\n};\n\n\n# 148 排序链表\n\n给定一个链表，请将其按 升序 排列并返回 排序后的链表\n\n输入一个链表，输出按升序排序的链表\n\n> 输入：head = [4,2,1,3]\n> 输出：[1,2,3,4]\n\n解析：\n\n本题可以采用归并排序的思想解决。\n\n分治策略：首先使用快慢指针找链表中点的方法找到链表中点，然后以此将链表分割为两个部分，然后再进行递归的划分链表，直到不可划分。在寻找中点需要注意的是不能直接以 nullptr 判断快指针是否达到终点，而是要将其与链表尾节点 tail 进行比较。\n\n分割完成之后，使用合并两个链表的方法，将链表按照升序合并，最终形成完整的升序链表。\n\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n\t// 将两个链表按照升序合并\n    ListNode* mergeTwoList(ListNode* l1, ListNode* l2){\n        if(!l1 || !l2) return l1?l1:l2;\n        ListNode head;\n        ListNode *tail = &head;\n        ListNode *p1 = l1, *p2 = l2;\n        while(p1 && p2){\n            if(p1->val < p2->val){\n                tail->next = p1;\n                p1 = p1->next;\n            }else{\n                tail->next = p2;\n                p2 = p2->next;\n            }\n            tail = tail->next;\n        }\n        tail->next = p1?p1:p2;\n        return head.next;\n    }\n\n    ListNode* mergeSort(ListNode* head, ListNode* tail){\n        if(!head) return head;\n        if(head->next == tail){\n            head->next = nullptr;\n            return head;\n        }\n        // 寻找链表中点\n        ListNode *fast = head, *slow=head;\n        while (fast != tail) {\n            slow = slow->next;\n            fast = fast->next;\n            if (fast != tail) {\n                fast = fast->next;\n            }\n        }\n        ListNode* mid = slow;\n        // 根据链表中点递归分割，并合并结果\n        return mergeTwoList(mergeSort(head,mid),mergeSort(mid,tail));\n    }\n\n    ListNode* sortList(ListNode* head) {\n        return mergeSort(head,nullptr);\n    }\n};\n",normalizedContent:"# 01 链表基础操作\n\n链表是由节点和指针构成的数据结构，每个节点存有一个值，和一个指向下一个节点的指针，因此很多链表问题可以用递归来处理。不同于数组，链表并不能直接获取任意节点的值，必须要通过指针找到该节点后才能获取其值。同理，在未遍历到链表结尾时，我们也无法知道链表的长度，除非依赖其他数据结构储存长度。链表一般表示方法如下。\n\nstruct listnode {\n    int val;\n    listnode *next;\n    listnode(int x) : val(x), next(nullptr) {}\n};\n\n// 在节点 a->b 中插入 c 插入操作\nlistnode *p = a;\nc->next = b;\np->next = c;\np = c;\n// 从链表 a->c->b 中删除节点 c\nlistnode *p = c;\nc = c->next;\na->next = c;\ndelete(p);\n// 交换链表 a->c->b->d 中的 c 和 b 节点\na->next = b; // a 指向 b\nc->next = b->next; // c 指向 d\nb->next = c; // b 指向 c\n\n\n由于在进行链表操作时，尤其是删除节点时，经常会因为对当前节点进行操作而导致内存或指针出现问题。有两个小技巧可以解决这个问题：\n\n * 一是尽量处理当前节点的下一个节点而非当前节点本身\n * 二是建立一个虚拟节点 (dummy node)，使其指向当前链表的头节点，这样即使原链表所有节点全被删除，也会有一个 dummy 存在，返回 dummy->next 即可。\n\n# 206 反转链表\n\n翻转一个链表。\n\n输入一个链表，输出该链表翻转后的结果。\n\n> 输入：head = [1,2,3,4,5]\n> 输出：[5,4,3,2,1]\n\n解析：\n\n反转链表需要建立一个指向头节点的虚拟节点 prev，使用头节点的反转操作与其他节点保持一致。另外需要注意的是节点 next 指向改变的顺序，首先需要保存当前节点的 next 指向，然后修改其 next 指向为前一节点，最后移动指向前驱节点和当前节点的指针，完成一次反转操作。重复该操作，直至所有节点完成反转。\n\n/**\n * definition for singly-linked list.\n * struct listnode {\n *     int val;\n *     listnode *next;\n *     listnode() : val(0), next(nullptr) {}\n *     listnode(int x) : val(x), next(nullptr) {}\n *     listnode(int x, listnode *next) : val(x), next(next) {}\n * };\n */\nclass solution {\npublic:\n    listnode* reverselist(listnode* head) {\n        listnode* prev = nullptr;\n        listnode* next = head;\n        while(head){\n            next = head->next;\n            head->next = prev;\n            prev = head;\n            head = next;\n        }\n        return prev;\n    }\n};\n\n\n本题也可以采用递归解决，终止条件为当前节点为空说明链表遍历完成。\n\n/**\n * definition for singly-linked list.\n * struct listnode {\n *     int val;\n *     listnode *next;\n *     listnode() : val(0), next(nullptr) {}\n *     listnode(int x) : val(x), next(nullptr) {}\n *     listnode(int x, listnode *next) : val(x), next(next) {}\n * };\n */\nclass solution {\npublic:\n    listnode* reverselistrec(listnode* head, listnode* prev){\n        if(!head){\n            return prev;\n        }\n        listnode* next = head->next;\n        head->next = prev;\n        return reverselistrec(next,head);\n    }\n\n    listnode* reverselist(listnode* head) {\n        return reverselistrec(head,nullptr);\n    }\n};\n\n\n# 83 删除排序链表中的重复元素\n\n给定一个按升序排列的链表，删除其中所有重复的元素\n\n输入一个链表，输出该链表删除重复元素后的结果\n\n> 输入：head = [1,1,2,3,3]\n> 输出：[1,2,3]\n\n解析：\n\n本题的本质上就是简单的链表删除节点操作，注意回收内存空间。\n\n/**\n * definition for singly-linked list.\n * struct listnode {\n *     int val;\n *     listnode *next;\n *     listnode() : val(0), next(nullptr) {}\n *     listnode(int x) : val(x), next(nullptr) {}\n *     listnode(int x, listnode *next) : val(x), next(next) {}\n * };\n */\nclass solution {\npublic:\n    listnode* deleteduplicates(listnode* head) {\n        if(!head || !head->next){\n            return head;\n        }\n        listnode *cur = head;\n        while(cur->next){\n            if(cur->val == cur->next->val){\n                listnode *p = cur->next;\n                cur->next = p->next;\n                delete(p);\n            }else{\n                cur = cur->next;\n            }\n        }\n        return head;\n    }\n};\n\n\n# 328 奇偶链表\n\n给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。\n\n输入一个链表，输出链表根据节点编号奇偶性重新组织后的结果\n\n> 输入: 2->1->3->5->6->4->7->null \n> 输出: 2->3->6->7->1->5->4->null\n\n解析：\n\n本题并不复杂，只需要将奇偶编号的节点分开再合并即可。\n\n首先，将第一个节点作为奇数编号链表的头节点，第二个节点作为偶数编号链表的头节点\n\n然后，分别定义两个指针指向奇链表和偶链表的尾部，在原链表中：奇数编号节点的next就是偶数编号的节点，同样偶数编号节点的next就是奇数编号节点。\n\n所以一个奇偶链表的构造操作例子如下：\n\n// 原链表\n1  2  3  4\na->b->c->d\n// 构造过程\nlistnode *odd = a, *even = b; // 将 a 作为奇链表的头节点， b 作为偶链表的头节点，odd指向奇链表尾部，even指向偶链表尾部\nodd->next = even->next; // a 指向 c\nodd = odd->next; // odd 指向 c\neven->next = odd->next; // b 指向 d\neven = even->next; // even 指向 d\n\n\n/**\n * definition for singly-linked list.\n * struct listnode {\n *     int val;\n *     listnode *next;\n *     listnode() : val(0), next(nullptr) {}\n *     listnode(int x) : val(x), next(nullptr) {}\n *     listnode(int x, listnode *next) : val(x), next(next) {}\n * };\n */\nclass solution {\npublic:\n    listnode* oddevenlist(listnode* head) {\n        if(!head || !head->next){\n            return head;\n        }\n        listnode *evenhead = head->next;\n        listnode *odd = head, *even = head->next;\n        while(even && even->next){\n            odd->next = even->next;\n            odd = odd->next;\n            even->next = odd->next;\n            even = even->next;\n        }\n        odd->next = evenhead;\n        return head;\n    }\n};\n\n\n# 24 两两交换链表中的节点\n\n给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。\n\n输入一个链表，输出该链表交换后的结果。\n\n> 输入：head = [1,2,3,4]\n> 输出：[2,1,4,3]\n\n解析：\n\n本题的关键就是不要把指针指向搞混，要注意两个相邻节点交换中指针的变换顺序\n\n/**\n * definition for singly-linked list.\n * struct listnode {\n *     int val;\n *     listnode *next;\n *     listnode() : val(0), next(nullptr) {}\n *     listnode(int x) : val(x), next(nullptr) {}\n *     listnode(int x, listnode *next) : val(x), next(next) {}\n * };\n */\nclass solution {\npublic:\n    listnode* swappairs(listnode* head) {\n        listnode *p = head, *s = nullptr;\n        if(p && p->next){\n            s = p->next;\n            p->next = s->next;\n            s->next = p;\n            head = s;\n            while(p->next&& p->next->next){\n                s = p->next->next;\n                p->next->next = s->next; \n                s->next = p->next;\n                p->next = s;\n                p = s->next;\n            }\n        }\n        return head;\n    }\n};\n\n\n采用递归更好理解本题，用 head 表示原始链表的头节点，新的链表的第二个节点，用 newhead 表示新的链表的头节点，原始链表的第二个节点，则原始链表中的其余节点的头节点是 newhead->next。令 head->next = swappairs(newhead->next)，表示将其余节点进行两两交换，交换后的新的头节点为 head 的下一个节点。然后令 newhead->next = head，即完成了所有节点的交换。最后返回新的链表的头节点 newhead。\n\nclass solution {\npublic:\n    listnode* swappairs(listnode* head) {\n        if (head == nullptr || head->next == nullptr) {\n            return head;\n        }\n        listnode* newhead = head->next;\n        head->next = swappairs(newhead->next);\n        newhead->next = head;\n        return newhead;\n    }\n};\n\n\n# 21 合并两个有序链表\n\n给定两个增序的链表，试将其合并成一个增序的链表。\n\n输入两个链表，输出一个链表，表示两个链表合并的结果。\n\n> 输入：l1 = [1,2,4], l2 = [1,3,4]\n> 输出：[1,1,2,3,4,4]\n\n解析：\n\n本题可以采用双指针求解，首先建立一个虚拟指针 dummy，其next指向合并后链表的头节点。用两个指针分别指向两个链表，逐个比较节点值大小插入合并链表。\n\n/**\n * definition for singly-linked list.\n * struct listnode {\n *     int val;\n *     listnode *next;\n *     listnode() : val(0), next(nullptr) {}\n *     listnode(int x) : val(x), next(nullptr) {}\n *     listnode(int x, listnode *next) : val(x), next(next) {}\n * };\n */\nclass solution {\npublic:\n    listnode* mergetwolists(listnode* l1, listnode* l2) {\n        if(!l1 || !l2){\n            return l1?l1:l2;\n        }\n        listnode dummy;\n        listnode* cur = &dummy;\n        listnode* p1 = l1;\n        listnode* p2 = l2;\n        while(p1&&p2){\n            if(p1->val < p2->val){\n                cur->next = p1;\n                p1 = p1->next;\n            }else{\n                cur->next = p2;\n                p2 = p2->next;\n            }\n            cur = cur->next;\n        }\n        cur->next = p1?p1:p2;\n        return dummy.next;\n    }\n};\n\n\n本题也可以采用递归实现，将两个链表头部值较小的一个节点与剩下元素的 merge 操作结果合并。\n\nclass solution {\npublic:\n    listnode* mergetwolists(listnode* l1, listnode* l2) {\n        if(!l1 || !l2){\n            return l1?l1:l2;\n        }\n\n        if(l1->val > l2->val){\n            l2->next = mergetwolists(l1,l2->next);\n            return l2;\n        }\n        l1->next = mergetwolists(l1->next,l2);\n        return l1;\n    }\n};\n\n\n本题也可以采用stl中的容器适配器 priority_queue，把两个链表头节点存储在一个优先队列中，每次提取头节点值较小的那个节点，直到两个链表都被提取完为止。\n\n需要注意的是 priority_queue 默认的元素比较方法是less<t>，即默认为最大值元素在前面的最大堆，维持着递减关系。如果我们想要获取最小的节点值，则需要实现一个最小堆，因此比较函数应该维持递增关系。实现侧策略就是使用函数对象，自定义 priority_queue 的元素比较方法，在该函数对象中重载 operator() ，使用大于号而不是等减关系时的小于号进行比较。\n\nstruct mycompare{\n    bool operator()(listnode* a, listnode* b){\n        return a->val > b->val;\n    }\n};\n\nclass solution {\npublic:\n    listnode* mergetwolists(listnode* l1, listnode* l2) {\n        if(!l1 || !l2){\n            return l1?l1:l2;\n        }\n        priority_queue<listnode*, vector<listnode*>, mycompare> pq;\n        pq.push(l1);\n        pq.push(l2);\n        listnode dummy;\n        listnode* cur = &dummy;\n        while(!pq.empty()){\n            cur->next = pq.top();\n            pq.pop();\n            cur = cur->next;\n            if(cur->next){\n                pq.push(cur->next);\n            }\n        }\n        return dummy.next;\n    }\n};\n\n\n# 148 排序链表\n\n给定一个链表，请将其按 升序 排列并返回 排序后的链表\n\n输入一个链表，输出按升序排序的链表\n\n> 输入：head = [4,2,1,3]\n> 输出：[1,2,3,4]\n\n解析：\n\n本题可以采用归并排序的思想解决。\n\n分治策略：首先使用快慢指针找链表中点的方法找到链表中点，然后以此将链表分割为两个部分，然后再进行递归的划分链表，直到不可划分。在寻找中点需要注意的是不能直接以 nullptr 判断快指针是否达到终点，而是要将其与链表尾节点 tail 进行比较。\n\n分割完成之后，使用合并两个链表的方法，将链表按照升序合并，最终形成完整的升序链表。\n\n/**\n * definition for singly-linked list.\n * struct listnode {\n *     int val;\n *     listnode *next;\n *     listnode() : val(0), next(nullptr) {}\n *     listnode(int x) : val(x), next(nullptr) {}\n *     listnode(int x, listnode *next) : val(x), next(next) {}\n * };\n */\nclass solution {\npublic:\n\t// 将两个链表按照升序合并\n    listnode* mergetwolist(listnode* l1, listnode* l2){\n        if(!l1 || !l2) return l1?l1:l2;\n        listnode head;\n        listnode *tail = &head;\n        listnode *p1 = l1, *p2 = l2;\n        while(p1 && p2){\n            if(p1->val < p2->val){\n                tail->next = p1;\n                p1 = p1->next;\n            }else{\n                tail->next = p2;\n                p2 = p2->next;\n            }\n            tail = tail->next;\n        }\n        tail->next = p1?p1:p2;\n        return head.next;\n    }\n\n    listnode* mergesort(listnode* head, listnode* tail){\n        if(!head) return head;\n        if(head->next == tail){\n            head->next = nullptr;\n            return head;\n        }\n        // 寻找链表中点\n        listnode *fast = head, *slow=head;\n        while (fast != tail) {\n            slow = slow->next;\n            fast = fast->next;\n            if (fast != tail) {\n                fast = fast->next;\n            }\n        }\n        listnode* mid = slow;\n        // 根据链表中点递归分割，并合并结果\n        return mergetwolist(mergesort(head,mid),mergesort(mid,tail));\n    }\n\n    listnode* sortlist(listnode* head) {\n        return mergesort(head,nullptr);\n    }\n};\n",charsets:{cjk:!0},lastUpdated:"2023/11/19, 12:55:48",lastUpdatedTimestamp:1700369748e3},{title:"Str",frontmatter:{title:"Str",date:"2023-03-24T18:39:49.000Z",permalink:"/pages/9c89cf/"},regularPath:"/03.LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/02.%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/02.%E5%AD%97%E7%AC%A6%E4%B8%B2/Str.html",relativePath:"03.LeetCode刷题笔记/02.基础数据结构/02.字符串/Str.md",key:"v-df77c33a",path:"/pages/9c89cf/",headers:[{level:2,title:"LeetCode刷题笔记 字符串",slug:"leetcode刷题笔记-字符串",normalizedTitle:"leetcode刷题笔记 字符串",charIndex:2},{level:3,title:"01 字符串比较",slug:"_01-字符串比较",normalizedTitle:"01 字符串比较",charIndex:78},{level:4,title:"242 有效的字母异位词",slug:"_242-有效的字母异位词",normalizedTitle:"242 有效的字母异位词",charIndex:90},{level:4,title:"205 同构字符串",slug:"_205-同构字符串",normalizedTitle:"205 同构字符串",charIndex:815},{level:4,title:"125 验证回文串",slug:"_125-验证回文串",normalizedTitle:"125 验证回文串",charIndex:1813},{level:4,title:"680 验证回文字符串 Ⅱ",slug:"_680-验证回文字符串-ii",normalizedTitle:"680 验证回文字符串 ⅱ",charIndex:2636},{level:4,title:"647 回文子串",slug:"_647-回文子串",normalizedTitle:"647 回文子串",charIndex:3578},{level:4,title:"696 计数二进制子串",slug:"_696-计数二进制子串",normalizedTitle:"696 计数二进制子串",charIndex:4393}],headersStr:"LeetCode刷题笔记 字符串 01 字符串比较 242 有效的字母异位词 205 同构字符串 125 验证回文串 680 验证回文字符串 Ⅱ 647 回文子串 696 计数二进制子串",content:'# LeetCode刷题笔记 字符串\n\n字符串可以看成是字符组成的数组。由于字符串是程序里经常需要处理的数据类型，因此有很多针对字符串处理的题目。\n\n\n# 01 字符串比较\n\n# 242 有效的字母异位词\n\n判断两个字符串包含的字符是否完全相同。\n\n输入两个字符串，输出一个布尔值，表示两个字符串是否满足条件。\n\n> 输入: s = "anagram", t = "nagaram"\n> 输出: true\n\n解析：\n\n可以利用哈希表或者数组统计两个数组中每个数字出现的频次，若频次相同，则说明它们包含的字符完全相同。\n\n为了降低空间复杂度，我们可以仅采用一个哈希表或数组记录 S 中字符的频次，然后减去 T 中对应字符出现的频次，如果最终该频次为 0 则该字符在 S 和 T 中个数相等，如果最终S和T所有字符频次都想等那么他们是异位词。这种方式避免了单独再开辟一个空间取存储 T 中字符的频次。\n\nclass Solution {\npublic:\n    bool isAnagram(string s, string t) {\n        if(s.length()!=t.length()) return false;\n        unordered_map<char,int> s_cnt;\n        for(int i=0;i<s.length();++i){\n            ++s_cnt[s[i]];\n            --s_cnt[t[i]];\n        }\n\n        for(const auto [h_key,h_val]: s_cnt){\n            if(h_val){\n                return false;\n            }\n        }\n        return true;\n    }\n};\n\n\n# 205 同构字符串\n\n判断两个字符串是否同构。同构的定义是，可以通过把一个字符串的某些相同的字符转换成另一些相同的字符，使得两个字符串相同，且两种不同的字符不能够被转换成同一种字符。\n\n输入两个字符串，输出一个布尔值，表示两个字符串是否满足条件。\n\n> 输入：s = "egg", t = "add"\n> 输出：true\n> 输入：s = "foo", t = "bar"\n> 输出：false\n\n解析：\n\n本题可以通过哈希表记录两个字符串每种字符第一次出现的位置，如果两个字符串中相同位置的字符与它们第一次出现的位置一样，那么这两个字符串同构。如果他们第一次出现的位置一样，那么说明当前两个字符的对应关系是正确的；如果不一样，说明当前两个字符的对应关系是错误的，不满足异构。\n\nclass Solution {\npublic:\n    bool isIsomorphic(string s, string t) {\n        if(s.length()!=t.length()) return false;\n        unordered_map<char,int> s_first_in;\n        unordered_map<char,int> t_first_in;\n        for(int i=1;i<s.length();++i){\n            if(s_first_in.find(s[i]) == s_first_in.end()){\n                s_first_in[s[i]] = i;\n            }\n            if(t_first_in.find(t[i]) == t_first_in.end()){\n                t_first_in[t[i]] = i;\n            }\n        }\n        for(int i=0;i<s.length();++i){\n            if(s_first_in[s[i]] != t_first_in[t[i]]){\n                return false;\n            }\n        }\n        return true;\n    }\n};\n\n\n# 125 验证回文串\n\n给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。\n\n输入一个字符串，输出一个布尔值表示该字符串是否为回文串\n\n> 输入: "A man, a plan, a canal: Panama"\n> 输出: true\n> 解释："amanaplanacanalpanama" 是回文串\n\n解析：\n\n回文串一般都可以采用双指针从两头向中间检验，或者采用中心扩展法从中间向两头验证是否为回文串。\n\n本题可以采用双指针的策略，从字符串首尾两端逐个字符检验。但是本题中给出的字符串有许多非字母字符，可以用一个新字符串保存原字符串中的所有字母小写形式，然后对其使用双指针方法验证。\n\nclass Solution {\npublic:\n    bool isPalindrome(string s) {\n        // 筛选出字母内容\n        string sgood;\n        for (char ch: s) {\n            if (isalnum(ch)) {\n                sgood += tolower(ch);\n            }\n        }\n        // 双指针验证回文串\n        int n = sgood.size();\n        int left = 0, right = n - 1;\n        while (left < right) {\n           if (sgood[left] != sgood[right]) {\n                return false;\n            }\n            ++left;\n            --right;\n        }\n        return true;\n    }\n};\n\n\n# 680 验证回文字符串 Ⅱ\n\n给定一个非空字符串 s，最多删除一个字符。判断是否能成为回文字符串。\n\n输入一个字符串，输出一个布尔值表示该字符串是否能通过删除操作构成回文串\n\n> 输入: s = "abca"\n> 输出: true\n> 解释: 你可以删除c字符。\n\n解析：\n\n本题采用双指针的方法检验回文串，两个指针分别指向字符串的头和尾，逐一比较两个指针指向的元素。当出现两个指针指向的字符不想等的情况时分别检验将头指针指向的元素删除和将尾指针指向的元素删除两种情况下继续比较字符，是否仍然可以构成回文串。\n\nclass Solution {\npublic:\n    bool subPalindrome(string s, int head, int tail){\n        for(;head<tail;++head,--tail){\n            if(s[head]!=s[tail]){\n                return false;\n            }\n        }\n        return true;\n    }\n\n    bool validPalindrome(string s) {\n        int head = 0, tail = s.size()-1;\n        while(head<tail){\n            if(s[head]==s[tail]){\n                ++head;\n                --tail;\n            }else{\n                if( subPalindrome(s,head,tail-1)||subPalindrome(s,head+1,tail)){\n                    return true;\n                }else{\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n};\n\n\n# 647 回文子串\n\n给定一个字符串，求其有多少个回文子字符串。回文的定义是左右对称。\n\n输入是一个字符串，输出一个整数，表示回文子字符串的数量。\n\n> 输入：s = "aaa"\n> 输出：6\n> 解释：6个回文子串: "a", "a", "a", "aa", "aa", "aaa"\n\n解析：\n\n本题采用中心扩展法，可以从字符串的每个位置开始，向左向右延长，判断存在多少以当前位置为中轴的回文 子字符串。中心扩展法：枚举每一个可能的回文中心，然后用两个指针分别向左右两边拓展，当两个指针指向的元素相同的时候就拓展，否则停止拓展。枚举过程中要区分子串的长度为偶数情况和奇数情况。\n\nclass Solution {\npublic:\n    int countCurSub(string s, int lsh, int rsh){\n        int count = 0;\n        while(lsh>=0 && rsh<s.length() && s[lsh]==s[rsh]){\n            --lsh;\n            ++rsh;\n            ++count;\n        }\n        return count;\n    }\n\n    int countSubstrings(string s) {\n        int ans = 0;\n        for(int i=0;i<s.length();++i){\n            // 长度为奇数的回文子串\n            ans += countCurSub(s,i,i);\n            // 长度为偶数的回文子串\n            ans += countCurSub(s,i,i+1);\n        }\n        return ans;\n    }\n};\n\n\n# 696 计数二进制子串\n\n给定一个 0-1 字符串，求有多少非空子字符串的 0 和 1 数量相同。\n\n输入是一个字符串，输出一个整数，表示满足条件的子字符串的数量。\n\n> 输入: "00110011" 输出: 6 解释: 有6个子串具有相同数量的连续1和0：“0011”，“01”，“1100”，“10”，“0011” 和 “01”。\n\n解析：\n\n从左往右遍历数组，记录和当前位置数字相同且连续的长度，以及其之前连续的不同数字的长度。举例来说，对于 00110 的最后一位，我们记录的相同数字长度是 1，因为只有一个连续 0；我们记录的不同数字长度是 2，因为在 0 之前有两个连续的 1。若不同数字的连续长度大于等于当前数字的连续长度，则说明存在一个且只存在一个以当前数字结尾的满足条件的子字符串。\n\nclass Solution {\npublic:\n    int countBinarySubstrings(string s) {\n        int pre = 0, cur = 1, count = 0;\n        for (int i = 1; i < s.length(); ++i) {\n            if (s[i] == s[i-1]) {\n                ++cur;\n            } else {\n                pre = cur;\n                cur = 1;\n            }\n            if (pre >= cur) {\n                ++count;\n            }\n        }\n        return count;\n    }\n};\n',normalizedContent:'# leetcode刷题笔记 字符串\n\n字符串可以看成是字符组成的数组。由于字符串是程序里经常需要处理的数据类型，因此有很多针对字符串处理的题目。\n\n\n# 01 字符串比较\n\n# 242 有效的字母异位词\n\n判断两个字符串包含的字符是否完全相同。\n\n输入两个字符串，输出一个布尔值，表示两个字符串是否满足条件。\n\n> 输入: s = "anagram", t = "nagaram"\n> 输出: true\n\n解析：\n\n可以利用哈希表或者数组统计两个数组中每个数字出现的频次，若频次相同，则说明它们包含的字符完全相同。\n\n为了降低空间复杂度，我们可以仅采用一个哈希表或数组记录 s 中字符的频次，然后减去 t 中对应字符出现的频次，如果最终该频次为 0 则该字符在 s 和 t 中个数相等，如果最终s和t所有字符频次都想等那么他们是异位词。这种方式避免了单独再开辟一个空间取存储 t 中字符的频次。\n\nclass solution {\npublic:\n    bool isanagram(string s, string t) {\n        if(s.length()!=t.length()) return false;\n        unordered_map<char,int> s_cnt;\n        for(int i=0;i<s.length();++i){\n            ++s_cnt[s[i]];\n            --s_cnt[t[i]];\n        }\n\n        for(const auto [h_key,h_val]: s_cnt){\n            if(h_val){\n                return false;\n            }\n        }\n        return true;\n    }\n};\n\n\n# 205 同构字符串\n\n判断两个字符串是否同构。同构的定义是，可以通过把一个字符串的某些相同的字符转换成另一些相同的字符，使得两个字符串相同，且两种不同的字符不能够被转换成同一种字符。\n\n输入两个字符串，输出一个布尔值，表示两个字符串是否满足条件。\n\n> 输入：s = "egg", t = "add"\n> 输出：true\n> 输入：s = "foo", t = "bar"\n> 输出：false\n\n解析：\n\n本题可以通过哈希表记录两个字符串每种字符第一次出现的位置，如果两个字符串中相同位置的字符与它们第一次出现的位置一样，那么这两个字符串同构。如果他们第一次出现的位置一样，那么说明当前两个字符的对应关系是正确的；如果不一样，说明当前两个字符的对应关系是错误的，不满足异构。\n\nclass solution {\npublic:\n    bool isisomorphic(string s, string t) {\n        if(s.length()!=t.length()) return false;\n        unordered_map<char,int> s_first_in;\n        unordered_map<char,int> t_first_in;\n        for(int i=1;i<s.length();++i){\n            if(s_first_in.find(s[i]) == s_first_in.end()){\n                s_first_in[s[i]] = i;\n            }\n            if(t_first_in.find(t[i]) == t_first_in.end()){\n                t_first_in[t[i]] = i;\n            }\n        }\n        for(int i=0;i<s.length();++i){\n            if(s_first_in[s[i]] != t_first_in[t[i]]){\n                return false;\n            }\n        }\n        return true;\n    }\n};\n\n\n# 125 验证回文串\n\n给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。\n\n输入一个字符串，输出一个布尔值表示该字符串是否为回文串\n\n> 输入: "a man, a plan, a canal: panama"\n> 输出: true\n> 解释："amanaplanacanalpanama" 是回文串\n\n解析：\n\n回文串一般都可以采用双指针从两头向中间检验，或者采用中心扩展法从中间向两头验证是否为回文串。\n\n本题可以采用双指针的策略，从字符串首尾两端逐个字符检验。但是本题中给出的字符串有许多非字母字符，可以用一个新字符串保存原字符串中的所有字母小写形式，然后对其使用双指针方法验证。\n\nclass solution {\npublic:\n    bool ispalindrome(string s) {\n        // 筛选出字母内容\n        string sgood;\n        for (char ch: s) {\n            if (isalnum(ch)) {\n                sgood += tolower(ch);\n            }\n        }\n        // 双指针验证回文串\n        int n = sgood.size();\n        int left = 0, right = n - 1;\n        while (left < right) {\n           if (sgood[left] != sgood[right]) {\n                return false;\n            }\n            ++left;\n            --right;\n        }\n        return true;\n    }\n};\n\n\n# 680 验证回文字符串 ⅱ\n\n给定一个非空字符串 s，最多删除一个字符。判断是否能成为回文字符串。\n\n输入一个字符串，输出一个布尔值表示该字符串是否能通过删除操作构成回文串\n\n> 输入: s = "abca"\n> 输出: true\n> 解释: 你可以删除c字符。\n\n解析：\n\n本题采用双指针的方法检验回文串，两个指针分别指向字符串的头和尾，逐一比较两个指针指向的元素。当出现两个指针指向的字符不想等的情况时分别检验将头指针指向的元素删除和将尾指针指向的元素删除两种情况下继续比较字符，是否仍然可以构成回文串。\n\nclass solution {\npublic:\n    bool subpalindrome(string s, int head, int tail){\n        for(;head<tail;++head,--tail){\n            if(s[head]!=s[tail]){\n                return false;\n            }\n        }\n        return true;\n    }\n\n    bool validpalindrome(string s) {\n        int head = 0, tail = s.size()-1;\n        while(head<tail){\n            if(s[head]==s[tail]){\n                ++head;\n                --tail;\n            }else{\n                if( subpalindrome(s,head,tail-1)||subpalindrome(s,head+1,tail)){\n                    return true;\n                }else{\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n};\n\n\n# 647 回文子串\n\n给定一个字符串，求其有多少个回文子字符串。回文的定义是左右对称。\n\n输入是一个字符串，输出一个整数，表示回文子字符串的数量。\n\n> 输入：s = "aaa"\n> 输出：6\n> 解释：6个回文子串: "a", "a", "a", "aa", "aa", "aaa"\n\n解析：\n\n本题采用中心扩展法，可以从字符串的每个位置开始，向左向右延长，判断存在多少以当前位置为中轴的回文 子字符串。中心扩展法：枚举每一个可能的回文中心，然后用两个指针分别向左右两边拓展，当两个指针指向的元素相同的时候就拓展，否则停止拓展。枚举过程中要区分子串的长度为偶数情况和奇数情况。\n\nclass solution {\npublic:\n    int countcursub(string s, int lsh, int rsh){\n        int count = 0;\n        while(lsh>=0 && rsh<s.length() && s[lsh]==s[rsh]){\n            --lsh;\n            ++rsh;\n            ++count;\n        }\n        return count;\n    }\n\n    int countsubstrings(string s) {\n        int ans = 0;\n        for(int i=0;i<s.length();++i){\n            // 长度为奇数的回文子串\n            ans += countcursub(s,i,i);\n            // 长度为偶数的回文子串\n            ans += countcursub(s,i,i+1);\n        }\n        return ans;\n    }\n};\n\n\n# 696 计数二进制子串\n\n给定一个 0-1 字符串，求有多少非空子字符串的 0 和 1 数量相同。\n\n输入是一个字符串，输出一个整数，表示满足条件的子字符串的数量。\n\n> 输入: "00110011" 输出: 6 解释: 有6个子串具有相同数量的连续1和0：“0011”，“01”，“1100”，“10”，“0011” 和 “01”。\n\n解析：\n\n从左往右遍历数组，记录和当前位置数字相同且连续的长度，以及其之前连续的不同数字的长度。举例来说，对于 00110 的最后一位，我们记录的相同数字长度是 1，因为只有一个连续 0；我们记录的不同数字长度是 2，因为在 0 之前有两个连续的 1。若不同数字的连续长度大于等于当前数字的连续长度，则说明存在一个且只存在一个以当前数字结尾的满足条件的子字符串。\n\nclass solution {\npublic:\n    int countbinarysubstrings(string s) {\n        int pre = 0, cur = 1, count = 0;\n        for (int i = 1; i < s.length(); ++i) {\n            if (s[i] == s[i-1]) {\n                ++cur;\n            } else {\n                pre = cur;\n                cur = 1;\n            }\n            if (pre >= cur) {\n                ++count;\n            }\n        }\n        return count;\n    }\n};\n',charsets:{cjk:!0},lastUpdated:"2023/11/19, 12:55:48",lastUpdatedTimestamp:1700369748e3},{title:"02链表遍历",frontmatter:{title:"02链表遍历",date:"2023-03-24T18:39:49.000Z",permalink:"/pages/3871a6/"},regularPath:"/03.LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/02.%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/03.%E5%8D%95%E9%93%BE%E8%A1%A8/02.%E9%93%BE%E8%A1%A8%E9%81%8D%E5%8E%86.html",relativePath:"03.LeetCode刷题笔记/02.基础数据结构/03.单链表/02.链表遍历.md",key:"v-ef6f3572",path:"/pages/3871a6/",headers:[{level:2,title:"02 遍历链表",slug:"_02-遍历链表",normalizedTitle:"02 遍历链表",charIndex:2},{level:4,title:"160 相交链表",slug:"_160-相交链表",normalizedTitle:"160 相交链表",charIndex:13},{level:4,title:"234 回文链表",slug:"_234-回文链表",normalizedTitle:"234 回文链表",charIndex:918},{level:4,title:"19 删除链表的倒数第 N 个结点",slug:"_19-删除链表的倒数第-n-个结点",normalizedTitle:"19 删除链表的倒数第 n 个结点",charIndex:2330}],headersStr:"02 遍历链表 160 相交链表 234 回文链表 19 删除链表的倒数第 N 个结点",content:"# 02 遍历链表\n\n# 160 相交链表\n\n给定两个链表，判断它们是否相交于一点，并求这个相交节点。\n\n输入是两条链表，输出是一个节点。如无相交节点，则返回一个空节点。\n\n> 输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3 输出：Intersected at '8' 解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。\n\n解析：\n\n假设链表 A 的头节点到相交点的距离是 a，链表 B 的头节点到相交点的距离是 b，相交点到链表终点的距离为 c。我们使用两个指针，分别指向两个链表的头节点，并以相同的速度前进，若到达链表结尾，则移动到另一条链表的头节点继续前进。按照这种前进方法，两个指针会在 a + b + c 次前进后同时到达相交节点。\n\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n        ListNode *pa = headA, *pb = headB;\n        while(pa != pb){\n            pa = pa?pa->next:headB;\n            pb = pb?pb->next:headA;\n        }\n        return pa;\n    }\n};\n\n\n# 234 回文链表\n\n以 O(1) 的空间复杂度，判断链表是否回文。\n\n输入是一个链表，输出是一个布尔值，表示链表是否回文。\n\n输入：head = [1,2,2,1]\n输出：true\n\n\n解析：\n\n先使用快慢指针找到链表中点，再把链表切成两半；然后把后半段翻转；最后比较两半是否相等。\n\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    // 链表翻转\n    ListNode* reverseList(ListNode* head) {\n           ListNode *prev = nullptr, *next = head;\n           while(head){\n               next = head->next;\n               head->next = prev;\n               prev = head;\n               head = next;\n           }\n           return prev;\n       }\n\n    bool isPalindrome(ListNode* head) {\n        if(!head || !head->next){\n            return true;\n        }\n        // 快慢指针找到链表中点\n        ListNode *fast = head, *slow = head;\n        while(fast->next && fast->next->next){\n            fast = fast->next->next;\n            slow = slow->next;\n        }\n        \n        // 不管链表长度为偶数还是奇数 slow 指向都是前半部分的最后一个节点\n        fast = slow->next;\n        fast = reverseList(fast);\n        slow = head;\n        // 比较两部分元素是否一致\n        while(fast){\n            if(slow->val != fast->val){\n                return false;\n            }\n            slow = slow->next;\n            fast = fast->next;\n        }\n        return true;\n    }\n};\n\n\n# 19 删除链表的倒数第 N 个结点\n\n给定一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。\n\n输入是一个链表，输出删除倒数第 n 个节点的链表\n\n> 输入：head = [1,2,3,4,5], n = 2\n> 输出：[1,2,3,5]\n\n解析：\n\n和使用快慢指针找到链表中点的思路一样，让快指针先于慢指针 n 个节点出发，那么当快指针到达链表尾部时，慢指针刚好处于链表倒数第 n+1 个节点，删除其next节点即可。\n\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\n        ListNode *slow=head, *fast=head;\n        // 快指针先走n步\n        for(int i=0;i<n;++i){\n            fast=fast->next;\n        }\n        if(!fast){\n            head = head->next;\n            return head;\n        }\n        while(fast->next){\n            fast=fast->next;\n            slow=slow->next;\n        }\n        ListNode *delNode = slow->next;\n        slow->next = delNode->next;\n        delete delNode;\n        return head;\n    }\n};\n",normalizedContent:"# 02 遍历链表\n\n# 160 相交链表\n\n给定两个链表，判断它们是否相交于一点，并求这个相交节点。\n\n输入是两条链表，输出是一个节点。如无相交节点，则返回一个空节点。\n\n> 输入：intersectval = 8, lista = [4,1,8,4,5], listb = [5,0,1,8,4,5], skipa = 2, skipb = 3 输出：intersected at '8' 解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 a 为 [4,1,8,4,5]，链表 b 为 [5,0,1,8,4,5]。在 a 中，相交节点前有 2 个节点；在 b 中，相交节点前有 3 个节点。\n\n解析：\n\n假设链表 a 的头节点到相交点的距离是 a，链表 b 的头节点到相交点的距离是 b，相交点到链表终点的距离为 c。我们使用两个指针，分别指向两个链表的头节点，并以相同的速度前进，若到达链表结尾，则移动到另一条链表的头节点继续前进。按照这种前进方法，两个指针会在 a + b + c 次前进后同时到达相交节点。\n\n/**\n * definition for singly-linked list.\n * struct listnode {\n *     int val;\n *     listnode *next;\n *     listnode(int x) : val(x), next(null) {}\n * };\n */\nclass solution {\npublic:\n    listnode *getintersectionnode(listnode *heada, listnode *headb) {\n        listnode *pa = heada, *pb = headb;\n        while(pa != pb){\n            pa = pa?pa->next:headb;\n            pb = pb?pb->next:heada;\n        }\n        return pa;\n    }\n};\n\n\n# 234 回文链表\n\n以 o(1) 的空间复杂度，判断链表是否回文。\n\n输入是一个链表，输出是一个布尔值，表示链表是否回文。\n\n输入：head = [1,2,2,1]\n输出：true\n\n\n解析：\n\n先使用快慢指针找到链表中点，再把链表切成两半；然后把后半段翻转；最后比较两半是否相等。\n\n/**\n * definition for singly-linked list.\n * struct listnode {\n *     int val;\n *     listnode *next;\n *     listnode() : val(0), next(nullptr) {}\n *     listnode(int x) : val(x), next(nullptr) {}\n *     listnode(int x, listnode *next) : val(x), next(next) {}\n * };\n */\nclass solution {\npublic:\n    // 链表翻转\n    listnode* reverselist(listnode* head) {\n           listnode *prev = nullptr, *next = head;\n           while(head){\n               next = head->next;\n               head->next = prev;\n               prev = head;\n               head = next;\n           }\n           return prev;\n       }\n\n    bool ispalindrome(listnode* head) {\n        if(!head || !head->next){\n            return true;\n        }\n        // 快慢指针找到链表中点\n        listnode *fast = head, *slow = head;\n        while(fast->next && fast->next->next){\n            fast = fast->next->next;\n            slow = slow->next;\n        }\n        \n        // 不管链表长度为偶数还是奇数 slow 指向都是前半部分的最后一个节点\n        fast = slow->next;\n        fast = reverselist(fast);\n        slow = head;\n        // 比较两部分元素是否一致\n        while(fast){\n            if(slow->val != fast->val){\n                return false;\n            }\n            slow = slow->next;\n            fast = fast->next;\n        }\n        return true;\n    }\n};\n\n\n# 19 删除链表的倒数第 n 个结点\n\n给定一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。\n\n输入是一个链表，输出删除倒数第 n 个节点的链表\n\n> 输入：head = [1,2,3,4,5], n = 2\n> 输出：[1,2,3,5]\n\n解析：\n\n和使用快慢指针找到链表中点的思路一样，让快指针先于慢指针 n 个节点出发，那么当快指针到达链表尾部时，慢指针刚好处于链表倒数第 n+1 个节点，删除其next节点即可。\n\n/**\n * definition for singly-linked list.\n * struct listnode {\n *     int val;\n *     listnode *next;\n *     listnode() : val(0), next(nullptr) {}\n *     listnode(int x) : val(x), next(nullptr) {}\n *     listnode(int x, listnode *next) : val(x), next(next) {}\n * };\n */\nclass solution {\npublic:\n    listnode* removenthfromend(listnode* head, int n) {\n        listnode *slow=head, *fast=head;\n        // 快指针先走n步\n        for(int i=0;i<n;++i){\n            fast=fast->next;\n        }\n        if(!fast){\n            head = head->next;\n            return head;\n        }\n        while(fast->next){\n            fast=fast->next;\n            slow=slow->next;\n        }\n        listnode *delnode = slow->next;\n        slow->next = delnode->next;\n        delete delnode;\n        return head;\n    }\n};\n",charsets:{cjk:!0},lastUpdated:"2023/11/19, 12:55:48",lastUpdatedTimestamp:1700369748e3},{title:"LinkList",frontmatter:{title:"LinkList",date:"2023-03-24T18:39:49.000Z",permalink:"/pages/2fa8a0/"},regularPath:"/03.LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/02.%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/03.%E5%8D%95%E9%93%BE%E8%A1%A8/LinkList.html",relativePath:"03.LeetCode刷题笔记/02.基础数据结构/03.单链表/LinkList.md",key:"v-a2a462c6",path:"/pages/2fa8a0/",headers:[{level:2,title:"LeetCode刷题笔记 链表",slug:"leetcode刷题笔记-链表",normalizedTitle:"leetcode刷题笔记 链表",charIndex:2}],headersStr:"LeetCode刷题笔记 链表",content:"# LeetCode刷题笔记 链表\n\n链表是由节点和指针构成的数据结构，每个节点存有一个值，和一个指向下一个节点的指针，因此很多链表问题可以用递归来处理。不同于数组，链表并不能直接获取任意节点的值，必须要通过指针找到该节点后才能获取其值。同理，在未遍历到链表结尾时，我们也无法知道链表的长度，除非依赖其他数据结构储存长度。链表一般表示方法如下。\n\nstruct ListNode {\n    int val;\n    ListNode *next;\n    ListNode(int x) : val(x), next(nullptr) {}\n};\n\n\n由于在进行链表操作时，尤其是删除节点时，经常会因为对当前节点进行操作而导致内存或指针出现问题。有两个小技巧可以解决这个问题：\n\n * 一是尽量处理当前节点的下一个节点而非当前节点本身\n * 二是建立一个虚拟节点 (dummy node)，使其指向当前链表的头节点，这样即使原链表所有节点全被删除，也会有一个 dummy 存在，返回 dummy->next 即可。",normalizedContent:"# leetcode刷题笔记 链表\n\n链表是由节点和指针构成的数据结构，每个节点存有一个值，和一个指向下一个节点的指针，因此很多链表问题可以用递归来处理。不同于数组，链表并不能直接获取任意节点的值，必须要通过指针找到该节点后才能获取其值。同理，在未遍历到链表结尾时，我们也无法知道链表的长度，除非依赖其他数据结构储存长度。链表一般表示方法如下。\n\nstruct listnode {\n    int val;\n    listnode *next;\n    listnode(int x) : val(x), next(nullptr) {}\n};\n\n\n由于在进行链表操作时，尤其是删除节点时，经常会因为对当前节点进行操作而导致内存或指针出现问题。有两个小技巧可以解决这个问题：\n\n * 一是尽量处理当前节点的下一个节点而非当前节点本身\n * 二是建立一个虚拟节点 (dummy node)，使其指向当前链表的头节点，这样即使原链表所有节点全被删除，也会有一个 dummy 存在，返回 dummy->next 即可。",charsets:{cjk:!0},lastUpdated:"2023/11/19, 12:55:48",lastUpdatedTimestamp:1700369748e3},{title:"01二叉树的属性",frontmatter:{title:"01二叉树的属性",date:"2023-03-24T18:39:49.000Z",permalink:"/pages/334633/"},regularPath:"/03.LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/02.%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/04.%E4%BA%8C%E5%8F%89%E6%A0%91/01.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%9E%E6%80%A7.html",relativePath:"03.LeetCode刷题笔记/02.基础数据结构/04.二叉树/01.二叉树的属性.md",key:"v-2e7b6e04",path:"/pages/334633/",headers:[{level:2,title:"01 二叉树的属性",slug:"_01-二叉树的属性",normalizedTitle:"01 二叉树的属性",charIndex:2},{level:4,title:"104 二叉树的最大深度",slug:"_104-二叉树的最大深度",normalizedTitle:"104 二叉树的最大深度",charIndex:490},{level:4,title:"110 平衡二叉树",slug:"_110-平衡二叉树",normalizedTitle:"110 平衡二叉树",charIndex:926},{level:4,title:"543 二叉树的直径",slug:"_543-二叉树的直径",normalizedTitle:"543 二叉树的直径",charIndex:1704},{level:4,title:"101 对称二叉树",slug:"_101-对称二叉树",normalizedTitle:"101 对称二叉树",charIndex:2510},{level:4,title:"572 另一棵树的子树",slug:"_572-另一棵树的子树",normalizedTitle:"572 另一棵树的子树",charIndex:3555},{level:4,title:"404 左叶子之和",slug:"_404-左叶子之和",normalizedTitle:"404 左叶子之和",charIndex:4996},{level:4,title:"437 路径总和 III",slug:"_437-路径总和-iii",normalizedTitle:"437 路径总和 iii",charIndex:5940}],headersStr:"01 二叉树的属性 104 二叉树的最大深度 110 平衡二叉树 543 二叉树的直径 101 对称二叉树 572 另一棵树的子树 404 左叶子之和 437 路径总和 III",content:"# 01 二叉树的属性\n\n最为常见的树就是二叉树，这种树的每个节点最多有两个子节点，二叉树可以看成是单链表的升级版，因为他和链表的主要区别就是多了一个子节点的指针。\n\n Definition for a binary tree node.\n struct TreeNode {\n     int val;\n     TreeNode *left;\n     TreeNode *right;\n     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n };\n\n\n二叉树的属性包含：树深度、树直径、树节点数、左叶子节点、对称性、平衡性和路径问题等。这些二叉树的属性都可通过递归或者迭代的方式求得或验证。\n\n# 104 二叉树的最大深度\n\n求一个二叉树的最大深度。\n\n输入是一个二叉树，输出是一个整数，表示该树的最大深度。\n\n> 输入： [3,9,20,null,null,15,7]，\n> \n>  3\n> / \\\n> 9  20\n>  /  \\\n> 15   7\n> \n> \n> 输出：3\n> \n> 解释：返回它的最大深度 3\n\n解析：\n\n采用深度优先搜索，其子问题是：左子树和右子树的最大深度 l 和 r，那么该二叉树的最大深度即为 max(l,r)+1。中止条件是访问的节点为空，推出递归。\n\nclass Solution {\npublic:\n    int maxDepth(TreeNode* root) {\n        if(!root){\n            return 0;\n        }\n        return max(maxDepth(root->left),maxDepth(root->right)) + 1;\n    }\n};\n\n\n# 110 平衡二叉树\n\n判断一个二叉树是否平衡。树平衡的定义是，对于树上的任意节点，其两侧节点的最大深度的差值不得大于 1。\n\n输入是一个二叉树，输出一个布尔值，表示树是否平衡。\n\n> 输入：root = [1,2,2,3,3,null,null,4,4]\n> 输出：false\n\n解析：\n\n本题的思路类似104 二叉树的最大深度，不同的是在获取子树深度时要对当前左右子树的深度进行比较，如果还未遍历完二叉树就已经发现左右子树不平衡，则直接返回-1，避免再继续往下计算子树深度。\n\n提前返回-1中断子树深度计算要注意的是：第一次返回-1的判断条件是abs(left - right) > 1，但是在往上回溯深度计算结果的过程中，如果出现了中断，那么回溯结果为 -1，这时表明下层子树出现了不平衡情况，所以上层返回-1的判断条件是left == -1 || right == -1\n\nclass Solution {\npublic:\n    int treeDepth(TreeNode* node){\n        if(!node){\n            return 0;\n        }\n        int l = treeDepth(node->left);\n        int r = treeDepth(node->right);\n        if(l==-1 || r==-1 || abs(l-r)>1){\n            return -1;\n        }\n        return max(l,r)+1;\n    }\n\n    bool isBalanced(TreeNode* root) {\n        return treeDepth(root) != -1;\n    }\n};\n\n\n# 543 二叉树的直径\n\n求一个二叉树的最长直径。直径的定义是二叉树上任意两节点之间的无向距离。\n\n输入是一个二叉树，输出一个整数，表示最长直径。\n\n> 输入：给定二叉树\n> \n>   1 \n>  / \\\n>  2  3\n> / \\    \n> 4  5    \n> \n> \n> 输出： 3\n> \n> 解释：它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。\n\n解析：\n\n本题可以直接转化为左子树最大深度与右子树最大深度之和，所以在递归计算子树深度时，更新的最长直径值和递归返回的值是不同的。这是因为待更新的最长直径值是经过该子树根节点的最长直径（即两侧长度）；而函数返回值是以该子树根节点为端点的最长直径值（即一侧长度），使用这样的返回值才可以通过递归更新父节点的最长直径值）。\n\nclass Solution {\npublic:\n    int maxDepth(TreeNode* root, int& diameter){\n        if(!root){\n            return 0;\n        }\n        int l = maxDepth(root->left,diameter);\n        int r = maxDepth(root->right,diameter);\n        // 更新当前节点的最长直径\n        diameter = max(l+r,diameter);\n        return max(l,r)+1;\n    }\n\n    int diameterOfBinaryTree(TreeNode* root) {\n        int diameter = 0;\n        maxDepth(root,diameter);\n        return diameter;\n    }\n};\n\n\n# 101 对称二叉树\n\n判断一个二叉树是否对称。\n\n输入一个二叉树，输出一个布尔值，表示该树是否对称。\n\n>       1\n>      / \\\n>     2   2\n>  / \\ / \\\n> 3  4 4  3\n> \n> \n> 二叉树 [1,2,2,3,4,4,3] 是对称的\n\n解析：\n\n本题可以将二叉树是否对称转化为其左右子树是否对称，本质上还是树的递归问题，但是递归过程中涉及到比较。对两个子树进行比较判断是否相等或对称的解法一般可以按照如下四步：\n\n * 如果两个子树都为空指针，则它们相等或对称，从根节点递归到叶子节点时都是相等的\n * 如果两个子树只有一个为空指针，则它们不相等或不对称，一棵子树却胳膊少腿肯定不相等\n * 如果两个子树根节点的值不相等，则它们不相等或不对称，出现比较位置不同值直接返回false\n * 根据相等或对称要求，进行递归处理；相等就是左子树的左节点和右子树的左节点比较，左子树的右节点和右子树的右节点比较；对称就是左子树的左节点和右子树的右节点比较，左子树的右节点和右子树的左节点比较\n\n需要注意的是前三个判断步骤不能调换顺序，因为有一个为空范围大于均为空，如果有空就无法取值。\n\nclass Solution {\npublic:\n    bool isSymmetric(TreeNode* left, TreeNode* right){\n        if(!left && !right){\n            return true;\n        }else if(!left || !right){\n            return false;\n        }else if(left->val != right->val){\n            return false;\n        }\n        return isSymmetric(left->left,right->right) && isSymmetric(left->right,right->left);\n    }\n\n    bool isSymmetric(TreeNode* root) {\n        if(!root){\n            return true;\n        }\n        return isSymmetric(root->left,root->right);\n    }\n};\n\n\n# 572 另一棵树的子树\n\n给定两棵二叉树 root 和 subRoot 。检验 root 中是否包含和 subRoot 具有相同结构和节点值的子树\n\n输入两棵二叉树，输出一个布尔值表示 root 树中是否包含 subRoot 树\n\n> 输入：root = [3,4,5,1,2], subRoot = [4,1,2]\n> \tTree root                  Tree subRoot               \n>           3                         4                             \n>          / \\                       / \\                            \n>         4   5                     1   2                        \n>        / \\                                                   \n>       1   2                                \n> 输出：true\n\n解析：\n\n本题是101 对称二叉树的变种题，解题分为两个步骤，第一步遍历 root 树找和 subRoot 相同的根节点，第二步判断 root 中子树是否和 subRoot 相同。\n\n判断两颗二叉树是否相同和判断二叉树是否对称思路一致，递归对比参与比较的两个节点值，最终递归将节点全部顺利比较完成则两颗二叉树相同，否在有一棵树先被遍历完成或者出现节点值不相同的情况，那么这两颗树也不相同。\n\n遍历二叉树寻找相同子树的过程就是递归遍历每一颗子树，遍历过程中不断与 subRoot 进行比较得出结果。\n\npublic:\n    bool isSameTree(TreeNode* root, TreeNode* subRoot){\n        if(!root && !subRoot){\n            return true;\n        }else if(!root || !subRoot){\n            return false;\n        }else if(root->val!=subRoot->val){\n            return false;\n        }\n        return isSameTree(root->left,subRoot->left) && isSameTree(root->right,subRoot->right);\n    }\n\n    bool isSubtree(TreeNode* root, TreeNode* subRoot) {\n        if(!subRoot){\n            return true;\n        }else if(!root){\n            return false;\n        }\n        return isSameTree(root,subRoot) || isSubtree(root->left,subRoot) || isSubtree(root->right,subRoot);\n    }\n};\n\n\n# 404 左叶子之和\n\n给定一个二叉树，计算该树的所有左叶子之和\n\n输入一颗二叉树，输出一个整数表示所有左叶子之和\n\n> 输入：\n>     3\n>    / \\\n>   9  20\n>     /  \\\n>    15   7\n> 输出：24\n> 解释：在这个二叉树中，有两个左叶子，分别是 9 和 15，所以返回 24\n\n解析：\n\n本题的关键就在于利用左叶子节点的定义进行有条件递归遍历二叉树，同时要判断一个节点是不是叶子节点，定义一个辅助函数如果该节点没有子节点则说明该节点是叶子节点。\n\n如果一个节点是左叶子节点，那么它是某个节点的左子节点，并且它还是一个叶子结点。\n\n根据此定义，在递归遍历过程中，如果一个节点有左子节点，且该节点是一个叶子节点，那么将该左子节点加到累和中；假若该左子节点不是叶子节点，则以该左子节点为根节点递归查找左叶子节点。\n\n如果一个节点有右子节点，且该节点是一个叶子节点，不进行累和且终止往下递归；假若该右子节点不是叶子节点，则将该右子节点为根节点递归查找左叶子节点。\n\nclass Solution {\npublic:\n    bool isLeafNode(TreeNode* root){\n        return  !root->left && !root->right;\n    }\n\n    int sumOfLeftLeaves(TreeNode* root) {\n        if(!root){\n            return 0;\n        }\n        int ans = 0;\n        if(root->left){\n            ans += isLeafNode(root->left)?root->left->val:sumOfLeftLeaves(root->left);\n        }\n        if(root->right){\n            ans += isLeafNode(root->right)?0:sumOfLeftLeaves(root->right);\n        }\n        return ans;\n    }\n};\n\n\n# 437 路径总和 III\n\n给定一个整数二叉树，求有多少条路径节点值的和等于给定值。\n\n输入一个二叉树和一个给定整数，输出一个整数，表示有多少条满足条件的路径。\n\n> 输入：root = [10,5,-3,3,2,null,11,3,-2,null,1], targetSum = 8\n> 输出：3\n\n解析：\n\n本题的关键在于计算路径和，所以在递归每个节点时，需要分情况考虑：\n\n * 如果选取该节点加入路径，则之后必须继续加入连续节点，或停止加入节点\n * 如果不选取该节点加入路径，则对其左右节点进行重新进行考虑\n\n因此一个方便的方法是创建一个辅函数，专门用来计算连续加入节点的路径。该辅助函数就是通过用给定值递归减去路径节点值，最终给定值减为0表示构成一条路径。\n\nclass Solution {\npublic:\n    int pathWithRoot(TreeNode* root, int sum){\n        if(!root){\n            return 0;\n        }\n        int count = 0;\n        // 如果当前节点值与路径和一致则形成一条路径\n        if(root->val == sum){\n            count = 1;\n        }else{\n            count = 0;\n        }\n        // 往左右子节点继续寻找路径\n        count += pathWithRoot(root->left, sum-root->val);\n        count += pathWithRoot(root->right, sum-root->val);\n        return count;\n    }\n\n    int pathSum(TreeNode* root, int targetSum) {\n        if(!root){\n            return 0;\n        }\n        // 将当前节点加入路径\n        int ans = 0;\n        ans = pathWithRoot(root,targetSum);\n        // 不将当前节点加入路径，从左右子节点开始寻找新路径\n        ans += pathSum(root->left,targetSum);\n        ans += pathSum(root->right,targetSum);\n        return ans;\n    }\n};\n",normalizedContent:"# 01 二叉树的属性\n\n最为常见的树就是二叉树，这种树的每个节点最多有两个子节点，二叉树可以看成是单链表的升级版，因为他和链表的主要区别就是多了一个子节点的指针。\n\n definition for a binary tree node.\n struct treenode {\n     int val;\n     treenode *left;\n     treenode *right;\n     treenode() : val(0), left(nullptr), right(nullptr) {}\n     treenode(int x) : val(x), left(nullptr), right(nullptr) {}\n     treenode(int x, treenode *left, treenode *right) : val(x), left(left), right(right) {}\n };\n\n\n二叉树的属性包含：树深度、树直径、树节点数、左叶子节点、对称性、平衡性和路径问题等。这些二叉树的属性都可通过递归或者迭代的方式求得或验证。\n\n# 104 二叉树的最大深度\n\n求一个二叉树的最大深度。\n\n输入是一个二叉树，输出是一个整数，表示该树的最大深度。\n\n> 输入： [3,9,20,null,null,15,7]，\n> \n>  3\n> / \\\n> 9  20\n>  /  \\\n> 15   7\n> \n> \n> 输出：3\n> \n> 解释：返回它的最大深度 3\n\n解析：\n\n采用深度优先搜索，其子问题是：左子树和右子树的最大深度 l 和 r，那么该二叉树的最大深度即为 max(l,r)+1。中止条件是访问的节点为空，推出递归。\n\nclass solution {\npublic:\n    int maxdepth(treenode* root) {\n        if(!root){\n            return 0;\n        }\n        return max(maxdepth(root->left),maxdepth(root->right)) + 1;\n    }\n};\n\n\n# 110 平衡二叉树\n\n判断一个二叉树是否平衡。树平衡的定义是，对于树上的任意节点，其两侧节点的最大深度的差值不得大于 1。\n\n输入是一个二叉树，输出一个布尔值，表示树是否平衡。\n\n> 输入：root = [1,2,2,3,3,null,null,4,4]\n> 输出：false\n\n解析：\n\n本题的思路类似104 二叉树的最大深度，不同的是在获取子树深度时要对当前左右子树的深度进行比较，如果还未遍历完二叉树就已经发现左右子树不平衡，则直接返回-1，避免再继续往下计算子树深度。\n\n提前返回-1中断子树深度计算要注意的是：第一次返回-1的判断条件是abs(left - right) > 1，但是在往上回溯深度计算结果的过程中，如果出现了中断，那么回溯结果为 -1，这时表明下层子树出现了不平衡情况，所以上层返回-1的判断条件是left == -1 || right == -1\n\nclass solution {\npublic:\n    int treedepth(treenode* node){\n        if(!node){\n            return 0;\n        }\n        int l = treedepth(node->left);\n        int r = treedepth(node->right);\n        if(l==-1 || r==-1 || abs(l-r)>1){\n            return -1;\n        }\n        return max(l,r)+1;\n    }\n\n    bool isbalanced(treenode* root) {\n        return treedepth(root) != -1;\n    }\n};\n\n\n# 543 二叉树的直径\n\n求一个二叉树的最长直径。直径的定义是二叉树上任意两节点之间的无向距离。\n\n输入是一个二叉树，输出一个整数，表示最长直径。\n\n> 输入：给定二叉树\n> \n>   1 \n>  / \\\n>  2  3\n> / \\    \n> 4  5    \n> \n> \n> 输出： 3\n> \n> 解释：它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。\n\n解析：\n\n本题可以直接转化为左子树最大深度与右子树最大深度之和，所以在递归计算子树深度时，更新的最长直径值和递归返回的值是不同的。这是因为待更新的最长直径值是经过该子树根节点的最长直径（即两侧长度）；而函数返回值是以该子树根节点为端点的最长直径值（即一侧长度），使用这样的返回值才可以通过递归更新父节点的最长直径值）。\n\nclass solution {\npublic:\n    int maxdepth(treenode* root, int& diameter){\n        if(!root){\n            return 0;\n        }\n        int l = maxdepth(root->left,diameter);\n        int r = maxdepth(root->right,diameter);\n        // 更新当前节点的最长直径\n        diameter = max(l+r,diameter);\n        return max(l,r)+1;\n    }\n\n    int diameterofbinarytree(treenode* root) {\n        int diameter = 0;\n        maxdepth(root,diameter);\n        return diameter;\n    }\n};\n\n\n# 101 对称二叉树\n\n判断一个二叉树是否对称。\n\n输入一个二叉树，输出一个布尔值，表示该树是否对称。\n\n>       1\n>      / \\\n>     2   2\n>  / \\ / \\\n> 3  4 4  3\n> \n> \n> 二叉树 [1,2,2,3,4,4,3] 是对称的\n\n解析：\n\n本题可以将二叉树是否对称转化为其左右子树是否对称，本质上还是树的递归问题，但是递归过程中涉及到比较。对两个子树进行比较判断是否相等或对称的解法一般可以按照如下四步：\n\n * 如果两个子树都为空指针，则它们相等或对称，从根节点递归到叶子节点时都是相等的\n * 如果两个子树只有一个为空指针，则它们不相等或不对称，一棵子树却胳膊少腿肯定不相等\n * 如果两个子树根节点的值不相等，则它们不相等或不对称，出现比较位置不同值直接返回false\n * 根据相等或对称要求，进行递归处理；相等就是左子树的左节点和右子树的左节点比较，左子树的右节点和右子树的右节点比较；对称就是左子树的左节点和右子树的右节点比较，左子树的右节点和右子树的左节点比较\n\n需要注意的是前三个判断步骤不能调换顺序，因为有一个为空范围大于均为空，如果有空就无法取值。\n\nclass solution {\npublic:\n    bool issymmetric(treenode* left, treenode* right){\n        if(!left && !right){\n            return true;\n        }else if(!left || !right){\n            return false;\n        }else if(left->val != right->val){\n            return false;\n        }\n        return issymmetric(left->left,right->right) && issymmetric(left->right,right->left);\n    }\n\n    bool issymmetric(treenode* root) {\n        if(!root){\n            return true;\n        }\n        return issymmetric(root->left,root->right);\n    }\n};\n\n\n# 572 另一棵树的子树\n\n给定两棵二叉树 root 和 subroot 。检验 root 中是否包含和 subroot 具有相同结构和节点值的子树\n\n输入两棵二叉树，输出一个布尔值表示 root 树中是否包含 subroot 树\n\n> 输入：root = [3,4,5,1,2], subroot = [4,1,2]\n> \ttree root                  tree subroot               \n>           3                         4                             \n>          / \\                       / \\                            \n>         4   5                     1   2                        \n>        / \\                                                   \n>       1   2                                \n> 输出：true\n\n解析：\n\n本题是101 对称二叉树的变种题，解题分为两个步骤，第一步遍历 root 树找和 subroot 相同的根节点，第二步判断 root 中子树是否和 subroot 相同。\n\n判断两颗二叉树是否相同和判断二叉树是否对称思路一致，递归对比参与比较的两个节点值，最终递归将节点全部顺利比较完成则两颗二叉树相同，否在有一棵树先被遍历完成或者出现节点值不相同的情况，那么这两颗树也不相同。\n\n遍历二叉树寻找相同子树的过程就是递归遍历每一颗子树，遍历过程中不断与 subroot 进行比较得出结果。\n\npublic:\n    bool issametree(treenode* root, treenode* subroot){\n        if(!root && !subroot){\n            return true;\n        }else if(!root || !subroot){\n            return false;\n        }else if(root->val!=subroot->val){\n            return false;\n        }\n        return issametree(root->left,subroot->left) && issametree(root->right,subroot->right);\n    }\n\n    bool issubtree(treenode* root, treenode* subroot) {\n        if(!subroot){\n            return true;\n        }else if(!root){\n            return false;\n        }\n        return issametree(root,subroot) || issubtree(root->left,subroot) || issubtree(root->right,subroot);\n    }\n};\n\n\n# 404 左叶子之和\n\n给定一个二叉树，计算该树的所有左叶子之和\n\n输入一颗二叉树，输出一个整数表示所有左叶子之和\n\n> 输入：\n>     3\n>    / \\\n>   9  20\n>     /  \\\n>    15   7\n> 输出：24\n> 解释：在这个二叉树中，有两个左叶子，分别是 9 和 15，所以返回 24\n\n解析：\n\n本题的关键就在于利用左叶子节点的定义进行有条件递归遍历二叉树，同时要判断一个节点是不是叶子节点，定义一个辅助函数如果该节点没有子节点则说明该节点是叶子节点。\n\n如果一个节点是左叶子节点，那么它是某个节点的左子节点，并且它还是一个叶子结点。\n\n根据此定义，在递归遍历过程中，如果一个节点有左子节点，且该节点是一个叶子节点，那么将该左子节点加到累和中；假若该左子节点不是叶子节点，则以该左子节点为根节点递归查找左叶子节点。\n\n如果一个节点有右子节点，且该节点是一个叶子节点，不进行累和且终止往下递归；假若该右子节点不是叶子节点，则将该右子节点为根节点递归查找左叶子节点。\n\nclass solution {\npublic:\n    bool isleafnode(treenode* root){\n        return  !root->left && !root->right;\n    }\n\n    int sumofleftleaves(treenode* root) {\n        if(!root){\n            return 0;\n        }\n        int ans = 0;\n        if(root->left){\n            ans += isleafnode(root->left)?root->left->val:sumofleftleaves(root->left);\n        }\n        if(root->right){\n            ans += isleafnode(root->right)?0:sumofleftleaves(root->right);\n        }\n        return ans;\n    }\n};\n\n\n# 437 路径总和 iii\n\n给定一个整数二叉树，求有多少条路径节点值的和等于给定值。\n\n输入一个二叉树和一个给定整数，输出一个整数，表示有多少条满足条件的路径。\n\n> 输入：root = [10,5,-3,3,2,null,11,3,-2,null,1], targetsum = 8\n> 输出：3\n\n解析：\n\n本题的关键在于计算路径和，所以在递归每个节点时，需要分情况考虑：\n\n * 如果选取该节点加入路径，则之后必须继续加入连续节点，或停止加入节点\n * 如果不选取该节点加入路径，则对其左右节点进行重新进行考虑\n\n因此一个方便的方法是创建一个辅函数，专门用来计算连续加入节点的路径。该辅助函数就是通过用给定值递归减去路径节点值，最终给定值减为0表示构成一条路径。\n\nclass solution {\npublic:\n    int pathwithroot(treenode* root, int sum){\n        if(!root){\n            return 0;\n        }\n        int count = 0;\n        // 如果当前节点值与路径和一致则形成一条路径\n        if(root->val == sum){\n            count = 1;\n        }else{\n            count = 0;\n        }\n        // 往左右子节点继续寻找路径\n        count += pathwithroot(root->left, sum-root->val);\n        count += pathwithroot(root->right, sum-root->val);\n        return count;\n    }\n\n    int pathsum(treenode* root, int targetsum) {\n        if(!root){\n            return 0;\n        }\n        // 将当前节点加入路径\n        int ans = 0;\n        ans = pathwithroot(root,targetsum);\n        // 不将当前节点加入路径，从左右子节点开始寻找新路径\n        ans += pathsum(root->left,targetsum);\n        ans += pathsum(root->right,targetsum);\n        return ans;\n    }\n};\n",charsets:{cjk:!0},lastUpdated:"2023/11/19, 12:55:48",lastUpdatedTimestamp:1700369748e3},{title:"02二叉树的操作",frontmatter:{title:"02二叉树的操作",date:"2023-03-24T18:39:49.000Z",permalink:"/pages/f97107/"},regularPath:"/03.LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/02.%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/04.%E4%BA%8C%E5%8F%89%E6%A0%91/02.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%93%8D%E4%BD%9C.html",relativePath:"03.LeetCode刷题笔记/02.基础数据结构/04.二叉树/02.二叉树的操作.md",key:"v-321f68a4",path:"/pages/f97107/",headers:[{level:2,title:"02 二叉树的操作",slug:"_02-二叉树的操作",normalizedTitle:"02 二叉树的操作",charIndex:2},{level:4,title:"226 翻转二叉树",slug:"_226-翻转二叉树",normalizedTitle:"226 翻转二叉树",charIndex:15},{level:4,title:"617 合并二叉树",slug:"_617-合并二叉树",normalizedTitle:"617 合并二叉树",charIndex:662},{level:4,title:"1110 删点成林",slug:"_1110-删点成林",normalizedTitle:"1110 删点成林",charIndex:1767}],headersStr:"02 二叉树的操作 226 翻转二叉树 617 合并二叉树 1110 删点成林",content:"# 02 二叉树的操作\n\n# 226 翻转二叉树\n\n翻转一棵二叉树\n\n输入一棵二叉树，输出一棵左右子树的位置跟输入正好相反的二叉树\n\n> 输入：\n> \n>      4\n>    /   \\\n>   2     7\n>  / \\   / \\\n> 1   3 6   9\n\n> 输出：\n> \n>        4\n>    /   \\\n>  7     2\n> / \\   / \\\n> 9   6 3   1\n\n解析：\n\n本题是一道经典的递归问题，我们采用自下而上的递归策略，从叶子节点开始交换左右节点。如果当前根节点 root 的左右子树都已经完成了翻转，那么仅需要交换两个子树的位置即可，即交换 root 左右节点的指向，就可以完成整颗子树的翻转。递归的终止条件：当前节点为 null 时返回。\n\nclass Solution {\npublic:\n    TreeNode* invertTree(TreeNode* root) {\n        if(!root){\n            return root;\n        }\n        TreeNode* left = invertTree(root->left);\n        TreeNode* right = invertTree(root->right);\n        root->left = right;\n        root->right = left;\n        return root;\n    }\n};\n\n\n# 617 合并二叉树\n\n给定两个二叉树，将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。\n\n输入两个二叉树，输出一个合并后的新二叉树\n\n> 输入:\n> \n> \tTree 1                     Tree 2                  \n>     1                         2                             \n>    / \\                       / \\                            \n>   3   2                     1   3                        \n>  /                           \\   \\                      \n> 5                             4   7          \n> \n> \n> 输出: 合并后的树\n> \n> \t     3\n> \t    / \\\n> \t   4   5\n> \t  / \\   \\ \n> \t 5   4   7\n\n解析：\n\n本题可以采用自上而下的递归策略，将Tree2的当前根节点 root2 的值合并到Tree1的当前根节点 root1 上，然后递归合并roo1和roo2根节点的左节点，递归合并roo1和roo2根节点的右节点，最终只保存 Tree1作为合并后的新二叉树。\n\n递归的终止条件是当前根节点roo1和roo2有至少一个为空，直接返回非空节点作为新二叉树的节点，均为空则返回空节点。\n\nclass Solution {\npublic:\n    TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) {\n        if(!root1 || !root2){\n            return root1?root1:root2;\n        }\n        root1->val += root2->val;\n        root1->left = mergeTrees(root1->left,root2->left);\n        root1->right = mergeTrees(root1->right,root2->right);\n        return root1;\n    }\n};\n\n\n# 1110 删点成林\n\n给定一个整数二叉树和一些整数，求删掉这些整数对应的节点后，剩余的子树。\n\n输入是一个整数二叉树和一个一维整数数组，输出一个数组，每个位置存储一个子树（的根节点）。\n\n> 输入：root = [1,2,3,4,5,6,7], to_delete = [3,5]\n> 输出：[[1,2,null,4],[6],[7]\n\n解析：\n\n本题核心递归逻辑就是当前节点是否要被删除，如果删除就将其左右子数加入结果集，不删除就直接返回该节点。\n\n使用一个节点数组存储结果集，使用哈希表存储删除节点，便于检验当前节点是否要被删除。\n\n递归过程中自底向上：将递归调用写在处理过程之前实现自底向上的处理\n\n从下层节点开始判断是否要被删除：\n\n * 如果删除就将其左右子数加入结果集，并将指向该节点的指针置为空\n * 不删除就直接返回该节点\n\n最终如果原树的根节点没有被删除将其加入森林\n\nclass Solution {\npublic:\n    vector<TreeNode*> delNodes(TreeNode* root, vector<int>& to_delete) {\n        // 使用一个节点数组存储所有可能的根节点\n        vector<TreeNode*> forest;\n        // 使用哈希表存储删除节点，便于查找检验\n        unordered_set<int> hash(to_delete.begin(),to_delete.end());\n        // 递归处理原树，删点成林\n        root = helper(root,hash,forest);\n        // 如果原树的根节点没有被删除将其加入森林\n        if(root){\n            forest.push_back(root);\n        }\n        return forest;\n    }\n    \n    TreeNode* helper(TreeNode* root, unordered_set<int>& hash, vector<TreeNode*>& forest){\n        if(!root){\n            return root;\n        }\n        // 递归处理左右子树\n        root->left = helper(root->left, hash, forest);\n        root->right = helper(root->right, hash, forest);\n        // 如果当前根节点要被删除，则将其左右子树加入森林\n        if(hash.find(root->val)!=hash.end()){\n            if(root->left){\n                forest.push_back(root->left);\n            }\n            if(root->right){\n                forest.push_back(root->right);\n            }\n            // 删除根节点\n            root = NULL;\n        }\n        // 当前根节点不用删除，这直接返回该节点\n        return root;\n    }\n};\n",normalizedContent:"# 02 二叉树的操作\n\n# 226 翻转二叉树\n\n翻转一棵二叉树\n\n输入一棵二叉树，输出一棵左右子树的位置跟输入正好相反的二叉树\n\n> 输入：\n> \n>      4\n>    /   \\\n>   2     7\n>  / \\   / \\\n> 1   3 6   9\n\n> 输出：\n> \n>        4\n>    /   \\\n>  7     2\n> / \\   / \\\n> 9   6 3   1\n\n解析：\n\n本题是一道经典的递归问题，我们采用自下而上的递归策略，从叶子节点开始交换左右节点。如果当前根节点 root 的左右子树都已经完成了翻转，那么仅需要交换两个子树的位置即可，即交换 root 左右节点的指向，就可以完成整颗子树的翻转。递归的终止条件：当前节点为 null 时返回。\n\nclass solution {\npublic:\n    treenode* inverttree(treenode* root) {\n        if(!root){\n            return root;\n        }\n        treenode* left = inverttree(root->left);\n        treenode* right = inverttree(root->right);\n        root->left = right;\n        root->right = left;\n        return root;\n    }\n};\n\n\n# 617 合并二叉树\n\n给定两个二叉树，将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 null 的节点将直接作为新二叉树的节点。\n\n输入两个二叉树，输出一个合并后的新二叉树\n\n> 输入:\n> \n> \ttree 1                     tree 2                  \n>     1                         2                             \n>    / \\                       / \\                            \n>   3   2                     1   3                        \n>  /                           \\   \\                      \n> 5                             4   7          \n> \n> \n> 输出: 合并后的树\n> \n> \t     3\n> \t    / \\\n> \t   4   5\n> \t  / \\   \\ \n> \t 5   4   7\n\n解析：\n\n本题可以采用自上而下的递归策略，将tree2的当前根节点 root2 的值合并到tree1的当前根节点 root1 上，然后递归合并roo1和roo2根节点的左节点，递归合并roo1和roo2根节点的右节点，最终只保存 tree1作为合并后的新二叉树。\n\n递归的终止条件是当前根节点roo1和roo2有至少一个为空，直接返回非空节点作为新二叉树的节点，均为空则返回空节点。\n\nclass solution {\npublic:\n    treenode* mergetrees(treenode* root1, treenode* root2) {\n        if(!root1 || !root2){\n            return root1?root1:root2;\n        }\n        root1->val += root2->val;\n        root1->left = mergetrees(root1->left,root2->left);\n        root1->right = mergetrees(root1->right,root2->right);\n        return root1;\n    }\n};\n\n\n# 1110 删点成林\n\n给定一个整数二叉树和一些整数，求删掉这些整数对应的节点后，剩余的子树。\n\n输入是一个整数二叉树和一个一维整数数组，输出一个数组，每个位置存储一个子树（的根节点）。\n\n> 输入：root = [1,2,3,4,5,6,7], to_delete = [3,5]\n> 输出：[[1,2,null,4],[6],[7]\n\n解析：\n\n本题核心递归逻辑就是当前节点是否要被删除，如果删除就将其左右子数加入结果集，不删除就直接返回该节点。\n\n使用一个节点数组存储结果集，使用哈希表存储删除节点，便于检验当前节点是否要被删除。\n\n递归过程中自底向上：将递归调用写在处理过程之前实现自底向上的处理\n\n从下层节点开始判断是否要被删除：\n\n * 如果删除就将其左右子数加入结果集，并将指向该节点的指针置为空\n * 不删除就直接返回该节点\n\n最终如果原树的根节点没有被删除将其加入森林\n\nclass solution {\npublic:\n    vector<treenode*> delnodes(treenode* root, vector<int>& to_delete) {\n        // 使用一个节点数组存储所有可能的根节点\n        vector<treenode*> forest;\n        // 使用哈希表存储删除节点，便于查找检验\n        unordered_set<int> hash(to_delete.begin(),to_delete.end());\n        // 递归处理原树，删点成林\n        root = helper(root,hash,forest);\n        // 如果原树的根节点没有被删除将其加入森林\n        if(root){\n            forest.push_back(root);\n        }\n        return forest;\n    }\n    \n    treenode* helper(treenode* root, unordered_set<int>& hash, vector<treenode*>& forest){\n        if(!root){\n            return root;\n        }\n        // 递归处理左右子树\n        root->left = helper(root->left, hash, forest);\n        root->right = helper(root->right, hash, forest);\n        // 如果当前根节点要被删除，则将其左右子树加入森林\n        if(hash.find(root->val)!=hash.end()){\n            if(root->left){\n                forest.push_back(root->left);\n            }\n            if(root->right){\n                forest.push_back(root->right);\n            }\n            // 删除根节点\n            root = null;\n        }\n        // 当前根节点不用删除，这直接返回该节点\n        return root;\n    }\n};\n",charsets:{cjk:!0},lastUpdated:"2023/11/19, 12:55:48",lastUpdatedTimestamp:1700369748e3},{title:"03层次遍历",frontmatter:{title:"03层次遍历",date:"2023-03-24T18:39:50.000Z",permalink:"/pages/22355f/"},regularPath:"/03.LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/02.%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/04.%E4%BA%8C%E5%8F%89%E6%A0%91/03.%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86.html",relativePath:"03.LeetCode刷题笔记/02.基础数据结构/04.二叉树/03.层次遍历.md",key:"v-72db9d7e",path:"/pages/22355f/",headers:[{level:2,title:"02 层次遍历",slug:"_02-层次遍历",normalizedTitle:"02 层次遍历",charIndex:2},{level:4,title:"102 二叉树的层序遍历",slug:"_102-二叉树的层序遍历",normalizedTitle:"102 二叉树的层序遍历",charIndex:127},{level:4,title:"637 二叉树的层平均值",slug:"_637-二叉树的层平均值",normalizedTitle:"637 二叉树的层平均值",charIndex:1231},{level:4,title:"513 找树左下角的值",slug:"_513-找树左下角的值",normalizedTitle:"513 找树左下角的值",charIndex:2262},{level:4,title:"662 二叉树最大宽度",slug:"_662-二叉树最大宽度",normalizedTitle:"662 二叉树最大宽度",charIndex:3146}],headersStr:"02 层次遍历 102 二叉树的层序遍历 637 二叉树的层平均值 513 找树左下角的值 662 二叉树最大宽度",content:"# 02 层次遍历\n\n通常使用广度优先搜索进行层次遍历。注意，不需要使用两个队列来分别存储当前层的节点和下一层的节点，因为在开始遍历一层的节点时，当前队列中的节点数就是当前层的节点数，只要控制遍历这么多节点数，就能保证这次遍历的都是当前层的节点。\n\n# 102 二叉树的层序遍历\n\n实现二叉树的层序遍历\n\n输入一个二叉树，输出一个二维数组，表示二叉树层序遍历的结果\n\n> 输入：[3,9,20,null,null,15,7]\n> \n>     3\n>    / \\\n>   9  20\n>     /  \\\n>    15   7\n> \n> \n> 输出：\n> \n> [\n>   [3],\n>   [9,20],\n>   [15,7]\n> ]\n\n解析：\n\n通常使用广度优先搜索进行层次遍历，使用一个队列存储当前层的所有节点。\n\n在开始遍历一层的节点时，当前队列中的节点数就是当前层的节点数。\n\n只要控制遍历这么多节点数，每遍历一个当前层的节点，将其出队列同时将其子节点入队列。\n\n通过这种操作就能保证每次遍历的队列中都是当前层的节点。\n\nclass Solution {\npublic:\n    vector<vector<int>> levelOrder(TreeNode* root) {\n        vector<vector<int>> res;\n        if(root==nullptr){\n            return res;\n        }\n        queue<TreeNode*> que;\n        que.push(root);\n        while(!que.empty()){\n            int queLen = que.size();\n            vector<int> levelElem;\n            for(int i=0;i<queLen;++i){\n                auto node = que.front();\n                que.pop();\n                levelElem.push_back(node->val);\n                if(node->left){\n                    que.push(node->left);\n                }\n                if(node->right){\n                    que.push(node->right);\n                }\n            }\n            res.push_back(levelElem);\n        }\n        return res;\n    }\n};\n\n\n# 637 二叉树的层平均值\n\n给定一个二叉树，求每一层的节点值的平均数。\n\n输入是一个二叉树，输出是一个一维数组，表示每层节点值的平均数。\n\n> 输入：\n> \n>  3\n> / \\\n> 9  20\n>  /  \\\n> 15   7\n> \n> \n> 输出：[3, 14.5, 11] 解释：第 0 层的平均值是 3 , 第1层是 14.5 , 第2层是 11 。因此返回 [3, 14.5, 11] 。\n\n解析：\n\n使用一个先入先出的队列对二叉树进行层次遍历，遍历每一层的过程中累计该层的总和并在最后将平均值加入结果集。\n\n使用双层循环完成每层均值计算：外循环逐层遍历二叉树；内循环遍历队列中当前层的所有节点，计算当前层节点值均值，并将下一层节点压入队列。\n\nclass Solution {\npublic:\n    vector<double> averageOfLevels(TreeNode* root) {\n        vector<double> ans;\n        if(!root){\n            return ans;\n        }\n        queue<TreeNode*> q;\n        q.push(root);\n        while(!q.empty()){\n            int len = q.size();\n            double sum = 0;\n            for(int i=0;i<len;++i){\n                auto node = q.front();\n                q.pop();\n                sum+=node->val;\n                if(node->left){\n                    q.push(node->left);\n                }\n                if(node->right){\n                    q.push(node->right);\n                }\n            }\n            ans.push_back(sum/len);\n        }\n        return ans;\n    }\n};\n\n\n# 513 找树左下角的值\n\n给定一个二叉树，找出该二叉树的 最底层 最左边 节点的值\n\n输入一个二叉树，输出一个整型值表示该二叉树左下角的值\n\n> 输入: root = [2,1,3]\n> 输出: 1\n\n解析：\n\n本题很容易想到使用层次遍历解决，因为二叉树的 最底层 最左边 节点的值就是层次遍历最后一层的第一个节点值。\n\n所以，本题仅需要得到二叉树的层次遍历结果，然后将最后一层的第一个值返回即可。\n\nclass Solution {\npublic:\n    int findBottomLeftValue(TreeNode* root) {\n        int ans = 0;\n        if(!root){\n            return ans;\n        }\n        queue<TreeNode*> q;\n        q.push(root);\n        while(!q.empty()){\n            int queLen = q.size(); // 要记录最初的队列长度，不然在后续push和pop操作中会影响该值\n            ans = q.front()->val; // 记录当前层的第一个值\n            for(int i=0;i<queLen;++i){\n                auto node = q.front();\n                q.pop();\n                if(node->left){\n                    q.push(node->left);\n                }\n                if(node->right){\n                    q.push(node->right);\n                }\n            }\n        }\n        return ans;\n    }\n};\n\n\n# 662 二叉树最大宽度\n\n给定一个二叉树，编写一个函数来获取这个树的最大宽度。树的宽度是所有层中的最大宽度。这个二叉树与满二叉树（full binary tree）结构相同，但一些节点为空。\n\n每一层的宽度被定义为两个端点（该层最左和最右的非空节点，两端点间的null节点也计入长度）之间的长度。\n\n示例:\n\n输入: \n\n           1\n         /   \\\n        3     2\n       / \\     \\  \n      5   3     9 \n\n输出: 4\n解释: 最大值出现在树的第 3 层，宽度为 4 (5,3,null,9)。\n\n\n解析：\n\n 1. 宽度优先会使用一个queue，而这个queue就可以帮助我们计算出目前层的宽度\n 2. 数值转换(关键一步，减少内存，加速计算)：为了计算宽度，我们需要记录每个节点出现的编号， 比如[1,3,2] 这样的二叉树，对应 1->0 3->0 2->1\n 3. 下一层，基于当前层的编号推出下一层：\n    * left: parent->val * 2\n    * right: parent->val * 2 +1\n 4. 当前层的宽度： back-val - front->val + 1\n    * 如 front->0 back=4, 那么宽度就是5\n 5. 额外，为了避免数字过大，我们会让val每次基于queue front编号做缩小\n    * queue front的编号是100\n    * front缩小为 100-100=0， 后续每个编号都需要减去100\n\nclass Solution {\npublic:\n    int widthOfBinaryTree(TreeNode* root) {\n        if(!root){\n            return 0;\n        }\n        queue<pair<TreeNode*,long long>> q; //pair的第二个位置记录当前是第几个节点\n        q.push(make_pair(root,1));\n        int ans = 0;\n        while(!q.empty()){\n            //start是本层起点, index是本层当前遍历到的节点的索引\n            int len = q.size();\n            long long start = q.front().second;\n            long long index;\n            for(int i=0;i<len;++i){\n                auto node = q.front().first;\n                index = q.front().second;\n                q.pop();\n                if(node->left){\n                    // -start*2 防止索引位置太大溢出\n                    q.push(make_pair(node->left,index*2-start*2));\n                }\n                if(node->right){\n                    q.push(make_pair(node->right,index*2+1-start*2));\n                }\n            }\n            int wid = index-start+1;\n            ans = max(ans,wid);\n        }\n        return ans;\n    }\n};\n",normalizedContent:"# 02 层次遍历\n\n通常使用广度优先搜索进行层次遍历。注意，不需要使用两个队列来分别存储当前层的节点和下一层的节点，因为在开始遍历一层的节点时，当前队列中的节点数就是当前层的节点数，只要控制遍历这么多节点数，就能保证这次遍历的都是当前层的节点。\n\n# 102 二叉树的层序遍历\n\n实现二叉树的层序遍历\n\n输入一个二叉树，输出一个二维数组，表示二叉树层序遍历的结果\n\n> 输入：[3,9,20,null,null,15,7]\n> \n>     3\n>    / \\\n>   9  20\n>     /  \\\n>    15   7\n> \n> \n> 输出：\n> \n> [\n>   [3],\n>   [9,20],\n>   [15,7]\n> ]\n\n解析：\n\n通常使用广度优先搜索进行层次遍历，使用一个队列存储当前层的所有节点。\n\n在开始遍历一层的节点时，当前队列中的节点数就是当前层的节点数。\n\n只要控制遍历这么多节点数，每遍历一个当前层的节点，将其出队列同时将其子节点入队列。\n\n通过这种操作就能保证每次遍历的队列中都是当前层的节点。\n\nclass solution {\npublic:\n    vector<vector<int>> levelorder(treenode* root) {\n        vector<vector<int>> res;\n        if(root==nullptr){\n            return res;\n        }\n        queue<treenode*> que;\n        que.push(root);\n        while(!que.empty()){\n            int quelen = que.size();\n            vector<int> levelelem;\n            for(int i=0;i<quelen;++i){\n                auto node = que.front();\n                que.pop();\n                levelelem.push_back(node->val);\n                if(node->left){\n                    que.push(node->left);\n                }\n                if(node->right){\n                    que.push(node->right);\n                }\n            }\n            res.push_back(levelelem);\n        }\n        return res;\n    }\n};\n\n\n# 637 二叉树的层平均值\n\n给定一个二叉树，求每一层的节点值的平均数。\n\n输入是一个二叉树，输出是一个一维数组，表示每层节点值的平均数。\n\n> 输入：\n> \n>  3\n> / \\\n> 9  20\n>  /  \\\n> 15   7\n> \n> \n> 输出：[3, 14.5, 11] 解释：第 0 层的平均值是 3 , 第1层是 14.5 , 第2层是 11 。因此返回 [3, 14.5, 11] 。\n\n解析：\n\n使用一个先入先出的队列对二叉树进行层次遍历，遍历每一层的过程中累计该层的总和并在最后将平均值加入结果集。\n\n使用双层循环完成每层均值计算：外循环逐层遍历二叉树；内循环遍历队列中当前层的所有节点，计算当前层节点值均值，并将下一层节点压入队列。\n\nclass solution {\npublic:\n    vector<double> averageoflevels(treenode* root) {\n        vector<double> ans;\n        if(!root){\n            return ans;\n        }\n        queue<treenode*> q;\n        q.push(root);\n        while(!q.empty()){\n            int len = q.size();\n            double sum = 0;\n            for(int i=0;i<len;++i){\n                auto node = q.front();\n                q.pop();\n                sum+=node->val;\n                if(node->left){\n                    q.push(node->left);\n                }\n                if(node->right){\n                    q.push(node->right);\n                }\n            }\n            ans.push_back(sum/len);\n        }\n        return ans;\n    }\n};\n\n\n# 513 找树左下角的值\n\n给定一个二叉树，找出该二叉树的 最底层 最左边 节点的值\n\n输入一个二叉树，输出一个整型值表示该二叉树左下角的值\n\n> 输入: root = [2,1,3]\n> 输出: 1\n\n解析：\n\n本题很容易想到使用层次遍历解决，因为二叉树的 最底层 最左边 节点的值就是层次遍历最后一层的第一个节点值。\n\n所以，本题仅需要得到二叉树的层次遍历结果，然后将最后一层的第一个值返回即可。\n\nclass solution {\npublic:\n    int findbottomleftvalue(treenode* root) {\n        int ans = 0;\n        if(!root){\n            return ans;\n        }\n        queue<treenode*> q;\n        q.push(root);\n        while(!q.empty()){\n            int quelen = q.size(); // 要记录最初的队列长度，不然在后续push和pop操作中会影响该值\n            ans = q.front()->val; // 记录当前层的第一个值\n            for(int i=0;i<quelen;++i){\n                auto node = q.front();\n                q.pop();\n                if(node->left){\n                    q.push(node->left);\n                }\n                if(node->right){\n                    q.push(node->right);\n                }\n            }\n        }\n        return ans;\n    }\n};\n\n\n# 662 二叉树最大宽度\n\n给定一个二叉树，编写一个函数来获取这个树的最大宽度。树的宽度是所有层中的最大宽度。这个二叉树与满二叉树（full binary tree）结构相同，但一些节点为空。\n\n每一层的宽度被定义为两个端点（该层最左和最右的非空节点，两端点间的null节点也计入长度）之间的长度。\n\n示例:\n\n输入: \n\n           1\n         /   \\\n        3     2\n       / \\     \\  \n      5   3     9 \n\n输出: 4\n解释: 最大值出现在树的第 3 层，宽度为 4 (5,3,null,9)。\n\n\n解析：\n\n 1. 宽度优先会使用一个queue，而这个queue就可以帮助我们计算出目前层的宽度\n 2. 数值转换(关键一步，减少内存，加速计算)：为了计算宽度，我们需要记录每个节点出现的编号， 比如[1,3,2] 这样的二叉树，对应 1->0 3->0 2->1\n 3. 下一层，基于当前层的编号推出下一层：\n    * left: parent->val * 2\n    * right: parent->val * 2 +1\n 4. 当前层的宽度： back-val - front->val + 1\n    * 如 front->0 back=4, 那么宽度就是5\n 5. 额外，为了避免数字过大，我们会让val每次基于queue front编号做缩小\n    * queue front的编号是100\n    * front缩小为 100-100=0， 后续每个编号都需要减去100\n\nclass solution {\npublic:\n    int widthofbinarytree(treenode* root) {\n        if(!root){\n            return 0;\n        }\n        queue<pair<treenode*,long long>> q; //pair的第二个位置记录当前是第几个节点\n        q.push(make_pair(root,1));\n        int ans = 0;\n        while(!q.empty()){\n            //start是本层起点, index是本层当前遍历到的节点的索引\n            int len = q.size();\n            long long start = q.front().second;\n            long long index;\n            for(int i=0;i<len;++i){\n                auto node = q.front().first;\n                index = q.front().second;\n                q.pop();\n                if(node->left){\n                    // -start*2 防止索引位置太大溢出\n                    q.push(make_pair(node->left,index*2-start*2));\n                }\n                if(node->right){\n                    q.push(make_pair(node->right,index*2+1-start*2));\n                }\n            }\n            int wid = index-start+1;\n            ans = max(ans,wid);\n        }\n        return ans;\n    }\n};\n",charsets:{cjk:!0},lastUpdated:"2023/11/19, 12:55:48",lastUpdatedTimestamp:1700369748e3},{title:"05二叉搜索树的属性",frontmatter:{title:"05二叉搜索树的属性",date:"2023-03-24T18:39:50.000Z",permalink:"/pages/b9029c/"},regularPath:"/03.LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/02.%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/04.%E4%BA%8C%E5%8F%89%E6%A0%91/05.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%B1%9E%E6%80%A7.html",relativePath:"03.LeetCode刷题笔记/02.基础数据结构/04.二叉树/05.二叉搜索树的属性.md",key:"v-2ccb02d9",path:"/pages/b9029c/",headers:[{level:2,title:"05 二叉搜索树的属性",slug:"_05-二叉搜索树的属性",normalizedTitle:"05 二叉搜索树的属性",charIndex:2},{level:4,title:"538 把二叉搜索树转换为累加树",slug:"_538-把二叉搜索树转换为累加树",normalizedTitle:"538 把二叉搜索树转换为累加树",charIndex:2171},{level:4,title:"235 二叉搜索树的最近公共祖先",slug:"_235-二叉搜索树的最近公共祖先",normalizedTitle:"235 二叉搜索树的最近公共祖先",charIndex:3088},{level:4,title:"236 二叉树的最近公共祖先",slug:"_236-二叉树的最近公共祖先",normalizedTitle:"236 二叉树的最近公共祖先",charIndex:3994},{level:4,title:"530 二叉搜索树的最小绝对差",slug:"_530-二叉搜索树的最小绝对差",normalizedTitle:"530 二叉搜索树的最小绝对差",charIndex:5035},{level:4,title:"897 递增顺序搜索树",slug:"_897-递增顺序搜索树",normalizedTitle:"897 递增顺序搜索树",charIndex:6770},{level:4,title:"653. 两数之和 IV - 输入 BST",slug:"_653-两数之和-iv-输入-bst",normalizedTitle:"653. 两数之和 iv - 输入 bst",charIndex:7946}],headersStr:"05 二叉搜索树的属性 538 把二叉搜索树转换为累加树 235 二叉搜索树的最近公共祖先 236 二叉树的最近公共祖先 530 二叉搜索树的最小绝对差 897 递增顺序搜索树 653. 两数之和 IV - 输入 BST",content:"# 05 二叉搜索树的属性\n\n二叉查找树 / 二叉搜索树（Binary Search Tree, BST）是一种特殊的二叉树：对于每个父节点，其左子节点的值小于等于父结点的值，其右子节点的值大于等于父结点的值。因此对于一个二叉查找树，我们可以在 O(nlogn) 的时间内查找一个值是否存在：从根节点开始，若当前节点的值大于查找值则向左下走，若当前节点的值小于查找值则向右下走。同时因为二叉查找树是有序的，对其中序遍历的结果即为排好序的数组。 一个二叉查找树的实现如下：\n\ntemplate <class T>\nclass BST {\n    struct Node {\n        T data;\n        Node* left;\n        Node* right;\n    };\n    \n    Node* root;\n    \n    Node* makeEmpty(Node* t) {\n        if (t == NULL) return NULL;\n        makeEmpty(t->left);\n        makeEmpty(t->right);\n        delete t;\n        return NULL;\n    }\n    \n    Node* insert(Node* t, T x) {\n        if (t == NULL) {\n            t = new Node;\n            t->data = x;\n            t->left = t->right = NULL;\n        } else if (x < t->data) {\n            t->left = insert(t->left, x);\n        } else if (x > t->data) {\n            t->right = insert(t->right, x);\n        }\n        return t;\n    }\n    \n    Node* find(Node* t, T x) {\n        if (t == NULL) return NULL;\n        if (x < t->data) return find(t->left, x);\n        if (x > t->data) return find(t->right, x);\n        return t;\n    }\n    \n    Node* findMin(Node* t) {\n        if (t == NULL || t->left == NULL) return t;\n        return findMin(t->left);\n    }\n    \n    Node* findMax(Node* t) {\n        if (t == NULL || t->right == NULL) return t;\n        return findMax(t->right);\n\t}\n    \n    Node* remove(Node* t, T x) {\n        ode* temp;\n        if (t == NULL) return NULL;\n        else if (x < t->data) t->left = remove(t->left, x);\n        else if (x > t->data) t->right = remove(t->right, x);\n        else if (t->left && t->right) {\n            temp = findMin(t->right);\n            t->data = temp->data;\n            t->right = remove(t->right, t->data);\n        } else {\n            temp = t;\n            if (t->left == NULL) t = t->right;\n            else if (t->right == NULL) t = t->left;\n            delete temp;\n        }\n        return t;\n    }\n\npublic:\n    BST(): root(NULL) {}\n    ~BST() {\n        root = makeEmpty(root);\n    }\n    void insert(T x) {\n    \tinsert(root, x);\n    }\n    void remove(T x) {\n    \tremove(root, x);\n    }\n};  \n\n\n二叉搜索树的特点是节点左子树都小于节点值，节点右子树都大于节点值。所以，二叉搜索树的中序遍历序列就是一个递增序列，这一属性被广泛使用。\n\n# 538 把二叉搜索树转换为累加树\n\n给出一个二叉搜索树，该树的节点值各不相同，请将其转换为累加树（Greater Sum Tree），使每个节点 node 的新值等于原树中大于或等于 node.val 的值之和。\n\n输入一个二叉搜索树，输出一个累加树\n\n> 输入：root = [3,2,4,1]\n> 输出：[7,9,4,10]\n\n解析：\n\n本题可以采用返序的中序遍历解决，中序遍历先遍历左节点、再遍历根节点、最后遍历右节点。\n\n而二叉搜索树的特点是节点左子树都小于节点值，节点右子树都大于节点值；累加树又是累加的是大于等于当前节点值的节点；所以只要从二叉搜索树最底层，最右侧开始遍历，就可以自下而上累加节点值。\n\n即当前节点值为其右子数最大累和加上自身节点值，而最大累和在右子树存在左子树的情况下出现在该左子数最底层最左侧节点累加值。\n\n根据累加树的节点值累加顺序：先右节点累和，然后根节点基于右节点值进行累和，最后左节点根据根节点值进行累和。所以本题采用返序中序遍历，先遍历右节点、再遍历根节点、最后遍历左节点；同时需要一个累和全局变量存储遍历当前节点时已经被遍历节点值之和。\n\n简而言之，按从大到小的顺序遍历二叉搜索树，每遍历一个节点，加上自身节点值来更新累和值，并将累和值作为其新值。\n\nclass Solution {\n    // 存储遍历当前节点时已经被遍历节点值之和\n    int sum = 0;\npublic:\n    TreeNode* convertBST(TreeNode* root) {\n        if(!root){\n            return root;\n        }\n        // 先遍历右节点\n        convertBST(root->right);\n        // 在遍历根节点\n        sum+=root->val;\n        root->val = sum;\n        // 最后遍历左节点\n        convertBST(root->left);\n        return root;\n    }\n};\n\n\n# 235 二叉搜索树的最近公共祖先\n\n给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先\n\n输入一个二叉搜索树，输出一个节点表示两个指定节点的最近公共祖先\n\n> 输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 0, q = 3 输出: 2 解释: 节点 0 和节点 3 的最近公共祖先是 2。\n\n解析：\n\n二叉搜索树的特点是节点左子树都小于节点值，节点右子树都大于节点值。\n\n利用此特性可以仅使用一遍遍历就可以找出最近公共祖先：\n\n从根节点开始遍历，如果 p 和 q 的值均小于当前节点的值，说明 p 和 q 应该在当前节点的左子树，将当前节点移动到它的左子节点。\n\n如果 p 和 q 的值均大于当前节点的值，说明 p 和 q 应该在当前节点的右子树，将当前节点移动到它的右子节点。\n\n如果当前节点的值不满足上述两条要求，即 p 和 q 分别位于当前节点的左右子树，那么说明当前节点就是 p 和 q 最近公共祖先。\n\nclass Solution {\npublic:\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\n        if(!root){\n            return root;\n        }\n        while(true){\n            if(root->val < p->val && root->val < q->val){\n                root = root->right;\n            }else if(root->val > p->val && root->val > q->val){\n                root = root->left;\n            }else{\n                break;\n            }\n        }\n        return root;\n    }\n};\n\n\n# 236 二叉树的最近公共祖先\n\n给定一个二叉树, 找到该树中两个指定节点的最近公共祖先\n\n输入一个二叉树，输出一个节点表示两个指定节点的最近公共祖先\n\n> 输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 6, q = 7 输出：5 解释：节点 6 和节点 7 的最近公共祖先是节点 5\n\n解析：\n\n二叉树不具备二叉搜索树的特点，所以要递归遍历查找。但是思想是一样的，判断是 p 和 q 是否分别位于当前节点的左右子树。\n\n采用深度优先搜索的遍历方法，递归遍历当前节点的左右子树：\n\n递归终止条件：当前节点为叶子节点或者刚好是 p 或者 q 节点。\n\n采用自上而下的递归遍历左右子树，返会结果时自下而上返回保证了返回的公共祖先是最近的。\n\n如果左右子树递归遍历返回结果都为真，那么说明 p 和 q 位于当前节点的左右子树，直接返回当前节点。如果左子树递归遍历结果为假，则说明 p 和 q 位于当前节点的右子树，返回右节点；如果右子树递归遍历结果为假，则说明 p 和 q 位于当前节点的左子树，返回左节点；如果左右子树递归遍历返回结果都为假，那么说明 p 和 q 不在以当前节点为根节点的子树中。\n\nclass Solution {\npublic:\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\n        if(!root || root == p || root == q){\n            return root;\n        }\n        auto left = lowestCommonAncestor(root->left,p,q);\n        auto right = lowestCommonAncestor(root->right,p,q);\n        if(left && right){\n            return root;\n        }else if(!left){\n            return right;\n        }else if(!right){\n            return left;\n        }else{\n            return nullptr;\n        }\n    }\n};\n\n\n# 530 二叉搜索树的最小绝对差\n\n给定一棵所有节点为非负值的二叉搜索树，请计算树中任意两节点的差的绝对值的最小值。\n\n输入一个二叉搜索树，输出一个整数表示树中任意两节点的差的绝对值的最小值\n\n> 输入：[1,null,3,null,null,2]\n> \n> 输出：1\n> \n> 解释：最小绝对差为 1，其中 2 和 1 的差的绝对值为 1（或者 2 和 3）。\n\n解析：\n\n二叉搜索树的特点是节点左子树都小于节点值，节点右子树都大于节点值。那么使用二叉搜索树的中序遍历序列就是一个递增序列，利用此特点可以快速解决本题。\n\n计算任意两节点的差的绝对值的最小值，有两种思路，一种就是将二叉搜索树的中序遍历序列存储到一个数组中，然后遍历该数组计算最小差。另一种思路就是在中序遍历过程中记录前一个节点值，在遍历过程中计算两节点的差的绝对值的最小值。\n\nclass Solution {\npublic:\n    int getMinimumDifference(TreeNode* root) {\n        if(!root){\n            return 0;\n        }\n        vector<int> inorder;\n        stack<TreeNode*> s;\n        TreeNode* cur = root;\n        while(cur || !s.empty()){\n            if(cur){\n                s.push(cur);\n                cur = cur->left;\n            }else{\n                cur = s.top();\n                s.pop();\n                inorder.push_back(cur->val);\n                cur = cur->right;\n            }\n        }\n        int ans = INT_MAX;\n        for(int i=1;i<inorder.size();++i){\n            ans = min(ans,inorder[i]-inorder[i-1]);\n        }\n        return ans;\n    }\n    \n    // 一遍遍历方式：使用pre记录前一个节点值\n    int getMinimumDifference(TreeNode* root) {\n        if(!root){\n            return 0;\n        }\n        int pre = -1, ans = INT_MAX;\n        stack<TreeNode*> s;\n        TreeNode* cur = root;\n        while(cur || !s.empty()){\n            if(cur){\n                s.push(cur);\n                cur = cur->left;\n            }else{\n                cur = s.top();\n                s.pop();\n                if(pre==-1){\n                    pre = cur->val;\n                }else{\n                    ans = min(ans,cur->val-pre);\n                    pre = cur->val;\n                }\n                cur = cur->right;\n            }\n        }\n        return ans;\n    }\n};\n\n\n# 897 递增顺序搜索树\n\n给定一棵二叉搜索树，请你 按中序遍历 将其重新排列为一棵递增顺序搜索树，使树中最左边的节点成为树的根节点，并且每个节点没有左子节点，只有一个右子节点。\n\n输入一个二叉搜索树，输出一个只有右节点的递增顺序搜索树\n\n> 输入：root = [5,3,6,2,4,null,8,1,null,null,null,7,9] 输出：[1,null,2,null,3,null,4,null,5,null,6,null,7,null,8,null,9]\n\n解析：\n\n本题和530 二叉搜索树的最小绝对差一样也可以从二叉搜索树的中序遍历是递增序列的思路解题。先设置一个空头节点，然后使用尾插法将遍历的每一个节点插入到上一节点的右节点。在中序遍历过程中将当前节点插入到上一节点的右节点，直到遍历完成。\n\n需要特别注意的是在插入节点的过程中要将当前节点的左节点置为空，因为二叉搜索树中左节点都小于当前节点，所以他们已经被插入到结果树中。如果不将左节点置为空，可能导致出现环路。\n\nclass Solution {\npublic:\n    TreeNode* increasingBST(TreeNode* root) {\n        if(!root){\n            return root;\n        }\n        // 创建空头节点\n        TreeNode* ans = new TreeNode();\n        TreeNode* tail = ans;\n        stack<TreeNode*> s;\n        TreeNode* cur = root;\n        while(cur || !s.empty()){\n            if(cur){\n                s.push(cur);\n                cur = cur->left;\n            }else{\n                cur = s.top();\n                s.pop();\n                // 将当前节点作为前一节点的右节点\n                tail->right = cur;\n                tail = cur;\n                // 将当前节点左节点置为空，避免环路\n                cur->left = nullptr;\n                cur = cur->right;\n            }\n        }\n        return ans->right;\n    }\n};\n\n\n# 653. 两数之和 IV - 输入 BST\n\n给定一个二叉搜索树和一个目标结果 k，如果 BST 中存在两个元素且它们的和等于给定的目标结果，则返回 true。\n\n输入一个二叉搜索树和目标值 k，输出一个布尔值表示是否存在两个元素之和为目标值k\n\n输入: root = [5,3,6,2,4,null,7], k = 9\n输出: true\n\n\n解析：\n\n看到两数之和很容易想到使用哈希表，那么一种最为简单的思路就是遍历二叉搜索树并将所有元素存入哈希表中。然后，遍历哈希表寻找两数之和。\n\nclass Solution {\npublic:\n    bool findTarget(TreeNode* root, int k) {\n        unordered_set<int> hash;\n        stack<TreeNode*> s;\n        TreeNode* cur = root;\n        while(cur || !s.empty()){\n            if(cur){\n                s.push(cur);\n                cur = cur->left;\n            }else{\n                cur = s.top();\n                s.pop();\n                hash.insert(cur->val);\n                cur = cur->right;\n            }\n        }\n        \n        for(const auto elem: hash){\n            if(hash.find(k-elem) != hash.end() && k-elem != elem){\n                return true;\n            }\n        }\n        return false;\n    }\n};\n",normalizedContent:"# 05 二叉搜索树的属性\n\n二叉查找树 / 二叉搜索树（binary search tree, bst）是一种特殊的二叉树：对于每个父节点，其左子节点的值小于等于父结点的值，其右子节点的值大于等于父结点的值。因此对于一个二叉查找树，我们可以在 o(nlogn) 的时间内查找一个值是否存在：从根节点开始，若当前节点的值大于查找值则向左下走，若当前节点的值小于查找值则向右下走。同时因为二叉查找树是有序的，对其中序遍历的结果即为排好序的数组。 一个二叉查找树的实现如下：\n\ntemplate <class t>\nclass bst {\n    struct node {\n        t data;\n        node* left;\n        node* right;\n    };\n    \n    node* root;\n    \n    node* makeempty(node* t) {\n        if (t == null) return null;\n        makeempty(t->left);\n        makeempty(t->right);\n        delete t;\n        return null;\n    }\n    \n    node* insert(node* t, t x) {\n        if (t == null) {\n            t = new node;\n            t->data = x;\n            t->left = t->right = null;\n        } else if (x < t->data) {\n            t->left = insert(t->left, x);\n        } else if (x > t->data) {\n            t->right = insert(t->right, x);\n        }\n        return t;\n    }\n    \n    node* find(node* t, t x) {\n        if (t == null) return null;\n        if (x < t->data) return find(t->left, x);\n        if (x > t->data) return find(t->right, x);\n        return t;\n    }\n    \n    node* findmin(node* t) {\n        if (t == null || t->left == null) return t;\n        return findmin(t->left);\n    }\n    \n    node* findmax(node* t) {\n        if (t == null || t->right == null) return t;\n        return findmax(t->right);\n\t}\n    \n    node* remove(node* t, t x) {\n        ode* temp;\n        if (t == null) return null;\n        else if (x < t->data) t->left = remove(t->left, x);\n        else if (x > t->data) t->right = remove(t->right, x);\n        else if (t->left && t->right) {\n            temp = findmin(t->right);\n            t->data = temp->data;\n            t->right = remove(t->right, t->data);\n        } else {\n            temp = t;\n            if (t->left == null) t = t->right;\n            else if (t->right == null) t = t->left;\n            delete temp;\n        }\n        return t;\n    }\n\npublic:\n    bst(): root(null) {}\n    ~bst() {\n        root = makeempty(root);\n    }\n    void insert(t x) {\n    \tinsert(root, x);\n    }\n    void remove(t x) {\n    \tremove(root, x);\n    }\n};  \n\n\n二叉搜索树的特点是节点左子树都小于节点值，节点右子树都大于节点值。所以，二叉搜索树的中序遍历序列就是一个递增序列，这一属性被广泛使用。\n\n# 538 把二叉搜索树转换为累加树\n\n给出一个二叉搜索树，该树的节点值各不相同，请将其转换为累加树（greater sum tree），使每个节点 node 的新值等于原树中大于或等于 node.val 的值之和。\n\n输入一个二叉搜索树，输出一个累加树\n\n> 输入：root = [3,2,4,1]\n> 输出：[7,9,4,10]\n\n解析：\n\n本题可以采用返序的中序遍历解决，中序遍历先遍历左节点、再遍历根节点、最后遍历右节点。\n\n而二叉搜索树的特点是节点左子树都小于节点值，节点右子树都大于节点值；累加树又是累加的是大于等于当前节点值的节点；所以只要从二叉搜索树最底层，最右侧开始遍历，就可以自下而上累加节点值。\n\n即当前节点值为其右子数最大累和加上自身节点值，而最大累和在右子树存在左子树的情况下出现在该左子数最底层最左侧节点累加值。\n\n根据累加树的节点值累加顺序：先右节点累和，然后根节点基于右节点值进行累和，最后左节点根据根节点值进行累和。所以本题采用返序中序遍历，先遍历右节点、再遍历根节点、最后遍历左节点；同时需要一个累和全局变量存储遍历当前节点时已经被遍历节点值之和。\n\n简而言之，按从大到小的顺序遍历二叉搜索树，每遍历一个节点，加上自身节点值来更新累和值，并将累和值作为其新值。\n\nclass solution {\n    // 存储遍历当前节点时已经被遍历节点值之和\n    int sum = 0;\npublic:\n    treenode* convertbst(treenode* root) {\n        if(!root){\n            return root;\n        }\n        // 先遍历右节点\n        convertbst(root->right);\n        // 在遍历根节点\n        sum+=root->val;\n        root->val = sum;\n        // 最后遍历左节点\n        convertbst(root->left);\n        return root;\n    }\n};\n\n\n# 235 二叉搜索树的最近公共祖先\n\n给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先\n\n输入一个二叉搜索树，输出一个节点表示两个指定节点的最近公共祖先\n\n> 输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 0, q = 3 输出: 2 解释: 节点 0 和节点 3 的最近公共祖先是 2。\n\n解析：\n\n二叉搜索树的特点是节点左子树都小于节点值，节点右子树都大于节点值。\n\n利用此特性可以仅使用一遍遍历就可以找出最近公共祖先：\n\n从根节点开始遍历，如果 p 和 q 的值均小于当前节点的值，说明 p 和 q 应该在当前节点的左子树，将当前节点移动到它的左子节点。\n\n如果 p 和 q 的值均大于当前节点的值，说明 p 和 q 应该在当前节点的右子树，将当前节点移动到它的右子节点。\n\n如果当前节点的值不满足上述两条要求，即 p 和 q 分别位于当前节点的左右子树，那么说明当前节点就是 p 和 q 最近公共祖先。\n\nclass solution {\npublic:\n    treenode* lowestcommonancestor(treenode* root, treenode* p, treenode* q) {\n        if(!root){\n            return root;\n        }\n        while(true){\n            if(root->val < p->val && root->val < q->val){\n                root = root->right;\n            }else if(root->val > p->val && root->val > q->val){\n                root = root->left;\n            }else{\n                break;\n            }\n        }\n        return root;\n    }\n};\n\n\n# 236 二叉树的最近公共祖先\n\n给定一个二叉树, 找到该树中两个指定节点的最近公共祖先\n\n输入一个二叉树，输出一个节点表示两个指定节点的最近公共祖先\n\n> 输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 6, q = 7 输出：5 解释：节点 6 和节点 7 的最近公共祖先是节点 5\n\n解析：\n\n二叉树不具备二叉搜索树的特点，所以要递归遍历查找。但是思想是一样的，判断是 p 和 q 是否分别位于当前节点的左右子树。\n\n采用深度优先搜索的遍历方法，递归遍历当前节点的左右子树：\n\n递归终止条件：当前节点为叶子节点或者刚好是 p 或者 q 节点。\n\n采用自上而下的递归遍历左右子树，返会结果时自下而上返回保证了返回的公共祖先是最近的。\n\n如果左右子树递归遍历返回结果都为真，那么说明 p 和 q 位于当前节点的左右子树，直接返回当前节点。如果左子树递归遍历结果为假，则说明 p 和 q 位于当前节点的右子树，返回右节点；如果右子树递归遍历结果为假，则说明 p 和 q 位于当前节点的左子树，返回左节点；如果左右子树递归遍历返回结果都为假，那么说明 p 和 q 不在以当前节点为根节点的子树中。\n\nclass solution {\npublic:\n    treenode* lowestcommonancestor(treenode* root, treenode* p, treenode* q) {\n        if(!root || root == p || root == q){\n            return root;\n        }\n        auto left = lowestcommonancestor(root->left,p,q);\n        auto right = lowestcommonancestor(root->right,p,q);\n        if(left && right){\n            return root;\n        }else if(!left){\n            return right;\n        }else if(!right){\n            return left;\n        }else{\n            return nullptr;\n        }\n    }\n};\n\n\n# 530 二叉搜索树的最小绝对差\n\n给定一棵所有节点为非负值的二叉搜索树，请计算树中任意两节点的差的绝对值的最小值。\n\n输入一个二叉搜索树，输出一个整数表示树中任意两节点的差的绝对值的最小值\n\n> 输入：[1,null,3,null,null,2]\n> \n> 输出：1\n> \n> 解释：最小绝对差为 1，其中 2 和 1 的差的绝对值为 1（或者 2 和 3）。\n\n解析：\n\n二叉搜索树的特点是节点左子树都小于节点值，节点右子树都大于节点值。那么使用二叉搜索树的中序遍历序列就是一个递增序列，利用此特点可以快速解决本题。\n\n计算任意两节点的差的绝对值的最小值，有两种思路，一种就是将二叉搜索树的中序遍历序列存储到一个数组中，然后遍历该数组计算最小差。另一种思路就是在中序遍历过程中记录前一个节点值，在遍历过程中计算两节点的差的绝对值的最小值。\n\nclass solution {\npublic:\n    int getminimumdifference(treenode* root) {\n        if(!root){\n            return 0;\n        }\n        vector<int> inorder;\n        stack<treenode*> s;\n        treenode* cur = root;\n        while(cur || !s.empty()){\n            if(cur){\n                s.push(cur);\n                cur = cur->left;\n            }else{\n                cur = s.top();\n                s.pop();\n                inorder.push_back(cur->val);\n                cur = cur->right;\n            }\n        }\n        int ans = int_max;\n        for(int i=1;i<inorder.size();++i){\n            ans = min(ans,inorder[i]-inorder[i-1]);\n        }\n        return ans;\n    }\n    \n    // 一遍遍历方式：使用pre记录前一个节点值\n    int getminimumdifference(treenode* root) {\n        if(!root){\n            return 0;\n        }\n        int pre = -1, ans = int_max;\n        stack<treenode*> s;\n        treenode* cur = root;\n        while(cur || !s.empty()){\n            if(cur){\n                s.push(cur);\n                cur = cur->left;\n            }else{\n                cur = s.top();\n                s.pop();\n                if(pre==-1){\n                    pre = cur->val;\n                }else{\n                    ans = min(ans,cur->val-pre);\n                    pre = cur->val;\n                }\n                cur = cur->right;\n            }\n        }\n        return ans;\n    }\n};\n\n\n# 897 递增顺序搜索树\n\n给定一棵二叉搜索树，请你 按中序遍历 将其重新排列为一棵递增顺序搜索树，使树中最左边的节点成为树的根节点，并且每个节点没有左子节点，只有一个右子节点。\n\n输入一个二叉搜索树，输出一个只有右节点的递增顺序搜索树\n\n> 输入：root = [5,3,6,2,4,null,8,1,null,null,null,7,9] 输出：[1,null,2,null,3,null,4,null,5,null,6,null,7,null,8,null,9]\n\n解析：\n\n本题和530 二叉搜索树的最小绝对差一样也可以从二叉搜索树的中序遍历是递增序列的思路解题。先设置一个空头节点，然后使用尾插法将遍历的每一个节点插入到上一节点的右节点。在中序遍历过程中将当前节点插入到上一节点的右节点，直到遍历完成。\n\n需要特别注意的是在插入节点的过程中要将当前节点的左节点置为空，因为二叉搜索树中左节点都小于当前节点，所以他们已经被插入到结果树中。如果不将左节点置为空，可能导致出现环路。\n\nclass solution {\npublic:\n    treenode* increasingbst(treenode* root) {\n        if(!root){\n            return root;\n        }\n        // 创建空头节点\n        treenode* ans = new treenode();\n        treenode* tail = ans;\n        stack<treenode*> s;\n        treenode* cur = root;\n        while(cur || !s.empty()){\n            if(cur){\n                s.push(cur);\n                cur = cur->left;\n            }else{\n                cur = s.top();\n                s.pop();\n                // 将当前节点作为前一节点的右节点\n                tail->right = cur;\n                tail = cur;\n                // 将当前节点左节点置为空，避免环路\n                cur->left = nullptr;\n                cur = cur->right;\n            }\n        }\n        return ans->right;\n    }\n};\n\n\n# 653. 两数之和 iv - 输入 bst\n\n给定一个二叉搜索树和一个目标结果 k，如果 bst 中存在两个元素且它们的和等于给定的目标结果，则返回 true。\n\n输入一个二叉搜索树和目标值 k，输出一个布尔值表示是否存在两个元素之和为目标值k\n\n输入: root = [5,3,6,2,4,null,7], k = 9\n输出: true\n\n\n解析：\n\n看到两数之和很容易想到使用哈希表，那么一种最为简单的思路就是遍历二叉搜索树并将所有元素存入哈希表中。然后，遍历哈希表寻找两数之和。\n\nclass solution {\npublic:\n    bool findtarget(treenode* root, int k) {\n        unordered_set<int> hash;\n        stack<treenode*> s;\n        treenode* cur = root;\n        while(cur || !s.empty()){\n            if(cur){\n                s.push(cur);\n                cur = cur->left;\n            }else{\n                cur = s.top();\n                s.pop();\n                hash.insert(cur->val);\n                cur = cur->right;\n            }\n        }\n        \n        for(const auto elem: hash){\n            if(hash.find(k-elem) != hash.end() && k-elem != elem){\n                return true;\n            }\n        }\n        return false;\n    }\n};\n",charsets:{cjk:!0},lastUpdated:"2023/11/19, 12:55:48",lastUpdatedTimestamp:1700369748e3},{title:"06二叉搜索树的操作",frontmatter:{title:"06二叉搜索树的操作",date:"2023-03-24T18:39:50.000Z",permalink:"/pages/8995b9/"},regularPath:"/03.LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/02.%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/04.%E4%BA%8C%E5%8F%89%E6%A0%91/06.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%93%8D%E4%BD%9C.html",relativePath:"03.LeetCode刷题笔记/02.基础数据结构/04.二叉树/06.二叉搜索树的操作.md",key:"v-7386757a",path:"/pages/8995b9/",headers:[{level:2,title:"06 二叉搜索树的操作",slug:"_06-二叉搜索树的操作",normalizedTitle:"06 二叉搜索树的操作",charIndex:2},{level:4,title:"669 修剪二叉搜索树",slug:"_669-修剪二叉搜索树",normalizedTitle:"669 修剪二叉搜索树",charIndex:17},{level:4,title:"99 恢复二叉搜索树",slug:"_99-恢复二叉搜索树",normalizedTitle:"99 恢复二叉搜索树",charIndex:911},{level:4,title:"109 有序链表转换二叉搜索树",slug:"_109-有序链表转换二叉搜索树",normalizedTitle:"109 有序链表转换二叉搜索树",charIndex:2525},{level:4,title:"450 删除二叉搜索树中的节点",slug:"_450-删除二叉搜索树中的节点",normalizedTitle:"450 删除二叉搜索树中的节点",charIndex:4902}],headersStr:"06 二叉搜索树的操作 669 修剪二叉搜索树 99 恢复二叉搜索树 109 有序链表转换二叉搜索树 450 删除二叉搜索树中的节点",content:"# 06 二叉搜索树的操作\n\n# 669 修剪二叉搜索树\n\n给定一个二叉查找树和两个整数 L 和 R，且 L < R，试修剪此二叉查找树，使得修剪后所有节点的值都在 [L, R] 的范围内。\n\n输入是一个二叉查找树和两个整数 L 和 R，输出一个被修剪好的二叉查找树。\n\n> 输入：root = [3,0,4,null,2,null,null,1], low = 1, high = 3\n> 输出：[3,2,null,1]\n\n解析：\n\n利用二叉查找树的大小关系，我们可以很容易地利用递归进行树的处理。\n\n递归遍历每一个节点，如果当前值大于 high 那么修剪后的二叉树必定出现在节点的左边；如果当前值小于 low 那么修剪后的二叉树出现在节点的右边；如果当前节点值在区间内，则往左右子树递归。\n\nclass Solution {\npublic:\n    TreeNode* trimBST(TreeNode* root, int low, int high) {\n        if(!root){\n            return root;\n        }\n        // 当前值大于 high 那么修剪后的二叉树必定出现在节点的左边\n        if(root->val > high){\n            return trimBST(root->left,low,high);\n        }\n        // 当前值小于 low 那么修剪后的二叉树出现在节点的右边\n        if(root->val < low){\n            return trimBST(root->right,low,high);\n        }\n        // 当前值在区间内，则往左右子树递归\n        root->left = trimBST(root->left,low,high);\n        root->right = trimBST(root->right,low,high);\n        return root;\n    }\n};\n\n\n# 99 恢复二叉搜索树\n\n给定一个二叉搜索树，已知有两个节点被不小心交换了，试复原此树\n\n输入是一个被误交换两个节点的二叉搜索树，输出是改正后的二叉搜索树\n\n> 输入：root = [3,1,4,null,null,2] 输出：[2,1,4,null,null,3] 解释：2 不能在 3 的右子树中，因为 2 < 3 。交换 2 和 3 使二叉搜索树有效。\n\n解析：\n\n本题没搞懂，有待深究\n\n使用中序遍历一棵二叉搜索树，得到的遍历结果是节点值递增的序列，利用二叉搜索树这一特点可以快速找出错误的节点。\n\n得到二叉搜索树的中序遍历序列，找到错误的节点，交换两个节点的值。\n\nclass Solution {\npublic:\n    void inorder(TreeNode* root, vector<int>& nums) {\n        if (root == nullptr) {\n            return;\n        }\n        inorder(root->left, nums);\n        nums.push_back(root->val);\n        inorder(root->right, nums);\n    }\n\n    pair<int,int> findTwoSwapped(vector<int>& nums) {\n        int n = nums.size();\n        int index1 = -1, index2 = -1;\n        for (int i = 0; i < n - 1; ++i) {\n            if (nums[i + 1] < nums[i]) {\n                index2 = i + 1;\n                if (index1 == -1) {\n                    index1 = i;\n                } else {\n                    break;\n                }\n            }\n        }\n        int x = nums[index1], y = nums[index2];\n        return {x, y};\n    }\n    \n    void recover(TreeNode* r, int count, int x, int y) {\n        if (r != nullptr) {\n            if (r->val == x || r->val == y) {\n                r->val = r->val == x ? y : x;\n                if (--count == 0) {\n                    return;\n                }\n            }\n            recover(r->left, count, x, y);\n            recover(r->right, count, x, y);\n        }\n    }\n\n    void recoverTree(TreeNode* root) {\n        vector<int> nums;\n        inorder(root, nums);\n        pair<int,int> swapped= findTwoSwapped(nums);\n        recover(root, 2, swapped.first, swapped.second);\n    }\n};\n\n\n# 109 有序链表转换二叉搜索树\n\n给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。\n\n输入一个链表，输出一个左右子树高度差不超过1的平衡二叉搜索树\n\n> 给定的有序链表： [-10, -3, 0, 5, 9],\n> \n> 一个可能的答案是：[0, -3, 9, -10, null, 5], 它可以表示下面这个高度平衡二叉搜索树：\n> \n>       0\n>      / \\\n>    -3   9\n>    /   /\n>  -10  5\n\n解析：\n\n要保证平衡，那么需要寻找链表的中点，以中点为根节点构造二叉树，小于中点的元素组成左子树，大于中点的元素组成右子树，它们分别对应着有序链表中连续的一段，这就保证了左右子树节点数目之差不超过1，从而实现二叉树的平衡。\n\n在这之后，我们使用分治的思想，继续递归地对左右子树进行构造，找出对应的中点作为根节点，直到构造叶子节点完成时返回。\n\n寻找链表中点的一种常见方式就是快慢指针，快指针和慢指针在同一节点出发，快指针一次走两步，慢指针一次走一步，当快指针到达终点时，慢指针指向的就是链表中点。注意循环条件，本题在递归过程中，子树对应的链表最后一个节点的next不一定是nullptr。\n\n找到链表中点之后，构造该节点，并递归构造其左右节点。\n\nclass Solution {\npublic:\n\n    ListNode* getMid(ListNode* left, ListNode* right){\n        ListNode* fast = left;\n        ListNode* slow = left;\n        // 注意判断条件，终止条件是右边接而不是 nullptr\n        while(fast != right && fast->next != right){\n            fast = fast->next->next;\n            slow = slow->next;\n        }\n        return slow;\n    }\n\n    TreeNode* buildTree(ListNode* left, ListNode* right){\n        if(left == right){\n            return nullptr;\n        }\n        ListNode* midNode = getMid(left,right);\n        TreeNode* root = new TreeNode(midNode->val);\n        root->left = buildTree(left,midNode);\n        root->right = buildTree(midNode->next,right);\n        return root;\n    }\n\n    TreeNode* sortedListToBST(ListNode* head) {\n        // 链表的右边界是nullptr\n        return buildTree(head,nullptr);\n    }\n};\n\n\n每次构造节点都需要使用快慢指针遍历链表寻找中点，这极大地耗损了算法效率。由于构造出的二叉搜索树的中序遍历结果就是链表本身，我们可以采用中序遍历思路减少时间复杂度。\n\n中序遍历的顺序是「左子树 - 根节点 - 右子树」，那么在分治的过程中，我们不用急着找出链表的中位数节点，而是使用一个占位节点，等到中序遍历到该节点时，再填充它的值。\n\n在中序序列中，假设左端点编号为left，右端点编号为right，那么根节点就是 mid = (left+right+1)/2 或者是 mid = (left+right)/2 ，左子树节点范围为 [left, mid-1]，右子树节点范围为 [mid+1，right]。根据中序遍历结果恢复二叉搜索树。\n\nclass Solution {\npublic:\n    TreeNode* buildTreeMid(ListNode*& head, int left, int right){\n        if(left > right){\n            return nullptr;\n        }\n        int mid = (left+right+1)/2;\n        TreeNode* root = new TreeNode();\n        root->left = buildTreeMid(head,left,mid-1);\n        root->val = head->val;\n        head = head->next; // 不懂为什么要传引用，而不可以直接传实参\n        root->right = buildTreeMid(head,mid+1,right);\n        return root;\n    }\n\n    TreeNode* sortedListToBST(ListNode* head) {\n        int len = 0;\n        ListNode* cur = head;\n        while(cur){\n            ++len;\n            cur = cur->next;\n        }\n        return buildTreeMid(head,0,len-1);\n    }\n};\n\n\n# 450 删除二叉搜索树中的节点\n\n给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变。\n\n输入一个二叉搜索树和待删除节点值 key，输入一个删除节点key后的二叉搜索树\n\n> 输入：root = [5,3,6,2,4,null,7], key = 3 输出：[5,4,6,2,null,null,7] 解释：给定需要删除的节点值是 3，所以我们首先找到 3 这个节点，然后删除它。一个正确的答案是 [5,4,6,2,null,null,7]\n\n解析：\n\n1. 找到需要删除的节点\n\n利用二叉搜索树特性，递归查找待删除节点。如果当前节点值小于 key 那么往其右子树递归查找，如果当前节点值大于 key 那么往其左子树递归查找，如果相等就开始删除操作。\n\n2. 删除的节点\n\n删除节点要区分四种情况：当前节点是叶节点、只有左子节点、只有右子节点和有两个子节点\n\n * 当前节点是叶节点：直接删除节点， 返回NULL为根节点、\n * 当前节点只有左子节点：删除节点，左孩子补位，返回左孩子为根节点\n * 当前节点只有右子节点：删除节点，右孩子补位，返回右孩子为根节点\n * 当前节点有两个子节点：将当前节点的左子树整体移动到其右子树的最左侧节点的左节点上，返回删除节点右节点为新的根节点\n\nclass Solution {\npublic:\n    TreeNode* deleteNode(TreeNode* root, int key) {\n        if(!root){\n            return root;\n        }\n        if(root->val == key){\n            // 叶子节点\n            if(!root->left && !root->right){\n                delete root;\n                return nullptr;\n            }\n            // 只有左节点\n            else if(root->left && !root->right){\n                TreeNode* node = root->left;\n                delete root;\n                return node;\n            }\n            // 只有右节点\n            else if(!root->left && root->right){\n                TreeNode* node = root->right;\n                delete root;\n                return node;\n            }\n            // 有两个子节点\n            else{\n                TreeNode* cur = root->right;\n                while(cur->left){\n                    cur = cur->left;\n                }\n                cur->left = root->left;\n                TreeNode* node = root->right;\n                delete root;\n                return node;\n            }\n        }\n        // 递归查找删除节点\n        if(root->val > key){\n            root->left = deleteNode(root->left,key);\n        }\n        if(root->val < key){\n            root->right = deleteNode(root->right,key);\n        }\n        return root;\n    }\n};\n",normalizedContent:"# 06 二叉搜索树的操作\n\n# 669 修剪二叉搜索树\n\n给定一个二叉查找树和两个整数 l 和 r，且 l < r，试修剪此二叉查找树，使得修剪后所有节点的值都在 [l, r] 的范围内。\n\n输入是一个二叉查找树和两个整数 l 和 r，输出一个被修剪好的二叉查找树。\n\n> 输入：root = [3,0,4,null,2,null,null,1], low = 1, high = 3\n> 输出：[3,2,null,1]\n\n解析：\n\n利用二叉查找树的大小关系，我们可以很容易地利用递归进行树的处理。\n\n递归遍历每一个节点，如果当前值大于 high 那么修剪后的二叉树必定出现在节点的左边；如果当前值小于 low 那么修剪后的二叉树出现在节点的右边；如果当前节点值在区间内，则往左右子树递归。\n\nclass solution {\npublic:\n    treenode* trimbst(treenode* root, int low, int high) {\n        if(!root){\n            return root;\n        }\n        // 当前值大于 high 那么修剪后的二叉树必定出现在节点的左边\n        if(root->val > high){\n            return trimbst(root->left,low,high);\n        }\n        // 当前值小于 low 那么修剪后的二叉树出现在节点的右边\n        if(root->val < low){\n            return trimbst(root->right,low,high);\n        }\n        // 当前值在区间内，则往左右子树递归\n        root->left = trimbst(root->left,low,high);\n        root->right = trimbst(root->right,low,high);\n        return root;\n    }\n};\n\n\n# 99 恢复二叉搜索树\n\n给定一个二叉搜索树，已知有两个节点被不小心交换了，试复原此树\n\n输入是一个被误交换两个节点的二叉搜索树，输出是改正后的二叉搜索树\n\n> 输入：root = [3,1,4,null,null,2] 输出：[2,1,4,null,null,3] 解释：2 不能在 3 的右子树中，因为 2 < 3 。交换 2 和 3 使二叉搜索树有效。\n\n解析：\n\n本题没搞懂，有待深究\n\n使用中序遍历一棵二叉搜索树，得到的遍历结果是节点值递增的序列，利用二叉搜索树这一特点可以快速找出错误的节点。\n\n得到二叉搜索树的中序遍历序列，找到错误的节点，交换两个节点的值。\n\nclass solution {\npublic:\n    void inorder(treenode* root, vector<int>& nums) {\n        if (root == nullptr) {\n            return;\n        }\n        inorder(root->left, nums);\n        nums.push_back(root->val);\n        inorder(root->right, nums);\n    }\n\n    pair<int,int> findtwoswapped(vector<int>& nums) {\n        int n = nums.size();\n        int index1 = -1, index2 = -1;\n        for (int i = 0; i < n - 1; ++i) {\n            if (nums[i + 1] < nums[i]) {\n                index2 = i + 1;\n                if (index1 == -1) {\n                    index1 = i;\n                } else {\n                    break;\n                }\n            }\n        }\n        int x = nums[index1], y = nums[index2];\n        return {x, y};\n    }\n    \n    void recover(treenode* r, int count, int x, int y) {\n        if (r != nullptr) {\n            if (r->val == x || r->val == y) {\n                r->val = r->val == x ? y : x;\n                if (--count == 0) {\n                    return;\n                }\n            }\n            recover(r->left, count, x, y);\n            recover(r->right, count, x, y);\n        }\n    }\n\n    void recovertree(treenode* root) {\n        vector<int> nums;\n        inorder(root, nums);\n        pair<int,int> swapped= findtwoswapped(nums);\n        recover(root, 2, swapped.first, swapped.second);\n    }\n};\n\n\n# 109 有序链表转换二叉搜索树\n\n给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。\n\n输入一个链表，输出一个左右子树高度差不超过1的平衡二叉搜索树\n\n> 给定的有序链表： [-10, -3, 0, 5, 9],\n> \n> 一个可能的答案是：[0, -3, 9, -10, null, 5], 它可以表示下面这个高度平衡二叉搜索树：\n> \n>       0\n>      / \\\n>    -3   9\n>    /   /\n>  -10  5\n\n解析：\n\n要保证平衡，那么需要寻找链表的中点，以中点为根节点构造二叉树，小于中点的元素组成左子树，大于中点的元素组成右子树，它们分别对应着有序链表中连续的一段，这就保证了左右子树节点数目之差不超过1，从而实现二叉树的平衡。\n\n在这之后，我们使用分治的思想，继续递归地对左右子树进行构造，找出对应的中点作为根节点，直到构造叶子节点完成时返回。\n\n寻找链表中点的一种常见方式就是快慢指针，快指针和慢指针在同一节点出发，快指针一次走两步，慢指针一次走一步，当快指针到达终点时，慢指针指向的就是链表中点。注意循环条件，本题在递归过程中，子树对应的链表最后一个节点的next不一定是nullptr。\n\n找到链表中点之后，构造该节点，并递归构造其左右节点。\n\nclass solution {\npublic:\n\n    listnode* getmid(listnode* left, listnode* right){\n        listnode* fast = left;\n        listnode* slow = left;\n        // 注意判断条件，终止条件是右边接而不是 nullptr\n        while(fast != right && fast->next != right){\n            fast = fast->next->next;\n            slow = slow->next;\n        }\n        return slow;\n    }\n\n    treenode* buildtree(listnode* left, listnode* right){\n        if(left == right){\n            return nullptr;\n        }\n        listnode* midnode = getmid(left,right);\n        treenode* root = new treenode(midnode->val);\n        root->left = buildtree(left,midnode);\n        root->right = buildtree(midnode->next,right);\n        return root;\n    }\n\n    treenode* sortedlisttobst(listnode* head) {\n        // 链表的右边界是nullptr\n        return buildtree(head,nullptr);\n    }\n};\n\n\n每次构造节点都需要使用快慢指针遍历链表寻找中点，这极大地耗损了算法效率。由于构造出的二叉搜索树的中序遍历结果就是链表本身，我们可以采用中序遍历思路减少时间复杂度。\n\n中序遍历的顺序是「左子树 - 根节点 - 右子树」，那么在分治的过程中，我们不用急着找出链表的中位数节点，而是使用一个占位节点，等到中序遍历到该节点时，再填充它的值。\n\n在中序序列中，假设左端点编号为left，右端点编号为right，那么根节点就是 mid = (left+right+1)/2 或者是 mid = (left+right)/2 ，左子树节点范围为 [left, mid-1]，右子树节点范围为 [mid+1，right]。根据中序遍历结果恢复二叉搜索树。\n\nclass solution {\npublic:\n    treenode* buildtreemid(listnode*& head, int left, int right){\n        if(left > right){\n            return nullptr;\n        }\n        int mid = (left+right+1)/2;\n        treenode* root = new treenode();\n        root->left = buildtreemid(head,left,mid-1);\n        root->val = head->val;\n        head = head->next; // 不懂为什么要传引用，而不可以直接传实参\n        root->right = buildtreemid(head,mid+1,right);\n        return root;\n    }\n\n    treenode* sortedlisttobst(listnode* head) {\n        int len = 0;\n        listnode* cur = head;\n        while(cur){\n            ++len;\n            cur = cur->next;\n        }\n        return buildtreemid(head,0,len-1);\n    }\n};\n\n\n# 450 删除二叉搜索树中的节点\n\n给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变。\n\n输入一个二叉搜索树和待删除节点值 key，输入一个删除节点key后的二叉搜索树\n\n> 输入：root = [5,3,6,2,4,null,7], key = 3 输出：[5,4,6,2,null,null,7] 解释：给定需要删除的节点值是 3，所以我们首先找到 3 这个节点，然后删除它。一个正确的答案是 [5,4,6,2,null,null,7]\n\n解析：\n\n1. 找到需要删除的节点\n\n利用二叉搜索树特性，递归查找待删除节点。如果当前节点值小于 key 那么往其右子树递归查找，如果当前节点值大于 key 那么往其左子树递归查找，如果相等就开始删除操作。\n\n2. 删除的节点\n\n删除节点要区分四种情况：当前节点是叶节点、只有左子节点、只有右子节点和有两个子节点\n\n * 当前节点是叶节点：直接删除节点， 返回null为根节点、\n * 当前节点只有左子节点：删除节点，左孩子补位，返回左孩子为根节点\n * 当前节点只有右子节点：删除节点，右孩子补位，返回右孩子为根节点\n * 当前节点有两个子节点：将当前节点的左子树整体移动到其右子树的最左侧节点的左节点上，返回删除节点右节点为新的根节点\n\nclass solution {\npublic:\n    treenode* deletenode(treenode* root, int key) {\n        if(!root){\n            return root;\n        }\n        if(root->val == key){\n            // 叶子节点\n            if(!root->left && !root->right){\n                delete root;\n                return nullptr;\n            }\n            // 只有左节点\n            else if(root->left && !root->right){\n                treenode* node = root->left;\n                delete root;\n                return node;\n            }\n            // 只有右节点\n            else if(!root->left && root->right){\n                treenode* node = root->right;\n                delete root;\n                return node;\n            }\n            // 有两个子节点\n            else{\n                treenode* cur = root->right;\n                while(cur->left){\n                    cur = cur->left;\n                }\n                cur->left = root->left;\n                treenode* node = root->right;\n                delete root;\n                return node;\n            }\n        }\n        // 递归查找删除节点\n        if(root->val > key){\n            root->left = deletenode(root->left,key);\n        }\n        if(root->val < key){\n            root->right = deletenode(root->right,key);\n        }\n        return root;\n    }\n};\n",charsets:{cjk:!0},lastUpdated:"2023/11/19, 12:55:48",lastUpdatedTimestamp:1700369748e3},{title:"07字典树",frontmatter:{title:"07字典树",date:"2023-03-24T18:39:50.000Z",permalink:"/pages/5c0017/"},regularPath:"/03.LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/02.%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/04.%E4%BA%8C%E5%8F%89%E6%A0%91/07.%E5%AD%97%E5%85%B8%E6%A0%91.html",relativePath:"03.LeetCode刷题笔记/02.基础数据结构/04.二叉树/07.字典树.md",key:"v-bfa92168",path:"/pages/5c0017/",headers:[{level:2,title:"05 字典树",slug:"_05-字典树",normalizedTitle:"05 字典树",charIndex:2},{level:4,title:"208 实现 Trie (前缀树)",slug:"_208-实现-trie-前缀树",normalizedTitle:"208 实现 trie (前缀树)",charIndex:248},{level:4,title:"820 单词的压缩编码",slug:"_820-单词的压缩编码",normalizedTitle:"820 单词的压缩编码",charIndex:1671}],headersStr:"05 字典树 208 实现 Trie (前缀树) 820 单词的压缩编码",content:'# 05 字典树\n\n字典树一般用于判断字符串是否存在或者是否具有某种字符串前缀。如下图一个字典树中，存储了 A、to、tea、ted、ten、i、in 和 inn，以及它们的频率。\n\n为什么需要用字典树解决这类问题呢？假如我们有一个储存了近万个单词的字典，即使我们使用哈希，在其中搜索一个单词的实际开销也是非常大的，且无法轻易支持搜索单词前缀。然而由于一个英文单词的长度 n 通常在 10 以内，如果我们使用字典树，则可以在 O(n)——近似 O(1)的时间内完成搜索，且额外开销非常小。\n\n# 208 实现 Trie (前缀树)\n\n尝试建立一个字典树，支持快速插入单词、查找单词、查找单词前缀的功能\n\n以下是数据结构的调用样例\n\n> 输入: ["Trie", "insert", "search", "search", "startsWith", "insert", "search"] [[], ["apple"], ["apple"], ["app"], ["app"], ["app"], ["app"]] 输出: [null, null, true, false, true, null, true]\n> \n> 解释: Trie trie = new Trie(); trie.insert("apple"); trie.search("apple"); // 返回 True trie.search("app"); // 返回 False trie.startsWith("app"); // 返回 True trie.insert("app"); trie.search("app"); // 返回 True\n\nclass Trie {\nprivate:\n    vector<Trie*> children;\n    bool isEnd;\n\n    Trie* searchPrefix(string prefix) {\n        Trie* node = this;\n        for (char ch : prefix) {\n            ch -= \'a\';\n            if (node->children[ch] == nullptr) {\n                return nullptr;\n            }\n            node = node->children[ch];\n        }\n        return node;\n    }\n\npublic:\n    Trie() : children(26), isEnd(false) {}\n\n    void insert(string word) {\n        Trie* node = this;\n        for (char ch : word) {\n            ch -= \'a\';\n            if (node->children[ch] == nullptr) {\n                node->children[ch] = new Trie();\n            }\n            node = node->children[ch];\n        }\n        node->isEnd = true;\n    }\n\n    bool search(string word) {\n        Trie* node = this->searchPrefix(word);\n        return node != nullptr && node->isEnd;\n    }\n\n    bool startsWith(string prefix) {\n        return this->searchPrefix(prefix) != nullptr;\n    }\n};\n\n\n# 820 单词的压缩编码\n\n单词数组 words 的 有效编码 由任意助记字符串 s 和下标数组 indices 组成，且满足：\n\n * words.length == indices.length\n * 助记字符串 s 以 \'#\' 字符结尾\n * 对于每个下标 indices[i] ，s 的一个从 indices[i] 开始、到下一个 \'#\' 字符结束（但不包括 \'#\'）的 子字符串 恰好与 words[i] 相等\n\n给定一个单词数组 words ，返回成功对 words 进行编码的最小助记字符串 s 的长度 。\n\n> 输入：words = ["time", "me", "bell"]\n> \n> 输出：10\n> \n> 解释：一组有效编码为 s = "time#bell#" 和 indices = [0, 2, 5] 。 words[0] = "time" ，s 开始于 indices[0] = 0 到下一个 \'#\' 结束的子字符串，如加粗部分所示 "time#bell#" words[1] = "me" ，s 开始于 indices[1] = 2 到下一个 \'#\' 结束的子字符串，如加粗部分所示 "time#bell#" words[2] = "bell" ，s 开始于 indices[2] = 5 到下一个 \'#\' 结束的子字符串，如加粗部分所示 "time#bell#"\n\n解析:\n\nclass Trie{\nprivate:\n    Trie* child[26];\n    bool found;\npublic:\n    Trie(){\n        for(int i=0;i<26;++i){\n            child[i] = nullptr;\n            found = false;\n        }\n    }\n\n    void insert(string word){\n        Trie* node = this;\n        for(const auto ch:word){\n            if(node->child[ch-\'a\'] == nullptr){\n                node->child[ch-\'a\'] = new Trie();\n            }\n            node = node->child[ch-\'a\'];\n        }\n        node->found = true;\n    }\n\n    bool search(string word){\n        Trie* node = this;\n        for(const auto ch:word){\n            if(node->child[ch-\'a\']==nullptr){\n                return false;\n            }\n            node = node->child[ch-\'a\'];\n        }\n        return node->found;\n    }\n\n    bool prefix(string prefix){\n        Trie* node = this;\n        for(const auto ch:prefix){\n            if(node->child[ch-\'a\']==nullptr){\n                return false;\n            }\n            node = node->child[ch-\'a\'];\n        }\n        return true;\n    }\n};\n\nclass Solution {\npublic:\n    int minimumLengthEncoding(vector<string>& words) {\n        unordered_set<string> hash;\n        // 要从长单词到短单词构建字典树\n        sort(words.begin(),words.end(),[](string& a, string& b){\n            return a.length() > b.length();\n        });\n        Trie* trie = new Trie();\n        // 遍历所有单词,如果已经存在字典树中则直接跳过,反之生成插入新单词\n        for(string& word:words){\n            reverse(word.begin(),word.end()); // 后缀检验和插入\n            if(trie->prefix(word)){\n                continue;\n            }\n            trie->insert(word);\n            hash.insert(word);\n        }\n\n        // 计算字典树中表征的单词个数\n        int ans = 0;\n        for(auto word:hash){\n            ans += word.length()+1;\n        }\n        return ans;\n    }\n};\n',normalizedContent:'# 05 字典树\n\n字典树一般用于判断字符串是否存在或者是否具有某种字符串前缀。如下图一个字典树中，存储了 a、to、tea、ted、ten、i、in 和 inn，以及它们的频率。\n\n为什么需要用字典树解决这类问题呢？假如我们有一个储存了近万个单词的字典，即使我们使用哈希，在其中搜索一个单词的实际开销也是非常大的，且无法轻易支持搜索单词前缀。然而由于一个英文单词的长度 n 通常在 10 以内，如果我们使用字典树，则可以在 o(n)——近似 o(1)的时间内完成搜索，且额外开销非常小。\n\n# 208 实现 trie (前缀树)\n\n尝试建立一个字典树，支持快速插入单词、查找单词、查找单词前缀的功能\n\n以下是数据结构的调用样例\n\n> 输入: ["trie", "insert", "search", "search", "startswith", "insert", "search"] [[], ["apple"], ["apple"], ["app"], ["app"], ["app"], ["app"]] 输出: [null, null, true, false, true, null, true]\n> \n> 解释: trie trie = new trie(); trie.insert("apple"); trie.search("apple"); // 返回 true trie.search("app"); // 返回 false trie.startswith("app"); // 返回 true trie.insert("app"); trie.search("app"); // 返回 true\n\nclass trie {\nprivate:\n    vector<trie*> children;\n    bool isend;\n\n    trie* searchprefix(string prefix) {\n        trie* node = this;\n        for (char ch : prefix) {\n            ch -= \'a\';\n            if (node->children[ch] == nullptr) {\n                return nullptr;\n            }\n            node = node->children[ch];\n        }\n        return node;\n    }\n\npublic:\n    trie() : children(26), isend(false) {}\n\n    void insert(string word) {\n        trie* node = this;\n        for (char ch : word) {\n            ch -= \'a\';\n            if (node->children[ch] == nullptr) {\n                node->children[ch] = new trie();\n            }\n            node = node->children[ch];\n        }\n        node->isend = true;\n    }\n\n    bool search(string word) {\n        trie* node = this->searchprefix(word);\n        return node != nullptr && node->isend;\n    }\n\n    bool startswith(string prefix) {\n        return this->searchprefix(prefix) != nullptr;\n    }\n};\n\n\n# 820 单词的压缩编码\n\n单词数组 words 的 有效编码 由任意助记字符串 s 和下标数组 indices 组成，且满足：\n\n * words.length == indices.length\n * 助记字符串 s 以 \'#\' 字符结尾\n * 对于每个下标 indices[i] ，s 的一个从 indices[i] 开始、到下一个 \'#\' 字符结束（但不包括 \'#\'）的 子字符串 恰好与 words[i] 相等\n\n给定一个单词数组 words ，返回成功对 words 进行编码的最小助记字符串 s 的长度 。\n\n> 输入：words = ["time", "me", "bell"]\n> \n> 输出：10\n> \n> 解释：一组有效编码为 s = "time#bell#" 和 indices = [0, 2, 5] 。 words[0] = "time" ，s 开始于 indices[0] = 0 到下一个 \'#\' 结束的子字符串，如加粗部分所示 "time#bell#" words[1] = "me" ，s 开始于 indices[1] = 2 到下一个 \'#\' 结束的子字符串，如加粗部分所示 "time#bell#" words[2] = "bell" ，s 开始于 indices[2] = 5 到下一个 \'#\' 结束的子字符串，如加粗部分所示 "time#bell#"\n\n解析:\n\nclass trie{\nprivate:\n    trie* child[26];\n    bool found;\npublic:\n    trie(){\n        for(int i=0;i<26;++i){\n            child[i] = nullptr;\n            found = false;\n        }\n    }\n\n    void insert(string word){\n        trie* node = this;\n        for(const auto ch:word){\n            if(node->child[ch-\'a\'] == nullptr){\n                node->child[ch-\'a\'] = new trie();\n            }\n            node = node->child[ch-\'a\'];\n        }\n        node->found = true;\n    }\n\n    bool search(string word){\n        trie* node = this;\n        for(const auto ch:word){\n            if(node->child[ch-\'a\']==nullptr){\n                return false;\n            }\n            node = node->child[ch-\'a\'];\n        }\n        return node->found;\n    }\n\n    bool prefix(string prefix){\n        trie* node = this;\n        for(const auto ch:prefix){\n            if(node->child[ch-\'a\']==nullptr){\n                return false;\n            }\n            node = node->child[ch-\'a\'];\n        }\n        return true;\n    }\n};\n\nclass solution {\npublic:\n    int minimumlengthencoding(vector<string>& words) {\n        unordered_set<string> hash;\n        // 要从长单词到短单词构建字典树\n        sort(words.begin(),words.end(),[](string& a, string& b){\n            return a.length() > b.length();\n        });\n        trie* trie = new trie();\n        // 遍历所有单词,如果已经存在字典树中则直接跳过,反之生成插入新单词\n        for(string& word:words){\n            reverse(word.begin(),word.end()); // 后缀检验和插入\n            if(trie->prefix(word)){\n                continue;\n            }\n            trie->insert(word);\n            hash.insert(word);\n        }\n\n        // 计算字典树中表征的单词个数\n        int ans = 0;\n        for(auto word:hash){\n            ans += word.length()+1;\n        }\n        return ans;\n    }\n};\n',charsets:{cjk:!0},lastUpdated:"2023/11/19, 12:55:48",lastUpdatedTimestamp:1700369748e3},{title:"04前中后序遍历",frontmatter:{title:"04前中后序遍历",date:"2023-03-24T18:39:50.000Z",permalink:"/pages/0480d5/"},regularPath:"/03.LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/02.%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/04.%E4%BA%8C%E5%8F%89%E6%A0%91/04.%E5%89%8D%E4%B8%AD%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86.html",relativePath:"03.LeetCode刷题笔记/02.基础数据结构/04.二叉树/04.前中后序遍历.md",key:"v-e2468eaa",path:"/pages/0480d5/",headers:[{level:2,title:"03 前中后序遍历",slug:"_03-前中后序遍历",normalizedTitle:"03 前中后序遍历",charIndex:2},{level:4,title:"144. 二叉树的前序遍历",slug:"_144-二叉树的前序遍历",normalizedTitle:"144. 二叉树的前序遍历",charIndex:578},{level:4,title:"145 二叉树的后序遍历",slug:"_145-二叉树的后序遍历",normalizedTitle:"145 二叉树的后序遍历",charIndex:1479},{level:4,title:"94 二叉树的中序遍历",slug:"_94-二叉树的中序遍历",normalizedTitle:"94 二叉树的中序遍历",charIndex:2425},{level:4,title:"105 从前序与中序遍历序列构造二叉树",slug:"_105-从前序与中序遍历序列构造二叉树",normalizedTitle:"105 从前序与中序遍历序列构造二叉树",charIndex:3508},{level:4,title:"106 从中序与后序遍历序列构造二叉树",slug:"_106-从中序与后序遍历序列构造二叉树",normalizedTitle:"106 从中序与后序遍历序列构造二叉树",charIndex:5820},{level:4,title:"889 根据前序和后序遍历构造二叉树",slug:"_889-根据前序和后序遍历构造二叉树",normalizedTitle:"889 根据前序和后序遍历构造二叉树",charIndex:7238}],headersStr:"03 前中后序遍历 144. 二叉树的前序遍历 145 二叉树的后序遍历 94 二叉树的中序遍历 105 从前序与中序遍历序列构造二叉树 106 从中序与后序遍历序列构造二叉树 889 根据前序和后序遍历构造二叉树",content:"# 03 前中后序遍历\n\n前序遍历、中序遍历和后序遍历是三种利用深度优先搜索遍历二叉树的方式。它们是在对节点访问的顺序有一点不同，其它完全相同。例如层次遍历得到的二叉数为 [1,2,3,4,5,6,7]\n\nNLR 其前序遍历结果为 [1,2,4,5,3,6,7]，先遍历父结点，再遍历左结点，最后遍历右节点\n\nvoid preorder(TreeNode* root) {\n    visit(root);\n    preorder(root->left);\n    preorder(root->right);\n}\n\n\nLNR 其中序遍历结果为[4,2,5,1,6,3,7]，先遍历左节点，再遍历父结点，最后遍历右节点\n\nvoid inorder(TreeNode* root) {\n    inorder(root->left);\n    visit(root);\n    inorder(root->right);\n}\n\n\nLRN 其后序遍历结果为 [4,5,2,6,7,3,1]，先遍历左节点，再遍历右结点，最后遍历父节点\n\nvoid postorder(TreeNode* root) {\n    postorder(root->left);\n    postorder(root->right);\n    visit(root);\n}\n\n\n# 144. 二叉树的前序遍历\n\n实现二叉树的前序遍历\n\n输入一个二叉树，输出一个数组，为二叉树前序遍历的结果\n\n> 输入：root = [1,null,2,3]\n>    1\n>     \\\n>      2\n>     /\n>    3 \n> 输出：[1,2,3]\n\n解析：\n\n二叉树的遍历用递归实现起来很简单，除了递归也可以使用迭代的思路实现，主要就是利用递归的本质就是栈调用，因此可以通过栈来实现二叉树的遍历。\n\n前序遍历是使用迭代思路实现的一种较为简单的情况，将根节点入栈，然后迭代逐层将左右节点入栈。需要注意的是前序遍历中，要注意右节点和左节点的入栈顺序。栈是先入后出的，为了先遍历左节点，让右节点先于左节点入栈，保证左节点先出栈。\n\nclass Solution {\npublic:\n    vector<int> preorderTraversal(TreeNode* root) {\n        vector<int> ans;\n        if(!root){\n            return ans;\n        }\n        stack<TreeNode*> s;\n        s.push(root);\n        while(!s.empty()){\n            TreeNode* node = s.top();\n            s.pop();\n            ans.push_back(node->val);\n            // 栈是先入后出的，所以先右子节点入栈再左子节点入栈，保证左节点先出栈\n            if(node->right){\n                s.push(node->right);\n            }\n            if(node->left){\n                s.push(node->left);\n            }\n        }\n        return ans;\n    }\n};\n\n\n# 145 二叉树的后序遍历\n\n实现二叉树的后序遍历\n\n输入一个二叉树，输出一个数组，为二叉树后序遍历的结果\n\n> 输入: [1,null,2,3]  \n>    1\n>     \\\n>      2\n>     /\n>    3 \n> 输出: [3,2,1]\n\n解析：\n\n二叉树的后序遍历的迭代实现可以直接基于前序遍历实现，因为前序的遍历顺序是 父左右 ，而后序遍历的顺序是 左右父。将前序遍历过程稍作修改就可以得到后序遍历结果：\n\n * 前序遍历中左右节点入栈顺序为右节点先于左节点，得到的遍历结果为 父左右 。\n\n * 如果前序遍历中入栈让左节点先于右节点，那么得到的遍历结果就是 父右左 。\n\n * 将这个得到的遍历结果反转就得到了后序遍历 左右父。\n\nclass Solution {\npublic:\n    vector<int> postorderTraversal(TreeNode* root) {\n        vector<int> ans;\n        if(!root){\n            return ans;\n        }\n        stack<TreeNode*> s;\n        s.push(root);\n        while(!s.empty()){\n            TreeNode* node = s.top();\n            s.pop();\n            ans.push_back(node->val);\n            // 让左节点先于右节点入栈\n            if(node->left){\n                s.push(node->left);\n            }\n            if(node->right){\n                s.push(node->right);\n            }\n        }\n        // 将遍历结果反转\n        reverse(ans.begin(),ans.end());\n        return ans;\n    }\n};\n\n\n# 94 二叉树的中序遍历\n\n实现二叉树的中序遍历\n\n输入一个二叉树，输出一个数组，为二叉树中序遍历的结果\n\n> 输入：root = [1,null,2,3]\n>    1\n>     \\\n>      2\n>     /\n>    3 \n> 输出：[1,3,2]\n\n解析：\n\n迭代实现二叉树的中序遍历要难于前序遍历。根据他们的递归实现可知，前序遍历是自上而下的递归，从根节点处理到子节点，而中序则是从左子树的最左边的叶子节点开始处理，是自下而上的递归。\n\n节点访问过程：由于是自下而上的访问，使用迭代实现中序遍历需要一个额外的指针来访问节点，从根节点一层层向左访问到左子树的最左边的叶子节点并逐个入栈，再开始向上迭代处理节点值。完成访问之后，栈中保存的是从根节点到最左边的叶子节点路径上的所有节点，他们都是左节点。\n\n节点处理过程：直接取栈顶元素将其值加入结果集，然后查看它是否具有右节点。如果有右节点则使用指针从该节点开始进行和根节点一样的访问过程，将从该节点开始到以该节点为根节点的子树的最左叶子节点路径上的所有节点入栈。完成访问之后再重复处理过程，最终完成所有节点的访问和处理。\n\npublic:\n    vector<int> inorderTraversal(TreeNode* root) {\n        vector<int> ans;\n        if(!root){\n            return ans;\n        }\n        stack<TreeNode*> s;\n        TreeNode* cur = root;\n        while(cur || !s.empty()){\n            if(cur){\n                // 从根节点到最左叶子节点的访问过程\n                s.push(cur);\n                cur = cur->left;\n            }else{\n                // 自下而上 左中右的节点处理过程\n                cur = s.top();\n                s.pop();\n                ans.push_back(cur->val);\n                cur = cur->right;\n            }\n        }\n        return ans;\n    }\n};\n\n\n# 105 从前序与中序遍历序列构造二叉树\n\n给定一个二叉树的前序遍历和中序遍历结果，尝试复原这个树。已知树里不存在重复值的节点。\n\n输入是两个一维数组，分别表示树的前序遍历和中序遍历结果；输出是一个二叉树。\n\n> 输入: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7] 输出: [3,9,20,null,null,15,7]\n\n解析：\n\n前序遍历结果+中序遍历结果，或者后序遍历结果+中序遍历结果可以唯一确定二叉树结构。以前序+中序为例，先在前序中从左到右找根节点，然后在中序中找到根节点位置，此时中序中根节点的左侧就是左子树，右侧就是右子树。以preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]为例：\n\n * 前序中找到第一个根节点 3，在中序中区分 3 的左子树长度为 1 包含9，右子树长度为 3 包含15,20,7\n * 前序中找到根节点为 9 的左子树根节点，在中序中发现其左侧为空，右侧为根节点，所以没有左右子树\n * 前序中找到根节点为 20 的右子树根节点，在中序中区分 20 的左子树长度为 1 包含15，右子树长度为 1 包含7\n * 前序中找到根节点为 15 的左子树根节点，在中序中发现其左侧长度为0，右侧长度也为0，所以没有左右子树\n * 前序中找到根节点为 7 的左子树根节点，在中序中发现其左侧长度为0，右侧为空，所以没有左右子树\n * 最终构成了二叉数的层次遍历为[3,9,20,null,null,15,7]\n\n可以看出根据遍历结果构造二叉树的核心思想就是：在前序或者后序遍历结果中找到根节点，然后在中序遍历中对根节点进行定位找出根节点的左右子树。\n\n在中序遍历中对根节点进行定位时，一种简单的方法是直接扫描整个中序遍历的结果并找出根节点，但这样做的时间复杂度较高。为了便于检索，可以使用哈希表预处理中序遍历的结果，将中序遍历以 <节点值, 中序位置> 存储在哈希表中。\n\n定位根节点之后，构建一个节点，并计算该根节点的左子树节点数目，定义当前根节点子树的左右边界。然后根据边界递归定位其左右子节点。\n\nclass Solution {\npublic:\n\t/*\n\t * leftBound 中序中当前根节点的左子树的最左节点的位置\n\t * rightBound 中序中当前根节点的右子树的最右节点的位置\n\t * rootPreIndex 前序中当前根节点的位置\n\t*/\n    TreeNode* helper(unordered_map<int,int>& hash, vector<int>& preorder, int leftBound, int rightBound, int rootPreIndex){\n        if(leftBound > rightBound){\n            return nullptr;\n        }\n        // 根据前序找到中序中根节点的位置，并计算左子树节点数目\n        int rootVal = preorder[rootPreIndex];\n        int rootInIndex = hash[rootVal];\n        int leftLen = rootInIndex - leftBound + 1;\n        // 构建节点\n        TreeNode* node = new TreeNode(rootVal);\n        // 递归构建左右子节点，类似二分查找改变左右边界\n        // 左子节点为其左子树的根节点，leftBound不变，rightBound变成中序中当前根节点的前一个位置，前序中根节点的后一个节点就是左子数的根节点 rootPreIndex+1\n        node->left = helper(hash,preorder,leftBound,rootInIndex-1,rootPreIndex+1);\n        // 右子节点为其右子树的根节点，leftBound变成中序中当前根节点的后一个位置，rightBound不变，前序中根节点跨过左子树节点数目的长度就是右子数的根节点 rootPreIndex+leftLen+1\n        node->right = helper(hash,preorder,rootInIndex+1,rightBound,rootPreIndex+leftLen);\n        return node;\n    }\n\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\n        if(preorder.empty()){\n            return nullptr;\n        }\n        // 用哈希表预处理中序遍历 <节点值, 中序位置>\n        unordered_map<int,int> hash;\n        for(int i=0;i<inorder.size();++i){\n            hash[inorder[i]] = i;\n        }\n\n        return helper(hash,preorder,0,inorder.size()-1,0);\n    }\n};\n\n\n# 106 从中序与后序遍历序列构造二叉树\n\n给定一个二叉树的后序遍历和中序遍历结果，尝试复原这个树。已知树里不存在重复值的节点。\n\n输入是两个一维数组，分别表示树的后序遍历和中序遍历结果；输出是一个二叉树。\n\n> 输入：中序遍历 inorder = [9,3,15,20,7]，后序遍历 postorder = [9,15,7,20,3]\n> \n> 输出：如下二叉树\n> \n>     3\n>    / \\\n>   9  20\n>     /  \\\n>    15   7\n\n解析：\n\n后序+中序和前序+中序本质是没有什么区别，同样采用哈希表预处理中序遍历 <节点值, 中序位置>，然后递归构造二叉树，但是需要注意的是构造过程中，根据后序找到中序中根节点的位置，确定右子树根节点，并计算其右子树节点数目。然后根据右子树数目确定左子树根节点和左右边界。\n\nclass Solution {\npublic:\n\n    TreeNode* helper(unordered_map<int,int>& hash, vector<int>& postorder, int leftBound, int rightBound, int rootPostIndex){\n        if(leftBound > rightBound){\n            return nullptr;\n        }\n        int rootVal = postorder[rootPostIndex];\n        int rootInIndex = hash[rootVal];\n        // 计算其右子树节点数目\n        int rightLen = rightBound - rootInIndex + 1;\n        \n        TreeNode* node = new TreeNode(rootVal);\n        // 根据右子树数目确定左子树根节点和左右边界\n        node->left = helper(hash,postorder,leftBound,rootInIndex-1,rootPostIndex-rightLen);\n        node->right = helper(hash,postorder,rootInIndex+1,rightBound,rootPostIndex-1);\n        return node;\n    }\n\n    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\n        if(postorder.empty()){\n            return nullptr;\n        }\n        unordered_map<int,int> hash;\n        for(int i=0;i<inorder.size();++i){\n            hash[inorder[i]] = i;\n        }\n\n        return helper(hash,postorder,0,inorder.size()-1,postorder.size()-1);\n    }\n};\n\n\n# 889 根据前序和后序遍历构造二叉树\n\n给定一个二叉树的前序遍历和后序遍历结果，尝试复原这个树。已知树里不存在重复值的节点。\n\n输入是两个一维数组，分别表示树的前序遍历和后序遍历结果；输出是一个二叉树。\n\n> 输入：pre = [1,2,4,5,3,6,7], post = [4,5,2,6,7,3,1]\n> 输出：[1,2,3,4,5,6,7]\n\n解析：\n\n前序+后序，与中序与其中之一组合构造二叉树的区别在于增加的区分左右子树的难度，但是核心思想还是一致的：在前序或者后序遍历结果中找到根节点，然后在另一个遍历结果中找出根节点的左右子树。\n\n前序遍历为：(根结点) (前序遍历左分支) (前序遍历右分支)\n\n后序遍历为：(后序遍历左分支) (后序遍历右分支) (根结点)\n\n假设通过前序找根节点，通过后续确定根节点的左右子树。从根节点开始，假设其左子树包含的节点数目为 leftLen，已知的是该左子树的根节点在前序中是 pre[1]，那么他在后序则是post[leftLen-1]，由此可以得出根节点左子树的数目leftLen = post.indexOf(pre[1]) + 1。所以左子树的范围是post[0:leftLen)；同理，根节点的右子树范围为post[leftLen:post.size()-1)，根节点为post[post.size()-1]。\n\n同样为了便于检索，我们使用哈希表预处理后序遍历的结果，将中序遍历以 <节点值, 中序位置> 存储在哈希表中。\n\n递归过程：定位根节点之后，构建一个节点，并计算该根节点的左子树节点数目，定义当前根节点子树的左右边界。然后根据边界递归定位其左右子节点。值得注意的是递归开始之前要先构造根节点。\n\nclass Solution {\npublic:\n    TreeNode* helper(unordered_map<int,int> hash, vector<int>& preorder, int leftBound, int rigthBound, int rootPreIndex, int preEnd){\n        if(rootPreIndex > preEnd){\n            return nullptr;\n        }\n  \n        int rootVal = preorder[rootPreIndex];\n        TreeNode* node = new TreeNode(rootVal);\n        // preEnd 就是当前子树在前序序列中最后一个节点所在位置\n        // 计算之前判断当前节点是否是叶子节点，要先判断否则会越界\n        if(rootPreIndex+1 > preEnd){\n            return node;\n        }\n        // 根据当前根节点的左节点在后序序列中的位置计算左子树包含的节点数\n        int leftChildPostIndex = hash[preorder[rootPreIndex+1]];\n        int leftLen = leftChildPostIndex - leftBound + 1;\n\t\t\n        // 左子树在后序序列的范围是 [leftBound,leftChildPostIndex]\n        // 当前根节点的左节点为其前序序列的后一位 rootPreIndex+1\n        // 左子树在前序序列的最后一个节点是 rootPreIndex+leftLen\n        node->left = helper(hash,preorder,leftBound,leftChildPostIndex,rootPreIndex+1,rootPreIndex+leftLen);\n        // 右子树在后序序列的范围是 [leftChildPostIndex+1,rigthBound-1]（减去根节点）\n        // 当前根节点的右节点为其前序序列的后左子数节点数加一 rootPreIndex+leftLen+1\n        // 右子树不用考虑其在前序的结束边界\n        node->right = helper(hash,preorder,leftChildPostIndex+1,rigthBound-1,rootPreIndex+leftLen+1,preEnd);\n        return node;\n    }\n\n    TreeNode* constructFromPrePost(vector<int>& preorder, vector<int>& postorder) {\n        int len = preorder.size();\n        if(len == 0){\n            return nullptr;\n        }\n\n        unordered_map<int,int> hash;\n        for(int i=0;i<len-1;++i){\n            hash[postorder[i]] = i;\n        }\n\n        return helper(hash,preorder,0,len-1,0,len-1);\n    }\n};\n",normalizedContent:"# 03 前中后序遍历\n\n前序遍历、中序遍历和后序遍历是三种利用深度优先搜索遍历二叉树的方式。它们是在对节点访问的顺序有一点不同，其它完全相同。例如层次遍历得到的二叉数为 [1,2,3,4,5,6,7]\n\nnlr 其前序遍历结果为 [1,2,4,5,3,6,7]，先遍历父结点，再遍历左结点，最后遍历右节点\n\nvoid preorder(treenode* root) {\n    visit(root);\n    preorder(root->left);\n    preorder(root->right);\n}\n\n\nlnr 其中序遍历结果为[4,2,5,1,6,3,7]，先遍历左节点，再遍历父结点，最后遍历右节点\n\nvoid inorder(treenode* root) {\n    inorder(root->left);\n    visit(root);\n    inorder(root->right);\n}\n\n\nlrn 其后序遍历结果为 [4,5,2,6,7,3,1]，先遍历左节点，再遍历右结点，最后遍历父节点\n\nvoid postorder(treenode* root) {\n    postorder(root->left);\n    postorder(root->right);\n    visit(root);\n}\n\n\n# 144. 二叉树的前序遍历\n\n实现二叉树的前序遍历\n\n输入一个二叉树，输出一个数组，为二叉树前序遍历的结果\n\n> 输入：root = [1,null,2,3]\n>    1\n>     \\\n>      2\n>     /\n>    3 \n> 输出：[1,2,3]\n\n解析：\n\n二叉树的遍历用递归实现起来很简单，除了递归也可以使用迭代的思路实现，主要就是利用递归的本质就是栈调用，因此可以通过栈来实现二叉树的遍历。\n\n前序遍历是使用迭代思路实现的一种较为简单的情况，将根节点入栈，然后迭代逐层将左右节点入栈。需要注意的是前序遍历中，要注意右节点和左节点的入栈顺序。栈是先入后出的，为了先遍历左节点，让右节点先于左节点入栈，保证左节点先出栈。\n\nclass solution {\npublic:\n    vector<int> preordertraversal(treenode* root) {\n        vector<int> ans;\n        if(!root){\n            return ans;\n        }\n        stack<treenode*> s;\n        s.push(root);\n        while(!s.empty()){\n            treenode* node = s.top();\n            s.pop();\n            ans.push_back(node->val);\n            // 栈是先入后出的，所以先右子节点入栈再左子节点入栈，保证左节点先出栈\n            if(node->right){\n                s.push(node->right);\n            }\n            if(node->left){\n                s.push(node->left);\n            }\n        }\n        return ans;\n    }\n};\n\n\n# 145 二叉树的后序遍历\n\n实现二叉树的后序遍历\n\n输入一个二叉树，输出一个数组，为二叉树后序遍历的结果\n\n> 输入: [1,null,2,3]  \n>    1\n>     \\\n>      2\n>     /\n>    3 \n> 输出: [3,2,1]\n\n解析：\n\n二叉树的后序遍历的迭代实现可以直接基于前序遍历实现，因为前序的遍历顺序是 父左右 ，而后序遍历的顺序是 左右父。将前序遍历过程稍作修改就可以得到后序遍历结果：\n\n * 前序遍历中左右节点入栈顺序为右节点先于左节点，得到的遍历结果为 父左右 。\n\n * 如果前序遍历中入栈让左节点先于右节点，那么得到的遍历结果就是 父右左 。\n\n * 将这个得到的遍历结果反转就得到了后序遍历 左右父。\n\nclass solution {\npublic:\n    vector<int> postordertraversal(treenode* root) {\n        vector<int> ans;\n        if(!root){\n            return ans;\n        }\n        stack<treenode*> s;\n        s.push(root);\n        while(!s.empty()){\n            treenode* node = s.top();\n            s.pop();\n            ans.push_back(node->val);\n            // 让左节点先于右节点入栈\n            if(node->left){\n                s.push(node->left);\n            }\n            if(node->right){\n                s.push(node->right);\n            }\n        }\n        // 将遍历结果反转\n        reverse(ans.begin(),ans.end());\n        return ans;\n    }\n};\n\n\n# 94 二叉树的中序遍历\n\n实现二叉树的中序遍历\n\n输入一个二叉树，输出一个数组，为二叉树中序遍历的结果\n\n> 输入：root = [1,null,2,3]\n>    1\n>     \\\n>      2\n>     /\n>    3 \n> 输出：[1,3,2]\n\n解析：\n\n迭代实现二叉树的中序遍历要难于前序遍历。根据他们的递归实现可知，前序遍历是自上而下的递归，从根节点处理到子节点，而中序则是从左子树的最左边的叶子节点开始处理，是自下而上的递归。\n\n节点访问过程：由于是自下而上的访问，使用迭代实现中序遍历需要一个额外的指针来访问节点，从根节点一层层向左访问到左子树的最左边的叶子节点并逐个入栈，再开始向上迭代处理节点值。完成访问之后，栈中保存的是从根节点到最左边的叶子节点路径上的所有节点，他们都是左节点。\n\n节点处理过程：直接取栈顶元素将其值加入结果集，然后查看它是否具有右节点。如果有右节点则使用指针从该节点开始进行和根节点一样的访问过程，将从该节点开始到以该节点为根节点的子树的最左叶子节点路径上的所有节点入栈。完成访问之后再重复处理过程，最终完成所有节点的访问和处理。\n\npublic:\n    vector<int> inordertraversal(treenode* root) {\n        vector<int> ans;\n        if(!root){\n            return ans;\n        }\n        stack<treenode*> s;\n        treenode* cur = root;\n        while(cur || !s.empty()){\n            if(cur){\n                // 从根节点到最左叶子节点的访问过程\n                s.push(cur);\n                cur = cur->left;\n            }else{\n                // 自下而上 左中右的节点处理过程\n                cur = s.top();\n                s.pop();\n                ans.push_back(cur->val);\n                cur = cur->right;\n            }\n        }\n        return ans;\n    }\n};\n\n\n# 105 从前序与中序遍历序列构造二叉树\n\n给定一个二叉树的前序遍历和中序遍历结果，尝试复原这个树。已知树里不存在重复值的节点。\n\n输入是两个一维数组，分别表示树的前序遍历和中序遍历结果；输出是一个二叉树。\n\n> 输入: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7] 输出: [3,9,20,null,null,15,7]\n\n解析：\n\n前序遍历结果+中序遍历结果，或者后序遍历结果+中序遍历结果可以唯一确定二叉树结构。以前序+中序为例，先在前序中从左到右找根节点，然后在中序中找到根节点位置，此时中序中根节点的左侧就是左子树，右侧就是右子树。以preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]为例：\n\n * 前序中找到第一个根节点 3，在中序中区分 3 的左子树长度为 1 包含9，右子树长度为 3 包含15,20,7\n * 前序中找到根节点为 9 的左子树根节点，在中序中发现其左侧为空，右侧为根节点，所以没有左右子树\n * 前序中找到根节点为 20 的右子树根节点，在中序中区分 20 的左子树长度为 1 包含15，右子树长度为 1 包含7\n * 前序中找到根节点为 15 的左子树根节点，在中序中发现其左侧长度为0，右侧长度也为0，所以没有左右子树\n * 前序中找到根节点为 7 的左子树根节点，在中序中发现其左侧长度为0，右侧为空，所以没有左右子树\n * 最终构成了二叉数的层次遍历为[3,9,20,null,null,15,7]\n\n可以看出根据遍历结果构造二叉树的核心思想就是：在前序或者后序遍历结果中找到根节点，然后在中序遍历中对根节点进行定位找出根节点的左右子树。\n\n在中序遍历中对根节点进行定位时，一种简单的方法是直接扫描整个中序遍历的结果并找出根节点，但这样做的时间复杂度较高。为了便于检索，可以使用哈希表预处理中序遍历的结果，将中序遍历以 <节点值, 中序位置> 存储在哈希表中。\n\n定位根节点之后，构建一个节点，并计算该根节点的左子树节点数目，定义当前根节点子树的左右边界。然后根据边界递归定位其左右子节点。\n\nclass solution {\npublic:\n\t/*\n\t * leftbound 中序中当前根节点的左子树的最左节点的位置\n\t * rightbound 中序中当前根节点的右子树的最右节点的位置\n\t * rootpreindex 前序中当前根节点的位置\n\t*/\n    treenode* helper(unordered_map<int,int>& hash, vector<int>& preorder, int leftbound, int rightbound, int rootpreindex){\n        if(leftbound > rightbound){\n            return nullptr;\n        }\n        // 根据前序找到中序中根节点的位置，并计算左子树节点数目\n        int rootval = preorder[rootpreindex];\n        int rootinindex = hash[rootval];\n        int leftlen = rootinindex - leftbound + 1;\n        // 构建节点\n        treenode* node = new treenode(rootval);\n        // 递归构建左右子节点，类似二分查找改变左右边界\n        // 左子节点为其左子树的根节点，leftbound不变，rightbound变成中序中当前根节点的前一个位置，前序中根节点的后一个节点就是左子数的根节点 rootpreindex+1\n        node->left = helper(hash,preorder,leftbound,rootinindex-1,rootpreindex+1);\n        // 右子节点为其右子树的根节点，leftbound变成中序中当前根节点的后一个位置，rightbound不变，前序中根节点跨过左子树节点数目的长度就是右子数的根节点 rootpreindex+leftlen+1\n        node->right = helper(hash,preorder,rootinindex+1,rightbound,rootpreindex+leftlen);\n        return node;\n    }\n\n    treenode* buildtree(vector<int>& preorder, vector<int>& inorder) {\n        if(preorder.empty()){\n            return nullptr;\n        }\n        // 用哈希表预处理中序遍历 <节点值, 中序位置>\n        unordered_map<int,int> hash;\n        for(int i=0;i<inorder.size();++i){\n            hash[inorder[i]] = i;\n        }\n\n        return helper(hash,preorder,0,inorder.size()-1,0);\n    }\n};\n\n\n# 106 从中序与后序遍历序列构造二叉树\n\n给定一个二叉树的后序遍历和中序遍历结果，尝试复原这个树。已知树里不存在重复值的节点。\n\n输入是两个一维数组，分别表示树的后序遍历和中序遍历结果；输出是一个二叉树。\n\n> 输入：中序遍历 inorder = [9,3,15,20,7]，后序遍历 postorder = [9,15,7,20,3]\n> \n> 输出：如下二叉树\n> \n>     3\n>    / \\\n>   9  20\n>     /  \\\n>    15   7\n\n解析：\n\n后序+中序和前序+中序本质是没有什么区别，同样采用哈希表预处理中序遍历 <节点值, 中序位置>，然后递归构造二叉树，但是需要注意的是构造过程中，根据后序找到中序中根节点的位置，确定右子树根节点，并计算其右子树节点数目。然后根据右子树数目确定左子树根节点和左右边界。\n\nclass solution {\npublic:\n\n    treenode* helper(unordered_map<int,int>& hash, vector<int>& postorder, int leftbound, int rightbound, int rootpostindex){\n        if(leftbound > rightbound){\n            return nullptr;\n        }\n        int rootval = postorder[rootpostindex];\n        int rootinindex = hash[rootval];\n        // 计算其右子树节点数目\n        int rightlen = rightbound - rootinindex + 1;\n        \n        treenode* node = new treenode(rootval);\n        // 根据右子树数目确定左子树根节点和左右边界\n        node->left = helper(hash,postorder,leftbound,rootinindex-1,rootpostindex-rightlen);\n        node->right = helper(hash,postorder,rootinindex+1,rightbound,rootpostindex-1);\n        return node;\n    }\n\n    treenode* buildtree(vector<int>& inorder, vector<int>& postorder) {\n        if(postorder.empty()){\n            return nullptr;\n        }\n        unordered_map<int,int> hash;\n        for(int i=0;i<inorder.size();++i){\n            hash[inorder[i]] = i;\n        }\n\n        return helper(hash,postorder,0,inorder.size()-1,postorder.size()-1);\n    }\n};\n\n\n# 889 根据前序和后序遍历构造二叉树\n\n给定一个二叉树的前序遍历和后序遍历结果，尝试复原这个树。已知树里不存在重复值的节点。\n\n输入是两个一维数组，分别表示树的前序遍历和后序遍历结果；输出是一个二叉树。\n\n> 输入：pre = [1,2,4,5,3,6,7], post = [4,5,2,6,7,3,1]\n> 输出：[1,2,3,4,5,6,7]\n\n解析：\n\n前序+后序，与中序与其中之一组合构造二叉树的区别在于增加的区分左右子树的难度，但是核心思想还是一致的：在前序或者后序遍历结果中找到根节点，然后在另一个遍历结果中找出根节点的左右子树。\n\n前序遍历为：(根结点) (前序遍历左分支) (前序遍历右分支)\n\n后序遍历为：(后序遍历左分支) (后序遍历右分支) (根结点)\n\n假设通过前序找根节点，通过后续确定根节点的左右子树。从根节点开始，假设其左子树包含的节点数目为 leftlen，已知的是该左子树的根节点在前序中是 pre[1]，那么他在后序则是post[leftlen-1]，由此可以得出根节点左子树的数目leftlen = post.indexof(pre[1]) + 1。所以左子树的范围是post[0:leftlen)；同理，根节点的右子树范围为post[leftlen:post.size()-1)，根节点为post[post.size()-1]。\n\n同样为了便于检索，我们使用哈希表预处理后序遍历的结果，将中序遍历以 <节点值, 中序位置> 存储在哈希表中。\n\n递归过程：定位根节点之后，构建一个节点，并计算该根节点的左子树节点数目，定义当前根节点子树的左右边界。然后根据边界递归定位其左右子节点。值得注意的是递归开始之前要先构造根节点。\n\nclass solution {\npublic:\n    treenode* helper(unordered_map<int,int> hash, vector<int>& preorder, int leftbound, int rigthbound, int rootpreindex, int preend){\n        if(rootpreindex > preend){\n            return nullptr;\n        }\n  \n        int rootval = preorder[rootpreindex];\n        treenode* node = new treenode(rootval);\n        // preend 就是当前子树在前序序列中最后一个节点所在位置\n        // 计算之前判断当前节点是否是叶子节点，要先判断否则会越界\n        if(rootpreindex+1 > preend){\n            return node;\n        }\n        // 根据当前根节点的左节点在后序序列中的位置计算左子树包含的节点数\n        int leftchildpostindex = hash[preorder[rootpreindex+1]];\n        int leftlen = leftchildpostindex - leftbound + 1;\n\t\t\n        // 左子树在后序序列的范围是 [leftbound,leftchildpostindex]\n        // 当前根节点的左节点为其前序序列的后一位 rootpreindex+1\n        // 左子树在前序序列的最后一个节点是 rootpreindex+leftlen\n        node->left = helper(hash,preorder,leftbound,leftchildpostindex,rootpreindex+1,rootpreindex+leftlen);\n        // 右子树在后序序列的范围是 [leftchildpostindex+1,rigthbound-1]（减去根节点）\n        // 当前根节点的右节点为其前序序列的后左子数节点数加一 rootpreindex+leftlen+1\n        // 右子树不用考虑其在前序的结束边界\n        node->right = helper(hash,preorder,leftchildpostindex+1,rigthbound-1,rootpreindex+leftlen+1,preend);\n        return node;\n    }\n\n    treenode* constructfromprepost(vector<int>& preorder, vector<int>& postorder) {\n        int len = preorder.size();\n        if(len == 0){\n            return nullptr;\n        }\n\n        unordered_map<int,int> hash;\n        for(int i=0;i<len-1;++i){\n            hash[postorder[i]] = i;\n        }\n\n        return helper(hash,preorder,0,len-1,0,len-1);\n    }\n};\n",charsets:{cjk:!0},lastUpdated:"2023/11/19, 12:55:48",lastUpdatedTimestamp:1700369748e3},{title:"08二叉搜索树BST",frontmatter:{title:"08二叉搜索树BST",date:"2023-03-24T18:39:50.000Z",permalink:"/pages/01f1e6/"},regularPath:"/03.LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/02.%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/04.%E4%BA%8C%E5%8F%89%E6%A0%91/08.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91BST.html",relativePath:"03.LeetCode刷题笔记/02.基础数据结构/04.二叉树/08.二叉搜索树BST.md",key:"v-0c19afd3",path:"/pages/01f1e6/",headers:[{level:2,title:"二叉搜索树 BST",slug:"二叉搜索树-bst",normalizedTitle:"二叉搜索树 bst",charIndex:2},{level:3,title:"什么是二叉搜索树",slug:"什么是二叉搜索树",normalizedTitle:"什么是二叉搜索树",charIndex:16},{level:3,title:"BST 的节点属性",slug:"bst-的节点属性",normalizedTitle:"bst 的节点属性",charIndex:364},{level:3,title:"BST 的中序遍历",slug:"bst-的中序遍历",normalizedTitle:"bst 的中序遍历",charIndex:625},{level:3,title:"BST 搜索",slug:"bst-搜索",normalizedTitle:"bst 搜索",charIndex:1740},{level:3,title:"BST 插入",slug:"bst-插入",normalizedTitle:"bst 插入",charIndex:2594},{level:3,title:"BST 删除的三种情况",slug:"bst-删除的三种情况",normalizedTitle:"bst 删除的三种情况",charIndex:3167},{level:4,title:"1 目标节点是叶子节点",slug:"_1-目标节点是叶子节点",normalizedTitle:"1 目标节点是叶子节点",charIndex:3313},{level:4,title:"2 目标节点有一个子节点",slug:"_2-目标节点有一个子节点",normalizedTitle:"2 目标节点有一个子节点",charIndex:3420},{level:4,title:"3 目标节点有两个子节点",slug:"_3-目标节点有两个子节点",normalizedTitle:"3 目标节点有两个子节点",charIndex:3548},{level:2,title:"平衡二叉搜索树",slug:"平衡二叉搜索树",normalizedTitle:"平衡二叉搜索树",charIndex:4425},{level:2,title:"自平衡二叉搜索树 AVL",slug:"自平衡二叉搜索树-avl",normalizedTitle:"自平衡二叉搜索树 avl",charIndex:4923},{level:3,title:"什么是 AVL",slug:"什么是-avl",normalizedTitle:"什么是 avl",charIndex:4940},{level:3,title:"树的旋转",slug:"树的旋转",normalizedTitle:"树的旋转",charIndex:5212},{level:4,title:"1 LL 单旋转",slug:"_1-ll-单旋转",normalizedTitle:"1 ll 单旋转",charIndex:5521},{level:4,title:"2 RR 单旋转",slug:"_2-rr-单旋转",normalizedTitle:"2 rr 单旋转",charIndex:6667},{level:4,title:"3 LR 双旋转",slug:"_3-lr-双旋转",normalizedTitle:"3 lr 双旋转",charIndex:7828},{level:4,title:"4 RL 双旋转",slug:"_4-rl-双旋转",normalizedTitle:"4 rl 双旋转",charIndex:8269},{level:3,title:"AVL 插入与删除",slug:"avl-插入与删除",normalizedTitle:"avl 插入与删除",charIndex:8711},{level:4,title:"1 AVL 插入",slug:"_1-avl-插入",normalizedTitle:"1 avl 插入",charIndex:8724},{level:4,title:"2 AVL 删除",slug:"_2-avl-删除",normalizedTitle:"2 avl 删除",charIndex:8977}],headersStr:"二叉搜索树 BST 什么是二叉搜索树 BST 的节点属性 BST 的中序遍历 BST 搜索 BST 插入 BST 删除的三种情况 1 目标节点是叶子节点 2 目标节点有一个子节点 3 目标节点有两个子节点 平衡二叉搜索树 自平衡二叉搜索树 AVL 什么是 AVL 树的旋转 1 LL 单旋转 2 RR 单旋转 3 LR 双旋转 4 RL 双旋转 AVL 插入与删除 1 AVL 插入 2 AVL 删除",content:"# 二叉搜索树 BST\n\n\n# 什么是二叉搜索树\n\n二叉搜索树（又称：二叉查找树，二叉排序树，Binary Search Tree, BST）是一种特殊的二叉树：对于每个父节点，其左子节点的值小于等于父结点的值，其右子节点的值大于等于父结点的值。\n\n因此对于一个二叉搜索树，我们可以在 O(nlogn) 的时间内查找一个值是否存在：从根节点开始，若当前节点的值大于查找值则向左下走，若当前节点的值小于查找值则向右下走。\n\n同时因为二叉查找树是有序的，对其中序遍历的结果即为排好序的数组。\n\n一个二叉搜索树实例[15,6,23,4,7,null,71,null,5,null,null,null,null,50,null]如下图所示：\n\n\n\n二叉搜索树除了创建二叉树之外的基本操作有三种：（1）搜索（2）插入 （3）删除\n\n\n# BST 的节点属性\n\n和普通二叉树一样，二叉搜索树的每个节点至少有 3 个属性：左孩子，右孩子和数据值，它然节点还可以包含其他潜在的属性。 二叉搜索树节点的结构体声明可以如下：\n\nstruct Node {\n\tT data; // T 代表模板类\n\tNode* left;\n\tNode* right;\n};\n\n\n二叉搜索树的节点放置规则是：任何节点的数据值一定大于其左子树中的每个节点的数据值，并小于其右子树中的每个节点的数据值。所以，在遍历二叉搜索树时，一直往左走可以得到最小元素，一直往右走可以得到最大元素。\n\n\n# BST 的中序遍历\n\n我们再来复习一遍二叉搜索树的特性：左子树上所有结点的值均小于它的根结点的值，右子树上所有结点的值均大于它的根结点的值。\n\n依据这一特性我们可以推出二叉搜索树的另一个重要特性：二叉搜索树的中序遍历序列是一个递增序列。\n\n二叉搜索树的中序遍历实现和普通二叉树一样，也有递归和非递归的实现方式。但是无论 BST 的高度如何，中序遍历的时间复杂度都是O(N)。\n\n**（1）递归实现方式：**先遍历左节点，再遍历父结点，最后遍历右节点\n\nvoid inorder(Node* root) {\n    inorder(root->left);\n    visit(root);\n    inorder(root->right);\n}\n\n\n（2）非递归实现方式：\n\n二叉树中序遍历是从左子树的最左边的叶子节点开始处理，是自下而上的递归。\n\n节点访问过程：由于是自下而上的访问，使用迭代实现中序遍历需要一个额外的指针来访问节点，从根节点一层层向左访问到左子树的最左边的叶子节点并逐个入栈，再开始向上迭代处理节点值。完成访问之后，栈中保存的是从根节点到最左边的叶子节点路径上的所有节点，他们都是左节点。\n\n节点处理过程：直接取栈顶元素将其值加入结果集，然后查看它是否具有右节点。如果有右节点则使用指针从该节点开始进行和根节点一样的访问过程，将从该节点开始到以该节点为根节点的子树的最左叶子节点路径上的所有节点入栈。完成访问之后再重复处理过程，最终完成所有节点的访问和处理。\n\n实现代码如下：\n\nvector<int> inorderTraversal(TreeNode* root) {\n\tvector<int> ans;\n\tif(!root){\n\t    return ans;\n\t}\n\tstack<TreeNode*> s;\n\tTreeNode* cur = root;\n\twhile(cur || !s.empty()){\n        if(cur){\n            // 从根节点到最左叶子节点的访问过程\n            s.push(cur);\n            cur = cur->left;\n        }else{\n            // 自下而上 左中右的节点处理过程\n            cur = s.top();\n            s.pop();\n            ans.push_back(cur->val);\n            cur = cur->right;\n        }\n\t}\n\treturn ans;\n}\n\n\n\n# BST 搜索\n\n二叉搜索树，最为基础的操作当然就是搜索了。\n\n二叉树搜索过程中使用根结点 root 和目标值 target 进行比较，不同情况处理如下：\n\n * 若 target 小于根结点键值，只需在左子树中继续搜索\n * 如果 target 大于根结点的键值，在右子树中进行继续搜索\n * 若两者比较结果是相等，搜索完成，返回指向此结点的指针。\n\n\n\n搜索过程的代码实现如下：\n\nNode* find(Node* t, T target) {\n\tif (t == NULL) return NULL;\n\tif (target < t->data) return find(t->left, target);\n\tif (target > t->data) return find(t->right, target);\n\treturn t;\n}\n\n\n除了快速搜索目标值，二叉搜索树中还可以快速查找最大值和最小值。\n\n查找最大值和最小值\n\n二叉搜索树的节点放置规则是：任何节点的数据值一定大于其左子树中的每个节点的数据值，并小于其右子树中的每个节点的数据值。所以，在遍历二叉搜索树时，一直往左走就可以得到最小元素，一直往右走就可以得到最大元素。\n\n查找最大值和最小值的代码实现如下：\n\n// 查找最小值\nNode* findMin(Node* t) {\n\tif (t == NULL || t->left == NULL) return t;\n\treturn findMin(t->left);\n}\n\n// 查找最大值\nNode* findMax(Node* t) {\n\tif (t == NULL || t->right == NULL) return t;\n\treturn findMax(t->right);\n}\n\n\n二叉搜索树的搜索时间复杂度与其自身高度 h 相关，通常为O(h)。但值得注意的是：在普通的 BST 中其自身高度 h 可能和元素 O(N) 一样高，即向右倾斜或向左倾斜的情况。\n\n\n# BST 插入\n\n二叉搜索树中插入新元素时，从根节点开始寻找插入位置，遇到数据值较大的节点就向左，遇到数据值较小的节点就向右。重复上述步骤一直到尾端，最终完成插入位置的寻找，然后插入新节点。\n\n我们还是使用递归实现二叉搜索树的插入操作：\n\n * 遇到数据值较大的节点就向左递归\n * 遇到数据值较小的节点就向右递归\n * 到达尾端，新建节点并插入\n\n向上述二叉搜索树插入9, 60两个值的过程如下图：\n\n\n\n代码实现如下：\n\nNode* insert(Node* t, T x) {\n\tif (t == NULL) {\n        t = new Node;\n        t->data = x;\n        t->left = t->right = NULL;\n\t} else if (x < t->data) {\n        t->left = insert(t->left, x);\n\t} else if (x > t->data) {\n        t->right = insert(t->right, x);\n\t}\n\treturn t;\n}\n\n\n二叉搜索树插入的时间复杂度也是 O(h) ，其中 h 是 BST 的高度。同样的这个 h 在普通 BST 中可以和 O(N) 一样高，即向右倾斜或向左倾斜的情况。\n\n\n# BST 删除的三种情况\n\n二叉搜索树的删除操作还是通过与搜索操作相似先找到要删除的节点：\n\n * 如果找不到目标节点，什么都不做。\n * 如果找到了目标节点，这时需要考虑三个可能的删除情况：\n   * 目标节点是叶子节点\n   * 目标节点有一个子节点\n   * 目标节点有两个子节点\n\n# 1 目标节点是叶子节点\n\n第一种情况是最简单的，目标节点是当前二叉搜索树的叶子节点之一。\n\n要删除叶子顶点很容易，我们只需要找到这个节点并将其删除就可以了，下图展示了删除上述二叉搜索树叶子节点5的过程。\n\n\n\n# 2 目标节点有一个子节点\n\n第二种情况也不是那么难：目标节点是当前二叉搜索树的非叶子节点，但是它只有一个子节点。\n\n删除这个节点时我们只需要将该节点的唯一的子节点与该节点的父节点连接即可，下图展示了删除上述二叉搜索树中只有一个子节点71的过程。\n\n\n\n# 3 目标节点有两个子节点\n\n第三种情况是三者中最复杂的：目标节点是当前二叉搜索树中具有两个叶子节点的非叶子节点。\n\n删除该节点需要进行如下步骤：\n\n * 搜索二叉搜索树找到该节点\n * 找到以该节点为根节点的右子树中的最小结点findMin()\n * 使用右子树中的最小节点替代该节点\n * 然后依据上述三种删除情况，递归调整其右子树的放置情况\n\n下图展示了删除上述二叉搜索树具有两个叶子节点6的过程。\n\n二叉搜索树删除操作的代码实现如下：\n\nNode* remove(Node* t, T x) {\n\tNode* temp;\n    // 搜索目标节点\n\tif (t == NULL) return NULL;\n\telse if (x < t->data) t->left = remove(t->left, x);\n\telse if (x > t->data) t->right = remove(t->right, x);\n    // 情况 3\n\telse if (t->left && t->right) {\n\t\ttemp = findMin(t->right);\n        t->data = temp->data;\n        t->right = remove(t->right, t->data);\n    } else {\n        temp = t;\n        // 情况 2\n        if (t->left == NULL) t = t->right;\n        else if (t->right == NULL) t = t->left;\n        // 情况 1\n        delete temp;\n    }\n\treturn t;\n}\n\n\n二叉搜索树删除操作的时间复杂度也是 O(h) ，其中 h 是 BST 的高度，即使是第三种最复杂的情况时间复杂度也不会超过 O(h) 。同样的这个 h 在普通 BST 中可以和 O(N) 一样高，即向右倾斜或向左倾斜的情况。\n\n\n# 平衡二叉搜索树\n\n在二叉搜索树 BST 的介绍过程中，我们不断提到了操作的时间复杂度，其中除了中序遍历之外，大部分操作的时间复杂度都是 O(h) ，即与 BST 自身的高度相关。\n\n而普通二叉搜索树可能会出现向右倾斜或向左倾斜的情况，即导致其高度为 N-1，从而使得二叉搜索树操作出现最坏情况时间复杂度为 O(N) 。\n\n为了降低二叉搜索树操作的时间复杂度，我们将讨论平衡二叉搜索树的概念，以使得 h = O(logN)。\n\n二叉树的极度平衡和极度不平衡状态如下图所示：\n\n\n树形结构是否平衡并没有绝对的衡量标准，它指的是没有任何一个节点深度过大。不同的平衡条件，可以实现不同的树形操作效率，也会带来不同的实现复杂度。\n\n用的最多的平衡标准是：其左子树和右子树均为平衡二叉树，且左子树和右子树的高度差的绝对值不超过 1。这使得含有 N 个结点的平衡二叉树的最大深度为 O(logN)。\n\n基于平衡二叉树的概念，已经有多种实现平衡二叉搜索树的数据结构，例如 AVL-Tree, RB-Tree, B/B+ Tree等，他们比一般的二叉搜索树复杂，但是能够保证高效的查找、插入和删除等操作。\n\n\n# 自平衡二叉搜索树 AVL\n\n\n# 什么是 AVL\n\nAVL-Tree，是由两位俄罗斯（苏联）发明家 Georgy Adelson-Velskii 和 Evgenii Landis 在 1962 年提出的。\n\nAVL-Tree 使用的平衡标准就是：二叉搜索树所有非叶子节点的左子树和右子树均为平衡二叉树，且左子树和右子树的高度差的绝对值不超过 1。该平衡条件就是为了确保整颗二叉搜索树的深度为O(logN)。\n\n自平衡二叉搜索树 AVL 是带了自平衡功能的二叉搜索树。当对其进行插入或删除操作后破坏了平衡条件时，它能够进行调整，使整颗树的高度平衡为 O(logN)。\n\n\n\n\n# 树的旋转\n\n由于 AVL-Tree 的平衡条件，对其进行插入和删除操作后可能破坏整颗树的平衡，平衡被破坏后 AVL 能够自行进行调整恢复平衡。首先，找到平衡被破坏中的各个非叶子节点中深度最深的那一个。\n\n由于二叉树最多有两个子节点，而平衡被破坏即为该节点的左右子树的高度相差 2。因此，以插入操作为例可以将平衡被破坏分为如下四种情况：\n\n 1. 插入左子节点的左子树 LL\n 2. 插入右子节点的右子树 RR\n 3. 插入左子节点的右子树 LR\n 4. 插入右子节点的左子树 RL\n\n情况 1 和 2 又可以称为外侧插入，使用单旋转操作调整恢复平衡；情况 3 和 4 称为内侧插入，使用双旋转操作调整恢复平衡。\n\n# 1 LL 单旋转\n\n上述 AVL-Tree 中的节点20，我们进行外侧插入，在其左子节点11的左子树插入新的节点5。这就破坏了整颗树的平衡，处于不平衡状态的节点有41, 20，而20的深度更大。\n\n为了调整平衡状态，需要将以6为根节点的子树提高一层，将以29为根节点的子树下降一层，进行如下单向右旋步骤：\n\n * 深度最大的不平衡状态的节点 node，即20\n * node 的左孩子代替 node，即用11代替20，41->left = 11\n * node 左孩子的右子树变为 node 的左子树，即将20->left = 15\n * 将 node 作为其原始左孩子的右子树，即将11->right = 20\n\n\n\nAVL-Tree LL型调整操作的代码实现如下：（代码来源，如有侵权请告知）\n\n//LL型调整函数\n//返回:新父节点\nNode LL_rotate(Node node){\n    //node为离操作结点最近的失衡的结点\n    Node parent=NULL,son;\n    //获取失衡结点的父节点\n    parent=node->parent;\n    //获取失衡结点的左孩子\n    son=node->lchild;\n    //设置son结点右孩子的父指针\n    if (son->rchild!=NULL)  son->rchild->parent=node;\n    //失衡结点的左孩子变更为son的右孩子\n    node->lchild=son->rchild;\n    //更新失衡结点的高度信息\n    update_depth(node);\n    //失衡结点变成son的右孩子\n    son->rchild=node;\n    //设置son的父结点为原失衡结点的父结点\n    son->parent=parent;\n    //如果失衡结点不是根结点，则开始更新父节点\n    if (parent!=NULL){\n        //如果父节点的左孩子是失衡结点，指向现在更新后的新孩子son\n        if (parent->lchild==node){\n            parent->lchild=son;\n        }else{\n             //父节点的右孩子是失衡结点\n              parent->rchild=son;\n        }\n     }\n    //设置失衡结点的父亲\n    node->parent=son;\n    //更新son结点的高度信息\n    update_depth(son);\n    return son;\n}\n\n\n# 2 RR 单旋转\n\n上述 AVL-Tree 中的节点65，我们进行外侧插入，在其左子节点91的右子树插入新的节点100。这就破坏了整颗树的平衡，处于不平衡状态的节点有41, 65，而65的深度更大。\n\n为了调整平衡状态，需要将以99为根节点的子树提高一层，将以50为根节点的子树下降一层，进行如下单向左旋步骤：\n\n * 深度最大的不平衡状态的节点 node，即65\n * node 的右孩子代替 node，即用91代替65，41->right = 91\n * node 右孩子的左子树变为 node 的右子树，即将65->right = 72\n * 将 node 作为其原始右孩子的左子树，即将91->left = 65\n\n\n\nAVL-Tree RR型调整操作的代码实现如下：（代码来源，如有侵权请告知）\n\n/RR型调整函数\n//返回新父节点\nNode RR_rotate(Node node){\n    //node为离操作结点最近的失衡的结点\n    Node parent=NULL,son;\n    //获取失衡结点的父节点\n    parent=node->parent;\n    //获取失衡结点的右孩子\n    son=node->rchild;\n    //设置son结点左孩子的父指针\n    if (son->lchild!=NULL){\n          son->lchild->parent=node;\n    }\n    //失衡结点的右孩子变更为son的左孩子\n    node->rchild=son->lchild;\n    //更新失衡结点的高度信息\n    update_depth(node);\n    //失衡结点变成son的左孩子\n    son->lchild=node;\n    //设置son的父结点为原失衡结点的父结点\n    son->parent=parent;\n    //如果失衡结点不是根结点，则开始更新父节点\n    if (parent!=NULL){\n        //如果父节点的左孩子是失衡结点，指向现在更新后的新孩子son\n        if (parent->lchild==node){\n            parent->lchild=son;\n        }else{\n            //父节点的右孩子是失衡结点\n            parent->rchild=son;\n        } \n    }\n    //设置失衡结点的父亲\n    node->parent=son;\n    //更新son结点的高度信息\n    update_depth(son);\n    return son;\n}\n\n\n# 3 LR 双旋转\n\n上述 AVL-Tree 中的节点20，我们进行内侧插入，在其左子节点11的右子树插入新的节点14。这就破坏了整颗树的平衡，处于不平衡状态的节点有41, 20，而20的深度更大。\n\n这种情况我们无法直接使用 LL 或者 RR 的单旋转完整调整，因为旋转之后仍然是不平衡的。为了调整平衡状态，需要将以15作为跳转子树的新根节点，这使得11必将成为15的左子节点，而20则将称为15的右子节点，这样就恢复了平衡状态。\n\n这一过程需要进行两次单旋转，首先进行 RR 单向左旋转让11成为15的左孩子；然后进行 LL 单向右旋转让20成为15的右孩子。\n\n\n\nAVL-Tree LR型调整操作的代码实现如下：（代码来源，如有侵权请告知）\n\n//LR型，先左旋转，再右旋转\n//返回：新父节点\nNode LR_rotate(Node node){\n    RR_rotate(node->lchild);\n    return LL_rotate(node);\n}\n\n\n# 4 RL 双旋转\n\n上述 AVL-Tree 中的节点65，我们进行内侧插入，在其右子节点91的左子树插入新的节点73。这就破坏了整颗树的平衡，处于不平衡状态的节点有41, 65，而65的深度更大。\n\n这种情况我们无法直接使用 LL 或者 RR 的单旋转完整调整，因为旋转之后仍然是不平衡的。为了调整平衡状态，需要将以72作为跳转子树的新根节点，这使得91必将成为72的右子节点，而65则将称为72的左子节点，这样就恢复了平衡状态。\n\n这一过程需要进行两次单旋转，首先进行 LL 单向右旋转让91成为72的右孩子；然后进行 RR 单向左旋转让65成为72的右孩子。\n\n\n\nAVL-Tree RL型调整操作的代码实现如下：（代码来源，如有侵权请告知）\n\n//RL型，先右旋转，再左旋转\n//返回:新父节点\nNode RL_rotate(Node node){\n    LL_rotate(node->rchild);\n    return RR_rotate(node);\n}\n\n\n\n# AVL 插入与删除\n\n# 1 AVL 插入\n\n介绍完树的旋转，其实就已经介绍完了 AVL-Tree 的核心步骤。\n\nAVL-Tree 插入的总体步骤如下：\n\n 1. 和普通二叉搜索树插入过程一样，BST 插入\n 2. 从插入点向上走遍历 AVL-Tree 直到回到根节点。每遍历一个节点，我们更新处于不平衡状态节点的高度和平衡因子：\n    * 如果存在不平衡状态的节点，停止在不平衡的第一个节点即深度最大的不平衡状态节点，其平衡因子为+2 或 -2\n    * 使用四个树旋转案例中的一个来跳转二叉树，使其重新达到平衡状态\n\n# 2 AVL 删除\n\nAVL 删除和 AVL 插入本质上是相似的方法，核心还是在于使用树旋转调整平衡状态。\n\nAVL-Tree 删除的总体步骤如下：\n\n 1. 和普通二叉搜索树删除过程一样，使用三个删除案例中的一个进行 BST 删除\n 2. 在 AVL-Tree 中从删除点向上走直到回到根节点。每遍历一个节点，我们更新处于不平衡状态节点的高度和平衡因子：\n    * 如果存在不平衡状态的节点，停止在不平衡的第一个节点即深度最大的不平衡状态节点，其平衡因子为+2 或 -2\n    * 使用四个树旋转案例中的一个来跳转二叉树，使其重新达到平衡状态\n\n总结\n\nBST 插入和删除操作与AVL 的插入和删除操作相比的主要区别在于：可能会多次触发四种可能的需要重新平衡情况中的一种，但时间复杂度不会超过 h = O(logN)。",normalizedContent:"# 二叉搜索树 bst\n\n\n# 什么是二叉搜索树\n\n二叉搜索树（又称：二叉查找树，二叉排序树，binary search tree, bst）是一种特殊的二叉树：对于每个父节点，其左子节点的值小于等于父结点的值，其右子节点的值大于等于父结点的值。\n\n因此对于一个二叉搜索树，我们可以在 o(nlogn) 的时间内查找一个值是否存在：从根节点开始，若当前节点的值大于查找值则向左下走，若当前节点的值小于查找值则向右下走。\n\n同时因为二叉查找树是有序的，对其中序遍历的结果即为排好序的数组。\n\n一个二叉搜索树实例[15,6,23,4,7,null,71,null,5,null,null,null,null,50,null]如下图所示：\n\n\n\n二叉搜索树除了创建二叉树之外的基本操作有三种：（1）搜索（2）插入 （3）删除\n\n\n# bst 的节点属性\n\n和普通二叉树一样，二叉搜索树的每个节点至少有 3 个属性：左孩子，右孩子和数据值，它然节点还可以包含其他潜在的属性。 二叉搜索树节点的结构体声明可以如下：\n\nstruct node {\n\tt data; // t 代表模板类\n\tnode* left;\n\tnode* right;\n};\n\n\n二叉搜索树的节点放置规则是：任何节点的数据值一定大于其左子树中的每个节点的数据值，并小于其右子树中的每个节点的数据值。所以，在遍历二叉搜索树时，一直往左走可以得到最小元素，一直往右走可以得到最大元素。\n\n\n# bst 的中序遍历\n\n我们再来复习一遍二叉搜索树的特性：左子树上所有结点的值均小于它的根结点的值，右子树上所有结点的值均大于它的根结点的值。\n\n依据这一特性我们可以推出二叉搜索树的另一个重要特性：二叉搜索树的中序遍历序列是一个递增序列。\n\n二叉搜索树的中序遍历实现和普通二叉树一样，也有递归和非递归的实现方式。但是无论 bst 的高度如何，中序遍历的时间复杂度都是o(n)。\n\n**（1）递归实现方式：**先遍历左节点，再遍历父结点，最后遍历右节点\n\nvoid inorder(node* root) {\n    inorder(root->left);\n    visit(root);\n    inorder(root->right);\n}\n\n\n（2）非递归实现方式：\n\n二叉树中序遍历是从左子树的最左边的叶子节点开始处理，是自下而上的递归。\n\n节点访问过程：由于是自下而上的访问，使用迭代实现中序遍历需要一个额外的指针来访问节点，从根节点一层层向左访问到左子树的最左边的叶子节点并逐个入栈，再开始向上迭代处理节点值。完成访问之后，栈中保存的是从根节点到最左边的叶子节点路径上的所有节点，他们都是左节点。\n\n节点处理过程：直接取栈顶元素将其值加入结果集，然后查看它是否具有右节点。如果有右节点则使用指针从该节点开始进行和根节点一样的访问过程，将从该节点开始到以该节点为根节点的子树的最左叶子节点路径上的所有节点入栈。完成访问之后再重复处理过程，最终完成所有节点的访问和处理。\n\n实现代码如下：\n\nvector<int> inordertraversal(treenode* root) {\n\tvector<int> ans;\n\tif(!root){\n\t    return ans;\n\t}\n\tstack<treenode*> s;\n\ttreenode* cur = root;\n\twhile(cur || !s.empty()){\n        if(cur){\n            // 从根节点到最左叶子节点的访问过程\n            s.push(cur);\n            cur = cur->left;\n        }else{\n            // 自下而上 左中右的节点处理过程\n            cur = s.top();\n            s.pop();\n            ans.push_back(cur->val);\n            cur = cur->right;\n        }\n\t}\n\treturn ans;\n}\n\n\n\n# bst 搜索\n\n二叉搜索树，最为基础的操作当然就是搜索了。\n\n二叉树搜索过程中使用根结点 root 和目标值 target 进行比较，不同情况处理如下：\n\n * 若 target 小于根结点键值，只需在左子树中继续搜索\n * 如果 target 大于根结点的键值，在右子树中进行继续搜索\n * 若两者比较结果是相等，搜索完成，返回指向此结点的指针。\n\n\n\n搜索过程的代码实现如下：\n\nnode* find(node* t, t target) {\n\tif (t == null) return null;\n\tif (target < t->data) return find(t->left, target);\n\tif (target > t->data) return find(t->right, target);\n\treturn t;\n}\n\n\n除了快速搜索目标值，二叉搜索树中还可以快速查找最大值和最小值。\n\n查找最大值和最小值\n\n二叉搜索树的节点放置规则是：任何节点的数据值一定大于其左子树中的每个节点的数据值，并小于其右子树中的每个节点的数据值。所以，在遍历二叉搜索树时，一直往左走就可以得到最小元素，一直往右走就可以得到最大元素。\n\n查找最大值和最小值的代码实现如下：\n\n// 查找最小值\nnode* findmin(node* t) {\n\tif (t == null || t->left == null) return t;\n\treturn findmin(t->left);\n}\n\n// 查找最大值\nnode* findmax(node* t) {\n\tif (t == null || t->right == null) return t;\n\treturn findmax(t->right);\n}\n\n\n二叉搜索树的搜索时间复杂度与其自身高度 h 相关，通常为o(h)。但值得注意的是：在普通的 bst 中其自身高度 h 可能和元素 o(n) 一样高，即向右倾斜或向左倾斜的情况。\n\n\n# bst 插入\n\n二叉搜索树中插入新元素时，从根节点开始寻找插入位置，遇到数据值较大的节点就向左，遇到数据值较小的节点就向右。重复上述步骤一直到尾端，最终完成插入位置的寻找，然后插入新节点。\n\n我们还是使用递归实现二叉搜索树的插入操作：\n\n * 遇到数据值较大的节点就向左递归\n * 遇到数据值较小的节点就向右递归\n * 到达尾端，新建节点并插入\n\n向上述二叉搜索树插入9, 60两个值的过程如下图：\n\n\n\n代码实现如下：\n\nnode* insert(node* t, t x) {\n\tif (t == null) {\n        t = new node;\n        t->data = x;\n        t->left = t->right = null;\n\t} else if (x < t->data) {\n        t->left = insert(t->left, x);\n\t} else if (x > t->data) {\n        t->right = insert(t->right, x);\n\t}\n\treturn t;\n}\n\n\n二叉搜索树插入的时间复杂度也是 o(h) ，其中 h 是 bst 的高度。同样的这个 h 在普通 bst 中可以和 o(n) 一样高，即向右倾斜或向左倾斜的情况。\n\n\n# bst 删除的三种情况\n\n二叉搜索树的删除操作还是通过与搜索操作相似先找到要删除的节点：\n\n * 如果找不到目标节点，什么都不做。\n * 如果找到了目标节点，这时需要考虑三个可能的删除情况：\n   * 目标节点是叶子节点\n   * 目标节点有一个子节点\n   * 目标节点有两个子节点\n\n# 1 目标节点是叶子节点\n\n第一种情况是最简单的，目标节点是当前二叉搜索树的叶子节点之一。\n\n要删除叶子顶点很容易，我们只需要找到这个节点并将其删除就可以了，下图展示了删除上述二叉搜索树叶子节点5的过程。\n\n\n\n# 2 目标节点有一个子节点\n\n第二种情况也不是那么难：目标节点是当前二叉搜索树的非叶子节点，但是它只有一个子节点。\n\n删除这个节点时我们只需要将该节点的唯一的子节点与该节点的父节点连接即可，下图展示了删除上述二叉搜索树中只有一个子节点71的过程。\n\n\n\n# 3 目标节点有两个子节点\n\n第三种情况是三者中最复杂的：目标节点是当前二叉搜索树中具有两个叶子节点的非叶子节点。\n\n删除该节点需要进行如下步骤：\n\n * 搜索二叉搜索树找到该节点\n * 找到以该节点为根节点的右子树中的最小结点findmin()\n * 使用右子树中的最小节点替代该节点\n * 然后依据上述三种删除情况，递归调整其右子树的放置情况\n\n下图展示了删除上述二叉搜索树具有两个叶子节点6的过程。\n\n二叉搜索树删除操作的代码实现如下：\n\nnode* remove(node* t, t x) {\n\tnode* temp;\n    // 搜索目标节点\n\tif (t == null) return null;\n\telse if (x < t->data) t->left = remove(t->left, x);\n\telse if (x > t->data) t->right = remove(t->right, x);\n    // 情况 3\n\telse if (t->left && t->right) {\n\t\ttemp = findmin(t->right);\n        t->data = temp->data;\n        t->right = remove(t->right, t->data);\n    } else {\n        temp = t;\n        // 情况 2\n        if (t->left == null) t = t->right;\n        else if (t->right == null) t = t->left;\n        // 情况 1\n        delete temp;\n    }\n\treturn t;\n}\n\n\n二叉搜索树删除操作的时间复杂度也是 o(h) ，其中 h 是 bst 的高度，即使是第三种最复杂的情况时间复杂度也不会超过 o(h) 。同样的这个 h 在普通 bst 中可以和 o(n) 一样高，即向右倾斜或向左倾斜的情况。\n\n\n# 平衡二叉搜索树\n\n在二叉搜索树 bst 的介绍过程中，我们不断提到了操作的时间复杂度，其中除了中序遍历之外，大部分操作的时间复杂度都是 o(h) ，即与 bst 自身的高度相关。\n\n而普通二叉搜索树可能会出现向右倾斜或向左倾斜的情况，即导致其高度为 n-1，从而使得二叉搜索树操作出现最坏情况时间复杂度为 o(n) 。\n\n为了降低二叉搜索树操作的时间复杂度，我们将讨论平衡二叉搜索树的概念，以使得 h = o(logn)。\n\n二叉树的极度平衡和极度不平衡状态如下图所示：\n\n\n树形结构是否平衡并没有绝对的衡量标准，它指的是没有任何一个节点深度过大。不同的平衡条件，可以实现不同的树形操作效率，也会带来不同的实现复杂度。\n\n用的最多的平衡标准是：其左子树和右子树均为平衡二叉树，且左子树和右子树的高度差的绝对值不超过 1。这使得含有 n 个结点的平衡二叉树的最大深度为 o(logn)。\n\n基于平衡二叉树的概念，已经有多种实现平衡二叉搜索树的数据结构，例如 avl-tree, rb-tree, b/b+ tree等，他们比一般的二叉搜索树复杂，但是能够保证高效的查找、插入和删除等操作。\n\n\n# 自平衡二叉搜索树 avl\n\n\n# 什么是 avl\n\navl-tree，是由两位俄罗斯（苏联）发明家 georgy adelson-velskii 和 evgenii landis 在 1962 年提出的。\n\navl-tree 使用的平衡标准就是：二叉搜索树所有非叶子节点的左子树和右子树均为平衡二叉树，且左子树和右子树的高度差的绝对值不超过 1。该平衡条件就是为了确保整颗二叉搜索树的深度为o(logn)。\n\n自平衡二叉搜索树 avl 是带了自平衡功能的二叉搜索树。当对其进行插入或删除操作后破坏了平衡条件时，它能够进行调整，使整颗树的高度平衡为 o(logn)。\n\n\n\n\n# 树的旋转\n\n由于 avl-tree 的平衡条件，对其进行插入和删除操作后可能破坏整颗树的平衡，平衡被破坏后 avl 能够自行进行调整恢复平衡。首先，找到平衡被破坏中的各个非叶子节点中深度最深的那一个。\n\n由于二叉树最多有两个子节点，而平衡被破坏即为该节点的左右子树的高度相差 2。因此，以插入操作为例可以将平衡被破坏分为如下四种情况：\n\n 1. 插入左子节点的左子树 ll\n 2. 插入右子节点的右子树 rr\n 3. 插入左子节点的右子树 lr\n 4. 插入右子节点的左子树 rl\n\n情况 1 和 2 又可以称为外侧插入，使用单旋转操作调整恢复平衡；情况 3 和 4 称为内侧插入，使用双旋转操作调整恢复平衡。\n\n# 1 ll 单旋转\n\n上述 avl-tree 中的节点20，我们进行外侧插入，在其左子节点11的左子树插入新的节点5。这就破坏了整颗树的平衡，处于不平衡状态的节点有41, 20，而20的深度更大。\n\n为了调整平衡状态，需要将以6为根节点的子树提高一层，将以29为根节点的子树下降一层，进行如下单向右旋步骤：\n\n * 深度最大的不平衡状态的节点 node，即20\n * node 的左孩子代替 node，即用11代替20，41->left = 11\n * node 左孩子的右子树变为 node 的左子树，即将20->left = 15\n * 将 node 作为其原始左孩子的右子树，即将11->right = 20\n\n\n\navl-tree ll型调整操作的代码实现如下：（代码来源，如有侵权请告知）\n\n//ll型调整函数\n//返回:新父节点\nnode ll_rotate(node node){\n    //node为离操作结点最近的失衡的结点\n    node parent=null,son;\n    //获取失衡结点的父节点\n    parent=node->parent;\n    //获取失衡结点的左孩子\n    son=node->lchild;\n    //设置son结点右孩子的父指针\n    if (son->rchild!=null)  son->rchild->parent=node;\n    //失衡结点的左孩子变更为son的右孩子\n    node->lchild=son->rchild;\n    //更新失衡结点的高度信息\n    update_depth(node);\n    //失衡结点变成son的右孩子\n    son->rchild=node;\n    //设置son的父结点为原失衡结点的父结点\n    son->parent=parent;\n    //如果失衡结点不是根结点，则开始更新父节点\n    if (parent!=null){\n        //如果父节点的左孩子是失衡结点，指向现在更新后的新孩子son\n        if (parent->lchild==node){\n            parent->lchild=son;\n        }else{\n             //父节点的右孩子是失衡结点\n              parent->rchild=son;\n        }\n     }\n    //设置失衡结点的父亲\n    node->parent=son;\n    //更新son结点的高度信息\n    update_depth(son);\n    return son;\n}\n\n\n# 2 rr 单旋转\n\n上述 avl-tree 中的节点65，我们进行外侧插入，在其左子节点91的右子树插入新的节点100。这就破坏了整颗树的平衡，处于不平衡状态的节点有41, 65，而65的深度更大。\n\n为了调整平衡状态，需要将以99为根节点的子树提高一层，将以50为根节点的子树下降一层，进行如下单向左旋步骤：\n\n * 深度最大的不平衡状态的节点 node，即65\n * node 的右孩子代替 node，即用91代替65，41->right = 91\n * node 右孩子的左子树变为 node 的右子树，即将65->right = 72\n * 将 node 作为其原始右孩子的左子树，即将91->left = 65\n\n\n\navl-tree rr型调整操作的代码实现如下：（代码来源，如有侵权请告知）\n\n/rr型调整函数\n//返回新父节点\nnode rr_rotate(node node){\n    //node为离操作结点最近的失衡的结点\n    node parent=null,son;\n    //获取失衡结点的父节点\n    parent=node->parent;\n    //获取失衡结点的右孩子\n    son=node->rchild;\n    //设置son结点左孩子的父指针\n    if (son->lchild!=null){\n          son->lchild->parent=node;\n    }\n    //失衡结点的右孩子变更为son的左孩子\n    node->rchild=son->lchild;\n    //更新失衡结点的高度信息\n    update_depth(node);\n    //失衡结点变成son的左孩子\n    son->lchild=node;\n    //设置son的父结点为原失衡结点的父结点\n    son->parent=parent;\n    //如果失衡结点不是根结点，则开始更新父节点\n    if (parent!=null){\n        //如果父节点的左孩子是失衡结点，指向现在更新后的新孩子son\n        if (parent->lchild==node){\n            parent->lchild=son;\n        }else{\n            //父节点的右孩子是失衡结点\n            parent->rchild=son;\n        } \n    }\n    //设置失衡结点的父亲\n    node->parent=son;\n    //更新son结点的高度信息\n    update_depth(son);\n    return son;\n}\n\n\n# 3 lr 双旋转\n\n上述 avl-tree 中的节点20，我们进行内侧插入，在其左子节点11的右子树插入新的节点14。这就破坏了整颗树的平衡，处于不平衡状态的节点有41, 20，而20的深度更大。\n\n这种情况我们无法直接使用 ll 或者 rr 的单旋转完整调整，因为旋转之后仍然是不平衡的。为了调整平衡状态，需要将以15作为跳转子树的新根节点，这使得11必将成为15的左子节点，而20则将称为15的右子节点，这样就恢复了平衡状态。\n\n这一过程需要进行两次单旋转，首先进行 rr 单向左旋转让11成为15的左孩子；然后进行 ll 单向右旋转让20成为15的右孩子。\n\n\n\navl-tree lr型调整操作的代码实现如下：（代码来源，如有侵权请告知）\n\n//lr型，先左旋转，再右旋转\n//返回：新父节点\nnode lr_rotate(node node){\n    rr_rotate(node->lchild);\n    return ll_rotate(node);\n}\n\n\n# 4 rl 双旋转\n\n上述 avl-tree 中的节点65，我们进行内侧插入，在其右子节点91的左子树插入新的节点73。这就破坏了整颗树的平衡，处于不平衡状态的节点有41, 65，而65的深度更大。\n\n这种情况我们无法直接使用 ll 或者 rr 的单旋转完整调整，因为旋转之后仍然是不平衡的。为了调整平衡状态，需要将以72作为跳转子树的新根节点，这使得91必将成为72的右子节点，而65则将称为72的左子节点，这样就恢复了平衡状态。\n\n这一过程需要进行两次单旋转，首先进行 ll 单向右旋转让91成为72的右孩子；然后进行 rr 单向左旋转让65成为72的右孩子。\n\n\n\navl-tree rl型调整操作的代码实现如下：（代码来源，如有侵权请告知）\n\n//rl型，先右旋转，再左旋转\n//返回:新父节点\nnode rl_rotate(node node){\n    ll_rotate(node->rchild);\n    return rr_rotate(node);\n}\n\n\n\n# avl 插入与删除\n\n# 1 avl 插入\n\n介绍完树的旋转，其实就已经介绍完了 avl-tree 的核心步骤。\n\navl-tree 插入的总体步骤如下：\n\n 1. 和普通二叉搜索树插入过程一样，bst 插入\n 2. 从插入点向上走遍历 avl-tree 直到回到根节点。每遍历一个节点，我们更新处于不平衡状态节点的高度和平衡因子：\n    * 如果存在不平衡状态的节点，停止在不平衡的第一个节点即深度最大的不平衡状态节点，其平衡因子为+2 或 -2\n    * 使用四个树旋转案例中的一个来跳转二叉树，使其重新达到平衡状态\n\n# 2 avl 删除\n\navl 删除和 avl 插入本质上是相似的方法，核心还是在于使用树旋转调整平衡状态。\n\navl-tree 删除的总体步骤如下：\n\n 1. 和普通二叉搜索树删除过程一样，使用三个删除案例中的一个进行 bst 删除\n 2. 在 avl-tree 中从删除点向上走直到回到根节点。每遍历一个节点，我们更新处于不平衡状态节点的高度和平衡因子：\n    * 如果存在不平衡状态的节点，停止在不平衡的第一个节点即深度最大的不平衡状态节点，其平衡因子为+2 或 -2\n    * 使用四个树旋转案例中的一个来跳转二叉树，使其重新达到平衡状态\n\n总结\n\nbst 插入和删除操作与avl 的插入和删除操作相比的主要区别在于：可能会多次触发四种可能的需要重新平衡情况中的一种，但时间复杂度不会超过 h = o(logn)。",charsets:{cjk:!0},lastUpdated:"2023/11/19, 12:55:48",lastUpdatedTimestamp:1700369748e3},{title:"Tree",frontmatter:{title:"Tree",date:"2023-03-24T18:39:50.000Z",permalink:"/pages/000c1c/"},regularPath:"/03.LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/02.%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/04.%E4%BA%8C%E5%8F%89%E6%A0%91/Tree.html",relativePath:"03.LeetCode刷题笔记/02.基础数据结构/04.二叉树/Tree.md",key:"v-59c0df46",path:"/pages/000c1c/",headers:[{level:2,title:"LeetCode刷题笔记 树",slug:"leetcode刷题笔记-树",normalizedTitle:"leetcode刷题笔记 树",charIndex:2}],headersStr:"LeetCode刷题笔记 树",content:"# LeetCode刷题笔记 树\n\n最为常见的树就是二叉树，这种树的每个节点最多有两个子节点，二叉树可以看成是单链表的升级版，因为他和链表的主要区别就是多了一个子节点的指针。\n\n Definition for a binary tree node.\n struct TreeNode {\n     int val;\n     TreeNode *left;\n     TreeNode *right;\n     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n };\n",normalizedContent:"# leetcode刷题笔记 树\n\n最为常见的树就是二叉树，这种树的每个节点最多有两个子节点，二叉树可以看成是单链表的升级版，因为他和链表的主要区别就是多了一个子节点的指针。\n\n definition for a binary tree node.\n struct treenode {\n     int val;\n     treenode *left;\n     treenode *right;\n     treenode() : val(0), left(nullptr), right(nullptr) {}\n     treenode(int x) : val(x), left(nullptr), right(nullptr) {}\n     treenode(int x, treenode *left, treenode *right) : val(x), left(left), right(right) {}\n };\n",charsets:{cjk:!0},lastUpdated:"2023/11/19, 12:55:48",lastUpdatedTimestamp:1700369748e3},{title:"02拓扑排序",frontmatter:{title:"02拓扑排序",date:"2023-03-24T18:39:49.000Z",permalink:"/pages/f51192/"},regularPath:"/03.LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/02.%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/05.%E5%9B%BE/02.%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F.html",relativePath:"03.LeetCode刷题笔记/02.基础数据结构/05.图/02.拓扑排序.md",key:"v-2eca7826",path:"/pages/f51192/",headers:[{level:2,title:"02 拓扑排序",slug:"_02-拓扑排序",normalizedTitle:"02 拓扑排序",charIndex:2},{level:4,title:"207 课程表",slug:"_207-课程表",normalizedTitle:"207 课程表",charIndex:145},{level:4,title:"210 课程表 II",slug:"_210-课程表-ii",normalizedTitle:"210 课程表 ii",charIndex:2079}],headersStr:"02 拓扑排序 207 课程表 210 课程表 II",content:"# 02 拓扑排序\n\n拓扑排序（topological sort）是一种常见的，对有向无环图排序的算法。给定有向无环图中的 N 个节点，我们把它们排序成一个线性序列；若原图中节点 i 指向节点 j，则排序结果中 i 一定在 j 之前。拓扑排序的结果不是唯一的，只要满足以上条件即可。\n\n# 207 课程表\n\n给定学期必须选修 numCourses 门课程，记为 0 到 numCourses - 1 。在选修某些课程之前需要一些先修课程。 先修课程按数组 prerequisites 给出，其中 prerequisites[i] = [ai, bi] ，表示如果要学习课程 ai 则 必须 先学习课程 bi 。\n\n例如，先修课程对 [0, 1] 表示：想要学习课程 0 ，需要先完成课程 1 。\n\n请判断是否可能完成所有课程的学习？如果可以，返回 true ；否则，返回 false 。\n\n> 输入：numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]] 输出：true 解释：总共有 4 门课程。要学习课程 3，你应该先完成课程 1 和课程 2。并且课程 1 和课程 2 都应该排在课程 0 之后。因此，课程是可能完成的。\n\n解析：\n\n拓扑排序的主要思路就是：考虑每一个节点的入度，当节点入度为 0 时，将其加入排序序列，同时将其指向的其他节点的入度减 1，所有节点完成遍历之后得到最终拓扑排序。\n\n对于本题我们可以先为拓扑图建立一个邻接矩阵表示图，题目中节点是后置课程指向前置课程，这在获取拓扑排序结果时是反向的。所以，我们在建立邻接矩阵时将所有边反向，使得如果课程 i 指向课程 j，那么课程 i 需要在课程 j 前面先修完。\n\n根据拓扑排序的思路，我们使用广度优先搜索解决本题：\n\n * 我们先遍历一遍所有节点，把入度为 0 的节点（即没有前置课程要求）放在队列中\n * 在每次从队列中获得节点时，我们将该节点放在目前排序的末尾\n * 同时，遍历该节点指向的后置课程，并且把这些课程的入度各减 1。如果在这个过程中该节点的后置课程中出现了入度为 0，那么该后置课程的前置课程都已经完成了，将其加入可选队列。\n * 当队列为空时，说明所有节点都已经遍历完成，或者是图中存在环路导致无法取得拓扑排序结果。\n\nclass Solution {\npublic:\n    bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {\n        // 构建邻接表\n        vector<vector<int>> graph(numCourses,vector<int>());\n        vector<int> indegree(numCourses,0); // 记录各节点入度\n        for(const auto edge:prerequisites){\n            int prev = edge[1];\n            int next = edge[0];\n            graph[prev].push_back(next);\n            ++indegree[next];\n        }\n\n        // 入度为 0 的压入队列\n        queue<int> que;\n        for(int i=0;i<numCourses;++i){\n            if(!indegree[i]){\n                que.push(i);\n            }\n        }\n\n        // 使用队列进行广度优先遍历\n        while(!que.empty()){\n            int node = que.front();\n            que.pop();\n            for(const auto next:graph[node]){\n                --indegree[next];\n                if(!indegree[next]){\n                    que.push(next);\n                }\n            }\n        }\n\n        // 遍历完之后如果还存在 入度不为 0 的节点，说明存在环路\n        for(const auto degree:indegree){\n            if(degree){\n                return false;\n            }\n        }\n\n        return true;\n    }\n};\n\n\n# 210 课程表 II\n\n给定 N 个课程和这些课程的前置必修课，求可以一次性上完所有课的顺序\n\n输入是一个正整数，表示课程数量，和一个二维矩阵，表示所有的有向边，例如 [1,0] 表示上课程 1 之前必须先上课程 0。输出是一个一维数组，表示拓扑排序结果。\n\n> 输入：numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]] 输出：[0,2,1,3] 解释：总共有 4 门课程。要学习课程 3，你应该先完成课程 1 和课程 2。并且课程 1 和课程 2 都应该排在课程 0 之后。因此，一个正确的课程顺序是 [0,1,2,3] 。另一个正确的排序是 [0,2,1,3] 。\n\n解析：\n\n拓扑排序的主要思路就是：考虑每一个节点的入度，当节点入度为 0 时，将其加入排序序列，同时将其指向的其他节点的入度减 1，所有节点完成遍历之后得到最终拓扑排序。\n\n对于本题我们可以先为拓扑图建立一个邻接矩阵表示图，题目中节点是后置课程指向前置课程，这在获取拓扑排序结果时是反向的。所以，我们在建立邻接矩阵时将所有边反向，使得如果课程 i 指向课程 j，那么课程 i 需要在课程 j 前面先修完。\n\n根据拓扑排序的思路，我们使用广度优先搜索解决本题：\n\n * 我们先遍历一遍所有节点，把入度为 0 的节点（即没有前置课程要求）放在队列中\n * 在每次从队列中获得节点时，我们将该节点放在目前排序的末尾\n * 同时，遍历该节点指向的后置课程，并且把这些课程的入度各减 1。如果在这个过程中该节点的后置课程中出现了入度为 0，那么该后置课程的前置课程都已经加入到了排序结果中，则将该后置课程加入队列中。\n * 当队列为空时，说明所有节点都已经遍历完成，或者是图中存在环路导致无法取得拓扑排序结果。\n\nclass Solution {\npublic:\n    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {\n        vector<vector<int>> graph(numCourses,vector<int>());\n        vector<int> indegree(numCourses,0);\n        for(const auto edge:prerequisites){\n            // 让前置课程指向后置课程\n            graph[edge[1]].push_back(edge[0]);\n            // 后置课程入度+1\n            ++indegree[edge[0]];\n        }\n\n        queue<int> q;\n        // 将入度为0的节点加入队列\n        for(int i=0;i<numCourses;++i){\n            if(!indegree[i]){\n                q.push(i);\n            }\n        }\n\n        // 广度优先搜索 遍历图\n        vector<int> res;\n        while(!q.empty()){\n            const auto node = q.front();\n            q.pop();\n            res.push_back(node);\n            // 遍历当前节点的所有后置课程\n            for(const auto post:graph[node]){\n                --indegree[post];\n                if(!indegree[post]){\n                    q.push(post);\n                }\n            }\n        }\n\n        // 如果存在节点入度不为0,那么图中存在环，不能完成所有课程\n        for(const auto degree:indegree){\n            if(degree){\n                return {};\n            }\n        }\n        \n        return res;\n    }\n};\n",normalizedContent:"# 02 拓扑排序\n\n拓扑排序（topological sort）是一种常见的，对有向无环图排序的算法。给定有向无环图中的 n 个节点，我们把它们排序成一个线性序列；若原图中节点 i 指向节点 j，则排序结果中 i 一定在 j 之前。拓扑排序的结果不是唯一的，只要满足以上条件即可。\n\n# 207 课程表\n\n给定学期必须选修 numcourses 门课程，记为 0 到 numcourses - 1 。在选修某些课程之前需要一些先修课程。 先修课程按数组 prerequisites 给出，其中 prerequisites[i] = [ai, bi] ，表示如果要学习课程 ai 则 必须 先学习课程 bi 。\n\n例如，先修课程对 [0, 1] 表示：想要学习课程 0 ，需要先完成课程 1 。\n\n请判断是否可能完成所有课程的学习？如果可以，返回 true ；否则，返回 false 。\n\n> 输入：numcourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]] 输出：true 解释：总共有 4 门课程。要学习课程 3，你应该先完成课程 1 和课程 2。并且课程 1 和课程 2 都应该排在课程 0 之后。因此，课程是可能完成的。\n\n解析：\n\n拓扑排序的主要思路就是：考虑每一个节点的入度，当节点入度为 0 时，将其加入排序序列，同时将其指向的其他节点的入度减 1，所有节点完成遍历之后得到最终拓扑排序。\n\n对于本题我们可以先为拓扑图建立一个邻接矩阵表示图，题目中节点是后置课程指向前置课程，这在获取拓扑排序结果时是反向的。所以，我们在建立邻接矩阵时将所有边反向，使得如果课程 i 指向课程 j，那么课程 i 需要在课程 j 前面先修完。\n\n根据拓扑排序的思路，我们使用广度优先搜索解决本题：\n\n * 我们先遍历一遍所有节点，把入度为 0 的节点（即没有前置课程要求）放在队列中\n * 在每次从队列中获得节点时，我们将该节点放在目前排序的末尾\n * 同时，遍历该节点指向的后置课程，并且把这些课程的入度各减 1。如果在这个过程中该节点的后置课程中出现了入度为 0，那么该后置课程的前置课程都已经完成了，将其加入可选队列。\n * 当队列为空时，说明所有节点都已经遍历完成，或者是图中存在环路导致无法取得拓扑排序结果。\n\nclass solution {\npublic:\n    bool canfinish(int numcourses, vector<vector<int>>& prerequisites) {\n        // 构建邻接表\n        vector<vector<int>> graph(numcourses,vector<int>());\n        vector<int> indegree(numcourses,0); // 记录各节点入度\n        for(const auto edge:prerequisites){\n            int prev = edge[1];\n            int next = edge[0];\n            graph[prev].push_back(next);\n            ++indegree[next];\n        }\n\n        // 入度为 0 的压入队列\n        queue<int> que;\n        for(int i=0;i<numcourses;++i){\n            if(!indegree[i]){\n                que.push(i);\n            }\n        }\n\n        // 使用队列进行广度优先遍历\n        while(!que.empty()){\n            int node = que.front();\n            que.pop();\n            for(const auto next:graph[node]){\n                --indegree[next];\n                if(!indegree[next]){\n                    que.push(next);\n                }\n            }\n        }\n\n        // 遍历完之后如果还存在 入度不为 0 的节点，说明存在环路\n        for(const auto degree:indegree){\n            if(degree){\n                return false;\n            }\n        }\n\n        return true;\n    }\n};\n\n\n# 210 课程表 ii\n\n给定 n 个课程和这些课程的前置必修课，求可以一次性上完所有课的顺序\n\n输入是一个正整数，表示课程数量，和一个二维矩阵，表示所有的有向边，例如 [1,0] 表示上课程 1 之前必须先上课程 0。输出是一个一维数组，表示拓扑排序结果。\n\n> 输入：numcourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]] 输出：[0,2,1,3] 解释：总共有 4 门课程。要学习课程 3，你应该先完成课程 1 和课程 2。并且课程 1 和课程 2 都应该排在课程 0 之后。因此，一个正确的课程顺序是 [0,1,2,3] 。另一个正确的排序是 [0,2,1,3] 。\n\n解析：\n\n拓扑排序的主要思路就是：考虑每一个节点的入度，当节点入度为 0 时，将其加入排序序列，同时将其指向的其他节点的入度减 1，所有节点完成遍历之后得到最终拓扑排序。\n\n对于本题我们可以先为拓扑图建立一个邻接矩阵表示图，题目中节点是后置课程指向前置课程，这在获取拓扑排序结果时是反向的。所以，我们在建立邻接矩阵时将所有边反向，使得如果课程 i 指向课程 j，那么课程 i 需要在课程 j 前面先修完。\n\n根据拓扑排序的思路，我们使用广度优先搜索解决本题：\n\n * 我们先遍历一遍所有节点，把入度为 0 的节点（即没有前置课程要求）放在队列中\n * 在每次从队列中获得节点时，我们将该节点放在目前排序的末尾\n * 同时，遍历该节点指向的后置课程，并且把这些课程的入度各减 1。如果在这个过程中该节点的后置课程中出现了入度为 0，那么该后置课程的前置课程都已经加入到了排序结果中，则将该后置课程加入队列中。\n * 当队列为空时，说明所有节点都已经遍历完成，或者是图中存在环路导致无法取得拓扑排序结果。\n\nclass solution {\npublic:\n    vector<int> findorder(int numcourses, vector<vector<int>>& prerequisites) {\n        vector<vector<int>> graph(numcourses,vector<int>());\n        vector<int> indegree(numcourses,0);\n        for(const auto edge:prerequisites){\n            // 让前置课程指向后置课程\n            graph[edge[1]].push_back(edge[0]);\n            // 后置课程入度+1\n            ++indegree[edge[0]];\n        }\n\n        queue<int> q;\n        // 将入度为0的节点加入队列\n        for(int i=0;i<numcourses;++i){\n            if(!indegree[i]){\n                q.push(i);\n            }\n        }\n\n        // 广度优先搜索 遍历图\n        vector<int> res;\n        while(!q.empty()){\n            const auto node = q.front();\n            q.pop();\n            res.push_back(node);\n            // 遍历当前节点的所有后置课程\n            for(const auto post:graph[node]){\n                --indegree[post];\n                if(!indegree[post]){\n                    q.push(post);\n                }\n            }\n        }\n\n        // 如果存在节点入度不为0,那么图中存在环，不能完成所有课程\n        for(const auto degree:indegree){\n            if(degree){\n                return {};\n            }\n        }\n        \n        return res;\n    }\n};\n",charsets:{cjk:!0},lastUpdated:"2023/11/19, 12:55:48",lastUpdatedTimestamp:1700369748e3},{title:"03并查集",frontmatter:{title:"03并查集",date:"2023-03-24T18:39:49.000Z",permalink:"/pages/e70bde/"},regularPath:"/03.LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/02.%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/05.%E5%9B%BE/03.%E5%B9%B6%E6%9F%A5%E9%9B%86.html",relativePath:"03.LeetCode刷题笔记/02.基础数据结构/05.图/03.并查集.md",key:"v-70c9603f",path:"/pages/e70bde/",headers:[{level:2,title:"03 并查集",slug:"_03-并查集",normalizedTitle:"03 并查集",charIndex:2},{level:4,title:"684 冗余连接",slug:"_684-冗余连接",normalizedTitle:"684 冗余连接",charIndex:180},{level:4,title:"685 冗余连接 II",slug:"_685-冗余连接-ii",normalizedTitle:"685 冗余连接 ii",charIndex:376},{level:4,title:"399 除法求值",slug:"_399-除法求值",normalizedTitle:"399 除法求值",charIndex:777},{level:4,title:"1631 最小体力消耗路径",slug:"_1631-最小体力消耗路径",normalizedTitle:"1631 最小体力消耗路径",charIndex:1405},{level:4,title:"547 省份数量",slug:"_547-省份数量",normalizedTitle:"547 省份数量",charIndex:1800}],headersStr:"03 并查集 684 冗余连接 685 冗余连接 II 399 除法求值 1631 最小体力消耗路径 547 省份数量",content:'# 03 并查集\n\n并查集（union-find, 或 disjoint set）可以动态地连通两个点，并且可以非常快速地判断两个 点是否连通。假设存在 n 个节点，我们先将所有节点的父亲标为自己；每次要连接节点 i 和 j 时， 我们可以将 i 的父亲标为 j；每次要查询两个节点是否相连时，我们可以查找 i 和 j 的祖先是否最 终为同一个人。\n\n\n\n# 684 冗余连接\n\n在无向图找出一条边，移除它之后该图能够成为一棵树（即无向无环图）。如果有多个解，返 回在原数组中位置最靠后的那条边。\n\n输入是一个二维数组，表示所有的边（对应的两个节点）；输出是一个一维数组，表示需要移除的边（对应的两个节点）。\n\n> 输入: edges = [[1,2], [2,3], [3,4], [1,4], [1,5]]\n> 输出: [1,4]\n\n解析：\n\n# 685 冗余连接 II\n\n在本问题中，有根树指满足以下条件的 有向 图。该树只有一个根节点，所有其他节点都是该根节点的后继。该树除了根节点之外的每一个节点都有且只有一个父节点，而根节点没有父节点。\n\n输入一个有向图，该图由一个有着 n 个节点（节点值不重复，从 1 到 n）的树及一条附加的有向边构成。附加的边包含在 1 到 n 中的两个不同顶点间，这条附加的边不属于树中已存在的边。\n\n结果图是一个以边组成的二维数组 edges 。 每个元素是一对 [ui, vi]，用以表示 有向 图中连接顶点 ui 和顶点 vi 的边，其中 ui 是 vi 的一个父节点。\n\n返回一条能删除的边，使得剩下的图是有 n 个节点的有根树。若有多个答案，返回最后出现在给定二维数组的答案。\n\n\n\n输入：edges = [[1,2],[2,3],[3,4],[4,1],[1,5]]\n输出：[4,1]\n\n\n解析：\n\n# 399 除法求值\n\n给定一个变量对数组 equations 和一个实数值数组 values 作为已知条件，其中 equations[i] = [Ai, Bi] 和 values[i] 共同表示等式 Ai / Bi = values[i] 。每个 Ai 或 Bi 是一个表示单个变量的字符串。\n\n另有一些以数组 queries 表示的问题，其中 queries[j] = [Cj, Dj] 表示第 j 个问题，请根据已知条件找出 Cj / Dj = ? 的结果作为答案。\n\n返回所有问题的答案 。如果存在某个无法确定的答案，则用 -1.0 替代这个答案。如果问题中出现了给定的已知条件中没有出现的字符串，也需要用 -1.0 替代这个答案。\n\n> 输入：equations = [["a","b"],["b","c"]], values = [2.0,3.0], queries = [["a","c"],["b","a"],["a","e"],["a","a"],["x","x"]]\n> \n> 输出：[6.00000,0.50000,-1.00000,1.00000,-1.00000]\n> \n> 解释： 条件：a / b = 2.0, b / c = 3.0 问题：a / c = ?, b / a = ?, a / e = ?, a / a = ?, x / x = ? 结果：[6.0, 0.5, -1.0, 1.0, -1.0 ]\n\n解析：\n\n# 1631 最小体力消耗路径\n\n给定一个二维 rows x columns 的地图 heights ，其中 heights[row][col] 表示格子 (row, col) 的高度。\n\n一开始在最左上角的格子 (0, 0) ，且希望去最右下角的格子 (rows-1, columns-1) （注意下标从 0 开始编号）。\n\n每次可以往 上，下，左，右 四个方向之一移动，想要找到耗费体力最小的一条路径。\n\n一条路径耗费的体力值是路径上相邻格子之间高度差绝对值的最大值决定的。\n\n请返回从左上角走到右下角的最小体力消耗值 。\n\n\n\n> 输入：heights = [[1,2,2],[3,8,2],[5,3,5]] 输出：2 解释：路径 [1,3,5,3,5] 连续格子的差值绝对值最大为 2 。这条路径比路径 [1,2,2,2,5] 更优，因为另一条路径差值最大值为 3 。\n\n解析：\n\n# 547 省份数量',normalizedContent:'# 03 并查集\n\n并查集（union-find, 或 disjoint set）可以动态地连通两个点，并且可以非常快速地判断两个 点是否连通。假设存在 n 个节点，我们先将所有节点的父亲标为自己；每次要连接节点 i 和 j 时， 我们可以将 i 的父亲标为 j；每次要查询两个节点是否相连时，我们可以查找 i 和 j 的祖先是否最 终为同一个人。\n\n\n\n# 684 冗余连接\n\n在无向图找出一条边，移除它之后该图能够成为一棵树（即无向无环图）。如果有多个解，返 回在原数组中位置最靠后的那条边。\n\n输入是一个二维数组，表示所有的边（对应的两个节点）；输出是一个一维数组，表示需要移除的边（对应的两个节点）。\n\n> 输入: edges = [[1,2], [2,3], [3,4], [1,4], [1,5]]\n> 输出: [1,4]\n\n解析：\n\n# 685 冗余连接 ii\n\n在本问题中，有根树指满足以下条件的 有向 图。该树只有一个根节点，所有其他节点都是该根节点的后继。该树除了根节点之外的每一个节点都有且只有一个父节点，而根节点没有父节点。\n\n输入一个有向图，该图由一个有着 n 个节点（节点值不重复，从 1 到 n）的树及一条附加的有向边构成。附加的边包含在 1 到 n 中的两个不同顶点间，这条附加的边不属于树中已存在的边。\n\n结果图是一个以边组成的二维数组 edges 。 每个元素是一对 [ui, vi]，用以表示 有向 图中连接顶点 ui 和顶点 vi 的边，其中 ui 是 vi 的一个父节点。\n\n返回一条能删除的边，使得剩下的图是有 n 个节点的有根树。若有多个答案，返回最后出现在给定二维数组的答案。\n\n\n\n输入：edges = [[1,2],[2,3],[3,4],[4,1],[1,5]]\n输出：[4,1]\n\n\n解析：\n\n# 399 除法求值\n\n给定一个变量对数组 equations 和一个实数值数组 values 作为已知条件，其中 equations[i] = [ai, bi] 和 values[i] 共同表示等式 ai / bi = values[i] 。每个 ai 或 bi 是一个表示单个变量的字符串。\n\n另有一些以数组 queries 表示的问题，其中 queries[j] = [cj, dj] 表示第 j 个问题，请根据已知条件找出 cj / dj = ? 的结果作为答案。\n\n返回所有问题的答案 。如果存在某个无法确定的答案，则用 -1.0 替代这个答案。如果问题中出现了给定的已知条件中没有出现的字符串，也需要用 -1.0 替代这个答案。\n\n> 输入：equations = [["a","b"],["b","c"]], values = [2.0,3.0], queries = [["a","c"],["b","a"],["a","e"],["a","a"],["x","x"]]\n> \n> 输出：[6.00000,0.50000,-1.00000,1.00000,-1.00000]\n> \n> 解释： 条件：a / b = 2.0, b / c = 3.0 问题：a / c = ?, b / a = ?, a / e = ?, a / a = ?, x / x = ? 结果：[6.0, 0.5, -1.0, 1.0, -1.0 ]\n\n解析：\n\n# 1631 最小体力消耗路径\n\n给定一个二维 rows x columns 的地图 heights ，其中 heights[row][col] 表示格子 (row, col) 的高度。\n\n一开始在最左上角的格子 (0, 0) ，且希望去最右下角的格子 (rows-1, columns-1) （注意下标从 0 开始编号）。\n\n每次可以往 上，下，左，右 四个方向之一移动，想要找到耗费体力最小的一条路径。\n\n一条路径耗费的体力值是路径上相邻格子之间高度差绝对值的最大值决定的。\n\n请返回从左上角走到右下角的最小体力消耗值 。\n\n\n\n> 输入：heights = [[1,2,2],[3,8,2],[5,3,5]] 输出：2 解释：路径 [1,3,5,3,5] 连续格子的差值绝对值最大为 2 。这条路径比路径 [1,2,2,2,5] 更优，因为另一条路径差值最大值为 3 。\n\n解析：\n\n# 547 省份数量',charsets:{cjk:!0},lastUpdated:"2023/11/19, 12:55:48",lastUpdatedTimestamp:1700369748e3},{title:"04最小生成树",frontmatter:{title:"04最小生成树",date:"2023-03-24T18:39:49.000Z",permalink:"/pages/599b16/"},regularPath:"/03.LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/02.%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/05.%E5%9B%BE/04.%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91.html",relativePath:"03.LeetCode刷题笔记/02.基础数据结构/05.图/04.最小生成树.md",key:"v-b6beb69c",path:"/pages/599b16/",headers:[{level:2,title:"最小生成树问题",slug:"最小生成树问题",normalizedTitle:"最小生成树问题",charIndex:2},{level:4,title:"Prim算法",slug:"prim算法",normalizedTitle:"prim算法",charIndex:307},{level:4,title:"Kruskal算法",slug:"kruskal算法",normalizedTitle:"kruskal算法",charIndex:319}],headersStr:"最小生成树问题 Prim算法 Kruskal算法",content:"# 最小生成树问题\n\n参考链接：https://blog.csdn.net/Africa_South/article/details/88608619\n\n一个连通图的生成树是一个极小连通子图，它含有图中全部的顶点，但是只有足有构成一棵树的n-1条边。它有如下性质：\n\n * 一棵有n个顶点的生成树有且只有n − 1条边；\n * 如果一个图有n个顶点和小于n − 1条边，则是非连通图；如果它多于n − 1条边，则一定有环；\n * 但是有n − 1条边的n个顶点的图不一定是生成树。（它只是必要条件）\n\n一棵生成树的代价就是树上各边的代价之和。\n\n最小生成树就是构造连通图的最小代价生成树，简称为最小生成树。\n\n# Prim算法\n\n\n\n# Kruskal算法\n\n",normalizedContent:"# 最小生成树问题\n\n参考链接：https://blog.csdn.net/africa_south/article/details/88608619\n\n一个连通图的生成树是一个极小连通子图，它含有图中全部的顶点，但是只有足有构成一棵树的n-1条边。它有如下性质：\n\n * 一棵有n个顶点的生成树有且只有n − 1条边；\n * 如果一个图有n个顶点和小于n − 1条边，则是非连通图；如果它多于n − 1条边，则一定有环；\n * 但是有n − 1条边的n个顶点的图不一定是生成树。（它只是必要条件）\n\n一棵生成树的代价就是树上各边的代价之和。\n\n最小生成树就是构造连通图的最小代价生成树，简称为最小生成树。\n\n# prim算法\n\n\n\n# kruskal算法\n\n",charsets:{cjk:!0},lastUpdated:"2023/11/19, 12:55:48",lastUpdatedTimestamp:1700369748e3},{title:"01二分图",frontmatter:{title:"01二分图",date:"2023-03-24T18:39:49.000Z",permalink:"/pages/208d53/"},regularPath:"/03.LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/02.%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/05.%E5%9B%BE/01.%E4%BA%8C%E5%88%86%E5%9B%BE.html",relativePath:"03.LeetCode刷题笔记/02.基础数据结构/05.图/01.二分图.md",key:"v-0dbfcf13",path:"/pages/208d53/",headers:[{level:2,title:"01 二分图",slug:"_01-二分图",normalizedTitle:"01 二分图",charIndex:2},{level:4,title:"785 判断二分图",slug:"_785-判断二分图",normalizedTitle:"785 判断二分图",charIndex:162}],headersStr:"01 二分图 785 判断二分图",content:"# 01 二分图\n\n二分图算法也称为染色法，是一种广度优先搜索。如果可以用两种颜色对图中的节点进行着色，并且保证相邻的节点颜色不同，那么图为二分。\n\n二分图定义：如果能将一个图的节点集合分割成两个独立的子集 A 和 B ，并使图中的每一条边的两个节点一个来自 A 集合，一个来自 B 集合，就将这个图称为 二分图 。\n\n# 785 判断二分图\n\n给定一个图，判断其是否可以二分\n\n输入是邻接链表表示的图（如位置 0 的邻接链表为 [1,3]，表示 0 与 1、0 与 3 相连）；输出是一个布尔值，表示图是否二分。\n\n> 输入：graph = [[1,3],[0,2],[1,3],[0,2]]\n> 输出：true\n> 解释：可以将节点分成两组: {0, 2} 和 {1, 3} 。\n\n解析：\n\n利用队列和广度优先搜索，我们可以对未染色的节点进行染色，并且检查是否有颜色相同的相邻节点存在。如果遍历完所有节点没有颜色相同的相邻节点，则该图为二分图；否则就不是二分图。在遍历过程中，我们用 0 表示未检查的节点，用 1 和 2 表示两种不同的颜色。\n\n我们任选一个节点开始，将其染成 1 色，并从该节点开始对整个无向图进行遍历；\n\n在遍历的过程中，如果我们通过节点 u 遍历到了节点 v，那么会有两种情况：如果 v 未被染色，那么我们将其染成与 u 不同的颜色，并对 v 直接相连的节点进行遍历；如果 v 已经被染色，并且颜色与 u 相同，那么说明给定的无向图不是二分图，可以直接退出并返回 False。\n\n当遍历完成时，说明给定的无向图是二分图，返回 True。\n\nclass Solution {\npublic:\n    bool isBipartite(vector<vector<int>>& graph) {\n        if(graph.empty()){\n            return false;\n        }\n        vector<int> color(graph.size(),0);\n        queue<int> q;\n        for(int i=0;i<graph.size();++i){\n            if(!color[i]){\n                q.push(i);\n                color[i] = 1;\n            }\n            while(!q.empty()){\n                int node = q.front();\n                q.pop();\n                // 对 v 直接相连的节点进行遍历\n                for(const auto& j: graph[node]){\n                    if(!color[j]){\n                        q.push(j);\n                        color[j] = color[node] == 2?1:2;\n                    }else if(color[j] == color[node]){\n                        return false;\n                    }\n                }\n            }\n        }\n        return true;\n    }\n};\n",normalizedContent:"# 01 二分图\n\n二分图算法也称为染色法，是一种广度优先搜索。如果可以用两种颜色对图中的节点进行着色，并且保证相邻的节点颜色不同，那么图为二分。\n\n二分图定义：如果能将一个图的节点集合分割成两个独立的子集 a 和 b ，并使图中的每一条边的两个节点一个来自 a 集合，一个来自 b 集合，就将这个图称为 二分图 。\n\n# 785 判断二分图\n\n给定一个图，判断其是否可以二分\n\n输入是邻接链表表示的图（如位置 0 的邻接链表为 [1,3]，表示 0 与 1、0 与 3 相连）；输出是一个布尔值，表示图是否二分。\n\n> 输入：graph = [[1,3],[0,2],[1,3],[0,2]]\n> 输出：true\n> 解释：可以将节点分成两组: {0, 2} 和 {1, 3} 。\n\n解析：\n\n利用队列和广度优先搜索，我们可以对未染色的节点进行染色，并且检查是否有颜色相同的相邻节点存在。如果遍历完所有节点没有颜色相同的相邻节点，则该图为二分图；否则就不是二分图。在遍历过程中，我们用 0 表示未检查的节点，用 1 和 2 表示两种不同的颜色。\n\n我们任选一个节点开始，将其染成 1 色，并从该节点开始对整个无向图进行遍历；\n\n在遍历的过程中，如果我们通过节点 u 遍历到了节点 v，那么会有两种情况：如果 v 未被染色，那么我们将其染成与 u 不同的颜色，并对 v 直接相连的节点进行遍历；如果 v 已经被染色，并且颜色与 u 相同，那么说明给定的无向图不是二分图，可以直接退出并返回 false。\n\n当遍历完成时，说明给定的无向图是二分图，返回 true。\n\nclass solution {\npublic:\n    bool isbipartite(vector<vector<int>>& graph) {\n        if(graph.empty()){\n            return false;\n        }\n        vector<int> color(graph.size(),0);\n        queue<int> q;\n        for(int i=0;i<graph.size();++i){\n            if(!color[i]){\n                q.push(i);\n                color[i] = 1;\n            }\n            while(!q.empty()){\n                int node = q.front();\n                q.pop();\n                // 对 v 直接相连的节点进行遍历\n                for(const auto& j: graph[node]){\n                    if(!color[j]){\n                        q.push(j);\n                        color[j] = color[node] == 2?1:2;\n                    }else if(color[j] == color[node]){\n                        return false;\n                    }\n                }\n            }\n        }\n        return true;\n    }\n};\n",charsets:{cjk:!0},lastUpdated:"2023/11/19, 12:55:48",lastUpdatedTimestamp:1700369748e3},{title:"Graph",frontmatter:{title:"Graph",date:"2023-03-24T18:39:49.000Z",permalink:"/pages/68e203/"},regularPath:"/03.LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/02.%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/05.%E5%9B%BE/Graph.html",relativePath:"03.LeetCode刷题笔记/02.基础数据结构/05.图/Graph.md",key:"v-6b98cea6",path:"/pages/68e203/",headers:[{level:2,title:"LeetCode刷题笔记 图",slug:"leetcode刷题笔记-图",normalizedTitle:"leetcode刷题笔记 图",charIndex:2}],headersStr:"LeetCode刷题笔记 图",content:"# LeetCode刷题笔记 图\n\n图是树的升级版。图通常分为有向（directed）或无向（undirected），有循环（cyclic）或无循环（acyclic） ，所有节点相连（connected）或不相连（disconnected）。树即是一个相连的无向无环图，而另一种很常见的图是有向无环图（Directed Acyclic Graph，DAG）。\n\n图通常有两种表示方法。假设图中一共有 n 个节点、m 条边。\n\n第一种表示方法是邻接矩阵（adjacency matrix）：我们可以建立一个 n × n 的矩阵 G，如果第 i 个节点连向第 j 个节点，则 G[i][j]= 1，反之为 0；如果图是无向的，则这个矩阵一定是对称矩阵，即 G[i][j] = G[j][i]。\n\n第二种表示方法是邻接链表（adjacency list）：我们可以建立一个大小为 n 的数组，每个位置 i 储存一个数组 或者链表，表示第 i 个节点连向的其它节点。\n\n邻接矩阵空间开销比邻接链表大，但是邻接链表不支持快速查找 i 和 j 是否相连，因此两种表示方法可以根据题目需要适当选择。除此之外，我们也可以直接用一个 m × 2 的矩阵储存所有的边。",normalizedContent:"# leetcode刷题笔记 图\n\n图是树的升级版。图通常分为有向（directed）或无向（undirected），有循环（cyclic）或无循环（acyclic） ，所有节点相连（connected）或不相连（disconnected）。树即是一个相连的无向无环图，而另一种很常见的图是有向无环图（directed acyclic graph，dag）。\n\n图通常有两种表示方法。假设图中一共有 n 个节点、m 条边。\n\n第一种表示方法是邻接矩阵（adjacency matrix）：我们可以建立一个 n × n 的矩阵 g，如果第 i 个节点连向第 j 个节点，则 g[i][j]= 1，反之为 0；如果图是无向的，则这个矩阵一定是对称矩阵，即 g[i][j] = g[j][i]。\n\n第二种表示方法是邻接链表（adjacency list）：我们可以建立一个大小为 n 的数组，每个位置 i 储存一个数组 或者链表，表示第 i 个节点连向的其它节点。\n\n邻接矩阵空间开销比邻接链表大，但是邻接链表不支持快速查找 i 和 j 是否相连，因此两种表示方法可以根据题目需要适当选择。除此之外，我们也可以直接用一个 m × 2 的矩阵储存所有的边。",charsets:{cjk:!0},lastUpdated:"2023/11/19, 12:55:48",lastUpdatedTimestamp:1700369748e3},{title:"05最短路径",frontmatter:{title:"05最短路径",date:"2023-03-24T18:39:49.000Z",permalink:"/pages/cc367b/"},regularPath:"/03.LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/02.%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/05.%E5%9B%BE/05.%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84.html",relativePath:"03.LeetCode刷题笔记/02.基础数据结构/05.图/05.最短路径.md",key:"v-aa15e9b4",path:"/pages/cc367b/",headers:[{level:2,title:"图的最短路径",slug:"图的最短路径",normalizedTitle:"图的最短路径",charIndex:2},{level:3,title:"Dijkstra 算法",slug:"dijkstra-算法",normalizedTitle:"dijkstra 算法",charIndex:13},{level:4,title:"1631 最小体力消耗路径",slug:"_1631-最小体力消耗路径",normalizedTitle:"1631 最小体力消耗路径",charIndex:1297}],headersStr:"图的最短路径 Dijkstra 算法 1631 最小体力消耗路径",content:"# 图的最短路径\n\n\n# Dijkstra 算法\n\n给定一个带权图以及其起点和终点，求起点到终点之间的最短路径。如下图所示，以A点为起点，F点为终点，求A到F的最短路径。\n\nDijkstra的算法思想是一种贪婪策略，算法贪婪地探索从s开始的路径，每次移动到下一个最近的节点，通过这种方式实际上构造了从s到图中每个其他节点的最短路径。即从上述最短距离数组中每次选择一个最近的点，将其作为下一个点，然后重新计算从起始点经过该点到其他所有点的距离，更新最短距离数据。已经选取过的点就是确定了最短路径的点，不再参与下一次计算。\n\n更加形式化的表达如下：\n\n * 对于图 $G=(V,E,W),V={A,B,C,D,E,F},s=A,t=F$\n\n * 初始化确定集合$K={s},Path(s)=\\varnothing,d(s)=0$\n\n * 对于所有不在K中的结点$i\\in (V-K)$，计算距离$d(i) = min{d(u)+w(u,i)},u \\in K$\n\n * 选择$d(i)$中最小的值对应的结点，将其加入到K中，并修改不属于K的结点到K中结点的最小距离\n\nconst int infinity = 99999;\n\nvoid dijkstra(vector<vector<int>> G, vector<int>& res){\n    int points = G.size();\n    vector<int> dist(points);\n    vector<bool> flag(points,false);\n    res = dist;\n    // 起点 初始化被选集\n    flag[0] = true;\n    for(int i=0;i<points;++i){\n        dist[i] = G[0][i];\n    }\n    // 寻找最短路径\n    for(int i=1;i<points-1;++i){\n        int min = infinity;\n        int u = -1;\n        for(int j=0;j<points;++j){\n            // 比较离原点最近的点\n            if(!flag[j]&&dist[j]<min){\n                u = j;\n                min = dist[j];\n            }\n        }\n        // 找出最近点之后，更新最短距离\n        flag[u] = true;\n        for(int j=1;j<points;++j){\n            if(!flag[j]&&(dist[u]+G[u][j]<dist[j])){\n                dist[j] = dist[u] + G[u][j];\n                res[j] = u;\n            }\n        }\n    }\n}\n\n\n# 1631 最小体力消耗路径\n\n给定一个二维 rows x columns 的地图 heights ，其中 heights[row][col] 表示格子 (row, col) 的高度。\n\n一开始在最左上角的格子 (0, 0) ，且希望去最右下角的格子 (rows-1, columns-1) （注意下标从 0 开始编号）。\n\n每次可以往 上，下，左，右 四个方向之一移动，想要找到耗费体力最小的一条路径。\n\n一条路径耗费的体力值是路径上相邻格子之间高度差绝对值的最大值决定的。\n\n请返回从左上角走到右下角的最小体力消耗值 。\n\n\n\n> 输入：heights = [[1,2,2],[3,8,2],[5,3,5]] 输出：2 解释：路径 [1,3,5,3,5] 连续格子的差值绝对值最大为 2 。这条路径比路径 [1,2,2,2,5] 更优，因为另一条路径差值最大值为 3 。\n\n解析：",normalizedContent:"# 图的最短路径\n\n\n# dijkstra 算法\n\n给定一个带权图以及其起点和终点，求起点到终点之间的最短路径。如下图所示，以a点为起点，f点为终点，求a到f的最短路径。\n\ndijkstra的算法思想是一种贪婪策略，算法贪婪地探索从s开始的路径，每次移动到下一个最近的节点，通过这种方式实际上构造了从s到图中每个其他节点的最短路径。即从上述最短距离数组中每次选择一个最近的点，将其作为下一个点，然后重新计算从起始点经过该点到其他所有点的距离，更新最短距离数据。已经选取过的点就是确定了最短路径的点，不再参与下一次计算。\n\n更加形式化的表达如下：\n\n * 对于图 $g=(v,e,w),v={a,b,c,d,e,f},s=a,t=f$\n\n * 初始化确定集合$k={s},path(s)=\\varnothing,d(s)=0$\n\n * 对于所有不在k中的结点$i\\in (v-k)$，计算距离$d(i) = min{d(u)+w(u,i)},u \\in k$\n\n * 选择$d(i)$中最小的值对应的结点，将其加入到k中，并修改不属于k的结点到k中结点的最小距离\n\nconst int infinity = 99999;\n\nvoid dijkstra(vector<vector<int>> g, vector<int>& res){\n    int points = g.size();\n    vector<int> dist(points);\n    vector<bool> flag(points,false);\n    res = dist;\n    // 起点 初始化被选集\n    flag[0] = true;\n    for(int i=0;i<points;++i){\n        dist[i] = g[0][i];\n    }\n    // 寻找最短路径\n    for(int i=1;i<points-1;++i){\n        int min = infinity;\n        int u = -1;\n        for(int j=0;j<points;++j){\n            // 比较离原点最近的点\n            if(!flag[j]&&dist[j]<min){\n                u = j;\n                min = dist[j];\n            }\n        }\n        // 找出最近点之后，更新最短距离\n        flag[u] = true;\n        for(int j=1;j<points;++j){\n            if(!flag[j]&&(dist[u]+g[u][j]<dist[j])){\n                dist[j] = dist[u] + g[u][j];\n                res[j] = u;\n            }\n        }\n    }\n}\n\n\n# 1631 最小体力消耗路径\n\n给定一个二维 rows x columns 的地图 heights ，其中 heights[row][col] 表示格子 (row, col) 的高度。\n\n一开始在最左上角的格子 (0, 0) ，且希望去最右下角的格子 (rows-1, columns-1) （注意下标从 0 开始编号）。\n\n每次可以往 上，下，左，右 四个方向之一移动，想要找到耗费体力最小的一条路径。\n\n一条路径耗费的体力值是路径上相邻格子之间高度差绝对值的最大值决定的。\n\n请返回从左上角走到右下角的最小体力消耗值 。\n\n\n\n> 输入：heights = [[1,2,2],[3,8,2],[5,3,5]] 输出：2 解释：路径 [1,3,5,3,5] 连续格子的差值绝对值最大为 2 。这条路径比路径 [1,2,2,2,5] 更优，因为另一条路径差值最大值为 3 。\n\n解析：",charsets:{cjk:!0},lastUpdated:"2023/11/19, 12:55:48",lastUpdatedTimestamp:1700369748e3},{title:"02分配问题",frontmatter:{title:"02分配问题",date:"2023-03-24T18:39:49.000Z",permalink:"/pages/82a324/"},regularPath:"/03.LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/03.%E8%BF%9B%E9%98%B6%E7%AE%97%E6%B3%95/01.%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/02.%E5%88%86%E9%85%8D%E9%97%AE%E9%A2%98.html",relativePath:"03.LeetCode刷题笔记/03.进阶算法/01.贪心算法/02.分配问题.md",key:"v-43523836",path:"/pages/82a324/",headers:[{level:3,title:"01 跳跃游戏",slug:"_01-跳跃游戏",normalizedTitle:"01 跳跃游戏",charIndex:2},{level:4,title:"55 跳跃游戏",slug:"_55-跳跃游戏",normalizedTitle:"55 跳跃游戏",charIndex:13}],headersStr:"01 跳跃游戏 55 跳跃游戏",content:"# 01 跳跃游戏\n\n# 55 跳跃游戏\n\n给定一个非负整数数组 nums ，最初位于数组的第一个下标 。数组中的每个元素代表你在该位置可以跳跃的最大长度。判断是否能够到达最后一个下标。\n\n> 输入：nums = [2,3,1,1,4]\n> 输出：true\n> 解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。\n\n解析：\n\nclass Solution {\npublic:\n    bool canJump(vector<int>& nums) {\n        int n = nums.size();\n        if(n==1){\n            return true;\n        }\n        int cover = nums[0];\n        // 遍历当前可达的区域\n        for(int i=1;i<=cover;++i){\n            // 更新更大的可达区域\n            cover = max(cover,i+nums[i]);\n            if(cover >= n-1){\n                return true;\n            }\n        }\n        return false;\n    }\n};\n",normalizedContent:"# 01 跳跃游戏\n\n# 55 跳跃游戏\n\n给定一个非负整数数组 nums ，最初位于数组的第一个下标 。数组中的每个元素代表你在该位置可以跳跃的最大长度。判断是否能够到达最后一个下标。\n\n> 输入：nums = [2,3,1,1,4]\n> 输出：true\n> 解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。\n\n解析：\n\nclass solution {\npublic:\n    bool canjump(vector<int>& nums) {\n        int n = nums.size();\n        if(n==1){\n            return true;\n        }\n        int cover = nums[0];\n        // 遍历当前可达的区域\n        for(int i=1;i<=cover;++i){\n            // 更新更大的可达区域\n            cover = max(cover,i+nums[i]);\n            if(cover >= n-1){\n                return true;\n            }\n        }\n        return false;\n    }\n};\n",charsets:{cjk:!0},lastUpdated:"2023/11/19, 12:55:48",lastUpdatedTimestamp:1700369748e3},{title:"03区间问题",frontmatter:{title:"03区间问题",date:"2023-03-24T18:39:49.000Z",permalink:"/pages/df21f6/"},regularPath:"/03.LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/03.%E8%BF%9B%E9%98%B6%E7%AE%97%E6%B3%95/01.%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/03.%E5%8C%BA%E9%97%B4%E9%97%AE%E9%A2%98.html",relativePath:"03.LeetCode刷题笔记/03.进阶算法/01.贪心算法/03.区间问题.md",key:"v-0565826e",path:"/pages/df21f6/",headers:[{level:3,title:"01 跳跃游戏",slug:"_01-跳跃游戏",normalizedTitle:"01 跳跃游戏",charIndex:2},{level:4,title:"55 跳跃游戏",slug:"_55-跳跃游戏",normalizedTitle:"55 跳跃游戏",charIndex:13}],headersStr:"01 跳跃游戏 55 跳跃游戏",content:"# 01 跳跃游戏\n\n# 55 跳跃游戏\n\n给定一个非负整数数组 nums ，最初位于数组的第一个下标 。数组中的每个元素代表你在该位置可以跳跃的最大长度。判断是否能够到达最后一个下标。\n\n> 输入：nums = [2,3,1,1,4]\n> 输出：true\n> 解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。\n\n解析：\n\nclass Solution {\npublic:\n    bool canJump(vector<int>& nums) {\n        int n = nums.size();\n        if(n==1){\n            return true;\n        }\n        int cover = nums[0];\n        // 遍历当前可达的区域\n        for(int i=1;i<=cover;++i){\n            // 更新更大的可达区域\n            cover = max(cover,i+nums[i]);\n            if(cover >= n-1){\n                return true;\n            }\n        }\n        return false;\n    }\n};\n",normalizedContent:"# 01 跳跃游戏\n\n# 55 跳跃游戏\n\n给定一个非负整数数组 nums ，最初位于数组的第一个下标 。数组中的每个元素代表你在该位置可以跳跃的最大长度。判断是否能够到达最后一个下标。\n\n> 输入：nums = [2,3,1,1,4]\n> 输出：true\n> 解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。\n\n解析：\n\nclass solution {\npublic:\n    bool canjump(vector<int>& nums) {\n        int n = nums.size();\n        if(n==1){\n            return true;\n        }\n        int cover = nums[0];\n        // 遍历当前可达的区域\n        for(int i=1;i<=cover;++i){\n            // 更新更大的可达区域\n            cover = max(cover,i+nums[i]);\n            if(cover >= n-1){\n                return true;\n            }\n        }\n        return false;\n    }\n};\n",charsets:{cjk:!0},lastUpdated:"2023/11/19, 12:55:48",lastUpdatedTimestamp:1700369748e3},{title:"DC",frontmatter:{title:"DC",date:"2023-03-24T18:39:49.000Z",permalink:"/pages/a967a6/"},regularPath:"/03.LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/03.%E8%BF%9B%E9%98%B6%E7%AE%97%E6%B3%95/02.%E5%88%86%E6%B2%BB%E7%AD%96%E7%95%A5/DC.html",relativePath:"03.LeetCode刷题笔记/03.进阶算法/02.分治策略/DC.md",key:"v-5dd3c9a7",path:"/pages/a967a6/",headers:[{level:2,title:"LeetCode刷题笔记 分治策略",slug:"leetcode刷题笔记-分治策略",normalizedTitle:"leetcode刷题笔记 分治策略",charIndex:2},{level:4,title:"241 为运算表达式设计优先级",slug:"_241-为运算表达式设计优先级",normalizedTitle:"241 为运算表达式设计优先级",charIndex:92}],headersStr:"LeetCode刷题笔记 分治策略 241 为运算表达式设计优先级",content:"# LeetCode刷题笔记 分治策略\n\n分治问题由分（divide）和治（conquer）两部分组成，通过把原问题分为子问题，再将子问题进行处理合并，从而实现对原问题的求解。\n\n# 241 为运算表达式设计优先级\n\n给定一个只包含加、减和乘法的数学表达式，求通过加括号可以得到多少种不同的结果。\n\n输入是一个字符串，表示数学表达式；输出是一个数组，存储所有不同的加括号结果。\n\n> 输入: \"2-1-1\"\n> 输出: [0, 2]\n> 解释: \n> ((2-1)-1) = 0 \n> (2-(1-1)) = 2\n\n解析：\n\n利用分治思想，我们可以把加括号转化为：对于每个运算符号，先执行处理两侧的数学表达式，再处理此运算符号。例如2-1-1，先将第一个减号的两侧划分为两个部分即2, 1-1，分别计算得到结果为 2；第二个减号的两侧划分为两个部分即2-1, 1，分别计算得到的结果是 0。注意边界情况，即字符串内无运算符号，只有数字。\n\nclass Solution {\npublic:\n    vector<int> diffWaysToCompute(string expression) {\n        vector<int> ways;\n        for(int i=0;i<expression.length();++i){\n            char c = expression[i];\n            if( c == '+' || c == '-' || c == '*'){\n                vector<int> lsh = diffWaysToCompute(expression.substr(0,i));\n                vector<int> rsh = diffWaysToCompute(expression.substr(i+1));\n                for(const int& l: lsh){\n                    for(const int& r: rsh){\n                        switch(c){\n                            case '+': ways.push_back(l+r); break;\n                            case '-': ways.push_back(l-r); break;\n                            case '*': ways.push_back(l*r); break;\n                        }\n                    }\n                }\n            }\n        }\n        if(ways.empty()){\n            ways.push_back(stio(expression));\n        }\n        return ways;\n    }\n};\n\n\nstoi()方法是 C++11的新特性，更多字符串与其他类型的相互转化如下\n\n// #include <string>\n// 其他类型转字符串\nstring to_string(int _Val);\nstring to_string(unsigned int _Val);\nstring to_string(long _Val);\nstring to_string(unsigned long _Val);\nstring to_string(long long _Val);\nstring to_string(unsigned long long _Val);\nstring to_string(float _Val);\nstring to_string(double _Val);\nstring to_string(long double _Val);\n\n// 字符串转其他类型\ndouble stod(const string& _Str, size_t *_Idx = nullptr);\nfloat stof(const string& _Str, size_t *_Idx = nullptr);\nint stoi(const string& _Str, size_t *_Idx = nullptr, int _Base = 10);\nlong stol(const string& _Str, size_t *_Idx = nullptr, int _Base = 10);\nlong double stold(const string& _Str, size_t *_Idx = nullptr);\nunsigned long stoul(const string& _Str, size_t *_Idx = nullptr, int _Base = 10);\nlong long stoll(const string& _Str, size_t *_Idx = nullptr, int _Base = 10);\nunsigned long long stoull(const string& _Str, size_t *_Idx = nullptr, int _Base = 10);\n",normalizedContent:"# leetcode刷题笔记 分治策略\n\n分治问题由分（divide）和治（conquer）两部分组成，通过把原问题分为子问题，再将子问题进行处理合并，从而实现对原问题的求解。\n\n# 241 为运算表达式设计优先级\n\n给定一个只包含加、减和乘法的数学表达式，求通过加括号可以得到多少种不同的结果。\n\n输入是一个字符串，表示数学表达式；输出是一个数组，存储所有不同的加括号结果。\n\n> 输入: \"2-1-1\"\n> 输出: [0, 2]\n> 解释: \n> ((2-1)-1) = 0 \n> (2-(1-1)) = 2\n\n解析：\n\n利用分治思想，我们可以把加括号转化为：对于每个运算符号，先执行处理两侧的数学表达式，再处理此运算符号。例如2-1-1，先将第一个减号的两侧划分为两个部分即2, 1-1，分别计算得到结果为 2；第二个减号的两侧划分为两个部分即2-1, 1，分别计算得到的结果是 0。注意边界情况，即字符串内无运算符号，只有数字。\n\nclass solution {\npublic:\n    vector<int> diffwaystocompute(string expression) {\n        vector<int> ways;\n        for(int i=0;i<expression.length();++i){\n            char c = expression[i];\n            if( c == '+' || c == '-' || c == '*'){\n                vector<int> lsh = diffwaystocompute(expression.substr(0,i));\n                vector<int> rsh = diffwaystocompute(expression.substr(i+1));\n                for(const int& l: lsh){\n                    for(const int& r: rsh){\n                        switch(c){\n                            case '+': ways.push_back(l+r); break;\n                            case '-': ways.push_back(l-r); break;\n                            case '*': ways.push_back(l*r); break;\n                        }\n                    }\n                }\n            }\n        }\n        if(ways.empty()){\n            ways.push_back(stio(expression));\n        }\n        return ways;\n    }\n};\n\n\nstoi()方法是 c++11的新特性，更多字符串与其他类型的相互转化如下\n\n// #include <string>\n// 其他类型转字符串\nstring to_string(int _val);\nstring to_string(unsigned int _val);\nstring to_string(long _val);\nstring to_string(unsigned long _val);\nstring to_string(long long _val);\nstring to_string(unsigned long long _val);\nstring to_string(float _val);\nstring to_string(double _val);\nstring to_string(long double _val);\n\n// 字符串转其他类型\ndouble stod(const string& _str, size_t *_idx = nullptr);\nfloat stof(const string& _str, size_t *_idx = nullptr);\nint stoi(const string& _str, size_t *_idx = nullptr, int _base = 10);\nlong stol(const string& _str, size_t *_idx = nullptr, int _base = 10);\nlong double stold(const string& _str, size_t *_idx = nullptr);\nunsigned long stoul(const string& _str, size_t *_idx = nullptr, int _base = 10);\nlong long stoll(const string& _str, size_t *_idx = nullptr, int _base = 10);\nunsigned long long stoull(const string& _str, size_t *_idx = nullptr, int _base = 10);\n",charsets:{cjk:!0},lastUpdated:"2023/11/19, 12:55:48",lastUpdatedTimestamp:1700369748e3},{title:"01跳跃游戏",frontmatter:{title:"01跳跃游戏",date:"2023-03-24T18:39:49.000Z",permalink:"/pages/fbf15c/"},regularPath:"/03.LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/03.%E8%BF%9B%E9%98%B6%E7%AE%97%E6%B3%95/01.%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/01.%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F.html",relativePath:"03.LeetCode刷题笔记/03.进阶算法/01.贪心算法/01.跳跃游戏.md",key:"v-13231700",path:"/pages/fbf15c/",headers:[{level:3,title:"01 跳跃游戏",slug:"_01-跳跃游戏",normalizedTitle:"01 跳跃游戏",charIndex:2},{level:4,title:"55 跳跃游戏",slug:"_55-跳跃游戏",normalizedTitle:"55 跳跃游戏",charIndex:13}],headersStr:"01 跳跃游戏 55 跳跃游戏",content:"# 01 跳跃游戏\n\n# 55 跳跃游戏\n\n给定一个非负整数数组 nums ，最初位于数组的第一个下标 。数组中的每个元素代表你在该位置可以跳跃的最大长度。判断是否能够到达最后一个下标。\n\n> 输入：nums = [2,3,1,1,4]\n> 输出：true\n> 解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。\n\n解析：\n\nclass Solution {\npublic:\n    bool canJump(vector<int>& nums) {\n        int n = nums.size();\n        if(n==1){\n            return true;\n        }\n        int cover = nums[0];\n        // 遍历当前可达的区域\n        for(int i=1;i<=cover;++i){\n            // 更新更大的可达区域\n            cover = max(cover,i+nums[i]);\n            if(cover >= n-1){\n                return true;\n            }\n        }\n        return false;\n    }\n};\n",normalizedContent:"# 01 跳跃游戏\n\n# 55 跳跃游戏\n\n给定一个非负整数数组 nums ，最初位于数组的第一个下标 。数组中的每个元素代表你在该位置可以跳跃的最大长度。判断是否能够到达最后一个下标。\n\n> 输入：nums = [2,3,1,1,4]\n> 输出：true\n> 解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。\n\n解析：\n\nclass solution {\npublic:\n    bool canjump(vector<int>& nums) {\n        int n = nums.size();\n        if(n==1){\n            return true;\n        }\n        int cover = nums[0];\n        // 遍历当前可达的区域\n        for(int i=1;i<=cover;++i){\n            // 更新更大的可达区域\n            cover = max(cover,i+nums[i]);\n            if(cover >= n-1){\n                return true;\n            }\n        }\n        return false;\n    }\n};\n",charsets:{cjk:!0},lastUpdated:"2023/11/19, 12:55:48",lastUpdatedTimestamp:1700369748e3},{title:"01一维动态规划",frontmatter:{title:"01一维动态规划",date:"2023-03-24T18:39:49.000Z",permalink:"/pages/be1ad8/"},regularPath:"/03.LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/03.%E8%BF%9B%E9%98%B6%E7%AE%97%E6%B3%95/03.%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/01.%E4%B8%80%E7%BB%B4%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.html",relativePath:"03.LeetCode刷题笔记/03.进阶算法/03.动态规划/01.一维动态规划.md",key:"v-66dc6312",path:"/pages/be1ad8/",headers:[{level:2,title:"01 一维动态规划",slug:"_01-一维动态规划",normalizedTitle:"01 一维动态规划",charIndex:2},{level:4,title:"70 爬楼梯",slug:"_70-爬楼梯",normalizedTitle:"70 爬楼梯",charIndex:15},{level:4,title:"198 打家劫舍",slug:"_198-打家劫舍",normalizedTitle:"198 打家劫舍",charIndex:623},{level:4,title:"213 打家劫舍 II",slug:"_213-打家劫舍-ii",normalizedTitle:"213 打家劫舍 ii",charIndex:1456},{level:4,title:"413 等差数列划分",slug:"_413-等差数列划分",normalizedTitle:"413 等差数列划分",charIndex:3240},{level:4,title:"53 最大子序和",slug:"_53-最大子序和",normalizedTitle:"53 最大子序和",charIndex:3993}],headersStr:"01 一维动态规划 70 爬楼梯 198 打家劫舍 213 打家劫舍 II 413 等差数列划分 53 最大子序和",content:"# 01 一维动态规划\n\n# 70 爬楼梯\n\n给定 n 节台阶，每次可以走一步或走两步，求一共有多少种方式可以走完这些台阶。\n\n输入是一个数字，表示台阶数量；输出是爬台阶的总方式。\n\n> 输入： 2\n> 输出： 2\n> 解释： 有两种方法可以爬到楼顶。\n> 1.  1 阶 + 1 阶\n> 2.  2 阶\n\n解析:\n\n这是十分经典的斐波那契数列题。\n\n设置状态：定义一个数组 dp，dp[i] 表示走到第 i 阶的方法数\n\n状态转移方程：因为我们每次可以走一步或者两步，所以第 i 阶可以从第 i-1 或 i-2 阶到达。换句话说，走到第 i 阶的方法数即为走到第 i-1 阶的方法数加上走到第 i-2 阶的方法数。这样我们就得到了状态转移方程dp[i] = dp[i-1] + dp[i-2]。\n\n初始情况：当阶数小于等于1时，方法数为1\n\nclass Solution {\npublic:\n    int climbStairs(int n) {\n        if(n<2) return n;\n        vector<int> dp(n+1);\n        dp[0] = dp[1] = 1;\n        for(int i=2;i<=n;++i){\n            dp[i] = dp[i-1] + dp[i-2];\n        }\n        return dp[n];\n    }\n};\n\n\n# 198 打家劫舍\n\n假如你是一个劫匪，并且决定抢劫一条街上的房子，每个房子内的钱财数量各不相同。如果你抢了两栋相邻的房子，则会触发警报机关。求在不触发机关的情况下最多可以抢劫多少钱。\n\n输入是一个一维数组，表示每个房子的钱财数量；输出是劫匪可以最多抢劫的钱财数量。\n\n> 输入：[1,2,3,1] 输出：4 解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。偷窃到的最高金额 = 1 + 3 = 4 。\n\n解析:\n\n设置状态：定义一个数组 dp，dp[i] 表示抢劫到第 i 个房子时，可以抢劫的最大数量。 状态转移方程：我们考虑 dp[i]，此时可以抢劫的最大数量有两种可能，一种是我们选择不抢劫这个房子，此时累计的金额即为dp[i-1]；另一种是我们选择抢劫这个房子，那么此前累计的最大金额只能是 dp[i-2]，因为我们不能够抢劫第 i-1 个房子，否则会触发警报机关。因此本题的状态转移方程为 dp[i] = max(dp[i-1],nums[i-1] + dp[i-2])。\n\n初始情况：第一个房子的抢劫最大数量 dp[1] = nums[0]\n\nclass Solution {\npublic:\n    int rob(vector<int>& nums) {\n        if(nums.empty()){\n            return 0;\n        }\n        int len = nums.size();\n        vector<int> dp(len+1,0);\n        dp[1] = nums[0];\n        for(int i=2;i<=len;++i){\n            dp[i] = max(dp[i-1],dp[i-2]+nums[i-1]);\n        }\n        return dp[len];\n    }\n};\n\n\n# 213 打家劫舍 II\n\n假如你是一个劫匪，并且决定抢劫一条街上的房子，这条街所有的房屋都 围成一圈 ，这意味着第一个房屋和最后一个房屋是紧挨着的。如果你抢了两栋相邻的房子，则会触发警报机关。求在不触发机关的情况下最多可以抢劫多少钱。\n\n输入是一个一维数组，表示每个房子的钱财数量；输出是劫匪可以最多抢劫的钱财数量。\n\n> 输入：nums = [2,3,2]\n> 输出：3\n> 解释：你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。\n\n解析:\n\n本题与198题的主要区别是输入的一维数组是一个环形数组，所以要分别考虑抢第一个房子和不抢第一个房子的情况。抢第一个房子，那么就不能抢最后一个房子，则可抢的范围为nums[0]~nums[len-2]；不抢第一个房子，那么就可以抢最后一个房子，则可抢的范围为nums[1]~nums[len-1]。\n\n基于上述两种情况使用与198题相同的动态规划方法解决本问题\n\nclass Solution {\npublic:\n    int rob(vector<int>& nums) {\n        int len = nums.size();\n        if(len < 1) return 0;\n        vector<int> nums1,nums2;\n        for(int i=0;i<len;++i){\n            if(i==0){\n                nums1.push_back(nums[i]);\n            }else if(i==len-1){\n                nums2.push_back(nums[i]);\n            }else{\n                nums1.push_back(nums[i]);\n                nums2.push_back(nums[i]);\n            }\n        }\n        return max(robRange(nums1),robRange(nums2));\n    }\n\n    int robRange(vector<int>& nums){\n        int len = nums.size();\n        if(len < 1) return 0;\n        vector<int> dp(len+1,0);\n        dp[1] = nums[0];\n        for(int i=2;i<=len;++i){\n            dp[i] = max(dp[i-1],dp[i-2]+nums[i-1]);\n        }\n        return dp[len];\n    }\n};\n\n\n上述解法较为直观，先分情况在计算最大抢劫价值；也可以通过划分区间的方式划分情况如下\n\nclass Solution {\npublic:\n    int rob(vector<int>& nums) {\n        int len = nums.size();\n        if(len == 1) return nums[0];\n        return max(robRange(nums,0,len-1),robRange(nums,1,len));\n    }\n\n    int robRange(vector<int>& nums, int start, int end){\n        int len = end - start;\n        if(len < 1) return 0;\n        vector<int> dp(len+1,0);\n        dp[1] = nums[start];\n        for(int i=2;i<=len;++i){\n            dp[i] = max(dp[i-1],dp[i-2]+nums[i+start-1]);\n        }\n        return dp[len];\n    }\n};\n\n\n# 413 等差数列划分\n\n给定一个数组，求这个数组中连续且等差的子数组一共有多少个。\n\n输入是一个一维数组，输出是满足等差条件的连续字数组个数。\n\n> 输入：nums = [1,2,3,4]\n> 输出：3\n> 解释：nums 中有三个子等差数组：[1, 2, 3]、[2, 3, 4] 和 [1,2,3,4] 自身。\n\n解析:\n\n这道题略微特殊，因为要求是等差数列，可以很自然的想到子数组必定满足 num[i] - num[i-1] = num[i-1] - num[i-2]。然而由于我们对于 dp 数组的定义通常为以 i 结尾的，满足某些条件的子数组数量，而等差子数组可以在任意一个位置终结，因此此题在最后需要对 dp 数组求和。\n\nclass Solution {\npublic:\n    int numberOfArithmeticSlices(vector<int>& nums) {\n        int len = nums.size();\n        int res = 0;\n        if(len < 3){\n            return res;\n        }\n        vector<int> dp(len,0);\n        for(int i = 2;i<len;++i){\n            if(nums[i]-nums[i-1] == nums[i-1] - nums[i-2]){\n                dp[i] = dp[i-1] + 1;\n                res += dp[i];\n            }\n        }\n        return res;\n    }\n};\n\n\n# 53 最大子序和\n\n给定一个数组，找出一个具有最大和的连续子数组，并返回其最大和。\n\n输入一个数组，输出一个整数，为连续子数组的最大和\n\n> 输入：nums = [-2,1,-3,4,-1,2,1,-5,4]\n> 输出：6\n> 解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。\n\n解析:\n\n设置状态：使用一维数组dp[i]表示以第 i 个元素结尾的子序列的最大和\n\n状态转移方程：我们考虑 dp[i]，此时构成最大和的子序列有两种可能，一种是我们选择不将第 i 个元素加入子序列，因为要构成连续的子序列，所以自己单独构成新的子序列此时最大和即为自身nums[i-1]；另一种是我们选择将第 i 个元素加入子序列，那么构成子序列的最大和为dp[i-1]+nums[i-1]。所以本题的状态转移方程为 dp[i] = max(nums[i-1],nums[i-1] + dp[i-1])。\n\n初始情况：只有一个元素，dp[1]=nums[0]\n\nclass Solution {\npublic:\n    int maxSubArray(vector<int>& nums) {\n        int len = nums.size();\n        if(len < 1) return 0;\n        vector<int> dp(len+1,0);\n        dp[1] = nums[0];\n        int ans = nums[0];\n        for(int i=2;i<=len;++i){\n            dp[i] = max(nums[i-1],dp[i-1]+nums[i-1]);\n            ans = max(ans,dp[i]);\n        }\n        return ans;\n    }\n};\n",normalizedContent:"# 01 一维动态规划\n\n# 70 爬楼梯\n\n给定 n 节台阶，每次可以走一步或走两步，求一共有多少种方式可以走完这些台阶。\n\n输入是一个数字，表示台阶数量；输出是爬台阶的总方式。\n\n> 输入： 2\n> 输出： 2\n> 解释： 有两种方法可以爬到楼顶。\n> 1.  1 阶 + 1 阶\n> 2.  2 阶\n\n解析:\n\n这是十分经典的斐波那契数列题。\n\n设置状态：定义一个数组 dp，dp[i] 表示走到第 i 阶的方法数\n\n状态转移方程：因为我们每次可以走一步或者两步，所以第 i 阶可以从第 i-1 或 i-2 阶到达。换句话说，走到第 i 阶的方法数即为走到第 i-1 阶的方法数加上走到第 i-2 阶的方法数。这样我们就得到了状态转移方程dp[i] = dp[i-1] + dp[i-2]。\n\n初始情况：当阶数小于等于1时，方法数为1\n\nclass solution {\npublic:\n    int climbstairs(int n) {\n        if(n<2) return n;\n        vector<int> dp(n+1);\n        dp[0] = dp[1] = 1;\n        for(int i=2;i<=n;++i){\n            dp[i] = dp[i-1] + dp[i-2];\n        }\n        return dp[n];\n    }\n};\n\n\n# 198 打家劫舍\n\n假如你是一个劫匪，并且决定抢劫一条街上的房子，每个房子内的钱财数量各不相同。如果你抢了两栋相邻的房子，则会触发警报机关。求在不触发机关的情况下最多可以抢劫多少钱。\n\n输入是一个一维数组，表示每个房子的钱财数量；输出是劫匪可以最多抢劫的钱财数量。\n\n> 输入：[1,2,3,1] 输出：4 解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。偷窃到的最高金额 = 1 + 3 = 4 。\n\n解析:\n\n设置状态：定义一个数组 dp，dp[i] 表示抢劫到第 i 个房子时，可以抢劫的最大数量。 状态转移方程：我们考虑 dp[i]，此时可以抢劫的最大数量有两种可能，一种是我们选择不抢劫这个房子，此时累计的金额即为dp[i-1]；另一种是我们选择抢劫这个房子，那么此前累计的最大金额只能是 dp[i-2]，因为我们不能够抢劫第 i-1 个房子，否则会触发警报机关。因此本题的状态转移方程为 dp[i] = max(dp[i-1],nums[i-1] + dp[i-2])。\n\n初始情况：第一个房子的抢劫最大数量 dp[1] = nums[0]\n\nclass solution {\npublic:\n    int rob(vector<int>& nums) {\n        if(nums.empty()){\n            return 0;\n        }\n        int len = nums.size();\n        vector<int> dp(len+1,0);\n        dp[1] = nums[0];\n        for(int i=2;i<=len;++i){\n            dp[i] = max(dp[i-1],dp[i-2]+nums[i-1]);\n        }\n        return dp[len];\n    }\n};\n\n\n# 213 打家劫舍 ii\n\n假如你是一个劫匪，并且决定抢劫一条街上的房子，这条街所有的房屋都 围成一圈 ，这意味着第一个房屋和最后一个房屋是紧挨着的。如果你抢了两栋相邻的房子，则会触发警报机关。求在不触发机关的情况下最多可以抢劫多少钱。\n\n输入是一个一维数组，表示每个房子的钱财数量；输出是劫匪可以最多抢劫的钱财数量。\n\n> 输入：nums = [2,3,2]\n> 输出：3\n> 解释：你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。\n\n解析:\n\n本题与198题的主要区别是输入的一维数组是一个环形数组，所以要分别考虑抢第一个房子和不抢第一个房子的情况。抢第一个房子，那么就不能抢最后一个房子，则可抢的范围为nums[0]~nums[len-2]；不抢第一个房子，那么就可以抢最后一个房子，则可抢的范围为nums[1]~nums[len-1]。\n\n基于上述两种情况使用与198题相同的动态规划方法解决本问题\n\nclass solution {\npublic:\n    int rob(vector<int>& nums) {\n        int len = nums.size();\n        if(len < 1) return 0;\n        vector<int> nums1,nums2;\n        for(int i=0;i<len;++i){\n            if(i==0){\n                nums1.push_back(nums[i]);\n            }else if(i==len-1){\n                nums2.push_back(nums[i]);\n            }else{\n                nums1.push_back(nums[i]);\n                nums2.push_back(nums[i]);\n            }\n        }\n        return max(robrange(nums1),robrange(nums2));\n    }\n\n    int robrange(vector<int>& nums){\n        int len = nums.size();\n        if(len < 1) return 0;\n        vector<int> dp(len+1,0);\n        dp[1] = nums[0];\n        for(int i=2;i<=len;++i){\n            dp[i] = max(dp[i-1],dp[i-2]+nums[i-1]);\n        }\n        return dp[len];\n    }\n};\n\n\n上述解法较为直观，先分情况在计算最大抢劫价值；也可以通过划分区间的方式划分情况如下\n\nclass solution {\npublic:\n    int rob(vector<int>& nums) {\n        int len = nums.size();\n        if(len == 1) return nums[0];\n        return max(robrange(nums,0,len-1),robrange(nums,1,len));\n    }\n\n    int robrange(vector<int>& nums, int start, int end){\n        int len = end - start;\n        if(len < 1) return 0;\n        vector<int> dp(len+1,0);\n        dp[1] = nums[start];\n        for(int i=2;i<=len;++i){\n            dp[i] = max(dp[i-1],dp[i-2]+nums[i+start-1]);\n        }\n        return dp[len];\n    }\n};\n\n\n# 413 等差数列划分\n\n给定一个数组，求这个数组中连续且等差的子数组一共有多少个。\n\n输入是一个一维数组，输出是满足等差条件的连续字数组个数。\n\n> 输入：nums = [1,2,3,4]\n> 输出：3\n> 解释：nums 中有三个子等差数组：[1, 2, 3]、[2, 3, 4] 和 [1,2,3,4] 自身。\n\n解析:\n\n这道题略微特殊，因为要求是等差数列，可以很自然的想到子数组必定满足 num[i] - num[i-1] = num[i-1] - num[i-2]。然而由于我们对于 dp 数组的定义通常为以 i 结尾的，满足某些条件的子数组数量，而等差子数组可以在任意一个位置终结，因此此题在最后需要对 dp 数组求和。\n\nclass solution {\npublic:\n    int numberofarithmeticslices(vector<int>& nums) {\n        int len = nums.size();\n        int res = 0;\n        if(len < 3){\n            return res;\n        }\n        vector<int> dp(len,0);\n        for(int i = 2;i<len;++i){\n            if(nums[i]-nums[i-1] == nums[i-1] - nums[i-2]){\n                dp[i] = dp[i-1] + 1;\n                res += dp[i];\n            }\n        }\n        return res;\n    }\n};\n\n\n# 53 最大子序和\n\n给定一个数组，找出一个具有最大和的连续子数组，并返回其最大和。\n\n输入一个数组，输出一个整数，为连续子数组的最大和\n\n> 输入：nums = [-2,1,-3,4,-1,2,1,-5,4]\n> 输出：6\n> 解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。\n\n解析:\n\n设置状态：使用一维数组dp[i]表示以第 i 个元素结尾的子序列的最大和\n\n状态转移方程：我们考虑 dp[i]，此时构成最大和的子序列有两种可能，一种是我们选择不将第 i 个元素加入子序列，因为要构成连续的子序列，所以自己单独构成新的子序列此时最大和即为自身nums[i-1]；另一种是我们选择将第 i 个元素加入子序列，那么构成子序列的最大和为dp[i-1]+nums[i-1]。所以本题的状态转移方程为 dp[i] = max(nums[i-1],nums[i-1] + dp[i-1])。\n\n初始情况：只有一个元素，dp[1]=nums[0]\n\nclass solution {\npublic:\n    int maxsubarray(vector<int>& nums) {\n        int len = nums.size();\n        if(len < 1) return 0;\n        vector<int> dp(len+1,0);\n        dp[1] = nums[0];\n        int ans = nums[0];\n        for(int i=2;i<=len;++i){\n            dp[i] = max(nums[i-1],dp[i-1]+nums[i-1]);\n            ans = max(ans,dp[i]);\n        }\n        return ans;\n    }\n};\n",charsets:{cjk:!0},lastUpdated:"2023/11/19, 12:55:48",lastUpdatedTimestamp:1700369748e3},{title:"02二维动态规划",frontmatter:{title:"02二维动态规划",date:"2023-03-24T18:39:49.000Z",permalink:"/pages/5b4acb/"},regularPath:"/03.LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/03.%E8%BF%9B%E9%98%B6%E7%AE%97%E6%B3%95/03.%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/02.%E4%BA%8C%E7%BB%B4%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.html",relativePath:"03.LeetCode刷题笔记/03.进阶算法/03.动态规划/02.二维动态规划.md",key:"v-5699caf5",path:"/pages/5b4acb/",headers:[{level:2,title:"02 二维动态规划",slug:"_02-二维动态规划",normalizedTitle:"02 二维动态规划",charIndex:2},{level:4,title:"64 最小路径和",slug:"_64-最小路径和",normalizedTitle:"64 最小路径和",charIndex:15},{level:4,title:"542 01矩阵",slug:"_542-01矩阵",normalizedTitle:"542 01矩阵",charIndex:1435},{level:4,title:"221 最大正方形",slug:"_221-最大正方形",normalizedTitle:"221 最大正方形",charIndex:3315}],headersStr:"02 二维动态规划 64 最小路径和 542 01矩阵 221 最大正方形",content:'# 02 二维动态规划\n\n# 64 最小路径和\n\n给定一个 m × n 大小的非负整数矩阵，求从左上角开始到右下角结束的、经过的数字的和最小的路径。每次只能向右或者向下移动。\n\n输入是一个二维数组，输出是最优路径的数字和。\n\n> 输入：grid = [[1,3,1],[1,5,1],[4,2,1]]\n> 输出：7\n> 解释：因为路径 1→3→1→1→1 的总和最小。\n\n解析:\n\n设置状态：使用一个二维的 dp 数组，其中 dp[i][j] 表示从左上角开始到 (i, j) 位置的最 优路径的数字和。\n\n状态转移方程：因为每次只能向下或者向右移动，我们可以很容易得到状态转移方程 dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]，其中 grid 表示原数组。\n\n边界条件：只有一格dp[0][0] = grid[0][0]；第一行的元素只能由前一个元素向右移动得到即dp[0][j] = dp[0][j-1]+grid[0][j]；第一列的元素只能由上一个元素向下移动得到即dp[i][0] = dp[i-1][0]+grid[i][0]\n\nclass Solution {\npublic:\n    int minPathSum_old(vector<vector<int>>& grid) {\n        int ans = 0;\n        if(grid.empty()||grid[0].empty()){\n            return ans;\n        }\n        int m = grid.size(), n = grid[0].size();\n        vector<vector<int>> dp(m,vector<int>(n));\n        for(int i=0;i<m;++i){\n            for(int j=0;j<n;++j){\n                if(i==0&&j==0){\n                    dp[i][j] = grid[0][0];\n                }else if(i==0){\n                    dp[i][j] = dp[i][j-1] + grid[i][j];\n                }else if(j==0){\n                    dp[i][j] = dp[i-1][j] + grid[i][j];\n                }else{\n                     dp[i][j] = min(dp[i][j-1],dp[i-1][j]) + grid[i][j];\n                }\n            }\n        }\n        return dp[m-1][n-1];\n    }\n};\n\n\n因为 dp 矩阵的每一个值只和左边和上面的值相关，我们可以使用空间压缩将 dp 数组压缩为一维。对于第 i 行，在遍历到第 j 列的时候，因为第 j-1 列已经更新过了，所以 dp[j-1] 代表 dp[i][j-1]的值；而 dp[j] 待更新，当前存储的值是在第 i-1 行的时候计算的，所以代表 dp[i-1][j]的值。\n\n# 542 01矩阵\n\n给定一个由 0 和 1 组成的二维矩阵，求每个位置到最近的 0 的距离。\n\n输入是一个二维 0-1 数组，输出是一个同样大小的非负整数数组，表示每个位置到最近的 0的距离。\n\n> 输入：mat = [[0,0,0],[0,1,0],[1,1,1]]\n> 输出：[[0,0,0],[0,1,0],[1,2,1]]\n\n解析:\n\n本题涉及到四个方向上的最近搜索，如果使用递归的方法进行搜索在二维数组中将造成极大的时间复杂度。使用动态规划进行存储化，可以使得递归搜索不会重复遍历相同位置；另一种更简单的方法是，从左上到右下进行一次动态搜索，再从右下到左上进行一次动态搜索，这样两次动态搜索即可完成四个方向上的查找。\n\n设置状态：使用一个二维数组 dp[i][j] 表示位置为 (i,j) 的元素与0的距离\n\n状态转移方程：值为0的元素到0的距离为0；从左上到右下进行动态搜索，那么dp[i][j] 可以从dp[i-1][j]、dp[i][j-1]和自身三个状态中转移得到dp[i][j]=min(dp[i][j],min(dp[i-1][j],dp[i][j-1])) + 1； 从右下到左上进行动态搜索的状态转移方程可以类比得到dp[i][j]=min(dp[i][j],min(dp[i+1][j],dp[i][j+1])) + 1\n\n边界情况：当d[i][j]处于矩阵的边界上时其状态转移受到限制，例如，从左上到右下进行动态搜索时处于第一行的元素状态仅能从自身和前一个状态转移得到，而第一列的元素状态仅能从自身和上一个状态转移得到。\n\nclass Solution {\npublic:\n    vector<vector<int>> updateMatrix(vector<vector<int>>& mat) {\n        if(mat.empty()||mat.empty()){\n            return {};\n        }\n        int m = mat.size(), n = mat[0].size();\n        vector<vector<int>> dp(m, vector<int>(n,INT_MAX-1)); // INT_MAX会在特殊用例中报错\n        // 从左上到右下进行动态搜索\n        for(int i=0;i<m;++i){\n            for(int j=0;j<n;++j){\n                if(mat[i][j]==0){\n                    dp[i][j] = 0;\n                }else{\n                    // 区分边界情况\n                    if(j>0){\n                        dp[i][j] = min(dp[i][j], dp[i][j-1]+1);\n                    }\n                    if(i>0){\n                        dp[i][j] = min(dp[i][j], dp[i-1][j]+1);\n                    }\n                }\n            }\n        }\n        // 从右下到左上进行动态搜索\n        for(int i=m-1;i>=0;--i){\n            for(int j=n-1;j>=0;--j){\n                if(mat[i][j]){\n                    if(j<n-1){\n                        dp[i][j] = min(dp[i][j], dp[i][j+1]+1);\n                    }\n                    if(i<m-1){\n                        dp[i][j] = min(dp[i][j], dp[i+1][j]+1);\n                    }\n                }\n            }\n        }\n        return dp;\n    }\n};\n\n\n# 221 最大正方形\n\n给定一个二维的 0-1 矩阵，求全由 1 构成的最大正方形面积。\n\n输入是一个二维 0-1 数组，输出是最大正方形面积。\n\n> 输入：matrix = [["1","0","1","0","0"],["1","0","1","1","1"],["1","1","1","1","1"],["1","0","0","1","0"]] 输出：4\n\n解析:\n\n对于在矩阵内搜索正方形或长方形的题型，一种常见的做法是定义一个二维 dp 数组，其中dp[i][j]表示满足题目条件的、以 (i, j) 为右下角的正方形或者长方形的属性。对于本题，则表示以 (i, j) 为右下角的全由 1 构成的最大正方形面积。\n\n设置状态：定义一个二维 dp 数组，其中dp[i][j]表示以 (i, j) 为右下角的全由 1 构成的最大正方形面积\n\n状态转移方程：如果当前位置是 0，那么 dp[i][j] 即为 0；如果当前位置是 1，我们假设 dp[i][j] = k^2 ，其充分条件为 dp[i-1][j-1]、dp[i][j-1]和 dp[i-1][j]的值必须都不小于 (k − 1)^2 ，否则 (i, j) 位置不可以构成一个边长为 k 的正方形。同理，如果这三个值中的最小值为 k − 1，则 (i, j) 位置一定且最大可以构成一个边长为 k 的正方形。所以状态转移方程为dp[i][j] = min(dp[i-1][j-1], min(dp[i][j-1], dp[i-1][j])) + 1\n\n初始情况：仅有一个方格构成正方形dp[0][0] = 1\n\nclass Solution {\npublic:\n    int maximalSquare(vector<vector<char>>& matrix) {\n        if(matrix.empty()||matrix[0].empty()){\n            return 0;\n        }\n        int m = matrix.size(), n = matrix[0].size();\n        int maxSize = 0;\n        vector<vector<int>> dp(m+1,vector<int>(n+1));\n        for(int i=1;i<=m;++i){\n            for(int j=1;j<=n;++j){\n                if(matrix[i-1][j-1] == \'1\'){\n                \tdp[i][j] = min(min(dp[i][j-1],dp[i-1][j]),dp[i-1][j-1]) + 1;\n                }\n                maxSize = max(dp[i][j],maxSize);\n            }\n        }\n        return maxSize * maxSize;\n    }\n};\n',normalizedContent:'# 02 二维动态规划\n\n# 64 最小路径和\n\n给定一个 m × n 大小的非负整数矩阵，求从左上角开始到右下角结束的、经过的数字的和最小的路径。每次只能向右或者向下移动。\n\n输入是一个二维数组，输出是最优路径的数字和。\n\n> 输入：grid = [[1,3,1],[1,5,1],[4,2,1]]\n> 输出：7\n> 解释：因为路径 1→3→1→1→1 的总和最小。\n\n解析:\n\n设置状态：使用一个二维的 dp 数组，其中 dp[i][j] 表示从左上角开始到 (i, j) 位置的最 优路径的数字和。\n\n状态转移方程：因为每次只能向下或者向右移动，我们可以很容易得到状态转移方程 dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]，其中 grid 表示原数组。\n\n边界条件：只有一格dp[0][0] = grid[0][0]；第一行的元素只能由前一个元素向右移动得到即dp[0][j] = dp[0][j-1]+grid[0][j]；第一列的元素只能由上一个元素向下移动得到即dp[i][0] = dp[i-1][0]+grid[i][0]\n\nclass solution {\npublic:\n    int minpathsum_old(vector<vector<int>>& grid) {\n        int ans = 0;\n        if(grid.empty()||grid[0].empty()){\n            return ans;\n        }\n        int m = grid.size(), n = grid[0].size();\n        vector<vector<int>> dp(m,vector<int>(n));\n        for(int i=0;i<m;++i){\n            for(int j=0;j<n;++j){\n                if(i==0&&j==0){\n                    dp[i][j] = grid[0][0];\n                }else if(i==0){\n                    dp[i][j] = dp[i][j-1] + grid[i][j];\n                }else if(j==0){\n                    dp[i][j] = dp[i-1][j] + grid[i][j];\n                }else{\n                     dp[i][j] = min(dp[i][j-1],dp[i-1][j]) + grid[i][j];\n                }\n            }\n        }\n        return dp[m-1][n-1];\n    }\n};\n\n\n因为 dp 矩阵的每一个值只和左边和上面的值相关，我们可以使用空间压缩将 dp 数组压缩为一维。对于第 i 行，在遍历到第 j 列的时候，因为第 j-1 列已经更新过了，所以 dp[j-1] 代表 dp[i][j-1]的值；而 dp[j] 待更新，当前存储的值是在第 i-1 行的时候计算的，所以代表 dp[i-1][j]的值。\n\n# 542 01矩阵\n\n给定一个由 0 和 1 组成的二维矩阵，求每个位置到最近的 0 的距离。\n\n输入是一个二维 0-1 数组，输出是一个同样大小的非负整数数组，表示每个位置到最近的 0的距离。\n\n> 输入：mat = [[0,0,0],[0,1,0],[1,1,1]]\n> 输出：[[0,0,0],[0,1,0],[1,2,1]]\n\n解析:\n\n本题涉及到四个方向上的最近搜索，如果使用递归的方法进行搜索在二维数组中将造成极大的时间复杂度。使用动态规划进行存储化，可以使得递归搜索不会重复遍历相同位置；另一种更简单的方法是，从左上到右下进行一次动态搜索，再从右下到左上进行一次动态搜索，这样两次动态搜索即可完成四个方向上的查找。\n\n设置状态：使用一个二维数组 dp[i][j] 表示位置为 (i,j) 的元素与0的距离\n\n状态转移方程：值为0的元素到0的距离为0；从左上到右下进行动态搜索，那么dp[i][j] 可以从dp[i-1][j]、dp[i][j-1]和自身三个状态中转移得到dp[i][j]=min(dp[i][j],min(dp[i-1][j],dp[i][j-1])) + 1； 从右下到左上进行动态搜索的状态转移方程可以类比得到dp[i][j]=min(dp[i][j],min(dp[i+1][j],dp[i][j+1])) + 1\n\n边界情况：当d[i][j]处于矩阵的边界上时其状态转移受到限制，例如，从左上到右下进行动态搜索时处于第一行的元素状态仅能从自身和前一个状态转移得到，而第一列的元素状态仅能从自身和上一个状态转移得到。\n\nclass solution {\npublic:\n    vector<vector<int>> updatematrix(vector<vector<int>>& mat) {\n        if(mat.empty()||mat.empty()){\n            return {};\n        }\n        int m = mat.size(), n = mat[0].size();\n        vector<vector<int>> dp(m, vector<int>(n,int_max-1)); // int_max会在特殊用例中报错\n        // 从左上到右下进行动态搜索\n        for(int i=0;i<m;++i){\n            for(int j=0;j<n;++j){\n                if(mat[i][j]==0){\n                    dp[i][j] = 0;\n                }else{\n                    // 区分边界情况\n                    if(j>0){\n                        dp[i][j] = min(dp[i][j], dp[i][j-1]+1);\n                    }\n                    if(i>0){\n                        dp[i][j] = min(dp[i][j], dp[i-1][j]+1);\n                    }\n                }\n            }\n        }\n        // 从右下到左上进行动态搜索\n        for(int i=m-1;i>=0;--i){\n            for(int j=n-1;j>=0;--j){\n                if(mat[i][j]){\n                    if(j<n-1){\n                        dp[i][j] = min(dp[i][j], dp[i][j+1]+1);\n                    }\n                    if(i<m-1){\n                        dp[i][j] = min(dp[i][j], dp[i+1][j]+1);\n                    }\n                }\n            }\n        }\n        return dp;\n    }\n};\n\n\n# 221 最大正方形\n\n给定一个二维的 0-1 矩阵，求全由 1 构成的最大正方形面积。\n\n输入是一个二维 0-1 数组，输出是最大正方形面积。\n\n> 输入：matrix = [["1","0","1","0","0"],["1","0","1","1","1"],["1","1","1","1","1"],["1","0","0","1","0"]] 输出：4\n\n解析:\n\n对于在矩阵内搜索正方形或长方形的题型，一种常见的做法是定义一个二维 dp 数组，其中dp[i][j]表示满足题目条件的、以 (i, j) 为右下角的正方形或者长方形的属性。对于本题，则表示以 (i, j) 为右下角的全由 1 构成的最大正方形面积。\n\n设置状态：定义一个二维 dp 数组，其中dp[i][j]表示以 (i, j) 为右下角的全由 1 构成的最大正方形面积\n\n状态转移方程：如果当前位置是 0，那么 dp[i][j] 即为 0；如果当前位置是 1，我们假设 dp[i][j] = k^2 ，其充分条件为 dp[i-1][j-1]、dp[i][j-1]和 dp[i-1][j]的值必须都不小于 (k − 1)^2 ，否则 (i, j) 位置不可以构成一个边长为 k 的正方形。同理，如果这三个值中的最小值为 k − 1，则 (i, j) 位置一定且最大可以构成一个边长为 k 的正方形。所以状态转移方程为dp[i][j] = min(dp[i-1][j-1], min(dp[i][j-1], dp[i-1][j])) + 1\n\n初始情况：仅有一个方格构成正方形dp[0][0] = 1\n\nclass solution {\npublic:\n    int maximalsquare(vector<vector<char>>& matrix) {\n        if(matrix.empty()||matrix[0].empty()){\n            return 0;\n        }\n        int m = matrix.size(), n = matrix[0].size();\n        int maxsize = 0;\n        vector<vector<int>> dp(m+1,vector<int>(n+1));\n        for(int i=1;i<=m;++i){\n            for(int j=1;j<=n;++j){\n                if(matrix[i-1][j-1] == \'1\'){\n                \tdp[i][j] = min(min(dp[i][j-1],dp[i-1][j]),dp[i-1][j-1]) + 1;\n                }\n                maxsize = max(dp[i][j],maxsize);\n            }\n        }\n        return maxsize * maxsize;\n    }\n};\n',charsets:{cjk:!0},lastUpdated:"2023/11/19, 12:55:48",lastUpdatedTimestamp:1700369748e3},{title:"04子序列问题",frontmatter:{title:"04子序列问题",date:"2023-03-24T18:39:49.000Z",permalink:"/pages/221930/"},regularPath:"/03.LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/03.%E8%BF%9B%E9%98%B6%E7%AE%97%E6%B3%95/03.%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/04.%E5%AD%90%E5%BA%8F%E5%88%97%E9%97%AE%E9%A2%98.html",relativePath:"03.LeetCode刷题笔记/03.进阶算法/03.动态规划/04.子序列问题.md",key:"v-098887ea",path:"/pages/221930/",headers:[{level:2,title:"04 子序列问题",slug:"_04-子序列问题",normalizedTitle:"04 子序列问题",charIndex:2},{level:4,title:"300 最长递增子序列",slug:"_300-最长递增子序列",normalizedTitle:"300 最长递增子序列",charIndex:198},{level:4,title:"646 最长数对链",slug:"_646-最长数对链",normalizedTitle:"646 最长数对链",charIndex:1160},{level:4,title:"376 摆动序列",slug:"_376-摆动序列",normalizedTitle:"376 摆动序列",charIndex:2019},{level:4,title:"1143 最长公共子序列",slug:"_1143-最长公共子序列",normalizedTitle:"1143 最长公共子序列",charIndex:3697},{level:4,title:"583 两个字符串的删除操作",slug:"_583-两个字符串的删除操作",normalizedTitle:"583 两个字符串的删除操作",charIndex:4857}],headersStr:"04 子序列问题 300 最长递增子序列 646 最长数对链 376 摆动序列 1143 最长公共子序列 583 两个字符串的删除操作",content:'# 04 子序列问题\n\n对于子序列问题，第一种动态规划方法是，定义一个 dp 数组，其中 dp[i]表示以 i 结尾的子序列的性质。在处理好每个位置后，统计一遍各个位置的结果即可得到题目要求的结果。第二种动态规划方法是，定义一个 dp数组，其中 dp[i] 表示到位置 i 为止的子序列的性质，并不必须以 i 结尾。这样 dp 数组的最后一位结果即为题目所求，不需要再对每个位置进行统计。\n\n# 300 最长递增子序列\n\n给定一个未排序的整数数组，求最长的递增子序列。\n\n输入是一个一维数组，输出是一个正整数，表示最长递增子序列的长度。\n\n> 输入：nums = [10,9,2,5,3,7,101,18]\n> 输出：4\n> 解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。\n\n解析:\n\n设置状态：使用一个一维数组dp[i] 可以表示以 i 结尾的、最长子序列长度。\n\n状态转移方程：对于每一个位置 i，如果其之前的某个位置 j 所对应的数字小于位置 i 所对应的数字，则可以获得一个以 i 结尾的、长度为 dp[j] + 1 的子序列，即dp[i] = max(dp[i],dp[j]+1)。为了遍历所有情况，我们需要 i 和 j 进行两层循环，并记录最大值。\n\n初始情况：dp[0] = 0, dp[1] = 1\n\nclass Solution {\npublic:\n    int lengthOfLIS(vector<int>& nums) {\n        int len = nums.size();\n        // 将所有位置初始化为 1, 因为len>=1,所以最短递增子序列就是 1 \n        vector<int> dp(len,1); \n        int ans = 1;\n        // i 控制每一个记录位置\n        for(int i=1;i<len;++i){ \n            // j 扫描 i 之前的子序列\n            for(int j=0;j<i;++j){ \n                // 如果出现递增情况，判断是否增加的子序列长度\n                if(nums[i]>nums[j]){ \n                    dp[i] = max(dp[i],dp[j]+1);\n                }\n            }\n            // 完成一个位置的记录之后，判断是否是较大长度\n            ans = max(ans,dp[i]);\n        }\n        return ans;\n    }\n};\n\n\n# 646 最长数对链\n\n给出 n 个数对，在每一个数对中，第一个数字总是比第二个数字小。对于数对(a,b),(c,d)如果 b < c则这两个数对可以构成数对链\n\n输入一个数对集合，输出一个整数表示能够形成的最长数对链的长度。\n\n> 输入：[[1,2], [2,3], [3,4]]\n> 输出：2\n> 解释：最长的数对链是 [1,2] -> [3,4]\n\n解析:\n\n本题和300题本质上是一样的，不同在于递增序列由数对构成。另外需要考虑数对出现的次序并不影响它是否能够加入数对链，所以在使用类似于300题的动态规划方法计算最长数对链长度之前需要对其进行排序，简化元素选择。本题中以区间（数对）结尾排序。\n\nclass Solution {\npublic:\n    int findLongestChain(vector<vector<int>>& pairs) {\n        int len = pairs.size();\n        if(len < 1) return 0; \n        sort(pairs.begin(),pairs.end(),[](vector<int> a, vector<int> b){ return a[1]<b[1];});\n        vector<int> dp(len,1);\n        int ans = 1;\n        for(int i=1;i<len;++i){\n            for(int j=0;j<i;++j){\n                if(pairs[j][1]<pairs[i][0]){\n                    dp[i] = max(dp[i],dp[j]+1);\n                }\n            }\n            ans = max(ans,dp[i]);\n        }\n        return ans;\n    }\n};\n\n\n# 376 摆动序列\n\n如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为摆动序列。给你一个整数数组 nums ，返回 nums 中作为 摆动序列 的 最长子序列的长度 。\n\n输入是一个一维数组，输出是一个正整数，表示作为摆动序列的最长子序列的长度。\n\n> 输入：nums = [1,17,5,10,13,15,10,5,16,8] 输出：7 解释：这个序列包含几个长度为 7 摆动序列。其中一个是 [1, 17, 10, 13, 10, 16, 8] ，各元素之间的差值为 (16, -7, 3, -3, 6, -8) 。\n\n解析:\n\n本题和递增子序列的差别在于摆动序列的元素选择取决于前一个被选元素的大小，既可以上升也可以下降。\n\n设置状态：使用一个二维数组dp[i][j]表示前 i 个元素中的某一个为结尾的最长摆动序列长度，其中 j 取值为 0 和 1分别表示上升摆动序列和下降摆动序列。上升摆动序列是指最后一个元素是呈上升趋势的摆动序列，下降摆动序列同理。d[i][0]表示以前 i 个元素中的某一个为结尾的最长的上升摆动序列的长度；dp[i][1]以前 i 个元素中的某一个为结尾的最长的下降摆动序列的长度。\n\n状态转移方程：考虑第 i 个元素，如果nums[i] > nums[i-1]，则该元素可以加入下降摆动序列形成上升摆动序列dp[i][0] = max(dp[i-1][0],dp[i-1][1] + 1)，但是该元素加入上升摆动序列并不会形成下降摆动序列dp[i][1] = dp[i-1][1]；如果nums[i] < nums[i-1]，则该元素可以加入上升摆动序列形成下降摆动序列dp[i][1] = max(dp[i-1][1],dp[i-1][0] + 1)，如果该元素加入下降摆动序列并不会形成上升摆动序列所以dp[i][0] = dp[i-1][0]；如果nums[i] == nums[i-1]那么可以直接跳过该元素dp[i][0] = dp[i-1][0], dp[i][1] = dp[i-1][1]。\n\n初始情况：当只有一个元素时，该元素既是上升摆动序列也是下降摆动序列，dp[0][j] = 1;\n\nclass Solution {\npublic:\n    int wiggleMaxLength(vector<int>& nums) {\n        int len = nums.size();\n        if(len < 2) return len;\n        vector<vector<int>> dp(len,vector<int>(2,1));\n        int ans = 1;\n        for(int i=1;i<len;++i){\n            if(nums[i] < nums[i-1]){\n                dp[i][0] = dp[i-1][0];\n                dp[i][1] = max(dp[i-1][1],dp[i-1][0] + 1);\n            }else if(nums[i] > nums[i-1]){\n                dp[i][0] = max(dp[i-1][0],dp[i-1][1] + 1);\n                dp[i][1] = dp[i-1][1];\n            }else{\n                dp[i][0] = dp[i-1][0];\n                dp[i][1] = dp[i-1][1];\n            }\n            ans = max(ans,max(dp[i][0],dp[i][1]));\n        }\n        return ans;\n    }\n};\n\n\n本题也可以采用贪心策略解决，使用极值构成最长摆动序列。\n\n# 1143 最长公共子序列\n\n给定两个字符串，求它们最长的公共子序列长度。\n\n输入是两个字符串，输出是一个整数，表示它们满足题目条件的长度。\n\n> 输入：text1 = "abcde", text2 = "ace" \n> 输出：3  \n> 解释：最长公共子序列是 "ace" ，它的长度为 3 。\n\n解析:\n\n设置状态：建立一个二维数组 dp，其中 dp[i][j] 表示到第一个字符串位置 i 为止、到第二个字符串位置 j 为止、最长的公共子序列长度。\n\n状态转移方程：从1开始计算字符串位置，那么当text1 的第 i 个字符与 text2 的第 j 个字符相等时，其最长公共子串长度为前一状态加1，即 dp[i][j] = dp[i-1][j-1] + 1；如果不相等，dp[i][j] 不会比dp[i-1][j] 和dp[i][j-1] 两者之中任何一个小，也不会比两者都大，即 dp[i][j] = max(dp[i-1][j],dp[i][j-1])\n\n初始情况：任一个字符串为空串则最长公共子序列的长度都为0，即dp[0][j] = dp[i][0] = 0\n\nclass Solution {\npublic:\n    int longestCommonSubsequence(string text1, string text2) {\n        int len1 = text1.length(), len2 = text2.length();\n        // 创建len+1行len2+1列的二维数组 dp，其中 dp[i][j] 表示 text1[0:i] 和 text2[0:j] 的最长公共子序列的长度\n        vector<vector<int>> dp(len1+1,vector<int>(len2+1));\n        for(int i=1;i<=len1;++i){\n            for(int j=1;j<=len2;++j){\n                // 相等情况\n                if(text1[i-1]==text2[j-1]){\n                    dp[i][j] = dp[i-1][j-1] + 1;\n                // 不等情况\n                }else{\n                    dp[i][j] = max(dp[i-1][j],dp[i][j-1]);\n                }\n            }\n        }\n        return dp[len1][len2];\n    }\n};\n\n\n# 583 两个字符串的删除操作\n\n给定两个字符串，求它们通过删除操作变成相同的最小步骤。\n\n输入是两个字符串，输出是一个整数，表示它们通过删除操作变成相同的最小步骤数。\n\n> 输入: "sea", "eat"\n> 输出: 2\n> 解释: 第一步将"sea"变为"ea"，第二步将"eat"变为"ea"\n\n解析:\n\n本题是最长公共子序列的一种变种题，可以直接求出最长公共子序列后用较长一个字符串的长度减去最长公共子序列的长度。\n\nclass Solution {\npublic:\n    int minDistance(string word1, string word2) {\n        int m = word1.length(), n = word2.length();\n        vector<vector<int>> dp(m+1,vector<int>(n+1));\n        for(int i=1;i<=m;++i){\n            for(int j=1;j<=n;++j){\n                if(word1[i-1] == word2[j-1]){\n                    dp[i][j] = dp[i-1][j-1] + 1;\n                }else{\n                    dp[i][j] = max(dp[i-1][j],dp[i][j-1]);\n                }\n            }\n        }\n        int LCS = dp[m][n];\n        return m+n-2*LCS;\n    }\n};\n',normalizedContent:'# 04 子序列问题\n\n对于子序列问题，第一种动态规划方法是，定义一个 dp 数组，其中 dp[i]表示以 i 结尾的子序列的性质。在处理好每个位置后，统计一遍各个位置的结果即可得到题目要求的结果。第二种动态规划方法是，定义一个 dp数组，其中 dp[i] 表示到位置 i 为止的子序列的性质，并不必须以 i 结尾。这样 dp 数组的最后一位结果即为题目所求，不需要再对每个位置进行统计。\n\n# 300 最长递增子序列\n\n给定一个未排序的整数数组，求最长的递增子序列。\n\n输入是一个一维数组，输出是一个正整数，表示最长递增子序列的长度。\n\n> 输入：nums = [10,9,2,5,3,7,101,18]\n> 输出：4\n> 解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。\n\n解析:\n\n设置状态：使用一个一维数组dp[i] 可以表示以 i 结尾的、最长子序列长度。\n\n状态转移方程：对于每一个位置 i，如果其之前的某个位置 j 所对应的数字小于位置 i 所对应的数字，则可以获得一个以 i 结尾的、长度为 dp[j] + 1 的子序列，即dp[i] = max(dp[i],dp[j]+1)。为了遍历所有情况，我们需要 i 和 j 进行两层循环，并记录最大值。\n\n初始情况：dp[0] = 0, dp[1] = 1\n\nclass solution {\npublic:\n    int lengthoflis(vector<int>& nums) {\n        int len = nums.size();\n        // 将所有位置初始化为 1, 因为len>=1,所以最短递增子序列就是 1 \n        vector<int> dp(len,1); \n        int ans = 1;\n        // i 控制每一个记录位置\n        for(int i=1;i<len;++i){ \n            // j 扫描 i 之前的子序列\n            for(int j=0;j<i;++j){ \n                // 如果出现递增情况，判断是否增加的子序列长度\n                if(nums[i]>nums[j]){ \n                    dp[i] = max(dp[i],dp[j]+1);\n                }\n            }\n            // 完成一个位置的记录之后，判断是否是较大长度\n            ans = max(ans,dp[i]);\n        }\n        return ans;\n    }\n};\n\n\n# 646 最长数对链\n\n给出 n 个数对，在每一个数对中，第一个数字总是比第二个数字小。对于数对(a,b),(c,d)如果 b < c则这两个数对可以构成数对链\n\n输入一个数对集合，输出一个整数表示能够形成的最长数对链的长度。\n\n> 输入：[[1,2], [2,3], [3,4]]\n> 输出：2\n> 解释：最长的数对链是 [1,2] -> [3,4]\n\n解析:\n\n本题和300题本质上是一样的，不同在于递增序列由数对构成。另外需要考虑数对出现的次序并不影响它是否能够加入数对链，所以在使用类似于300题的动态规划方法计算最长数对链长度之前需要对其进行排序，简化元素选择。本题中以区间（数对）结尾排序。\n\nclass solution {\npublic:\n    int findlongestchain(vector<vector<int>>& pairs) {\n        int len = pairs.size();\n        if(len < 1) return 0; \n        sort(pairs.begin(),pairs.end(),[](vector<int> a, vector<int> b){ return a[1]<b[1];});\n        vector<int> dp(len,1);\n        int ans = 1;\n        for(int i=1;i<len;++i){\n            for(int j=0;j<i;++j){\n                if(pairs[j][1]<pairs[i][0]){\n                    dp[i] = max(dp[i],dp[j]+1);\n                }\n            }\n            ans = max(ans,dp[i]);\n        }\n        return ans;\n    }\n};\n\n\n# 376 摆动序列\n\n如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为摆动序列。给你一个整数数组 nums ，返回 nums 中作为 摆动序列 的 最长子序列的长度 。\n\n输入是一个一维数组，输出是一个正整数，表示作为摆动序列的最长子序列的长度。\n\n> 输入：nums = [1,17,5,10,13,15,10,5,16,8] 输出：7 解释：这个序列包含几个长度为 7 摆动序列。其中一个是 [1, 17, 10, 13, 10, 16, 8] ，各元素之间的差值为 (16, -7, 3, -3, 6, -8) 。\n\n解析:\n\n本题和递增子序列的差别在于摆动序列的元素选择取决于前一个被选元素的大小，既可以上升也可以下降。\n\n设置状态：使用一个二维数组dp[i][j]表示前 i 个元素中的某一个为结尾的最长摆动序列长度，其中 j 取值为 0 和 1分别表示上升摆动序列和下降摆动序列。上升摆动序列是指最后一个元素是呈上升趋势的摆动序列，下降摆动序列同理。d[i][0]表示以前 i 个元素中的某一个为结尾的最长的上升摆动序列的长度；dp[i][1]以前 i 个元素中的某一个为结尾的最长的下降摆动序列的长度。\n\n状态转移方程：考虑第 i 个元素，如果nums[i] > nums[i-1]，则该元素可以加入下降摆动序列形成上升摆动序列dp[i][0] = max(dp[i-1][0],dp[i-1][1] + 1)，但是该元素加入上升摆动序列并不会形成下降摆动序列dp[i][1] = dp[i-1][1]；如果nums[i] < nums[i-1]，则该元素可以加入上升摆动序列形成下降摆动序列dp[i][1] = max(dp[i-1][1],dp[i-1][0] + 1)，如果该元素加入下降摆动序列并不会形成上升摆动序列所以dp[i][0] = dp[i-1][0]；如果nums[i] == nums[i-1]那么可以直接跳过该元素dp[i][0] = dp[i-1][0], dp[i][1] = dp[i-1][1]。\n\n初始情况：当只有一个元素时，该元素既是上升摆动序列也是下降摆动序列，dp[0][j] = 1;\n\nclass solution {\npublic:\n    int wigglemaxlength(vector<int>& nums) {\n        int len = nums.size();\n        if(len < 2) return len;\n        vector<vector<int>> dp(len,vector<int>(2,1));\n        int ans = 1;\n        for(int i=1;i<len;++i){\n            if(nums[i] < nums[i-1]){\n                dp[i][0] = dp[i-1][0];\n                dp[i][1] = max(dp[i-1][1],dp[i-1][0] + 1);\n            }else if(nums[i] > nums[i-1]){\n                dp[i][0] = max(dp[i-1][0],dp[i-1][1] + 1);\n                dp[i][1] = dp[i-1][1];\n            }else{\n                dp[i][0] = dp[i-1][0];\n                dp[i][1] = dp[i-1][1];\n            }\n            ans = max(ans,max(dp[i][0],dp[i][1]));\n        }\n        return ans;\n    }\n};\n\n\n本题也可以采用贪心策略解决，使用极值构成最长摆动序列。\n\n# 1143 最长公共子序列\n\n给定两个字符串，求它们最长的公共子序列长度。\n\n输入是两个字符串，输出是一个整数，表示它们满足题目条件的长度。\n\n> 输入：text1 = "abcde", text2 = "ace" \n> 输出：3  \n> 解释：最长公共子序列是 "ace" ，它的长度为 3 。\n\n解析:\n\n设置状态：建立一个二维数组 dp，其中 dp[i][j] 表示到第一个字符串位置 i 为止、到第二个字符串位置 j 为止、最长的公共子序列长度。\n\n状态转移方程：从1开始计算字符串位置，那么当text1 的第 i 个字符与 text2 的第 j 个字符相等时，其最长公共子串长度为前一状态加1，即 dp[i][j] = dp[i-1][j-1] + 1；如果不相等，dp[i][j] 不会比dp[i-1][j] 和dp[i][j-1] 两者之中任何一个小，也不会比两者都大，即 dp[i][j] = max(dp[i-1][j],dp[i][j-1])\n\n初始情况：任一个字符串为空串则最长公共子序列的长度都为0，即dp[0][j] = dp[i][0] = 0\n\nclass solution {\npublic:\n    int longestcommonsubsequence(string text1, string text2) {\n        int len1 = text1.length(), len2 = text2.length();\n        // 创建len+1行len2+1列的二维数组 dp，其中 dp[i][j] 表示 text1[0:i] 和 text2[0:j] 的最长公共子序列的长度\n        vector<vector<int>> dp(len1+1,vector<int>(len2+1));\n        for(int i=1;i<=len1;++i){\n            for(int j=1;j<=len2;++j){\n                // 相等情况\n                if(text1[i-1]==text2[j-1]){\n                    dp[i][j] = dp[i-1][j-1] + 1;\n                // 不等情况\n                }else{\n                    dp[i][j] = max(dp[i-1][j],dp[i][j-1]);\n                }\n            }\n        }\n        return dp[len1][len2];\n    }\n};\n\n\n# 583 两个字符串的删除操作\n\n给定两个字符串，求它们通过删除操作变成相同的最小步骤。\n\n输入是两个字符串，输出是一个整数，表示它们通过删除操作变成相同的最小步骤数。\n\n> 输入: "sea", "eat"\n> 输出: 2\n> 解释: 第一步将"sea"变为"ea"，第二步将"eat"变为"ea"\n\n解析:\n\n本题是最长公共子序列的一种变种题，可以直接求出最长公共子序列后用较长一个字符串的长度减去最长公共子序列的长度。\n\nclass solution {\npublic:\n    int mindistance(string word1, string word2) {\n        int m = word1.length(), n = word2.length();\n        vector<vector<int>> dp(m+1,vector<int>(n+1));\n        for(int i=1;i<=m;++i){\n            for(int j=1;j<=n;++j){\n                if(word1[i-1] == word2[j-1]){\n                    dp[i][j] = dp[i-1][j-1] + 1;\n                }else{\n                    dp[i][j] = max(dp[i-1][j],dp[i][j-1]);\n                }\n            }\n        }\n        int lcs = dp[m][n];\n        return m+n-2*lcs;\n    }\n};\n',charsets:{cjk:!0},lastUpdated:"2023/11/19, 12:55:48",lastUpdatedTimestamp:1700369748e3},{title:"05背包问题",frontmatter:{title:"05背包问题",date:"2023-03-24T18:39:49.000Z",permalink:"/pages/6417f0/"},regularPath:"/03.LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/03.%E8%BF%9B%E9%98%B6%E7%AE%97%E6%B3%95/03.%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/05.%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98.html",relativePath:"03.LeetCode刷题笔记/03.进阶算法/03.动态规划/05.背包问题.md",key:"v-596b536f",path:"/pages/6417f0/",headers:[{level:2,title:"05 背包问题",slug:"_05-背包问题",normalizedTitle:"05 背包问题",charIndex:2},{level:4,title:"416 分割等和子集",slug:"_416-分割等和子集",normalizedTitle:"416 分割等和子集",charIndex:1505},{level:4,title:"494 目标和",slug:"_494-目标和",normalizedTitle:"494 目标和",charIndex:3640},{level:4,title:"474 一和零",slug:"_474-一和零",normalizedTitle:"474 一和零",charIndex:5247},{level:4,title:"322 零钱兑换",slug:"_322-零钱兑换",normalizedTitle:"322 零钱兑换",charIndex:7020}],headersStr:"05 背包问题 416 分割等和子集 494 目标和 474 一和零 322 零钱兑换",content:'# 05 背包问题\n\n背包问题：有 N 个物品和容量为 W 的背包，每个物品都有自己的体积 w 和价值 v，求拿哪些物品可以使得背包所装下物品的总价值最大。如果限定每种物品只能选择 0 个或 1 个，则问题称为 0-1 背包问题；如果不限定每种物品的数量，则问题称为完全背包问题。\n\n0-1 背包问题，我们可以定义一个二维数组 dp 存储最大价值，其中 dp[i][j] 表示前 i 件物品体积不超过 j 的情况下能达到的最大价值。在我们遍历到第 i 件物品时，在当前背包总容量为 j 的情况下，分为两种情况：（1）如果我们不将物品 i 放入背包，即当前背包容量不足或这放入当前物品无法达到最大价值，那么 dp[i][j]= dp[i-1][j]，即前 i 个物品的最大价值等于只取前 i -1 个物品时的最大价值；（2）如果我们将物品 i 放入背包，假设第 i 件物品体积为 w，价值为 v，那么我们得到 dp[i][j] = dp[i-1][j-w] + v。\n\nint knapsack(vector<int> weights, vector<int> values, int N, int W) {\n\tvector<vector<int>> dp(N+1,vector<int>(W+1));\n    // 放置第i个物品\n    for(int i=1;i<=N;++i){\n        // 第 i 个物品的体积w和价值v\n        int w = weights[i-1], v = values[i-1];\n        // 遍历容量\n        for(int j=1;j<=W;++j){\n            if(j>=w){\n                dp[i][j] = max(dp[i-1][j],dp[i-1][j-w]+v);\n            }else{\n                dp[i][j] = dp[i-1][j];\n            }\n        }\n    }\n    return dp[N][W];\n}\n\n\n在完全背包问题中，一个物品可以拿多次。这里直接给出完全背包问题的状态转移方程dp[i][j] = max(dp[i-1][j], dp[i][j-w] + v)，其与 0-1 背包问题的差别仅仅是把状态转移方程中的第二个 i-1 变成了 i。\n\nint knapsack(vector<int> weights, vector<int> values, int N, int W) {\n\tvector<vector<int>> dp(N+1,vector<int>(W+1));\n    // 放置第i个物品\n    for(int i=1;i<=N;++i){\n        // 第 i 个物品的体积w和价值v\n        int w = weights[i-1], v = values[i-1];\n        // 遍历容量\n        for(int j=1;j<=W;++j){\n            if(j>=w){\n                dp[i][j] = max(dp[i-1][j],dp[i][j-w]+v);\n            }else{\n                dp[i][j] = dp[i-1][j];\n            }\n        }\n    }\n    return dp[N][W];\n}\n\n\n# 416 分割等和子集\n\n给定一个正整数数组，求是否可以把这个数组分成和相等的两部分。\n\n输入是一个一维正整数数组，输出时一个布尔值，表示是否可以满足题目要求。\n\n> 输入：nums = [1,5,11,5]\n> 输出：true\n> 解释：数组可以分割成 [1, 5, 5] 和 [11] 。\n\n解析:\n\n本题等价于 0-1 背包问题，设所有数字和为 sum，我们的目标是选取一部分物品，使得它们的总和为 target = sum/2，及用部分物品填满容量为target的背包。同时本题不需要考虑价值，因此我们只需要通过一个布尔值矩阵来表示状态转移矩阵。\n\n设置状态： dp[i][j] 表示 nums 的前 i 个整数是否能够组合成和为 j\n\n状态转移方程：(01背包问题的子问题都很简单只用区分选择当前物品或者不选择当前物品的情况)\n\n * 不选择 nums[i]：nums[i] 大于于当前容量 j 时，容量不够不选择该物品，dp[i][j] = dp[i-1][j]\n\n * 选择 nums[i]：\n   \n   >  * nums[i] 恰好等于当前容量 j，即nums[i]==j时，只放该物品就可以填满容量为 j 的背包，dp[i][j] =true\n   >  * nums[i] 小于当前容量 j，即nums[i]<j时，只放该物品不够填满容量为 j 的背包，检测放入该物品后dp[i-1][j-nums[i]]的情况下是否可以填满背包\n   > \n   > 总的说，当容量足够时，物品nums[i] 可选可不选（在有价值的情况下就需要选择价值较大的情况），则dp[i][j] = dp[i-1][j] || dp[i-1][j-nums[i]]\n\n初始情况：容量为0的时候，不选择任何物品，dp[i][0] = true；只有一个物品的时候，当容量为j == nums[0]时恰好满足，即dp[0][nums[0]] = true\n\n示例的状态转移矩阵根据上述状态转移方程可以得到如下表格：\n\n           0   1   2   3   4   5   6   7   8   9   10   11\n[0] = 1    T   T   F   F   F   F   F   F   F   F   F    F\n[1] = 5    T   T   F   F   F   T   T   F   F   F   F    F\n[2] = 11   T   T   F   F   F   T   T   F   F   F   F    T\n[3] = 5    T   T   F   F   F   T   T   F   F   F   T    T\n\nclass Solution {\npublic:\n    bool canPartition(vector<int>& nums) {\n        int sum = accumulate(nums.begin(),nums.end(),0);\n        auto maxPos = max_element(nums.begin(),nums.end());\n        int target = sum/2, len = nums.size();\n        // 注意特殊情况，和为奇数或者元素个数小与2都无法进行有效分割，而元素值大于target直接导致越界\n        if(len<2 || sum&1 || *maxPos > target){\n            return false;\n        }\n        vector<vector<bool>> dp(len,vector<bool>(target+1,false));\n        // 初始情况容量为0\n        for(int i=0;i<len;++i){\n            dp[i][0] = true;\n        }\n        // 初始情况物品只有一个\n        dp[0][nums[0]] = true;\n        for(int i=1;i<len;++i){\n            for(int j=1;j<=target;++j){\n                // 背包容量大于当前扫描物品，可选可不选\n                if(j >= nums[i]){\n                    dp[i][j] = dp[i-1][j] || dp[i-1][j-nums[i]];\n                // 背包容量小于当前扫描物品，没法选\n                }else{\n                    dp[i][j] = dp[i-1][j];\n                }\n            }\n        }\n        return dp[len-1][target];\n    }\n};\n\n\n# 494 目标和\n\n给定义一个整数数组 nums 和一个整数 target 。向数组中的每个整数前添加 \'+\' 或 \'-\' ，然后串联起所有整数，可以构造一个 表达式，返回可以完成表达式构造的、运算结果等于 target 的不同 表达式 的数目。\n\n输入一个一维数组和整数，输出一个整数表示构造表达式结果为target的方法数\n\n> 输入：nums = [1,1,1,1,1], target = 3 输出：5 解释：一共有 5 种方法让最终目标和为 3 。 -1 + 1 + 1 + 1 + 1 = 3 +1 - 1 + 1 + 1 + 1 = 3 +1 + 1 - 1 + 1 + 1 = 3 +1 + 1 + 1 - 1 + 1 = 3 +1 + 1 + 1 + 1 - 1 = 3\n\n解析：\n\n本题可以转化为 01 背包问题，假设数组元素总和为 sum，添加 \'+\'的元素和为 x，那么添加 \'-\'的元素和为 sum - x。由此可以得到 x - (sum - x) = target，即为x = (target + sum) / 2，那么本题就可以转化为使用 nums中的N个物品装满容量为 x 的背包，共有多少种方法，可以看出这时一个组合问题。\n\n设置状态：使用一个二维数组 dp[i][j] 表示数组 nums 中从开头到以 i 位置结尾的所有物品装满容量为 j 的背包的方法数。\n\n状态转移方程：考虑第 i 个元素，如果当前背包容量 j<nums[i]，则不能放入第 i 个元素 dp[i][j] = dp[i-1][j]；如果当前背包容量j >= nums[i]，不放入第 i 个元素的方法数为dp[i][j] = dp[i-1][j]，放入第 i 个元素的方法数为dp[i][j] = dp[i-1][j-nums[i]]，那么总的方法数为这两中情况之和即dp[i][j] = dp[i-1][j] + dp[i-1][j-nums[i]]\n\n边界情况：如果(target + sum)不为偶数是无解情况，如果 abs(target) > sum 也是无解情况，没有任何构造方式能够满足题目条件。当数组为空，背包容量为0时dp[0][0] == 1\n\nclass Solution {\npublic:\n    int findTargetSumWays(vector<int>& nums, int target) {\n        int len = nums.size();\n        int sum = accumulate(nums.begin(),nums.end(),0);\n        if((target+sum)&1 || abs(target)>sum){\n            return 0;\n        }\n        int weight = (target + sum)/2;\n        vector<vector<int>> dp(len+1,vector<int>(weight+1));\n        dp[0][0] = 1;\n        for(int i=1;i<=len;++i){\n            for(int j=0;j<=weight;++j){\n                dp[i][j] = dp[i-1][j];\n                if(j>=nums[i-1]){\n                    dp[i][j] = dp[i-1][j] + dp[i-1][j-nums[i-1]];\n                }\n            }\n        }\n        return dp[len][weight];\n    }\n};\n\n\n# 474 一和零\n\n给定 m 个数字 0 和 n 个数字 1，以及一些由 0-1 构成的字符串，求利用这些数字最多可以构成多少个给定的字符串，字符串只可以构成一次。\n\n输入两个整数 m 和 n，表示 0 和 1 的数量，以及一个一维字符串数组，表示待构成的字符串；输出是一个整数，表示最多可以生成的字符串个数。\n\n> 输入：strs = ["10", "0001", "111001", "1", "0"], m = 5, n = 3 输出：4 解释：最多有 5 个 0 和 3 个 1 的最大子集是 {"10","0001","1","0"} ，因此答案是 4 。其他满足题意但较小的子集包括 {"0001","1"} 和 {"10","1","0"} 。{"111001"} 不满足题意，因为它含 4 个 1 ，大于 n 的值 3 。\n\n解析：\n\n本题也是一个01背包问题，而其特点在于它有两个背包，一个装0，另一个装1。\n\n设置状态：dp[i][j][k] 表示装0背包容量为 j，装1背包容量为k的情况下，能够装入前 i 个物品中的几个\n\n状态转移方程：仍旧划为装入当前物品和不装入当前物品两个子问题，不装入则dp[i][j][k]=dp[i-1][j][k]，装入则dp[i][j][k]=max(dp[i-1][j][k],dp[i-1][j-w0[i]][k-w1[i]] + 1)，其中w0表示物品中0的体积，w1表示物品中1的体积。\n\nclass Solution {\npublic:\n\n    // 计算每个str中0和1的数量\n    pair<int,int> countWeight(string str){\n        int count0 = 0, count1 = 0;\n        for(int i=0;i<str.length();++i){\n            if(str[i] == \'0\'){\n                ++count0;\n            }else{\n                ++count1;\n            }\n        }\n        return make_pair(count0,count1);\n    }\n\n    int findMaxForm(vector<string>& strs, int m, int n) {\n        int len = strs.size();\n        // 用一个三维数组表示在前 i 个字符串中，使用 j 个 0 和 k 个 1 的情况下最多可以得到的字符串数量\n        vector<vector<vector<int>>> dp(len+1,vector<vector<int>>(m+1,vector<int>(n+1)));\n        for(int i=1;i<=len;++i){\n            auto count = countWeight(strs[i-1]);\n            // j 和 k 都从零开始，因为str存在\'0\'或\'1\'这种只有一种元素构成的情况\n            for(int j=0;j<=m;++j){\n                for(int k=0;k<=n;++k){\n                    if(j >= count.first && k >= count.second){\n                        dp[i][j][k] = max(dp[i-1][j][k],dp[i-1][j-count.first][k-count.second] + 1);\n                    }else{\n                        dp[i][j][k] = dp[i-1][j][k];\n                    }\n                }\n            }\n        }\n        return dp[len][m][n];\n    }\n};\n\n\n# 322 零钱兑换\n\n给定一些硬币的面额，求最少可以用多少颗硬币组成给定的金额。\n\n输入一个一维整数数组，表示硬币的面额；以及一个整数，表示给定的金额。输出一个整数，表示满足条件的最少的硬币数量。若不存在解，则返回-1。\n\n> 输入：coins = [1, 2, 5], amount = 11\n> 输出：3 \n> 解释：11 = 5 + 5 + 1\n\n解析：\n\n因为每个硬币可以用无限多次，这道题本质上是完全背包问题。完全背包问题还是没搞懂，记录一下，以后仔细琢磨。\n\nclass Solution {\npublic:\n    int coinChange(vector<int>& coins, int amount) {\n        int Max = amount + 1;\n        vector<int> dp(amount + 1, Max);\n        dp[0] = 0;\n        for (int i = 1; i <= amount; ++i) {\n            for (int j = 0; j < (int)coins.size(); ++j) {\n                if (coins[j] <= i) {\n                    dp[i] = min(dp[i], dp[i - coins[j]] + 1);\n                }\n            }\n        }\n        return dp[amount] > amount ? -1 : dp[amount];\n    }\n};\n',normalizedContent:'# 05 背包问题\n\n背包问题：有 n 个物品和容量为 w 的背包，每个物品都有自己的体积 w 和价值 v，求拿哪些物品可以使得背包所装下物品的总价值最大。如果限定每种物品只能选择 0 个或 1 个，则问题称为 0-1 背包问题；如果不限定每种物品的数量，则问题称为完全背包问题。\n\n0-1 背包问题，我们可以定义一个二维数组 dp 存储最大价值，其中 dp[i][j] 表示前 i 件物品体积不超过 j 的情况下能达到的最大价值。在我们遍历到第 i 件物品时，在当前背包总容量为 j 的情况下，分为两种情况：（1）如果我们不将物品 i 放入背包，即当前背包容量不足或这放入当前物品无法达到最大价值，那么 dp[i][j]= dp[i-1][j]，即前 i 个物品的最大价值等于只取前 i -1 个物品时的最大价值；（2）如果我们将物品 i 放入背包，假设第 i 件物品体积为 w，价值为 v，那么我们得到 dp[i][j] = dp[i-1][j-w] + v。\n\nint knapsack(vector<int> weights, vector<int> values, int n, int w) {\n\tvector<vector<int>> dp(n+1,vector<int>(w+1));\n    // 放置第i个物品\n    for(int i=1;i<=n;++i){\n        // 第 i 个物品的体积w和价值v\n        int w = weights[i-1], v = values[i-1];\n        // 遍历容量\n        for(int j=1;j<=w;++j){\n            if(j>=w){\n                dp[i][j] = max(dp[i-1][j],dp[i-1][j-w]+v);\n            }else{\n                dp[i][j] = dp[i-1][j];\n            }\n        }\n    }\n    return dp[n][w];\n}\n\n\n在完全背包问题中，一个物品可以拿多次。这里直接给出完全背包问题的状态转移方程dp[i][j] = max(dp[i-1][j], dp[i][j-w] + v)，其与 0-1 背包问题的差别仅仅是把状态转移方程中的第二个 i-1 变成了 i。\n\nint knapsack(vector<int> weights, vector<int> values, int n, int w) {\n\tvector<vector<int>> dp(n+1,vector<int>(w+1));\n    // 放置第i个物品\n    for(int i=1;i<=n;++i){\n        // 第 i 个物品的体积w和价值v\n        int w = weights[i-1], v = values[i-1];\n        // 遍历容量\n        for(int j=1;j<=w;++j){\n            if(j>=w){\n                dp[i][j] = max(dp[i-1][j],dp[i][j-w]+v);\n            }else{\n                dp[i][j] = dp[i-1][j];\n            }\n        }\n    }\n    return dp[n][w];\n}\n\n\n# 416 分割等和子集\n\n给定一个正整数数组，求是否可以把这个数组分成和相等的两部分。\n\n输入是一个一维正整数数组，输出时一个布尔值，表示是否可以满足题目要求。\n\n> 输入：nums = [1,5,11,5]\n> 输出：true\n> 解释：数组可以分割成 [1, 5, 5] 和 [11] 。\n\n解析:\n\n本题等价于 0-1 背包问题，设所有数字和为 sum，我们的目标是选取一部分物品，使得它们的总和为 target = sum/2，及用部分物品填满容量为target的背包。同时本题不需要考虑价值，因此我们只需要通过一个布尔值矩阵来表示状态转移矩阵。\n\n设置状态： dp[i][j] 表示 nums 的前 i 个整数是否能够组合成和为 j\n\n状态转移方程：(01背包问题的子问题都很简单只用区分选择当前物品或者不选择当前物品的情况)\n\n * 不选择 nums[i]：nums[i] 大于于当前容量 j 时，容量不够不选择该物品，dp[i][j] = dp[i-1][j]\n\n * 选择 nums[i]：\n   \n   >  * nums[i] 恰好等于当前容量 j，即nums[i]==j时，只放该物品就可以填满容量为 j 的背包，dp[i][j] =true\n   >  * nums[i] 小于当前容量 j，即nums[i]<j时，只放该物品不够填满容量为 j 的背包，检测放入该物品后dp[i-1][j-nums[i]]的情况下是否可以填满背包\n   > \n   > 总的说，当容量足够时，物品nums[i] 可选可不选（在有价值的情况下就需要选择价值较大的情况），则dp[i][j] = dp[i-1][j] || dp[i-1][j-nums[i]]\n\n初始情况：容量为0的时候，不选择任何物品，dp[i][0] = true；只有一个物品的时候，当容量为j == nums[0]时恰好满足，即dp[0][nums[0]] = true\n\n示例的状态转移矩阵根据上述状态转移方程可以得到如下表格：\n\n           0   1   2   3   4   5   6   7   8   9   10   11\n[0] = 1    t   t   f   f   f   f   f   f   f   f   f    f\n[1] = 5    t   t   f   f   f   t   t   f   f   f   f    f\n[2] = 11   t   t   f   f   f   t   t   f   f   f   f    t\n[3] = 5    t   t   f   f   f   t   t   f   f   f   t    t\n\nclass solution {\npublic:\n    bool canpartition(vector<int>& nums) {\n        int sum = accumulate(nums.begin(),nums.end(),0);\n        auto maxpos = max_element(nums.begin(),nums.end());\n        int target = sum/2, len = nums.size();\n        // 注意特殊情况，和为奇数或者元素个数小与2都无法进行有效分割，而元素值大于target直接导致越界\n        if(len<2 || sum&1 || *maxpos > target){\n            return false;\n        }\n        vector<vector<bool>> dp(len,vector<bool>(target+1,false));\n        // 初始情况容量为0\n        for(int i=0;i<len;++i){\n            dp[i][0] = true;\n        }\n        // 初始情况物品只有一个\n        dp[0][nums[0]] = true;\n        for(int i=1;i<len;++i){\n            for(int j=1;j<=target;++j){\n                // 背包容量大于当前扫描物品，可选可不选\n                if(j >= nums[i]){\n                    dp[i][j] = dp[i-1][j] || dp[i-1][j-nums[i]];\n                // 背包容量小于当前扫描物品，没法选\n                }else{\n                    dp[i][j] = dp[i-1][j];\n                }\n            }\n        }\n        return dp[len-1][target];\n    }\n};\n\n\n# 494 目标和\n\n给定义一个整数数组 nums 和一个整数 target 。向数组中的每个整数前添加 \'+\' 或 \'-\' ，然后串联起所有整数，可以构造一个 表达式，返回可以完成表达式构造的、运算结果等于 target 的不同 表达式 的数目。\n\n输入一个一维数组和整数，输出一个整数表示构造表达式结果为target的方法数\n\n> 输入：nums = [1,1,1,1,1], target = 3 输出：5 解释：一共有 5 种方法让最终目标和为 3 。 -1 + 1 + 1 + 1 + 1 = 3 +1 - 1 + 1 + 1 + 1 = 3 +1 + 1 - 1 + 1 + 1 = 3 +1 + 1 + 1 - 1 + 1 = 3 +1 + 1 + 1 + 1 - 1 = 3\n\n解析：\n\n本题可以转化为 01 背包问题，假设数组元素总和为 sum，添加 \'+\'的元素和为 x，那么添加 \'-\'的元素和为 sum - x。由此可以得到 x - (sum - x) = target，即为x = (target + sum) / 2，那么本题就可以转化为使用 nums中的n个物品装满容量为 x 的背包，共有多少种方法，可以看出这时一个组合问题。\n\n设置状态：使用一个二维数组 dp[i][j] 表示数组 nums 中从开头到以 i 位置结尾的所有物品装满容量为 j 的背包的方法数。\n\n状态转移方程：考虑第 i 个元素，如果当前背包容量 j<nums[i]，则不能放入第 i 个元素 dp[i][j] = dp[i-1][j]；如果当前背包容量j >= nums[i]，不放入第 i 个元素的方法数为dp[i][j] = dp[i-1][j]，放入第 i 个元素的方法数为dp[i][j] = dp[i-1][j-nums[i]]，那么总的方法数为这两中情况之和即dp[i][j] = dp[i-1][j] + dp[i-1][j-nums[i]]\n\n边界情况：如果(target + sum)不为偶数是无解情况，如果 abs(target) > sum 也是无解情况，没有任何构造方式能够满足题目条件。当数组为空，背包容量为0时dp[0][0] == 1\n\nclass solution {\npublic:\n    int findtargetsumways(vector<int>& nums, int target) {\n        int len = nums.size();\n        int sum = accumulate(nums.begin(),nums.end(),0);\n        if((target+sum)&1 || abs(target)>sum){\n            return 0;\n        }\n        int weight = (target + sum)/2;\n        vector<vector<int>> dp(len+1,vector<int>(weight+1));\n        dp[0][0] = 1;\n        for(int i=1;i<=len;++i){\n            for(int j=0;j<=weight;++j){\n                dp[i][j] = dp[i-1][j];\n                if(j>=nums[i-1]){\n                    dp[i][j] = dp[i-1][j] + dp[i-1][j-nums[i-1]];\n                }\n            }\n        }\n        return dp[len][weight];\n    }\n};\n\n\n# 474 一和零\n\n给定 m 个数字 0 和 n 个数字 1，以及一些由 0-1 构成的字符串，求利用这些数字最多可以构成多少个给定的字符串，字符串只可以构成一次。\n\n输入两个整数 m 和 n，表示 0 和 1 的数量，以及一个一维字符串数组，表示待构成的字符串；输出是一个整数，表示最多可以生成的字符串个数。\n\n> 输入：strs = ["10", "0001", "111001", "1", "0"], m = 5, n = 3 输出：4 解释：最多有 5 个 0 和 3 个 1 的最大子集是 {"10","0001","1","0"} ，因此答案是 4 。其他满足题意但较小的子集包括 {"0001","1"} 和 {"10","1","0"} 。{"111001"} 不满足题意，因为它含 4 个 1 ，大于 n 的值 3 。\n\n解析：\n\n本题也是一个01背包问题，而其特点在于它有两个背包，一个装0，另一个装1。\n\n设置状态：dp[i][j][k] 表示装0背包容量为 j，装1背包容量为k的情况下，能够装入前 i 个物品中的几个\n\n状态转移方程：仍旧划为装入当前物品和不装入当前物品两个子问题，不装入则dp[i][j][k]=dp[i-1][j][k]，装入则dp[i][j][k]=max(dp[i-1][j][k],dp[i-1][j-w0[i]][k-w1[i]] + 1)，其中w0表示物品中0的体积，w1表示物品中1的体积。\n\nclass solution {\npublic:\n\n    // 计算每个str中0和1的数量\n    pair<int,int> countweight(string str){\n        int count0 = 0, count1 = 0;\n        for(int i=0;i<str.length();++i){\n            if(str[i] == \'0\'){\n                ++count0;\n            }else{\n                ++count1;\n            }\n        }\n        return make_pair(count0,count1);\n    }\n\n    int findmaxform(vector<string>& strs, int m, int n) {\n        int len = strs.size();\n        // 用一个三维数组表示在前 i 个字符串中，使用 j 个 0 和 k 个 1 的情况下最多可以得到的字符串数量\n        vector<vector<vector<int>>> dp(len+1,vector<vector<int>>(m+1,vector<int>(n+1)));\n        for(int i=1;i<=len;++i){\n            auto count = countweight(strs[i-1]);\n            // j 和 k 都从零开始，因为str存在\'0\'或\'1\'这种只有一种元素构成的情况\n            for(int j=0;j<=m;++j){\n                for(int k=0;k<=n;++k){\n                    if(j >= count.first && k >= count.second){\n                        dp[i][j][k] = max(dp[i-1][j][k],dp[i-1][j-count.first][k-count.second] + 1);\n                    }else{\n                        dp[i][j][k] = dp[i-1][j][k];\n                    }\n                }\n            }\n        }\n        return dp[len][m][n];\n    }\n};\n\n\n# 322 零钱兑换\n\n给定一些硬币的面额，求最少可以用多少颗硬币组成给定的金额。\n\n输入一个一维整数数组，表示硬币的面额；以及一个整数，表示给定的金额。输出一个整数，表示满足条件的最少的硬币数量。若不存在解，则返回-1。\n\n> 输入：coins = [1, 2, 5], amount = 11\n> 输出：3 \n> 解释：11 = 5 + 5 + 1\n\n解析：\n\n因为每个硬币可以用无限多次，这道题本质上是完全背包问题。完全背包问题还是没搞懂，记录一下，以后仔细琢磨。\n\nclass solution {\npublic:\n    int coinchange(vector<int>& coins, int amount) {\n        int max = amount + 1;\n        vector<int> dp(amount + 1, max);\n        dp[0] = 0;\n        for (int i = 1; i <= amount; ++i) {\n            for (int j = 0; j < (int)coins.size(); ++j) {\n                if (coins[j] <= i) {\n                    dp[i] = min(dp[i], dp[i - coins[j]] + 1);\n                }\n            }\n        }\n        return dp[amount] > amount ? -1 : dp[amount];\n    }\n};\n',charsets:{cjk:!0},lastUpdated:"2023/11/19, 12:55:48",lastUpdatedTimestamp:1700369748e3},{title:"03分割型动态规划",frontmatter:{title:"03分割型动态规划",date:"2023-03-24T18:39:49.000Z",permalink:"/pages/4015bd/"},regularPath:"/03.LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/03.%E8%BF%9B%E9%98%B6%E7%AE%97%E6%B3%95/03.%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/03.%E5%88%86%E5%89%B2%E5%9E%8B%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.html",relativePath:"03.LeetCode刷题笔记/03.进阶算法/03.动态规划/03.分割型动态规划.md",key:"v-5222397a",path:"/pages/4015bd/",headers:[{level:2,title:"03 分割型动态规划",slug:"_03-分割型动态规划",normalizedTitle:"03 分割型动态规划",charIndex:2},{level:4,title:"279 完全平方数",slug:"_279-完全平方数",normalizedTitle:"279 完全平方数",charIndex:64},{level:4,title:"343 整数拆分",slug:"_343-整数拆分",normalizedTitle:"343 整数拆分",charIndex:706},{level:4,title:"91 解码方法",slug:"_91-解码方法",normalizedTitle:"91 解码方法",charIndex:1543},{level:4,title:"55 跳跃游戏",slug:"_55-跳跃游戏",normalizedTitle:"55 跳跃游戏",charIndex:2621},{level:4,title:"139 单词拆分",slug:"_139-单词拆分",normalizedTitle:"139 单词拆分",charIndex:3242}],headersStr:"03 分割型动态规划 279 完全平方数 343 整数拆分 91 解码方法 55 跳跃游戏 139 单词拆分",content:'# 03 分割型动态规划\n\n对于分割类型题，动态规划的状态转移方程通常并不依赖相邻的位置，而是依赖于满足分割条件的位置。\n\n# 279 完全平方数\n\n给定一个正整数，求其最少可以由几个完全平方数相加构成。\n\n输入是给定的正整数，输出也是一个正整数，表示输入的数字最少可以由几个完全平方数相加构成。\n\n> 输入：n = 12\n> 输出：3 \n> 解释：12 = 4 + 4 + 4\n\n解析：\n\n设置状态：定义一个一维矩阵 dp，其中 dp[i] 表示数字 i 最少可以由几个完全平方数相加构成\n\n状态转移方程：在本题中，位置 i 只依赖 i - k^2 的位置，如 i - 1、i - 4、i - 9 等等，才能满足完全平方分割的条件。因此数字 i 可以取的最小值为 dp[i] = 1 + min(dp[i-1], dp[i-4], dp[i-9], ....... )\n\n初始情况：0 无法由任一个完全平方数相加构成，即dp[0]=0\n\nclass Solution {\npublic:\n    int numSquares(int n) {\n        vector<int> dp(n+1,INT_MAX);\n        dp[0] = 0;\n        for(int i=1;i<=n;++i){\n            for(int j=1;i-j*j>=0;++j){\n                dp[i] = min(dp[i],dp[i-j*j]+1);\n            }\n        }\n        return dp[n];\n    }\n};\n\n\n# 343 整数拆分\n\n给定一个正整数 n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。\n\n输入是给定的正整数，输出也是一个正整数，表示输入的数字拆分获得的最大乘积。\n\n> 输入: 10\n> 输出: 36\n> 解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。\n\n解析：\n\n本题和279题相似，位置 i 依赖于 i - j 的位置\n\n设置状态：定义一个一维矩阵 dp，其中 dp[i] 表示数字 i 拆分可以获得的最大乘积\n\n状态转移方程：将 i 拆分分为两种情况，第一种是仅拆分为两个数即 i 和 i - j，不再拆分为更多正整数，这种情况的乘积为 j*(i-j)；第二种是拆分出第一个正整数 j 后，将 i - j 继续拆分为多个正整数，这种情况乘积为j*dp[i-j]。所以在拆分的第一个数 j 固定的情况下状态转移方程为dp[i] = max(j*(i-j),j*dp[i-j])。由于 j 的取值范围是 1 到 i - 1，需要遍历所有的 j 得到 dp[i] 的最大值，因此可以得到状态转移方程dp[i] = max(dp[i],max(j*(i-j),j*dp[i-j]))。\n\n初始情况：0 不是正整数，1 是最小的正整数，0 和 1 都不能拆分，因此 dp[0] = dp[1] = 0\n\nclass Solution {\npublic:\n    int integerBreak(int n) {\n        vector<int> dp(n+1,0);\n        for(int i=2;i<=n;++i){\n            for(int j=1;j<i;++j){\n                dp[i] = max(dp[i],max(j*(i-j),j*dp[i-j]));\n            }\n        }\n        return dp[n];\n    }\n};\n\n\n# 91 解码方法\n\n已知字母 A-Z 可以表示成数字 1-26。给定一个数字串，求有多少种不同的字符串等价于这个数字串。\n\n输入是一个由数字组成的字符串，输出是满足条件的解码方式总数。\n\n> 输入：s = "226"\n> 输出：3\n> 解释：它可以解码为 "BZ" (2 26), "VF" (22 6), 或者 "BBF" (2 2 6) \n\n解析：\n\n本题的特殊情况较多因为只有 1-26 可以表示字母，所以对于一些特殊情况，比如数字 0 或者当相邻两数字大于 26 时，需要有不同的状态转移方程。本人对此题还存在一些疑惑，仅贴出代码，欢迎解惑。\n\nclass Solution {\npublic:\n    int numDecodings(string s) {\n        int n = s.length();\n        if(n==0){\n            return 0;\n        }\n        int prev = s[0] - \'0\';\n        if(!prev){\n            return 0;\n        }\n        if(n==1){\n            return 1;\n        }\n        vector<int> dp(n+1,1);\n        for(int i=2;i<=n;++i){\n            int cur = s[i-1] - \'0\';\n            if((prev==0 || prev>2) && cur == 0){\n                return 0;\n            }\n            if((prev < 2 && prev>0) || prev == 2 && cur < 7){\n                if(cur){\n                    dp[i] = dp[i-2] + dp[i-1];\n                }else{\n                    dp[i] = dp[i-2];\n                }\n            }else{\n                dp[i] = dp[i-1];\n            }\n            prev = cur;\n        }\n        return dp[n];\n    }\n};\n\n\n# 55 跳跃游戏\n\n给定一个非负整数数组 nums ，最初位于数组的第一个下标 。数组中的每个元素代表你在该位置可以跳跃的最大长度。判断是否能够到达最后一个下标。\n\n> 输入：nums = [2,3,1,1,4]\n> 输出：true\n> 解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。\n\n解析：\n\nclass Solution {\npublic:\n    bool canJump(vector<int>& nums) {\n        int n = nums.size();\n        if(n==1){\n            return true;\n        }\n        vector<int> dp(n,false);\n        dp[0] = true;\n        for(int i=1;i<n;++i){\n            for(int j=0;j<i;++j){\n                if(dp[j] && nums[j]+j>=i){\n                    dp[i] = true;\n                    break;\n                }\n            }\n        }\n        return dp[n-1];\n    }\n};\n\n\n# 139 单词拆分\n\n给定一个字符串和一个字符串集合，求是否存在一种分割方式，使得原字符串分割后的子字符串都可以在集合内找到。\n\n> 输入: s = "applepenapple", wordDict = ["apple", "pen"] 输出: true 解释: 返回 true 因为 "applepenapple" 可以被拆分成 "apple pen apple"；注意你可以重复使用字典中的单词。\n\n解析：\n\n本题类似于完全平方数分割问题，这道题的分割条件由集合内的字符串决定，因此在考虑每个分割位置时，需要遍历字符串集合，以确定当前位置是否可以成功分割。\n\n设置状态：用一个一维数组 dp[i] 表示开头到以 i 位置结束的子串是否能够在集合中找到\n\n状态转移方程：如果开头到以 j 结尾的子串都能在集合中找到，且从 j 到 i 的子串也能够在集合中找到那么 dp[i] = true\n\n初始情况：字符串和集合都为空时为真，dp[0]=true\n\nclass Solution {\npublic:\n    bool wordBreak(string s, vector<string>& wordDict) {\n        unordered_set<string> wordDictSet;\n        for(const auto w: wordDict){\n            wordDictSet.insert(w);\n        }\n        int n = s.length();\n        vector<bool> dp(n+1,false);\n        dp[0] = true;\n        for(int i=1;i<=n;++i){\n            for(int j=0;j<i;++j){\n                // 分割类型动态规划：dp[i] = s[0]到s[j-1]为true && s[j]到s[i-j]子串在字典中\n                if(dp[j] && wordDictSet.find(s.substr(j,i-j)) != wordDictSet.end()){\n                    dp[i] = true;\n                    // dp[i] 表示的是 s[0]到s[i-1]的子串中单词是否出现在字典中\n                    break;\n                }\n            }\n        }\n        return dp[n];\n    }\n};\n',normalizedContent:'# 03 分割型动态规划\n\n对于分割类型题，动态规划的状态转移方程通常并不依赖相邻的位置，而是依赖于满足分割条件的位置。\n\n# 279 完全平方数\n\n给定一个正整数，求其最少可以由几个完全平方数相加构成。\n\n输入是给定的正整数，输出也是一个正整数，表示输入的数字最少可以由几个完全平方数相加构成。\n\n> 输入：n = 12\n> 输出：3 \n> 解释：12 = 4 + 4 + 4\n\n解析：\n\n设置状态：定义一个一维矩阵 dp，其中 dp[i] 表示数字 i 最少可以由几个完全平方数相加构成\n\n状态转移方程：在本题中，位置 i 只依赖 i - k^2 的位置，如 i - 1、i - 4、i - 9 等等，才能满足完全平方分割的条件。因此数字 i 可以取的最小值为 dp[i] = 1 + min(dp[i-1], dp[i-4], dp[i-9], ....... )\n\n初始情况：0 无法由任一个完全平方数相加构成，即dp[0]=0\n\nclass solution {\npublic:\n    int numsquares(int n) {\n        vector<int> dp(n+1,int_max);\n        dp[0] = 0;\n        for(int i=1;i<=n;++i){\n            for(int j=1;i-j*j>=0;++j){\n                dp[i] = min(dp[i],dp[i-j*j]+1);\n            }\n        }\n        return dp[n];\n    }\n};\n\n\n# 343 整数拆分\n\n给定一个正整数 n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。\n\n输入是给定的正整数，输出也是一个正整数，表示输入的数字拆分获得的最大乘积。\n\n> 输入: 10\n> 输出: 36\n> 解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。\n\n解析：\n\n本题和279题相似，位置 i 依赖于 i - j 的位置\n\n设置状态：定义一个一维矩阵 dp，其中 dp[i] 表示数字 i 拆分可以获得的最大乘积\n\n状态转移方程：将 i 拆分分为两种情况，第一种是仅拆分为两个数即 i 和 i - j，不再拆分为更多正整数，这种情况的乘积为 j*(i-j)；第二种是拆分出第一个正整数 j 后，将 i - j 继续拆分为多个正整数，这种情况乘积为j*dp[i-j]。所以在拆分的第一个数 j 固定的情况下状态转移方程为dp[i] = max(j*(i-j),j*dp[i-j])。由于 j 的取值范围是 1 到 i - 1，需要遍历所有的 j 得到 dp[i] 的最大值，因此可以得到状态转移方程dp[i] = max(dp[i],max(j*(i-j),j*dp[i-j]))。\n\n初始情况：0 不是正整数，1 是最小的正整数，0 和 1 都不能拆分，因此 dp[0] = dp[1] = 0\n\nclass solution {\npublic:\n    int integerbreak(int n) {\n        vector<int> dp(n+1,0);\n        for(int i=2;i<=n;++i){\n            for(int j=1;j<i;++j){\n                dp[i] = max(dp[i],max(j*(i-j),j*dp[i-j]));\n            }\n        }\n        return dp[n];\n    }\n};\n\n\n# 91 解码方法\n\n已知字母 a-z 可以表示成数字 1-26。给定一个数字串，求有多少种不同的字符串等价于这个数字串。\n\n输入是一个由数字组成的字符串，输出是满足条件的解码方式总数。\n\n> 输入：s = "226"\n> 输出：3\n> 解释：它可以解码为 "bz" (2 26), "vf" (22 6), 或者 "bbf" (2 2 6) \n\n解析：\n\n本题的特殊情况较多因为只有 1-26 可以表示字母，所以对于一些特殊情况，比如数字 0 或者当相邻两数字大于 26 时，需要有不同的状态转移方程。本人对此题还存在一些疑惑，仅贴出代码，欢迎解惑。\n\nclass solution {\npublic:\n    int numdecodings(string s) {\n        int n = s.length();\n        if(n==0){\n            return 0;\n        }\n        int prev = s[0] - \'0\';\n        if(!prev){\n            return 0;\n        }\n        if(n==1){\n            return 1;\n        }\n        vector<int> dp(n+1,1);\n        for(int i=2;i<=n;++i){\n            int cur = s[i-1] - \'0\';\n            if((prev==0 || prev>2) && cur == 0){\n                return 0;\n            }\n            if((prev < 2 && prev>0) || prev == 2 && cur < 7){\n                if(cur){\n                    dp[i] = dp[i-2] + dp[i-1];\n                }else{\n                    dp[i] = dp[i-2];\n                }\n            }else{\n                dp[i] = dp[i-1];\n            }\n            prev = cur;\n        }\n        return dp[n];\n    }\n};\n\n\n# 55 跳跃游戏\n\n给定一个非负整数数组 nums ，最初位于数组的第一个下标 。数组中的每个元素代表你在该位置可以跳跃的最大长度。判断是否能够到达最后一个下标。\n\n> 输入：nums = [2,3,1,1,4]\n> 输出：true\n> 解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。\n\n解析：\n\nclass solution {\npublic:\n    bool canjump(vector<int>& nums) {\n        int n = nums.size();\n        if(n==1){\n            return true;\n        }\n        vector<int> dp(n,false);\n        dp[0] = true;\n        for(int i=1;i<n;++i){\n            for(int j=0;j<i;++j){\n                if(dp[j] && nums[j]+j>=i){\n                    dp[i] = true;\n                    break;\n                }\n            }\n        }\n        return dp[n-1];\n    }\n};\n\n\n# 139 单词拆分\n\n给定一个字符串和一个字符串集合，求是否存在一种分割方式，使得原字符串分割后的子字符串都可以在集合内找到。\n\n> 输入: s = "applepenapple", worddict = ["apple", "pen"] 输出: true 解释: 返回 true 因为 "applepenapple" 可以被拆分成 "apple pen apple"；注意你可以重复使用字典中的单词。\n\n解析：\n\n本题类似于完全平方数分割问题，这道题的分割条件由集合内的字符串决定，因此在考虑每个分割位置时，需要遍历字符串集合，以确定当前位置是否可以成功分割。\n\n设置状态：用一个一维数组 dp[i] 表示开头到以 i 位置结束的子串是否能够在集合中找到\n\n状态转移方程：如果开头到以 j 结尾的子串都能在集合中找到，且从 j 到 i 的子串也能够在集合中找到那么 dp[i] = true\n\n初始情况：字符串和集合都为空时为真，dp[0]=true\n\nclass solution {\npublic:\n    bool wordbreak(string s, vector<string>& worddict) {\n        unordered_set<string> worddictset;\n        for(const auto w: worddict){\n            worddictset.insert(w);\n        }\n        int n = s.length();\n        vector<bool> dp(n+1,false);\n        dp[0] = true;\n        for(int i=1;i<=n;++i){\n            for(int j=0;j<i;++j){\n                // 分割类型动态规划：dp[i] = s[0]到s[j-1]为true && s[j]到s[i-j]子串在字典中\n                if(dp[j] && worddictset.find(s.substr(j,i-j)) != worddictset.end()){\n                    dp[i] = true;\n                    // dp[i] 表示的是 s[0]到s[i-1]的子串中单词是否出现在字典中\n                    break;\n                }\n            }\n        }\n        return dp[n];\n    }\n};\n',charsets:{cjk:!0},lastUpdated:"2023/11/19, 12:55:48",lastUpdatedTimestamp:1700369748e3},{title:"06字符串编辑问题",frontmatter:{title:"06字符串编辑问题",date:"2023-03-24T18:39:49.000Z",permalink:"/pages/ef03e8/"},regularPath:"/03.LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/03.%E8%BF%9B%E9%98%B6%E7%AE%97%E6%B3%95/03.%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/06.%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%BC%96%E8%BE%91%E9%97%AE%E9%A2%98.html",relativePath:"03.LeetCode刷题笔记/03.进阶算法/03.动态规划/06.字符串编辑问题.md",key:"v-53e283aa",path:"/pages/ef03e8/",headers:[{level:2,title:"06 字符串编辑问题",slug:"_06-字符串编辑问题",normalizedTitle:"06 字符串编辑问题",charIndex:2},{level:4,title:"72 编辑距离",slug:"_72-编辑距离",normalizedTitle:"72 编辑距离",charIndex:16},{level:4,title:"650 只有两个键的键盘",slug:"_650-只有两个键的键盘",normalizedTitle:"650 只有两个键的键盘",charIndex:1389},{level:4,title:"10 正则表达式匹配",slug:"_10-正则表达式匹配",normalizedTitle:"10 正则表达式匹配",charIndex:2206}],headersStr:"06 字符串编辑问题 72 编辑距离 650 只有两个键的键盘 10 正则表达式匹配",content:"# 06 字符串编辑问题\n\n# 72 编辑距离\n\n给定两个字符串，已知你可以删除、替换和插入任意字符串的任意字符，求最少编辑几步可以将两个字符串变成相同。\n\n输入是两个字符串，输出是一个整数，表示最少的步骤。\n\n> 输入：word1 = \"horse\", word2 = \"ros\" 输出：3 解释： horse -> rorse (将 'h' 替换为 'r') rorse -> rose (删除 'r') rose -> ros (删除 'e')\n\n解析：\n\n本题与最长公共子序列类似，两个字符串的对比所以需要使用一个二维数组来设置状态 dp[i][j]\n\n设置状态：dp[i][j] 表示将第一个字符串到位置 i 为止，和第二个字符串到位置 j 为止，最多需要几步编辑。\n\n状态转移方程：当第 i 位和第 j 位对应的字符相同时，dp[i][j] 等于 dp[i-1][j-1]；当二者对应的字符不同时，修改的消耗是 dp[i-1][j-1]+1，插入 i 位置/删除 j 位置的消耗是 dp[i][j-1] + 1，插入 j 位置/删除 i 位置的消耗是 dp[i-1][j] + 1，所以在不同的情况下状态转移方程dp[i][j] = min(dp[i-1][j-1],dp[i-1][j],dp[i][j-1])。\n\n边界情况：word1为空串时，需要插入字符与word2一致，即dp[0][j] = j；同理，word2为空串是dp[i][0] = i\n\nclass Solution {\npublic:\n    int minDistance(string word1, string word2) {\n        int m = word1.length(), n = word2.length();\n        vector<vector<int>> dp(m+1,vector<int>(n+1));\n        // 边界条件 word2为空串\n        for(int i=0;i<=m;++i){\n            dp[i][0] = i;\n        }\n        // 边界条件 word1为空串\n        for(int j=0;j<=n;++j){\n            dp[0][j] = j;\n        }\n        for(int i=1;i<=m;++i){\n            for(int j=1;j<=n;++j){\n                // 状态转移，相等情况不编辑，不等情况选择编辑次数最少的编辑\n                if(word1[i-1] == word2[j-1]){\n                    dp[i][j] = dp[i-1][j-1];\n                }else{\n                    dp[i][j] = min(dp[i-1][j-1],min(dp[i-1][j],dp[i][j-1])) + 1;\n                }\n            }\n        }\n        return dp[m][n];\n    }\n};\n\n\n# 650 只有两个键的键盘\n\n给定一个字母 A，已知你可以每次选择复制全部字符，或者粘贴之前复制的字符，求最少需要几次操作可以把字符串延展到指定长度。\n\n输入是一个正整数，代表指定长度；输出是一个整数，表示最少操作次数。\n\n> 输入：3 输出：3 解释： 最初, 只有一个字符 'A'。 第 1 步, 使用 Copy All 操作。 第 2 步, 使用 Paste 操作来获得 'AA'。 第 3 步, 使用 Paste 操作来获得 'AAA'。\n\n解析：\n\n不同于以往通过加减实现的动态规划，这里需要乘除法来计算位置，因为粘贴操作是倍数增加的。\n\n设置状态：使用一个一维数组 dp[i]，其中位置 i 表示延展到长度 i 的最少操作次数。\n\n状态转移方程：对于每个位置 j，如果 j 可以被 i 整除，那么长度 i 就可以由长度 j 操作得到，其操作次数等价于把一个长度为 1 的 A 延展到长度为 i/j。例如3由1操作得到A A A，6由2操作得到AA AA AA因此可以得到递推公式 dp[i] = dp[j] + dp[i/j]。\n\nclass Solution {\npublic:\n    int minSteps(int n) {\n        vector<int> dp(n+1);\n        for(int i=2;i<=n;++i){\n            dp[i] = i;\n            for(int j=2;j<=i;++j){\n                if(i%j==0){\n                    dp[i] = dp[j] + dp[i/j];\n                    break;\n                }\n            }\n        }\n        return dp[n];\n    }\n};\n\n\n# 10 正则表达式匹配\n\n给定一个字符串和一个正则表达式（regular expression, regex），求该字符串是否可以被匹配，其中'.' 匹配任意单个字符；'*' 匹配零个或多个前面的那一个元素。\n\n输入是一个待匹配字符串和一个用字符串表示的正则表达式，输出是一个布尔值，表示是否可以匹配成功。\n\n> 输入：s = \"aab\" p = \"cab\" 输出：true 解释：因为 '*' 表示零个或多个，这里 'c' 为 0 个, 'a' 被重复一次。因此可以匹配字符串 \"aab\"。\n\n解析：\n\n两个字符串进行匹配，且字符具有特殊含义，本题动态规划的特点在于多种情况下的不同状态转移方程。\n\n设置状态：使用一个布尔类型的二维数组 dp，其中 dp[i][j] 表示以 i 截止的字符串是否可以被以 j 截止的正则表达式匹配。\n\n状态转移方程：根据正则表达式的不同情况，即字符、星号，点号，分情况讨论来更新 dp 数组\n\n * 相等情况：即s[i-1] == p[j-1] || p[j-1] == '.'的情况，这种情况下dp[i][j] == dp[i-1][j-1]，即与前 i-1 个子串匹配情况一致\n\n * 不相等情况：\n   \n   >  * s[i-1] != p[j-1] && p[j-1] != '*' ，直接不匹配情况dp[i][j] = false\n   >  * p[j-1] == '*'：如果匹配0次则dp[i][j-2] == true 则 dp[i][j] = true；如果匹配多次则需要验证'*'前一个字符相等情况即s[i-1] == p[j-1] || p[j-1] == '.'，相等则dp[i][j] = dp[i-1][j]，否则不匹配\n\n初始情况：空串匹配非空正则表达式，dp[0][0]=true，当p[j-1]=='*'是可以匹配0次匹配空串即dp[0][j] =dp[0][j-2]；非空串匹配空正则表达式，dp[0][0]=true，其他情况都无法成功匹配。\n\nclass Solution {\npublic:\n    bool isMatch(string s, string p) {\n        int m = s.size(), n = p.size();\n        vector<vector<bool>> dp(m+1,vector<bool>(n+1,false));\n        dp[0][0] = true;\n        for(int j=1;j<=n;++j){\n            if(p[j-1] == '*'){\n                dp[0][j] = dp[0][j-2];\n            }\n        }\n\n        for(int i=1;i<=m;++i){\n            auto chs = s[i-1]; \n            for(int j=1;j<=n;++j){\n                auto chp = p[j-1];\n                if(chs == chp || chp == '.'){\n                    dp[i][j] = dp[i-1][j-1];\n                }else if(chp ==  '*'){\n                    if(j>1){\n                        if(dp[i][j-2]){\n                            dp[i][j] = true;\n                        }else{\n                            auto prechp = p[j-2];\n                            if(prechp==chs || prechp =='.'){\n                                dp[i][j] = dp[i-1][j];\n                            } \n                        }\n                    }\n                }\n            }\n        }\n        return dp[m][n];\n    }\n};\n",normalizedContent:"# 06 字符串编辑问题\n\n# 72 编辑距离\n\n给定两个字符串，已知你可以删除、替换和插入任意字符串的任意字符，求最少编辑几步可以将两个字符串变成相同。\n\n输入是两个字符串，输出是一个整数，表示最少的步骤。\n\n> 输入：word1 = \"horse\", word2 = \"ros\" 输出：3 解释： horse -> rorse (将 'h' 替换为 'r') rorse -> rose (删除 'r') rose -> ros (删除 'e')\n\n解析：\n\n本题与最长公共子序列类似，两个字符串的对比所以需要使用一个二维数组来设置状态 dp[i][j]\n\n设置状态：dp[i][j] 表示将第一个字符串到位置 i 为止，和第二个字符串到位置 j 为止，最多需要几步编辑。\n\n状态转移方程：当第 i 位和第 j 位对应的字符相同时，dp[i][j] 等于 dp[i-1][j-1]；当二者对应的字符不同时，修改的消耗是 dp[i-1][j-1]+1，插入 i 位置/删除 j 位置的消耗是 dp[i][j-1] + 1，插入 j 位置/删除 i 位置的消耗是 dp[i-1][j] + 1，所以在不同的情况下状态转移方程dp[i][j] = min(dp[i-1][j-1],dp[i-1][j],dp[i][j-1])。\n\n边界情况：word1为空串时，需要插入字符与word2一致，即dp[0][j] = j；同理，word2为空串是dp[i][0] = i\n\nclass solution {\npublic:\n    int mindistance(string word1, string word2) {\n        int m = word1.length(), n = word2.length();\n        vector<vector<int>> dp(m+1,vector<int>(n+1));\n        // 边界条件 word2为空串\n        for(int i=0;i<=m;++i){\n            dp[i][0] = i;\n        }\n        // 边界条件 word1为空串\n        for(int j=0;j<=n;++j){\n            dp[0][j] = j;\n        }\n        for(int i=1;i<=m;++i){\n            for(int j=1;j<=n;++j){\n                // 状态转移，相等情况不编辑，不等情况选择编辑次数最少的编辑\n                if(word1[i-1] == word2[j-1]){\n                    dp[i][j] = dp[i-1][j-1];\n                }else{\n                    dp[i][j] = min(dp[i-1][j-1],min(dp[i-1][j],dp[i][j-1])) + 1;\n                }\n            }\n        }\n        return dp[m][n];\n    }\n};\n\n\n# 650 只有两个键的键盘\n\n给定一个字母 a，已知你可以每次选择复制全部字符，或者粘贴之前复制的字符，求最少需要几次操作可以把字符串延展到指定长度。\n\n输入是一个正整数，代表指定长度；输出是一个整数，表示最少操作次数。\n\n> 输入：3 输出：3 解释： 最初, 只有一个字符 'a'。 第 1 步, 使用 copy all 操作。 第 2 步, 使用 paste 操作来获得 'aa'。 第 3 步, 使用 paste 操作来获得 'aaa'。\n\n解析：\n\n不同于以往通过加减实现的动态规划，这里需要乘除法来计算位置，因为粘贴操作是倍数增加的。\n\n设置状态：使用一个一维数组 dp[i]，其中位置 i 表示延展到长度 i 的最少操作次数。\n\n状态转移方程：对于每个位置 j，如果 j 可以被 i 整除，那么长度 i 就可以由长度 j 操作得到，其操作次数等价于把一个长度为 1 的 a 延展到长度为 i/j。例如3由1操作得到a a a，6由2操作得到aa aa aa因此可以得到递推公式 dp[i] = dp[j] + dp[i/j]。\n\nclass solution {\npublic:\n    int minsteps(int n) {\n        vector<int> dp(n+1);\n        for(int i=2;i<=n;++i){\n            dp[i] = i;\n            for(int j=2;j<=i;++j){\n                if(i%j==0){\n                    dp[i] = dp[j] + dp[i/j];\n                    break;\n                }\n            }\n        }\n        return dp[n];\n    }\n};\n\n\n# 10 正则表达式匹配\n\n给定一个字符串和一个正则表达式（regular expression, regex），求该字符串是否可以被匹配，其中'.' 匹配任意单个字符；'*' 匹配零个或多个前面的那一个元素。\n\n输入是一个待匹配字符串和一个用字符串表示的正则表达式，输出是一个布尔值，表示是否可以匹配成功。\n\n> 输入：s = \"aab\" p = \"cab\" 输出：true 解释：因为 '*' 表示零个或多个，这里 'c' 为 0 个, 'a' 被重复一次。因此可以匹配字符串 \"aab\"。\n\n解析：\n\n两个字符串进行匹配，且字符具有特殊含义，本题动态规划的特点在于多种情况下的不同状态转移方程。\n\n设置状态：使用一个布尔类型的二维数组 dp，其中 dp[i][j] 表示以 i 截止的字符串是否可以被以 j 截止的正则表达式匹配。\n\n状态转移方程：根据正则表达式的不同情况，即字符、星号，点号，分情况讨论来更新 dp 数组\n\n * 相等情况：即s[i-1] == p[j-1] || p[j-1] == '.'的情况，这种情况下dp[i][j] == dp[i-1][j-1]，即与前 i-1 个子串匹配情况一致\n\n * 不相等情况：\n   \n   >  * s[i-1] != p[j-1] && p[j-1] != '*' ，直接不匹配情况dp[i][j] = false\n   >  * p[j-1] == '*'：如果匹配0次则dp[i][j-2] == true 则 dp[i][j] = true；如果匹配多次则需要验证'*'前一个字符相等情况即s[i-1] == p[j-1] || p[j-1] == '.'，相等则dp[i][j] = dp[i-1][j]，否则不匹配\n\n初始情况：空串匹配非空正则表达式，dp[0][0]=true，当p[j-1]=='*'是可以匹配0次匹配空串即dp[0][j] =dp[0][j-2]；非空串匹配空正则表达式，dp[0][0]=true，其他情况都无法成功匹配。\n\nclass solution {\npublic:\n    bool ismatch(string s, string p) {\n        int m = s.size(), n = p.size();\n        vector<vector<bool>> dp(m+1,vector<bool>(n+1,false));\n        dp[0][0] = true;\n        for(int j=1;j<=n;++j){\n            if(p[j-1] == '*'){\n                dp[0][j] = dp[0][j-2];\n            }\n        }\n\n        for(int i=1;i<=m;++i){\n            auto chs = s[i-1]; \n            for(int j=1;j<=n;++j){\n                auto chp = p[j-1];\n                if(chs == chp || chp == '.'){\n                    dp[i][j] = dp[i-1][j-1];\n                }else if(chp ==  '*'){\n                    if(j>1){\n                        if(dp[i][j-2]){\n                            dp[i][j] = true;\n                        }else{\n                            auto prechp = p[j-2];\n                            if(prechp==chs || prechp =='.'){\n                                dp[i][j] = dp[i-1][j];\n                            } \n                        }\n                    }\n                }\n            }\n        }\n        return dp[m][n];\n    }\n};\n",charsets:{cjk:!0},lastUpdated:"2023/11/19, 12:55:48",lastUpdatedTimestamp:1700369748e3},{title:"07股票交易问题",frontmatter:{title:"07股票交易问题",date:"2023-03-24T18:39:49.000Z",permalink:"/pages/c50903/"},regularPath:"/03.LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/03.%E8%BF%9B%E9%98%B6%E7%AE%97%E6%B3%95/03.%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/07.%E8%82%A1%E7%A5%A8%E4%BA%A4%E6%98%93%E9%97%AE%E9%A2%98.html",relativePath:"03.LeetCode刷题笔记/03.进阶算法/03.动态规划/07.股票交易问题.md",key:"v-c0ef0954",path:"/pages/c50903/",headers:[{level:2,title:"07 股票交易问题",slug:"_07-股票交易问题",normalizedTitle:"07 股票交易问题",charIndex:2},{level:4,title:"121 买卖股票的最佳时机",slug:"_121-买卖股票的最佳时机",normalizedTitle:"121 买卖股票的最佳时机",charIndex:110},{level:4,title:"122 买卖股票的最佳时机 II",slug:"_122-买卖股票的最佳时机-ii",normalizedTitle:"122 买卖股票的最佳时机 ii",charIndex:137},{level:4,title:"714 买卖股票的最佳时机含手续费",slug:"_714-买卖股票的最佳时机含手续费",normalizedTitle:"714 买卖股票的最佳时机含手续费",charIndex:164},{level:4,title:"123 买卖股票的最佳时机 III",slug:"_123-买卖股票的最佳时机-iii",normalizedTitle:"123 买卖股票的最佳时机 iii",charIndex:199},{level:4,title:"188 买卖股票的最佳时机 IV",slug:"_188-买卖股票的最佳时机-iv",normalizedTitle:"188 买卖股票的最佳时机 iv",charIndex:226},{level:4,title:"309 最佳买卖股票时机含冷冻期",slug:"_309-最佳买卖股票时机含冷冻期",normalizedTitle:"309 最佳买卖股票时机含冷冻期",charIndex:255}],headersStr:"07 股票交易问题 121 买卖股票的最佳时机 122 买卖股票的最佳时机 II 714 买卖股票的最佳时机含手续费 123 买卖股票的最佳时机 III 188 买卖股票的最佳时机 IV 309 最佳买卖股票时机含冷冻期",content:"# 07 股票交易问题\n\n股票交易类问题通常可以用动态规划来解决。对于稍微复杂一些的股票交易类问题，比如需要冷却时间或者交易费用，则可以用通过动态规划实现的状态机来解决。\n\n题目                  特点\n121 买卖股票的最佳时机       只能买卖一次\n122 买卖股票的最佳时机 II    可以买卖多次\n714 买卖股票的最佳时机含手续费   可以买卖多次，每次都有手续费\n123 买卖股票的最佳时机 III   最多买卖两次\n188 买卖股票的最佳时机 IV    最多买卖 k 次\n309 最佳买卖股票时机含冷冻期    可以买卖多次，但是卖出有一天冷冻期\n\n# 121 买卖股票的最佳时机\n\n给定一段时间内每天的股票价格，已知你只可以买卖各一次，求最大的收益。\n\n输入一个一维整数数组，表示每天的股票价格；输出一个整数，表示最大的收益。\n\n> 输入：[7,1,5,3,6,4] 输出：5 解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5\n\n解析：\n\n求最大利润本质是也是一个优化问题，所以可以采用动态规划的思路解决。\n\n设置状态：用两个动态规划数组buy[i] 表示第 i 天持股时的现金数，sell[i]表示第 i 天不持股时的现金数\n\n状态转移方程：第 i 天持股 buy[i] = max(buy[i-1],-prices[i])，如果第 i-1 天不持股则花费-prices[i]的现金买入股票，如果第i-1天持股，则保持不变；第 i 天不持股 sell[i] = max(sell[i-1],buy[i-1]+prices[i])，如果第 i-1 天也不持股那么情况不变，如果第 i-1 天持股则需要将其卖出产生收益buy[i-1]+prices[i]。\n\n初始情况：第 1 天不持股sell[0] = 0；第 1 天持股buy[0] = -prices[0]\n\nclass Solution {\npublic:\n    int maxProfit(vector<int>& prices) {\n        int len = prices.size();\n        if(len<2) return 0;\n        vector<int> sell(len);\n        vector<int> buy(len);\n        sell[0] = 0;\n        buy[0] = -prices[0];\n        for(int i=1;i<len;++i){\n            buy[i] = max(buy[i-1],-prices[i]);\n            sell[i] = max(sell[i-1],buy[i-1]+prices[i]);\n        }\n        return sell[len-1];\n    }   \n}\n\n\n本题也可以用更直接的方法解决，遍历一遍数组，在每一个位置 i 时，记录 i 位置之前所有价格中的最低价格，然后将当前的价格作为售出价格，查看当前收益是不是最大收益，一遍遍历完成后就可以得到最大收益。\n\nclass Solution {\npublic:\n    int maxProfit(vector<int>& prices) {\n        int sell = 0, buy = INT_MAX;\n        for(int i=0;i<prices.size();++i){\n            buy = min(buy,prices[i]);\n            sell = max(sell,prices[i]-buy);\n        }\n        return sell;\n    }\n};\n\n\n# 122 买卖股票的最佳时机 II\n\n给定一段时间内每天的股票价格，已知你只可以多次买卖一支股票，求最大的收益。\n\n输入一个一维整数数组，表示每天的股票价格；输出一个整数，表示最大的收益。\n\n> 输入：[7,1,5,3,6,4] 输出：5 解释：在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6 - 3 = 3 。\n\n解析：\n\n本题和上一题的区别在于可以多次买卖，也可以采用动态规划的思路来解决。\n\n设置状态：除了用两个数组分别表示股票持股与不持股情况，也可以使用一个二维数组dp[i][j]来表示，其中 i 表示交易的时间，j 表示交易状态即买入或卖出 ，0 表示买入状态、1表示卖出状态；dp[i][0]表示第 i 天持股时的现金数，dp[i][1] 表示第 i 天不持股时的现金数。值得注意的是dp[i][0]，表示的是第i天，买入股票的状态，并不是说一定要第i天买入股票，dp[i][1]亦同\n\n状态转移方程：本题的状态转移方程和上一题的唯一区别在于第 i 天持股的情况，如果第 i-1 天也持股那么保持一致，如果第 i-1 天不持股由于可以进行多次交易，那么就需要在已获得收益的基础上花费-prices[i]的现金买入股票即dp[i][0] = max(dp[i-1][0],dp[i-1][1] - prices[i])。\n\n初始情况：第 1 天持股dp[0][0] = -prices[0]，第 1 天不持股dp[0][1] = 0\n\nclass Solution {\npublic:\n    int maxProfit(vector<int>& prices) {\n        int len = prices.size();\n        if(len<2) return 0;\n        vector<vector<int>> dp(len,vector<int>(2));\n        dp[0][0] = -prices[0];\n        dp[0][1] = 0;\n        for(int i=1;i<len;++i){\n            dp[i][0] = max(dp[i-1][0],dp[i-1][1] - prices[i]);\n            dp[i][1] = max(dp[i-1][1],dp[i-1][0] + prices[i]);\n        }\n        return dp[len-1][1];\n    }\n};\n\n\n本题可以采用贪心策略，由于不限制交易次数，只要今天股价比昨天高，就交易。\n\nclass Solution {\npublic:\n    int maxProfit(vector<int>& prices) {\n        int sum = 0;\n        for(int i=1;i<prices.size();++i){\n            if(prices[i]>prices[i-1]){\n                sum+=(prices[i]-prices[i-1]);\n            }\n        }\n        return sum;\n    }\n};\n\n\n# 714 买卖股票的最佳时机含手续费\n\n给定一段时间内每天的股票价格，已知每次交易都需要扣除fee的手续费，且每次只能拥有一支股票，求最大的收益。\n\n输入一个一维整数数组，表示每天的股票价格；输出一个整数，表示最大的收益。\n\n> 输入：prices = [1, 3, 2, 8, 4, 9], fee = 2 输出：8 解释：能够达到的最大利润 ((8 - 1) - 2) + ((9 - 4) - 2) = 8\n\n解析：\n\n本题本质上和122可多次交易并没有什么差别，主要的问题是需要考虑过多次数的交易可能会产生大量手续费，直接导致总的收益不如交易次数较少的利润。\n\n设置状态：使用一个二维数组dp[i][j]来表示，其中 i 表示交易的时间，j 表示交易状态即买入或卖出 ，0 表示买入状态、1表示卖出状态；dp[i][0]表示第 i 天持股时的现金数，dp[i][1] 表示第 i 天不持股时的现金数。\n\n状态转移方程：本题与122题状态转移方程的主要区别在于第 i 天不持股的情况，如果第 i-1 天也不持股那么保持一致，如果第 i-1 天持股，那么就需要将其卖出产生buy[i-1]+prices[i]的收益，同时需要从收益中扣除fee的手续费。得到第 i 天不持股情况的状态转移方程dp[i][1] = max(dp[i-1][1],dp[i-1][0] + prices[i] - fee)\n\n初始情况：第 1 天持股dp[0][0] = -prices[0]，第 1 天不持股dp[0][1] = 0\n\nclass Solution {\npublic:\n    int maxProfit(vector<int>& prices, int fee) {\n        int len = prices.size();\n        if(len < 2) return 0;\n        vector<vector<int>> dp(len,vector<int>(2));\n        dp[0][0] = -prices[0];\n        dp[0][1] = 0;\n        for(int i=1;i<len;++i){\n            dp[i][0] = max(dp[i-1][0],dp[i-1][1] - prices[i]);\n            dp[i][1] = max(dp[i-1][1],dp[i-1][0] + prices[i] - fee);\n        }\n        return dp[len-1][1];\n    }\n};\n\n\n# 123 买卖股票的最佳时机 III\n\n给定一段时间内每天的股票价格，已知你最多可以进行两次买卖一支股票，求最大的收益。\n\n输入一个一维整数数组，表示每天的股票价格；输出一个整数，表示最大的收益。\n\n> 输入：prices = [3,3,5,0,0,3,1,4] 输出：6 解释：在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。\n\n解析：\n\n本题限制了交易次数最多为两次买卖，那么就要对这两次交易操作进行区分，所以一天的交易就不再是前两题中持股和不持股两种状态，而是要在此基础上区分第一次交易持股状态和第二次交易持股状态。\n\n设置状态：使用一个二维数组dp[i][j]来表示，其中 i 表示交易的时间，j 为0～3表示交易状态。例如dp[i][0]表示第一次买入状态、dp[i][1]表示第一次卖出状态、dp[i][2]表示第二次买入状态、dp[i][3]表示第二次卖出状态。\n\n状态转移方程：\n\n>  * 第一次交易的状态转移方程与121的单次交易一致，如果第一次第 i 天持股dp[i][0] = max(dp[i-1][0],- prices[i])，第 i-1 天不持股则需要花费-prices[i]的现金买入股票达成买入状态，如果第i-1天持股，则保持不变；\n>  * 如果第一次第 i 天不持股dp[i][1] = max(dp[i-1][1],dp[i-1][0] + prices[i])，第 i-1 天也不持股那么情况不变，如果第 i-1 天持股则需要将其卖出达成卖出状态并产生收益prices[i]。\n>  * 第二次交易的状态转移方程则与122的多次交易大致相同，如果第二次交易第 i 天持股dp[i][2] = max(dp[i-1][2],dp[i-1][1] - prices[i])，如果第 i-1 天也持股那么不进行操作，如果第 i-1 天不持股则需要在第一次交易完成的基础上花费prices[i]的现金买入股票达成持股或买入状态；\n>  * 如果第 i 天为卖不持股或卖出状态dp[i][3] = max(dp[i-1][3],dp[i-1][2] + prices[i])，如果第 i-1 天不持股第 i-1 天也不持股那么情况不变，如果第 i-1 天持股则需要将其卖出达成卖出状态并产生收益prices[i]。\n\n初始情况：第 1 天持股dp[0][0] = -prices[0], dp[0][1] = -prices[0]，第 1 天不持股dp[0][1] = 0, dp[0][3] = 0\n\nclass Solution {\npublic:\n    int maxProfit(vector<int>& prices) {\n        int len = prices.size();\n        if(len<2) return 0;\n        vector<vector<int>> dp(len,vector<int>(4));\n        dp[0][0] = -prices[0];\n        dp[0][2] = -prices[0];\n        dp[0][1] = 0;\n        dp[0][3] = 0;\n        for(int i=1;i<len;++i){\n            dp[i][0] = max(dp[i-1][0],-prices[i]);\n            dp[i][1] = max(dp[i-1][1],dp[i-1][0]+prices[i]);\n            dp[i][2] = max(dp[i-1][2],dp[i-1][1]-prices[i]);\n            dp[i][3] = max(dp[i-1][3],dp[i-1][2]+prices[i]);\n        }\n        return dp[len-1][3];\n    }\n};\n\n\n# 188 买卖股票的最佳时机 IV\n\n给定一段时间内每天的股票价格，已知你最多可以进行 k 次买卖一支股票，求最大的收益。\n\n输入一个一维整数数组，表示每天的股票价格；输出一个整数，表示最大的收益。\n\n> 输入：k = 2, prices = [3,2,6,5,0,3] 输出：7 解释：在第 2 天 (股票价格 = 2) 的时候买入，在第 3 天 (股票价格 = 6) 的时候卖出, 这笔交易所能获得利润 = 6-2 = 4 。随后，在第 5 天 (股票价格 = 0) 的时候买入，在第 6 天 (股票价格 = 3) 的时候卖出, 这笔交易所能获得利润 = 3-0 = 3 。\n\n解析：\n\n本题限制了交易次数最多为 k 次，那么就要根据 k 值大小区分不同情况，如果 k 大于数组长度那么就可以类比122题相当于可以不限次数交易；如果 k 小于数组长度那么就可以类比为123题有限次数交易求最大利润。\n\n设置状态：还是使用一个二维数组dp[i][j]来记录所剩余的现金，其中 i 表示交易的时间，j 为表示交易状态。类比123题本题的不同在于交易次数是变化的，交易状态难以表征，但是我们也可以总结出规律，可以使用偶数表示买入状态，奇数表示卖出状态。\n\n状态转移方程：本题的状态转移方程可以直接类比123题，区别在于次数是变化的。\n\n初始情况：即所有交易次数中第一天不持股时为0，持股则为-prices[i]\n\nclass Solution {\npublic:\n    int maxProfit(int k, vector<int>& prices) {\n        int len = prices.size();\n        // 临界情况 k <= 0 || k >= len\n        if(len < 2 || k <= 0) return 0;\n        if(len <= k){\n            return unlimitedTimes(prices);\n        }\n        // 一般情况 0 < k && k < len\n        vector<vector<int>> dp(len,vector<int>(2*k));\n        // 初始情况\n        for(int i=0;i<2*k;++i){\n            if(i&1){\n                dp[0][i] = 0;\n            }else{\n                dp[0][i] = -prices[0];\n            }\n        }\n        \n        for(int i=1;i<len;++i){\n            // 第一次买入状态\n            dp[i][0] = max(dp[i-1][0],-prices[i]);\n            for(int j=1;j<2*k;++j){\n                if(j&1){\n                    // 卖出状态转移方程\n                    dp[i][j] = max(dp[i-1][j],dp[i-1][j-1]+prices[i]);\n                }else{\n                    // 买入状态转移方程\n                    dp[i][j] = max(dp[i-1][j],dp[i-1][j-1]-prices[i]);\n                }\n            }\n        }\n        return dp[len-1][2*k-1];\n    }\n\n    // 可以进行多次交易的贪心实现\n    int unlimitedTimes(vector<int>& prices){\n        int len = prices.size();\n        int sum = 0;\n        for(int i=1;i<len;++i){\n            if(prices[i]>prices[i-1]){\n                sum += (prices[i] - prices[i-1]);\n            }\n        }\n        return sum;\n    }\n};\n\n\n# 309 最佳买卖股票时机含冷冻期\n\n给定一段时间内每天的股票价格，已知每次卖出之后必须冷却一天，且每次只能拥有一支股票，求最大的收益。\n\n输入一个一维整数数组，表示每天的股票价格；输出一个整数，表示最大的收益。\n\n> 输入: [1,2,3,0,2]\n> 输出: 3 \n> 解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]\n\n解析：\n\n我们可以使用状态机来解决这类复杂的状态转移问题，通过建立多个状态以及它们的转移方式，我们可以很容易地推导出各个状态的转移方程。如图所示，我们可以建立四个状态来表示带有冷却的股票交易，以及它们的之间的转移方式。\n\n其中分为买入状态Buy、卖出状态Sell、买入后状态S1和卖出后状态S2（状态的划分本人也没有搞清楚，仅仅凭个人理解进行划分，如有错误感谢指正）\n\n * 买入状态：即通过买入股票达到的买入状态\n * 买入后状态：买入大于等于两天后的持股状态，一直没操作，保持持股\n * 卖出状态：通过卖出持有的股票达到卖出状态，可以从买入状态直接操作卖出股票进入卖出状态，也可以在买入之后的持有多天后卖出股票进入卖出状态，这两个过程都会产生收益\n * 卖出后状态：度过了冷冻期，大于等于两天前就卖出了股票，一直没操作，保持不持股\n\n设置状态：使用一个二维数组dp[i][j]来表示，其中 i 表示交易的时间，j 为0～3表示交易状态。例如dp[i][0]表示买入状态、dp[i][1]表示不操作状态、dp[i][2]表示卖出状态、dp[i][3]表示卖出后状态。\n\n状态转移方程：\n\n>  * 买入状态dp[i][0] = dp[i-1][3] - prices[i]，卖出后状态下所持有的现金中花费prices[i]买入股票达到买入状态。\n>  * 买入后状态dp[i][1] = max(dp[i-1][0],dp[i-1][1])，可以通过买入状态到达，也可以不操作，保持原先持股状态。\n>  * 卖出状态dp[i][2] = max(dp[i-1][0],dp[i-1][1]) + prices[i]，可以买入后第二天直接卖出股票到达卖出状态，也可以持有多天后再卖出股票达到卖出状态。\n>  * 卖出后状态dp[i][3] = max(dp[i-1][2],dp[i-1][3])，可以通过卖出状态到达，也可以不操作，保持原先不持股状态。\n\n初始情况：第一天不持股时为dp[0][2] = 0, dp[0][3] = 0，持股则为dp[0][0] = -prices[i], dp[0][1] = -prices[i]\n\nclass Solution {\npublic:\n    int maxProfit(vector<int>& prices) {\n        int len = prices.size();\n        if(len < 2) return 0;\n        vector<vector<int>> dp(len,vector<int>(4));\n        dp[0][0] = dp[0][1] = -prices[0];\n        dp[0][2] = dp[0][3] = 0;\n        for(int i=1;i<len;++i){\n            dp[i][0] = dp[i-1][3] - prices[i];\n            dp[i][1] = max(dp[i-1][0],dp[i-1][1]);\n            dp[i][2] = max(dp[i-1][0],dp[i-1][1]) + prices[i];\n            dp[i][3] = max(dp[i-1][2],dp[i-1][3]);\n        }\n        return max(dp[len-1][2],dp[len-1][3]);\n    }\n};\n",normalizedContent:"# 07 股票交易问题\n\n股票交易类问题通常可以用动态规划来解决。对于稍微复杂一些的股票交易类问题，比如需要冷却时间或者交易费用，则可以用通过动态规划实现的状态机来解决。\n\n题目                  特点\n121 买卖股票的最佳时机       只能买卖一次\n122 买卖股票的最佳时机 ii    可以买卖多次\n714 买卖股票的最佳时机含手续费   可以买卖多次，每次都有手续费\n123 买卖股票的最佳时机 iii   最多买卖两次\n188 买卖股票的最佳时机 iv    最多买卖 k 次\n309 最佳买卖股票时机含冷冻期    可以买卖多次，但是卖出有一天冷冻期\n\n# 121 买卖股票的最佳时机\n\n给定一段时间内每天的股票价格，已知你只可以买卖各一次，求最大的收益。\n\n输入一个一维整数数组，表示每天的股票价格；输出一个整数，表示最大的收益。\n\n> 输入：[7,1,5,3,6,4] 输出：5 解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5\n\n解析：\n\n求最大利润本质是也是一个优化问题，所以可以采用动态规划的思路解决。\n\n设置状态：用两个动态规划数组buy[i] 表示第 i 天持股时的现金数，sell[i]表示第 i 天不持股时的现金数\n\n状态转移方程：第 i 天持股 buy[i] = max(buy[i-1],-prices[i])，如果第 i-1 天不持股则花费-prices[i]的现金买入股票，如果第i-1天持股，则保持不变；第 i 天不持股 sell[i] = max(sell[i-1],buy[i-1]+prices[i])，如果第 i-1 天也不持股那么情况不变，如果第 i-1 天持股则需要将其卖出产生收益buy[i-1]+prices[i]。\n\n初始情况：第 1 天不持股sell[0] = 0；第 1 天持股buy[0] = -prices[0]\n\nclass solution {\npublic:\n    int maxprofit(vector<int>& prices) {\n        int len = prices.size();\n        if(len<2) return 0;\n        vector<int> sell(len);\n        vector<int> buy(len);\n        sell[0] = 0;\n        buy[0] = -prices[0];\n        for(int i=1;i<len;++i){\n            buy[i] = max(buy[i-1],-prices[i]);\n            sell[i] = max(sell[i-1],buy[i-1]+prices[i]);\n        }\n        return sell[len-1];\n    }   \n}\n\n\n本题也可以用更直接的方法解决，遍历一遍数组，在每一个位置 i 时，记录 i 位置之前所有价格中的最低价格，然后将当前的价格作为售出价格，查看当前收益是不是最大收益，一遍遍历完成后就可以得到最大收益。\n\nclass solution {\npublic:\n    int maxprofit(vector<int>& prices) {\n        int sell = 0, buy = int_max;\n        for(int i=0;i<prices.size();++i){\n            buy = min(buy,prices[i]);\n            sell = max(sell,prices[i]-buy);\n        }\n        return sell;\n    }\n};\n\n\n# 122 买卖股票的最佳时机 ii\n\n给定一段时间内每天的股票价格，已知你只可以多次买卖一支股票，求最大的收益。\n\n输入一个一维整数数组，表示每天的股票价格；输出一个整数，表示最大的收益。\n\n> 输入：[7,1,5,3,6,4] 输出：5 解释：在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6 - 3 = 3 。\n\n解析：\n\n本题和上一题的区别在于可以多次买卖，也可以采用动态规划的思路来解决。\n\n设置状态：除了用两个数组分别表示股票持股与不持股情况，也可以使用一个二维数组dp[i][j]来表示，其中 i 表示交易的时间，j 表示交易状态即买入或卖出 ，0 表示买入状态、1表示卖出状态；dp[i][0]表示第 i 天持股时的现金数，dp[i][1] 表示第 i 天不持股时的现金数。值得注意的是dp[i][0]，表示的是第i天，买入股票的状态，并不是说一定要第i天买入股票，dp[i][1]亦同\n\n状态转移方程：本题的状态转移方程和上一题的唯一区别在于第 i 天持股的情况，如果第 i-1 天也持股那么保持一致，如果第 i-1 天不持股由于可以进行多次交易，那么就需要在已获得收益的基础上花费-prices[i]的现金买入股票即dp[i][0] = max(dp[i-1][0],dp[i-1][1] - prices[i])。\n\n初始情况：第 1 天持股dp[0][0] = -prices[0]，第 1 天不持股dp[0][1] = 0\n\nclass solution {\npublic:\n    int maxprofit(vector<int>& prices) {\n        int len = prices.size();\n        if(len<2) return 0;\n        vector<vector<int>> dp(len,vector<int>(2));\n        dp[0][0] = -prices[0];\n        dp[0][1] = 0;\n        for(int i=1;i<len;++i){\n            dp[i][0] = max(dp[i-1][0],dp[i-1][1] - prices[i]);\n            dp[i][1] = max(dp[i-1][1],dp[i-1][0] + prices[i]);\n        }\n        return dp[len-1][1];\n    }\n};\n\n\n本题可以采用贪心策略，由于不限制交易次数，只要今天股价比昨天高，就交易。\n\nclass solution {\npublic:\n    int maxprofit(vector<int>& prices) {\n        int sum = 0;\n        for(int i=1;i<prices.size();++i){\n            if(prices[i]>prices[i-1]){\n                sum+=(prices[i]-prices[i-1]);\n            }\n        }\n        return sum;\n    }\n};\n\n\n# 714 买卖股票的最佳时机含手续费\n\n给定一段时间内每天的股票价格，已知每次交易都需要扣除fee的手续费，且每次只能拥有一支股票，求最大的收益。\n\n输入一个一维整数数组，表示每天的股票价格；输出一个整数，表示最大的收益。\n\n> 输入：prices = [1, 3, 2, 8, 4, 9], fee = 2 输出：8 解释：能够达到的最大利润 ((8 - 1) - 2) + ((9 - 4) - 2) = 8\n\n解析：\n\n本题本质上和122可多次交易并没有什么差别，主要的问题是需要考虑过多次数的交易可能会产生大量手续费，直接导致总的收益不如交易次数较少的利润。\n\n设置状态：使用一个二维数组dp[i][j]来表示，其中 i 表示交易的时间，j 表示交易状态即买入或卖出 ，0 表示买入状态、1表示卖出状态；dp[i][0]表示第 i 天持股时的现金数，dp[i][1] 表示第 i 天不持股时的现金数。\n\n状态转移方程：本题与122题状态转移方程的主要区别在于第 i 天不持股的情况，如果第 i-1 天也不持股那么保持一致，如果第 i-1 天持股，那么就需要将其卖出产生buy[i-1]+prices[i]的收益，同时需要从收益中扣除fee的手续费。得到第 i 天不持股情况的状态转移方程dp[i][1] = max(dp[i-1][1],dp[i-1][0] + prices[i] - fee)\n\n初始情况：第 1 天持股dp[0][0] = -prices[0]，第 1 天不持股dp[0][1] = 0\n\nclass solution {\npublic:\n    int maxprofit(vector<int>& prices, int fee) {\n        int len = prices.size();\n        if(len < 2) return 0;\n        vector<vector<int>> dp(len,vector<int>(2));\n        dp[0][0] = -prices[0];\n        dp[0][1] = 0;\n        for(int i=1;i<len;++i){\n            dp[i][0] = max(dp[i-1][0],dp[i-1][1] - prices[i]);\n            dp[i][1] = max(dp[i-1][1],dp[i-1][0] + prices[i] - fee);\n        }\n        return dp[len-1][1];\n    }\n};\n\n\n# 123 买卖股票的最佳时机 iii\n\n给定一段时间内每天的股票价格，已知你最多可以进行两次买卖一支股票，求最大的收益。\n\n输入一个一维整数数组，表示每天的股票价格；输出一个整数，表示最大的收益。\n\n> 输入：prices = [3,3,5,0,0,3,1,4] 输出：6 解释：在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。\n\n解析：\n\n本题限制了交易次数最多为两次买卖，那么就要对这两次交易操作进行区分，所以一天的交易就不再是前两题中持股和不持股两种状态，而是要在此基础上区分第一次交易持股状态和第二次交易持股状态。\n\n设置状态：使用一个二维数组dp[i][j]来表示，其中 i 表示交易的时间，j 为0～3表示交易状态。例如dp[i][0]表示第一次买入状态、dp[i][1]表示第一次卖出状态、dp[i][2]表示第二次买入状态、dp[i][3]表示第二次卖出状态。\n\n状态转移方程：\n\n>  * 第一次交易的状态转移方程与121的单次交易一致，如果第一次第 i 天持股dp[i][0] = max(dp[i-1][0],- prices[i])，第 i-1 天不持股则需要花费-prices[i]的现金买入股票达成买入状态，如果第i-1天持股，则保持不变；\n>  * 如果第一次第 i 天不持股dp[i][1] = max(dp[i-1][1],dp[i-1][0] + prices[i])，第 i-1 天也不持股那么情况不变，如果第 i-1 天持股则需要将其卖出达成卖出状态并产生收益prices[i]。\n>  * 第二次交易的状态转移方程则与122的多次交易大致相同，如果第二次交易第 i 天持股dp[i][2] = max(dp[i-1][2],dp[i-1][1] - prices[i])，如果第 i-1 天也持股那么不进行操作，如果第 i-1 天不持股则需要在第一次交易完成的基础上花费prices[i]的现金买入股票达成持股或买入状态；\n>  * 如果第 i 天为卖不持股或卖出状态dp[i][3] = max(dp[i-1][3],dp[i-1][2] + prices[i])，如果第 i-1 天不持股第 i-1 天也不持股那么情况不变，如果第 i-1 天持股则需要将其卖出达成卖出状态并产生收益prices[i]。\n\n初始情况：第 1 天持股dp[0][0] = -prices[0], dp[0][1] = -prices[0]，第 1 天不持股dp[0][1] = 0, dp[0][3] = 0\n\nclass solution {\npublic:\n    int maxprofit(vector<int>& prices) {\n        int len = prices.size();\n        if(len<2) return 0;\n        vector<vector<int>> dp(len,vector<int>(4));\n        dp[0][0] = -prices[0];\n        dp[0][2] = -prices[0];\n        dp[0][1] = 0;\n        dp[0][3] = 0;\n        for(int i=1;i<len;++i){\n            dp[i][0] = max(dp[i-1][0],-prices[i]);\n            dp[i][1] = max(dp[i-1][1],dp[i-1][0]+prices[i]);\n            dp[i][2] = max(dp[i-1][2],dp[i-1][1]-prices[i]);\n            dp[i][3] = max(dp[i-1][3],dp[i-1][2]+prices[i]);\n        }\n        return dp[len-1][3];\n    }\n};\n\n\n# 188 买卖股票的最佳时机 iv\n\n给定一段时间内每天的股票价格，已知你最多可以进行 k 次买卖一支股票，求最大的收益。\n\n输入一个一维整数数组，表示每天的股票价格；输出一个整数，表示最大的收益。\n\n> 输入：k = 2, prices = [3,2,6,5,0,3] 输出：7 解释：在第 2 天 (股票价格 = 2) 的时候买入，在第 3 天 (股票价格 = 6) 的时候卖出, 这笔交易所能获得利润 = 6-2 = 4 。随后，在第 5 天 (股票价格 = 0) 的时候买入，在第 6 天 (股票价格 = 3) 的时候卖出, 这笔交易所能获得利润 = 3-0 = 3 。\n\n解析：\n\n本题限制了交易次数最多为 k 次，那么就要根据 k 值大小区分不同情况，如果 k 大于数组长度那么就可以类比122题相当于可以不限次数交易；如果 k 小于数组长度那么就可以类比为123题有限次数交易求最大利润。\n\n设置状态：还是使用一个二维数组dp[i][j]来记录所剩余的现金，其中 i 表示交易的时间，j 为表示交易状态。类比123题本题的不同在于交易次数是变化的，交易状态难以表征，但是我们也可以总结出规律，可以使用偶数表示买入状态，奇数表示卖出状态。\n\n状态转移方程：本题的状态转移方程可以直接类比123题，区别在于次数是变化的。\n\n初始情况：即所有交易次数中第一天不持股时为0，持股则为-prices[i]\n\nclass solution {\npublic:\n    int maxprofit(int k, vector<int>& prices) {\n        int len = prices.size();\n        // 临界情况 k <= 0 || k >= len\n        if(len < 2 || k <= 0) return 0;\n        if(len <= k){\n            return unlimitedtimes(prices);\n        }\n        // 一般情况 0 < k && k < len\n        vector<vector<int>> dp(len,vector<int>(2*k));\n        // 初始情况\n        for(int i=0;i<2*k;++i){\n            if(i&1){\n                dp[0][i] = 0;\n            }else{\n                dp[0][i] = -prices[0];\n            }\n        }\n        \n        for(int i=1;i<len;++i){\n            // 第一次买入状态\n            dp[i][0] = max(dp[i-1][0],-prices[i]);\n            for(int j=1;j<2*k;++j){\n                if(j&1){\n                    // 卖出状态转移方程\n                    dp[i][j] = max(dp[i-1][j],dp[i-1][j-1]+prices[i]);\n                }else{\n                    // 买入状态转移方程\n                    dp[i][j] = max(dp[i-1][j],dp[i-1][j-1]-prices[i]);\n                }\n            }\n        }\n        return dp[len-1][2*k-1];\n    }\n\n    // 可以进行多次交易的贪心实现\n    int unlimitedtimes(vector<int>& prices){\n        int len = prices.size();\n        int sum = 0;\n        for(int i=1;i<len;++i){\n            if(prices[i]>prices[i-1]){\n                sum += (prices[i] - prices[i-1]);\n            }\n        }\n        return sum;\n    }\n};\n\n\n# 309 最佳买卖股票时机含冷冻期\n\n给定一段时间内每天的股票价格，已知每次卖出之后必须冷却一天，且每次只能拥有一支股票，求最大的收益。\n\n输入一个一维整数数组，表示每天的股票价格；输出一个整数，表示最大的收益。\n\n> 输入: [1,2,3,0,2]\n> 输出: 3 \n> 解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]\n\n解析：\n\n我们可以使用状态机来解决这类复杂的状态转移问题，通过建立多个状态以及它们的转移方式，我们可以很容易地推导出各个状态的转移方程。如图所示，我们可以建立四个状态来表示带有冷却的股票交易，以及它们的之间的转移方式。\n\n其中分为买入状态buy、卖出状态sell、买入后状态s1和卖出后状态s2（状态的划分本人也没有搞清楚，仅仅凭个人理解进行划分，如有错误感谢指正）\n\n * 买入状态：即通过买入股票达到的买入状态\n * 买入后状态：买入大于等于两天后的持股状态，一直没操作，保持持股\n * 卖出状态：通过卖出持有的股票达到卖出状态，可以从买入状态直接操作卖出股票进入卖出状态，也可以在买入之后的持有多天后卖出股票进入卖出状态，这两个过程都会产生收益\n * 卖出后状态：度过了冷冻期，大于等于两天前就卖出了股票，一直没操作，保持不持股\n\n设置状态：使用一个二维数组dp[i][j]来表示，其中 i 表示交易的时间，j 为0～3表示交易状态。例如dp[i][0]表示买入状态、dp[i][1]表示不操作状态、dp[i][2]表示卖出状态、dp[i][3]表示卖出后状态。\n\n状态转移方程：\n\n>  * 买入状态dp[i][0] = dp[i-1][3] - prices[i]，卖出后状态下所持有的现金中花费prices[i]买入股票达到买入状态。\n>  * 买入后状态dp[i][1] = max(dp[i-1][0],dp[i-1][1])，可以通过买入状态到达，也可以不操作，保持原先持股状态。\n>  * 卖出状态dp[i][2] = max(dp[i-1][0],dp[i-1][1]) + prices[i]，可以买入后第二天直接卖出股票到达卖出状态，也可以持有多天后再卖出股票达到卖出状态。\n>  * 卖出后状态dp[i][3] = max(dp[i-1][2],dp[i-1][3])，可以通过卖出状态到达，也可以不操作，保持原先不持股状态。\n\n初始情况：第一天不持股时为dp[0][2] = 0, dp[0][3] = 0，持股则为dp[0][0] = -prices[i], dp[0][1] = -prices[i]\n\nclass solution {\npublic:\n    int maxprofit(vector<int>& prices) {\n        int len = prices.size();\n        if(len < 2) return 0;\n        vector<vector<int>> dp(len,vector<int>(4));\n        dp[0][0] = dp[0][1] = -prices[0];\n        dp[0][2] = dp[0][3] = 0;\n        for(int i=1;i<len;++i){\n            dp[i][0] = dp[i-1][3] - prices[i];\n            dp[i][1] = max(dp[i-1][0],dp[i-1][1]);\n            dp[i][2] = max(dp[i-1][0],dp[i-1][1]) + prices[i];\n            dp[i][3] = max(dp[i-1][2],dp[i-1][3]);\n        }\n        return max(dp[len-1][2],dp[len-1][3]);\n    }\n};\n",charsets:{cjk:!0},lastUpdated:"2023/11/19, 12:55:48",lastUpdatedTimestamp:1700369748e3},{title:"DP",frontmatter:{title:"DP",date:"2023-03-24T18:39:49.000Z",permalink:"/pages/78cc80/"},regularPath:"/03.LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/03.%E8%BF%9B%E9%98%B6%E7%AE%97%E6%B3%95/03.%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/DP.html",relativePath:"03.LeetCode刷题笔记/03.进阶算法/03.动态规划/DP.md",key:"v-788365e1",path:"/pages/78cc80/",headers:[{level:2,title:"LeetCode刷题笔记 动态规划",slug:"leetcode刷题笔记-动态规划",normalizedTitle:"leetcode刷题笔记 动态规划",charIndex:2},{level:3,title:"01 一维动态规划",slug:"_01-一维动态规划",normalizedTitle:"01 一维动态规划",charIndex:24},{level:4,title:"70 爬楼梯",slug:"_70-爬楼梯",normalizedTitle:"70 爬楼梯",charIndex:37},{level:4,title:"198 打家劫舍",slug:"_198-打家劫舍",normalizedTitle:"198 打家劫舍",charIndex:645},{level:4,title:"213 打家劫舍 II",slug:"_213-打家劫舍-ii",normalizedTitle:"213 打家劫舍 ii",charIndex:1478},{level:4,title:"413 等差数列划分",slug:"_413-等差数列划分",normalizedTitle:"413 等差数列划分",charIndex:3262},{level:4,title:"53 最大子序和",slug:"_53-最大子序和",normalizedTitle:"53 最大子序和",charIndex:4015},{level:3,title:"02 二维动态规划",slug:"_02-二维动态规划",normalizedTitle:"02 二维动态规划",charIndex:4819},{level:4,title:"64 最小路径和",slug:"_64-最小路径和",normalizedTitle:"64 最小路径和",charIndex:4832},{level:4,title:"542 01矩阵",slug:"_542-01矩阵",normalizedTitle:"542 01矩阵",charIndex:6252},{level:4,title:"221 最大正方形",slug:"_221-最大正方形",normalizedTitle:"221 最大正方形",charIndex:8132},{level:3,title:"03 分割型动态规划",slug:"_03-分割型动态规划",normalizedTitle:"03 分割型动态规划",charIndex:9439},{level:4,title:"279 完全平方数",slug:"_279-完全平方数",normalizedTitle:"279 完全平方数",charIndex:9501},{level:4,title:"343 整数拆分",slug:"_343-整数拆分",normalizedTitle:"343 整数拆分",charIndex:10143},{level:4,title:"91 解码方法",slug:"_91-解码方法",normalizedTitle:"91 解码方法",charIndex:10980},{level:4,title:"139 单词拆分",slug:"_139-单词拆分",normalizedTitle:"139 单词拆分",charIndex:12058},{level:3,title:"04 子序列问题",slug:"_04-子序列问题",normalizedTitle:"04 子序列问题",charIndex:13201},{level:4,title:"300 最长递增子序列",slug:"_300-最长递增子序列",normalizedTitle:"300 最长递增子序列",charIndex:13397},{level:4,title:"646 最长数对链",slug:"_646-最长数对链",normalizedTitle:"646 最长数对链",charIndex:14359},{level:4,title:"376 摆动序列",slug:"_376-摆动序列",normalizedTitle:"376 摆动序列",charIndex:15218},{level:4,title:"1143 最长公共子序列",slug:"_1143-最长公共子序列",normalizedTitle:"1143 最长公共子序列",charIndex:16896},{level:4,title:"583 两个字符串的删除操作",slug:"_583-两个字符串的删除操作",normalizedTitle:"583 两个字符串的删除操作",charIndex:18056},{level:3,title:"05 背包问题",slug:"_05-背包问题",normalizedTitle:"05 背包问题",charIndex:18803},{level:4,title:"416 分割等和子集",slug:"_416-分割等和子集",normalizedTitle:"416 分割等和子集",charIndex:20306},{level:4,title:"494 目标和",slug:"_494-目标和",normalizedTitle:"494 目标和",charIndex:22441},{level:4,title:"474 一和零",slug:"_474-一和零",normalizedTitle:"474 一和零",charIndex:24048},{level:4,title:"322 零钱兑换",slug:"_322-零钱兑换",normalizedTitle:"322 零钱兑换",charIndex:25821},{level:3,title:"06 字符串编辑问题",slug:"_06-字符串编辑问题",normalizedTitle:"06 字符串编辑问题",charIndex:26535},{level:4,title:"72 编辑距离",slug:"_72-编辑距离",normalizedTitle:"72 编辑距离",charIndex:26549},{level:4,title:"650 只有两个键的键盘",slug:"_650-只有两个键的键盘",normalizedTitle:"650 只有两个键的键盘",charIndex:27922},{level:4,title:"10 正则表达式匹配",slug:"_10-正则表达式匹配",normalizedTitle:"10 正则表达式匹配",charIndex:28739},{level:3,title:"07 股票交易问题",slug:"_07-股票交易问题",normalizedTitle:"07 股票交易问题",charIndex:30652},{level:4,title:"121 买卖股票的最佳时机",slug:"_121-买卖股票的最佳时机",normalizedTitle:"121 买卖股票的最佳时机",charIndex:30760},{level:4,title:"122 买卖股票的最佳时机 II",slug:"_122-买卖股票的最佳时机-ii",normalizedTitle:"122 买卖股票的最佳时机 ii",charIndex:30787},{level:4,title:"714 买卖股票的最佳时机含手续费",slug:"_714-买卖股票的最佳时机含手续费",normalizedTitle:"714 买卖股票的最佳时机含手续费",charIndex:30814},{level:4,title:"123 买卖股票的最佳时机 III",slug:"_123-买卖股票的最佳时机-iii",normalizedTitle:"123 买卖股票的最佳时机 iii",charIndex:30849},{level:4,title:"188 买卖股票的最佳时机 IV",slug:"_188-买卖股票的最佳时机-iv",normalizedTitle:"188 买卖股票的最佳时机 iv",charIndex:30876},{level:4,title:"309 最佳买卖股票时机含冷冻期",slug:"_309-最佳买卖股票时机含冷冻期",normalizedTitle:"309 最佳买卖股票时机含冷冻期",charIndex:30905}],headersStr:"LeetCode刷题笔记 动态规划 01 一维动态规划 70 爬楼梯 198 打家劫舍 213 打家劫舍 II 413 等差数列划分 53 最大子序和 02 二维动态规划 64 最小路径和 542 01矩阵 221 最大正方形 03 分割型动态规划 279 完全平方数 343 整数拆分 91 解码方法 139 单词拆分 04 子序列问题 300 最长递增子序列 646 最长数对链 376 摆动序列 1143 最长公共子序列 583 两个字符串的删除操作 05 背包问题 416 分割等和子集 494 目标和 474 一和零 322 零钱兑换 06 字符串编辑问题 72 编辑距离 650 只有两个键的键盘 10 正则表达式匹配 07 股票交易问题 121 买卖股票的最佳时机 122 买卖股票的最佳时机 II 714 买卖股票的最佳时机含手续费 123 买卖股票的最佳时机 III 188 买卖股票的最佳时机 IV 309 最佳买卖股票时机含冷冻期",content:'# LeetCode刷题笔记 动态规划\n\n\n# 01 一维动态规划\n\n# 70 爬楼梯\n\n给定 n 节台阶，每次可以走一步或走两步，求一共有多少种方式可以走完这些台阶。\n\n输入是一个数字，表示台阶数量；输出是爬台阶的总方式。\n\n> 输入： 2\n> 输出： 2\n> 解释： 有两种方法可以爬到楼顶。\n> 1.  1 阶 + 1 阶\n> 2.  2 阶\n\n解析:\n\n这是十分经典的斐波那契数列题。\n\n设置状态：定义一个数组 dp，dp[i] 表示走到第 i 阶的方法数\n\n状态转移方程：因为我们每次可以走一步或者两步，所以第 i 阶可以从第 i-1 或 i-2 阶到达。换句话说，走到第 i 阶的方法数即为走到第 i-1 阶的方法数加上走到第 i-2 阶的方法数。这样我们就得到了状态转移方程dp[i] = dp[i-1] + dp[i-2]。\n\n初始情况：当阶数小于等于1时，方法数为1\n\nclass Solution {\npublic:\n    int climbStairs(int n) {\n        if(n<2) return n;\n        vector<int> dp(n+1);\n        dp[0] = dp[1] = 1;\n        for(int i=2;i<=n;++i){\n            dp[i] = dp[i-1] + dp[i-2];\n        }\n        return dp[n];\n    }\n};\n\n\n# 198 打家劫舍\n\n假如你是一个劫匪，并且决定抢劫一条街上的房子，每个房子内的钱财数量各不相同。如果你抢了两栋相邻的房子，则会触发警报机关。求在不触发机关的情况下最多可以抢劫多少钱。\n\n输入是一个一维数组，表示每个房子的钱财数量；输出是劫匪可以最多抢劫的钱财数量。\n\n> 输入：[1,2,3,1] 输出：4 解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。偷窃到的最高金额 = 1 + 3 = 4 。\n\n解析:\n\n设置状态：定义一个数组 dp，dp[i] 表示抢劫到第 i 个房子时，可以抢劫的最大数量。 状态转移方程：我们考虑 dp[i]，此时可以抢劫的最大数量有两种可能，一种是我们选择不抢劫这个房子，此时累计的金额即为dp[i-1]；另一种是我们选择抢劫这个房子，那么此前累计的最大金额只能是 dp[i-2]，因为我们不能够抢劫第 i-1 个房子，否则会触发警报机关。因此本题的状态转移方程为 dp[i] = max(dp[i-1],nums[i-1] + dp[i-2])。\n\n初始情况：第一个房子的抢劫最大数量 dp[1] = nums[0]\n\nclass Solution {\npublic:\n    int rob(vector<int>& nums) {\n        if(nums.empty()){\n            return 0;\n        }\n        int len = nums.size();\n        vector<int> dp(len+1,0);\n        dp[1] = nums[0];\n        for(int i=2;i<=len;++i){\n            dp[i] = max(dp[i-1],dp[i-2]+nums[i-1]);\n        }\n        return dp[len];\n    }\n};\n\n\n# 213 打家劫舍 II\n\n假如你是一个劫匪，并且决定抢劫一条街上的房子，这条街所有的房屋都 围成一圈 ，这意味着第一个房屋和最后一个房屋是紧挨着的。如果你抢了两栋相邻的房子，则会触发警报机关。求在不触发机关的情况下最多可以抢劫多少钱。\n\n输入是一个一维数组，表示每个房子的钱财数量；输出是劫匪可以最多抢劫的钱财数量。\n\n> 输入：nums = [2,3,2]\n> 输出：3\n> 解释：你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。\n\n解析:\n\n本题与198题的主要区别是输入的一维数组是一个环形数组，所以要分别考虑抢第一个房子和不抢第一个房子的情况。抢第一个房子，那么就不能抢最后一个房子，则可抢的范围为nums[0]~nums[len-2]；不抢第一个房子，那么就可以抢最后一个房子，则可抢的范围为nums[1]~nums[len-1]。\n\n基于上述两种情况使用与198题相同的动态规划方法解决本问题\n\nclass Solution {\npublic:\n    int rob(vector<int>& nums) {\n        int len = nums.size();\n        if(len < 1) return 0;\n        vector<int> nums1,nums2;\n        for(int i=0;i<len;++i){\n            if(i==0){\n                nums1.push_back(nums[i]);\n            }else if(i==len-1){\n                nums2.push_back(nums[i]);\n            }else{\n                nums1.push_back(nums[i]);\n                nums2.push_back(nums[i]);\n            }\n        }\n        return max(robRange(nums1),robRange(nums2));\n    }\n\n    int robRange(vector<int>& nums){\n        int len = nums.size();\n        if(len < 1) return 0;\n        vector<int> dp(len+1,0);\n        dp[1] = nums[0];\n        for(int i=2;i<=len;++i){\n            dp[i] = max(dp[i-1],dp[i-2]+nums[i-1]);\n        }\n        return dp[len];\n    }\n};\n\n\n上述解法较为直观，先分情况在计算最大抢劫价值；也可以通过划分区间的方式划分情况如下\n\nclass Solution {\npublic:\n    int rob(vector<int>& nums) {\n        int len = nums.size();\n        if(len == 1) return nums[0];\n        return max(robRange(nums,0,len-1),robRange(nums,1,len));\n    }\n\n    int robRange(vector<int>& nums, int start, int end){\n        int len = end - start;\n        if(len < 1) return 0;\n        vector<int> dp(len+1,0);\n        dp[1] = nums[start];\n        for(int i=2;i<=len;++i){\n            dp[i] = max(dp[i-1],dp[i-2]+nums[i+start-1]);\n        }\n        return dp[len];\n    }\n};\n\n\n# 413 等差数列划分\n\n给定一个数组，求这个数组中连续且等差的子数组一共有多少个。\n\n输入是一个一维数组，输出是满足等差条件的连续字数组个数。\n\n> 输入：nums = [1,2,3,4]\n> 输出：3\n> 解释：nums 中有三个子等差数组：[1, 2, 3]、[2, 3, 4] 和 [1,2,3,4] 自身。\n\n解析:\n\n这道题略微特殊，因为要求是等差数列，可以很自然的想到子数组必定满足 num[i] - num[i-1] = num[i-1] - num[i-2]。然而由于我们对于 dp 数组的定义通常为以 i 结尾的，满足某些条件的子数组数量，而等差子数组可以在任意一个位置终结，因此此题在最后需要对 dp 数组求和。\n\nclass Solution {\npublic:\n    int numberOfArithmeticSlices(vector<int>& nums) {\n        int len = nums.size();\n        int res = 0;\n        if(len < 3){\n            return res;\n        }\n        vector<int> dp(len,0);\n        for(int i = 2;i<len;++i){\n            if(nums[i]-nums[i-1] == nums[i-1] - nums[i-2]){\n                dp[i] = dp[i-1] + 1;\n                res += dp[i];\n            }\n        }\n        return res;\n    }\n};\n\n\n# 53 最大子序和\n\n给定一个数组，找出一个具有最大和的连续子数组，并返回其最大和。\n\n输入一个数组，输出一个整数，为连续子数组的最大和\n\n> 输入：nums = [-2,1,-3,4,-1,2,1,-5,4]\n> 输出：6\n> 解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。\n\n解析:\n\n设置状态：使用一维数组dp[i]表示以第 i 个元素结尾的子序列的最大和\n\n状态转移方程：我们考虑 dp[i]，此时构成最大和的子序列有两种可能，一种是我们选择不将第 i 个元素加入子序列，因为要构成连续的子序列，所以自己单独构成新的子序列此时最大和即为自身nums[i-1]；另一种是我们选择将第 i 个元素加入子序列，那么构成子序列的最大和为dp[i-1]+nums[i-1]。所以本题的状态转移方程为 dp[i] = max(nums[i-1],nums[i-1] + dp[i-1])。\n\n初始情况：只有一个元素，dp[1]=nums[0]\n\nclass Solution {\npublic:\n    int maxSubArray(vector<int>& nums) {\n        int len = nums.size();\n        if(len < 1) return 0;\n        vector<int> dp(len+1,0);\n        dp[1] = nums[0];\n        int ans = nums[0];\n        for(int i=2;i<=len;++i){\n            dp[i] = max(nums[i-1],dp[i-1]+nums[i-1]);\n            ans = max(ans,dp[i]);\n        }\n        return ans;\n    }\n};\n\n\n\n# 02 二维动态规划\n\n# 64 最小路径和\n\n给定一个 m × n 大小的非负整数矩阵，求从左上角开始到右下角结束的、经过的数字的和最小的路径。每次只能向右或者向下移动。\n\n输入是一个二维数组，输出是最优路径的数字和。\n\n> 输入：grid = [[1,3,1],[1,5,1],[4,2,1]]\n> 输出：7\n> 解释：因为路径 1→3→1→1→1 的总和最小。\n\n解析:\n\n设置状态：使用一个二维的 dp 数组，其中 dp[i][j] 表示从左上角开始到 (i, j) 位置的最 优路径的数字和。\n\n状态转移方程：因为每次只能向下或者向右移动，我们可以很容易得到状态转移方程 dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]，其中 grid 表示原数组。\n\n边界条件：只有一格dp[0][0] = grid[0][0]；第一行的元素只能由前一个元素向右移动得到即dp[0][j] = dp[0][j-1]+grid[0][j]；第一列的元素只能由上一个元素向下移动得到即dp[i][0] = dp[i-1][0]+grid[i][0]\n\nclass Solution {\npublic:\n    int minPathSum_old(vector<vector<int>>& grid) {\n        int ans = 0;\n        if(grid.empty()||grid[0].empty()){\n            return ans;\n        }\n        int m = grid.size(), n = grid[0].size();\n        vector<vector<int>> dp(m,vector<int>(n));\n        for(int i=0;i<m;++i){\n            for(int j=0;j<n;++j){\n                if(i==0&&j==0){\n                    dp[i][j] = grid[0][0];\n                }else if(i==0){\n                    dp[i][j] = dp[i][j-1] + grid[i][j];\n                }else if(j==0){\n                    dp[i][j] = dp[i-1][j] + grid[i][j];\n                }else{\n                     dp[i][j] = min(dp[i][j-1],dp[i-1][j]) + grid[i][j];\n                }\n            }\n        }\n        return dp[m-1][n-1];\n    }\n};\n\n\n因为 dp 矩阵的每一个值只和左边和上面的值相关，我们可以使用空间压缩将 dp 数组压缩为一维。对于第 i 行，在遍历到第 j 列的时候，因为第 j-1 列已经更新过了，所以 dp[j-1] 代表 dp[i][j-1]的值；而 dp[j] 待更新，当前存储的值是在第 i-1 行的时候计算的，所以代表 dp[i-1][j]的值。\n\n# 542 01矩阵\n\n给定一个由 0 和 1 组成的二维矩阵，求每个位置到最近的 0 的距离。\n\n输入是一个二维 0-1 数组，输出是一个同样大小的非负整数数组，表示每个位置到最近的 0的距离。\n\n> 输入：mat = [[0,0,0],[0,1,0],[1,1,1]]\n> 输出：[[0,0,0],[0,1,0],[1,2,1]]\n\n解析:\n\n本题涉及到四个方向上的最近搜索，如果使用递归的方法进行搜索在二维数组中将造成极大的时间复杂度。使用动态规划进行存储化，可以使得递归搜索不会重复遍历相同位置；另一种更简单的方法是，从左上到右下进行一次动态搜索，再从右下到左上进行一次动态搜索，这样两次动态搜索即可完成四个方向上的查找。\n\n设置状态：使用一个二维数组 dp[i][j] 表示位置为 (i,j) 的元素与0的距离\n\n状态转移方程：值为0的元素到0的距离为0；从左上到右下进行动态搜索，那么dp[i][j] 可以从dp[i-1][j]、dp[i][j-1]和自身三个状态中转移得到dp[i][j]=min(dp[i][j],min(dp[i-1][j],dp[i][j-1])) + 1； 从右下到左上进行动态搜索的状态转移方程可以类比得到dp[i][j]=min(dp[i][j],min(dp[i+1][j],dp[i][j+1])) + 1\n\n边界情况：当d[i][j]处于矩阵的边界上时其状态转移受到限制，例如，从左上到右下进行动态搜索时处于第一行的元素状态仅能从自身和前一个状态转移得到，而第一列的元素状态仅能从自身和上一个状态转移得到。\n\nclass Solution {\npublic:\n    vector<vector<int>> updateMatrix(vector<vector<int>>& mat) {\n        if(mat.empty()||mat.empty()){\n            return {};\n        }\n        int m = mat.size(), n = mat[0].size();\n        vector<vector<int>> dp(m, vector<int>(n,INT_MAX-1)); // INT_MAX会在特殊用例中报错\n        // 从左上到右下进行动态搜索\n        for(int i=0;i<m;++i){\n            for(int j=0;j<n;++j){\n                if(mat[i][j]==0){\n                    dp[i][j] = 0;\n                }else{\n                    // 区分边界情况\n                    if(j>0){\n                        dp[i][j] = min(dp[i][j], dp[i][j-1]+1);\n                    }\n                    if(i>0){\n                        dp[i][j] = min(dp[i][j], dp[i-1][j]+1);\n                    }\n                }\n            }\n        }\n        // 从右下到左上进行动态搜索\n        for(int i=m-1;i>=0;--i){\n            for(int j=n-1;j>=0;--j){\n                if(mat[i][j]){\n                    if(j<n-1){\n                        dp[i][j] = min(dp[i][j], dp[i][j+1]+1);\n                    }\n                    if(i<m-1){\n                        dp[i][j] = min(dp[i][j], dp[i+1][j]+1);\n                    }\n                }\n            }\n        }\n        return dp;\n    }\n};\n\n\n# 221 最大正方形\n\n给定一个二维的 0-1 矩阵，求全由 1 构成的最大正方形面积。\n\n输入是一个二维 0-1 数组，输出是最大正方形面积。\n\n> 输入：matrix = [["1","0","1","0","0"],["1","0","1","1","1"],["1","1","1","1","1"],["1","0","0","1","0"]] 输出：4\n\n解析:\n\n对于在矩阵内搜索正方形或长方形的题型，一种常见的做法是定义一个二维 dp 数组，其中dp[i][j]表示满足题目条件的、以 (i, j) 为右下角的正方形或者长方形的属性。对于本题，则表示以 (i, j) 为右下角的全由 1 构成的最大正方形面积。\n\n设置状态：定义一个二维 dp 数组，其中dp[i][j]表示以 (i, j) 为右下角的全由 1 构成的最大正方形面积\n\n状态转移方程：如果当前位置是 0，那么 dp[i][j] 即为 0；如果当前位置是 1，我们假设 dp[i][j] = k^2 ，其充分条件为 dp[i-1][j-1]、dp[i][j-1]和 dp[i-1][j]的值必须都不小于 (k − 1)^2 ，否则 (i, j) 位置不可以构成一个边长为 k 的正方形。同理，如果这三个值中的最小值为 k − 1，则 (i, j) 位置一定且最大可以构成一个边长为 k 的正方形。所以状态转移方程为dp[i][j] = min(dp[i-1][j-1], min(dp[i][j-1], dp[i-1][j])) + 1\n\n初始情况：仅有一个方格构成正方形dp[0][0] = 1\n\nclass Solution {\npublic:\n    int maximalSquare(vector<vector<char>>& matrix) {\n        if(matrix.empty()||matrix[0].empty()){\n            return 0;\n        }\n        int m = matrix.size(), n = matrix[0].size();\n        int maxSize = 0;\n        vector<vector<int>> dp(m+1,vector<int>(n+1));\n        for(int i=1;i<=m;++i){\n            for(int j=1;j<=n;++j){\n                if(matrix[i-1][j-1] == \'1\'){\n                \tdp[i][j] = min(min(dp[i][j-1],dp[i-1][j]),dp[i-1][j-1]) + 1;\n                }\n                maxSize = max(dp[i][j],maxSize);\n            }\n        }\n        return maxSize * maxSize;\n    }\n};\n\n\n\n# 03 分割型动态规划\n\n对于分割类型题，动态规划的状态转移方程通常并不依赖相邻的位置，而是依赖于满足分割条件的位置。\n\n# 279 完全平方数\n\n给定一个正整数，求其最少可以由几个完全平方数相加构成。\n\n输入是给定的正整数，输出也是一个正整数，表示输入的数字最少可以由几个完全平方数相加构成。\n\n> 输入：n = 12\n> 输出：3 \n> 解释：12 = 4 + 4 + 4\n\n解析：\n\n设置状态：定义一个一维矩阵 dp，其中 dp[i] 表示数字 i 最少可以由几个完全平方数相加构成\n\n状态转移方程：在本题中，位置 i 只依赖 i - k^2 的位置，如 i - 1、i - 4、i - 9 等等，才能满足完全平方分割的条件。因此数字 i 可以取的最小值为 dp[i] = 1 + min(dp[i-1], dp[i-4], dp[i-9], ....... )\n\n初始情况：0 无法由任一个完全平方数相加构成，即dp[0]=0\n\nclass Solution {\npublic:\n    int numSquares(int n) {\n        vector<int> dp(n+1,INT_MAX);\n        dp[0] = 0;\n        for(int i=1;i<=n;++i){\n            for(int j=1;i-j*j>=0;++j){\n                dp[i] = min(dp[i],dp[i-j*j]+1);\n            }\n        }\n        return dp[n];\n    }\n};\n\n\n# 343 整数拆分\n\n给定一个正整数 n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。\n\n输入是给定的正整数，输出也是一个正整数，表示输入的数字拆分获得的最大乘积。\n\n> 输入: 10\n> 输出: 36\n> 解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。\n\n解析：\n\n本题和279题相似，位置 i 依赖于 i - j 的位置\n\n设置状态：定义一个一维矩阵 dp，其中 dp[i] 表示数字 i 拆分可以获得的最大乘积\n\n状态转移方程：将 i 拆分分为两种情况，第一种是仅拆分为两个数即 i 和 i - j，不再拆分为更多正整数，这种情况的乘积为 j*(i-j)；第二种是拆分出第一个正整数 j 后，将 i - j 继续拆分为多个正整数，这种情况乘积为j*dp[i-j]。所以在拆分的第一个数 j 固定的情况下状态转移方程为dp[i] = max(j*(i-j),j*dp[i-j])。由于 j 的取值范围是 1 到 i - 1，需要遍历所有的 j 得到 dp[i] 的最大值，因此可以得到状态转移方程dp[i] = max(dp[i],max(j*(i-j),j*dp[i-j]))。\n\n初始情况：0 不是正整数，1 是最小的正整数，0 和 1 都不能拆分，因此 dp[0] = dp[1] = 0\n\nclass Solution {\npublic:\n    int integerBreak(int n) {\n        vector<int> dp(n+1,0);\n        for(int i=2;i<=n;++i){\n            for(int j=1;j<i;++j){\n                dp[i] = max(dp[i],max(j*(i-j),j*dp[i-j]));\n            }\n        }\n        return dp[n];\n    }\n};\n\n\n# 91 解码方法\n\n已知字母 A-Z 可以表示成数字 1-26。给定一个数字串，求有多少种不同的字符串等价于这个数字串。\n\n输入是一个由数字组成的字符串，输出是满足条件的解码方式总数。\n\n> 输入：s = "226"\n> 输出：3\n> 解释：它可以解码为 "BZ" (2 26), "VF" (22 6), 或者 "BBF" (2 2 6) \n\n解析：\n\n本题的特殊情况较多因为只有 1-26 可以表示字母，所以对于一些特殊情况，比如数字 0 或者当相邻两数字大于 26 时，需要有不同的状态转移方程。本人对此题还存在一些疑惑，仅贴出代码，欢迎解惑。\n\nclass Solution {\npublic:\n    int numDecodings(string s) {\n        int n = s.length();\n        if(n==0){\n            return 0;\n        }\n        int prev = s[0] - \'0\';\n        if(!prev){\n            return 0;\n        }\n        if(n==1){\n            return 1;\n        }\n        vector<int> dp(n+1,1);\n        for(int i=2;i<=n;++i){\n            int cur = s[i-1] - \'0\';\n            if((prev==0 || prev>2) && cur == 0){\n                return 0;\n            }\n            if((prev < 2 && prev>0) || prev == 2 && cur < 7){\n                if(cur){\n                    dp[i] = dp[i-2] + dp[i-1];\n                }else{\n                    dp[i] = dp[i-2];\n                }\n            }else{\n                dp[i] = dp[i-1];\n            }\n            prev = cur;\n        }\n        return dp[n];\n    }\n};\n\n\n# 139 单词拆分\n\n给定一个字符串和一个字符串集合，求是否存在一种分割方式，使得原字符串分割后的子字符串都可以在集合内找到。\n\n> 输入: s = "applepenapple", wordDict = ["apple", "pen"] 输出: true 解释: 返回 true 因为 "applepenapple" 可以被拆分成 "apple pen apple"；注意你可以重复使用字典中的单词。\n\n解析：\n\n本题类似于完全平方数分割问题，这道题的分割条件由集合内的字符串决定，因此在考虑每个分割位置时，需要遍历字符串集合，以确定当前位置是否可以成功分割。\n\n设置状态：用一个一维数组 dp[i] 表示开头到以 i 位置结束的子串是否能够在集合中找到\n\n状态转移方程：如果开头到以 j 结尾的子串都能在集合中找到，且从 j 到 i 的子串也能够在集合中找到那么 dp[i] = true\n\n初始情况：字符串和集合都为空时为真，dp[0]=true\n\nclass Solution {\npublic:\n    bool wordBreak(string s, vector<string>& wordDict) {\n        unordered_set<string> wordDictSet;\n        for(const auto w: wordDict){\n            wordDictSet.insert(w);\n        }\n        int n = s.length();\n        vector<bool> dp(n+1,false);\n        dp[0] = true;\n        for(int i=1;i<=n;++i){\n            for(int j=0;j<i;++j){\n                // 分割类型动态规划：dp[i] = s[0]到s[j-1]为true && s[j]到s[i-j]子串在字典中\n                if(dp[j] && wordDictSet.find(s.substr(j,i-j)) != wordDictSet.end()){\n                    dp[i] = true;\n                    // dp[i] 表示的是 s[0]到s[i-1]的子串中单词是否出现在字典中\n                    break;\n                }\n            }\n        }\n        return dp[n];\n    }\n};\n\n\n\n# 04 子序列问题\n\n对于子序列问题，第一种动态规划方法是，定义一个 dp 数组，其中 dp[i]表示以 i 结尾的子序列的性质。在处理好每个位置后，统计一遍各个位置的结果即可得到题目要求的结果。第二种动态规划方法是，定义一个 dp数组，其中 dp[i] 表示到位置 i 为止的子序列的性质，并不必须以 i 结尾。这样 dp 数组的最后一位结果即为题目所求，不需要再对每个位置进行统计。\n\n# 300 最长递增子序列\n\n给定一个未排序的整数数组，求最长的递增子序列。\n\n输入是一个一维数组，输出是一个正整数，表示最长递增子序列的长度。\n\n> 输入：nums = [10,9,2,5,3,7,101,18]\n> 输出：4\n> 解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。\n\n解析:\n\n设置状态：使用一个一维数组dp[i] 可以表示以 i 结尾的、最长子序列长度。\n\n状态转移方程：对于每一个位置 i，如果其之前的某个位置 j 所对应的数字小于位置 i 所对应的数字，则可以获得一个以 i 结尾的、长度为 dp[j] + 1 的子序列，即dp[i] = max(dp[i],dp[j]+1)。为了遍历所有情况，我们需要 i 和 j 进行两层循环，并记录最大值。\n\n初始情况：dp[0] = 0, dp[1] = 1\n\nclass Solution {\npublic:\n    int lengthOfLIS(vector<int>& nums) {\n        int len = nums.size();\n        // 将所有位置初始化为 1, 因为len>=1,所以最短递增子序列就是 1 \n        vector<int> dp(len,1); \n        int ans = 1;\n        // i 控制每一个记录位置\n        for(int i=1;i<len;++i){ \n            // j 扫描 i 之前的子序列\n            for(int j=0;j<i;++j){ \n                // 如果出现递增情况，判断是否增加的子序列长度\n                if(nums[i]>nums[j]){ \n                    dp[i] = max(dp[i],dp[j]+1);\n                }\n            }\n            // 完成一个位置的记录之后，判断是否是较大长度\n            ans = max(ans,dp[i]);\n        }\n        return ans;\n    }\n};\n\n\n# 646 最长数对链\n\n给出 n 个数对，在每一个数对中，第一个数字总是比第二个数字小。对于数对(a,b),(c,d)如果 b < c则这两个数对可以构成数对链\n\n输入一个数对集合，输出一个整数表示能够形成的最长数对链的长度。\n\n> 输入：[[1,2], [2,3], [3,4]]\n> 输出：2\n> 解释：最长的数对链是 [1,2] -> [3,4]\n\n解析:\n\n本题和300题本质上是一样的，不同在于递增序列由数对构成。另外需要考虑数对出现的次序并不影响它是否能够加入数对链，所以在使用类似于300题的动态规划方法计算最长数对链长度之前需要对其进行排序，简化元素选择。本题中以区间（数对）结尾排序。\n\nclass Solution {\npublic:\n    int findLongestChain(vector<vector<int>>& pairs) {\n        int len = pairs.size();\n        if(len < 1) return 0; \n        sort(pairs.begin(),pairs.end(),[](vector<int> a, vector<int> b){ return a[1]<b[1];});\n        vector<int> dp(len,1);\n        int ans = 1;\n        for(int i=1;i<len;++i){\n            for(int j=0;j<i;++j){\n                if(pairs[j][1]<pairs[i][0]){\n                    dp[i] = max(dp[i],dp[j]+1);\n                }\n            }\n            ans = max(ans,dp[i]);\n        }\n        return ans;\n    }\n};\n\n\n# 376 摆动序列\n\n如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为摆动序列。给你一个整数数组 nums ，返回 nums 中作为 摆动序列 的 最长子序列的长度 。\n\n输入是一个一维数组，输出是一个正整数，表示作为摆动序列的最长子序列的长度。\n\n> 输入：nums = [1,17,5,10,13,15,10,5,16,8] 输出：7 解释：这个序列包含几个长度为 7 摆动序列。其中一个是 [1, 17, 10, 13, 10, 16, 8] ，各元素之间的差值为 (16, -7, 3, -3, 6, -8) 。\n\n解析:\n\n本题和递增子序列的差别在于摆动序列的元素选择取决于前一个被选元素的大小，既可以上升也可以下降。\n\n设置状态：使用一个二维数组dp[i][j]表示前 i 个元素中的某一个为结尾的最长摆动序列长度，其中 j 取值为 0 和 1分别表示上升摆动序列和下降摆动序列。上升摆动序列是指最后一个元素是呈上升趋势的摆动序列，下降摆动序列同理。d[i][0]表示以前 i 个元素中的某一个为结尾的最长的上升摆动序列的长度；dp[i][1]以前 i 个元素中的某一个为结尾的最长的下降摆动序列的长度。\n\n状态转移方程：考虑第 i 个元素，如果nums[i] > nums[i-1]，则该元素可以加入下降摆动序列形成上升摆动序列dp[i][0] = max(dp[i-1][0],dp[i-1][1] + 1)，但是该元素加入上升摆动序列并不会形成下降摆动序列dp[i][1] = dp[i-1][1]；如果nums[i] < nums[i-1]，则该元素可以加入上升摆动序列形成下降摆动序列dp[i][1] = max(dp[i-1][1],dp[i-1][0] + 1)，如果该元素加入下降摆动序列并不会形成上升摆动序列所以dp[i][0] = dp[i-1][0]；如果nums[i] == nums[i-1]那么可以直接跳过该元素dp[i][0] = dp[i-1][0], dp[i][1] = dp[i-1][1]。\n\n初始情况：当只有一个元素时，该元素既是上升摆动序列也是下降摆动序列，dp[0][j] = 1;\n\nclass Solution {\npublic:\n    int wiggleMaxLength(vector<int>& nums) {\n        int len = nums.size();\n        if(len < 2) return len;\n        vector<vector<int>> dp(len,vector<int>(2,1));\n        int ans = 1;\n        for(int i=1;i<len;++i){\n            if(nums[i] < nums[i-1]){\n                dp[i][0] = dp[i-1][0];\n                dp[i][1] = max(dp[i-1][1],dp[i-1][0] + 1);\n            }else if(nums[i] > nums[i-1]){\n                dp[i][0] = max(dp[i-1][0],dp[i-1][1] + 1);\n                dp[i][1] = dp[i-1][1];\n            }else{\n                dp[i][0] = dp[i-1][0];\n                dp[i][1] = dp[i-1][1];\n            }\n            ans = max(ans,max(dp[i][0],dp[i][1]));\n        }\n        return ans;\n    }\n};\n\n\n本题也可以采用贪心策略解决，使用极值构成最长摆动序列。\n\n# 1143 最长公共子序列\n\n给定两个字符串，求它们最长的公共子序列长度。\n\n输入是两个字符串，输出是一个整数，表示它们满足题目条件的长度。\n\n> 输入：text1 = "abcde", text2 = "ace" \n> 输出：3  \n> 解释：最长公共子序列是 "ace" ，它的长度为 3 。\n\n解析:\n\n设置状态：建立一个二维数组 dp，其中 dp[i][j] 表示到第一个字符串位置 i 为止、到第二个字符串位置 j 为止、最长的公共子序列长度。\n\n状态转移方程：从1开始计算字符串位置，那么当text1 的第 i 个字符与 text2 的第 j 个字符相等时，其最长公共子串长度为前一状态加1，即 dp[i][j] = dp[i-1][j-1] + 1；如果不相等，dp[i][j] 不会比dp[i-1][j] 和dp[i][j-1] 两者之中任何一个小，也不会比两者都大，即 dp[i][j] = max(dp[i-1][j],dp[i][j-1])\n\n初始情况：任一个字符串为空串则最长公共子序列的长度都为0，即dp[0][j] = dp[i][0] = 0\n\nclass Solution {\npublic:\n    int longestCommonSubsequence(string text1, string text2) {\n        int len1 = text1.length(), len2 = text2.length();\n        // 创建len+1行len2+1列的二维数组 dp，其中 dp[i][j] 表示 text1[0:i] 和 text2[0:j] 的最长公共子序列的长度\n        vector<vector<int>> dp(len1+1,vector<int>(len2+1));\n        for(int i=1;i<=len1;++i){\n            for(int j=1;j<=len2;++j){\n                // 相等情况\n                if(text1[i-1]==text2[j-1]){\n                    dp[i][j] = dp[i-1][j-1] + 1;\n                // 不等情况\n                }else{\n                    dp[i][j] = max(dp[i-1][j],dp[i][j-1]);\n                }\n            }\n        }\n        return dp[len1][len2];\n    }\n};\n\n\n# 583 两个字符串的删除操作\n\n给定两个字符串，求它们通过删除操作变成相同的最小步骤。\n\n输入是两个字符串，输出是一个整数，表示它们通过删除操作变成相同的最小步骤数。\n\n> 输入: "sea", "eat"\n> 输出: 2\n> 解释: 第一步将"sea"变为"ea"，第二步将"eat"变为"ea"\n\n解析:\n\n本题是最长公共子序列的一种变种题，可以直接求出最长公共子序列后用较长一个字符串的长度减去最长公共子序列的长度。\n\nclass Solution {\npublic:\n    int minDistance(string word1, string word2) {\n        int m = word1.length(), n = word2.length();\n        vector<vector<int>> dp(m+1,vector<int>(n+1));\n        for(int i=1;i<=m;++i){\n            for(int j=1;j<=n;++j){\n                if(word1[i-1] == word2[j-1]){\n                    dp[i][j] = dp[i-1][j-1] + 1;\n                }else{\n                    dp[i][j] = max(dp[i-1][j],dp[i][j-1]);\n                }\n            }\n        }\n        int LCS = dp[m][n];\n        return m+n-2*LCS;\n    }\n};\n\n\n\n# 05 背包问题\n\n背包问题：有 N 个物品和容量为 W 的背包，每个物品都有自己的体积 w 和价值 v，求拿哪些物品可以使得背包所装下物品的总价值最大。如果限定每种物品只能选择 0 个或 1 个，则问题称为 0-1 背包问题；如果不限定每种物品的数量，则问题称为完全背包问题。\n\n0-1 背包问题，我们可以定义一个二维数组 dp 存储最大价值，其中 dp[i][j] 表示前 i 件物品体积不超过 j 的情况下能达到的最大价值。在我们遍历到第 i 件物品时，在当前背包总容量为 j 的情况下，分为两种情况：（1）如果我们不将物品 i 放入背包，即当前背包容量不足或这放入当前物品无法达到最大价值，那么 dp[i][j]= dp[i-1][j]，即前 i 个物品的最大价值等于只取前 i -1 个物品时的最大价值；（2）如果我们将物品 i 放入背包，假设第 i 件物品体积为 w，价值为 v，那么我们得到 dp[i][j] = dp[i-1][j-w] + v。\n\nint knapsack(vector<int> weights, vector<int> values, int N, int W) {\n\tvector<vector<int>> dp(N+1,vector<int>(W+1));\n    // 放置第i个物品\n    for(int i=1;i<=N;++i){\n        // 第 i 个物品的体积w和价值v\n        int w = weights[i-1], v = values[i-1];\n        // 遍历容量\n        for(int j=1;j<=W;++j){\n            if(j>=w){\n                dp[i][j] = max(dp[i-1][j],dp[i-1][j-w]+v);\n            }else{\n                dp[i][j] = dp[i-1][j];\n            }\n        }\n    }\n    return dp[N][W];\n}\n\n\n在完全背包问题中，一个物品可以拿多次。这里直接给出完全背包问题的状态转移方程dp[i][j] = max(dp[i-1][j], dp[i][j-w] + v)，其与 0-1 背包问题的差别仅仅是把状态转移方程中的第二个 i-1 变成了 i。\n\nint knapsack(vector<int> weights, vector<int> values, int N, int W) {\n\tvector<vector<int>> dp(N+1,vector<int>(W+1));\n    // 放置第i个物品\n    for(int i=1;i<=N;++i){\n        // 第 i 个物品的体积w和价值v\n        int w = weights[i-1], v = values[i-1];\n        // 遍历容量\n        for(int j=1;j<=W;++j){\n            if(j>=w){\n                dp[i][j] = max(dp[i-1][j],dp[i][j-w]+v);\n            }else{\n                dp[i][j] = dp[i-1][j];\n            }\n        }\n    }\n    return dp[N][W];\n}\n\n\n# 416 分割等和子集\n\n给定一个正整数数组，求是否可以把这个数组分成和相等的两部分。\n\n输入是一个一维正整数数组，输出时一个布尔值，表示是否可以满足题目要求。\n\n> 输入：nums = [1,5,11,5]\n> 输出：true\n> 解释：数组可以分割成 [1, 5, 5] 和 [11] 。\n\n解析:\n\n本题等价于 0-1 背包问题，设所有数字和为 sum，我们的目标是选取一部分物品，使得它们的总和为 target = sum/2，及用部分物品填满容量为target的背包。同时本题不需要考虑价值，因此我们只需要通过一个布尔值矩阵来表示状态转移矩阵。\n\n设置状态： dp[i][j] 表示 nums 的前 i 个整数是否能够组合成和为 j\n\n状态转移方程：(01背包问题的子问题都很简单只用区分选择当前物品或者不选择当前物品的情况)\n\n * 不选择 nums[i]：nums[i] 大于于当前容量 j 时，容量不够不选择该物品，dp[i][j] = dp[i-1][j]\n\n * 选择 nums[i]：\n   \n   >  * nums[i] 恰好等于当前容量 j，即nums[i]==j时，只放该物品就可以填满容量为 j 的背包，dp[i][j] =true\n   >  * nums[i] 小于当前容量 j，即nums[i]<j时，只放该物品不够填满容量为 j 的背包，检测放入该物品后dp[i-1][j-nums[i]]的情况下是否可以填满背包\n   > \n   > 总的说，当容量足够时，物品nums[i] 可选可不选（在有价值的情况下就需要选择价值较大的情况），则dp[i][j] = dp[i-1][j] || dp[i-1][j-nums[i]]\n\n初始情况：容量为0的时候，不选择任何物品，dp[i][0] = true；只有一个物品的时候，当容量为j == nums[0]时恰好满足，即dp[0][nums[0]] = true\n\n示例的状态转移矩阵根据上述状态转移方程可以得到如下表格：\n\n           0   1   2   3   4   5   6   7   8   9   10   11\n[0] = 1    T   T   F   F   F   F   F   F   F   F   F    F\n[1] = 5    T   T   F   F   F   T   T   F   F   F   F    F\n[2] = 11   T   T   F   F   F   T   T   F   F   F   F    T\n[3] = 5    T   T   F   F   F   T   T   F   F   F   T    T\n\nclass Solution {\npublic:\n    bool canPartition(vector<int>& nums) {\n        int sum = accumulate(nums.begin(),nums.end(),0);\n        auto maxPos = max_element(nums.begin(),nums.end());\n        int target = sum/2, len = nums.size();\n        // 注意特殊情况，和为奇数或者元素个数小与2都无法进行有效分割，而元素值大于target直接导致越界\n        if(len<2 || sum&1 || *maxPos > target){\n            return false;\n        }\n        vector<vector<bool>> dp(len,vector<bool>(target+1,false));\n        // 初始情况容量为0\n        for(int i=0;i<len;++i){\n            dp[i][0] = true;\n        }\n        // 初始情况物品只有一个\n        dp[0][nums[0]] = true;\n        for(int i=1;i<len;++i){\n            for(int j=1;j<=target;++j){\n                // 背包容量大于当前扫描物品，可选可不选\n                if(j >= nums[i]){\n                    dp[i][j] = dp[i-1][j] || dp[i-1][j-nums[i]];\n                // 背包容量小于当前扫描物品，没法选\n                }else{\n                    dp[i][j] = dp[i-1][j];\n                }\n            }\n        }\n        return dp[len-1][target];\n    }\n};\n\n\n# 494 目标和\n\n给定义一个整数数组 nums 和一个整数 target 。向数组中的每个整数前添加 \'+\' 或 \'-\' ，然后串联起所有整数，可以构造一个 表达式，返回可以完成表达式构造的、运算结果等于 target 的不同 表达式 的数目。\n\n输入一个一维数组和整数，输出一个整数表示构造表达式结果为target的方法数\n\n> 输入：nums = [1,1,1,1,1], target = 3 输出：5 解释：一共有 5 种方法让最终目标和为 3 。 -1 + 1 + 1 + 1 + 1 = 3 +1 - 1 + 1 + 1 + 1 = 3 +1 + 1 - 1 + 1 + 1 = 3 +1 + 1 + 1 - 1 + 1 = 3 +1 + 1 + 1 + 1 - 1 = 3\n\n解析：\n\n本题可以转化为 01 背包问题，假设数组元素总和为 sum，添加 \'+\'的元素和为 x，那么添加 \'-\'的元素和为 sum - x。由此可以得到 x - (sum - x) = target，即为x = (target + sum) / 2，那么本题就可以转化为使用 nums中的N个物品装满容量为 x 的背包，共有多少种方法，可以看出这时一个组合问题。\n\n设置状态：使用一个二维数组 dp[i][j] 表示数组 nums 中从开头到以 i 位置结尾的所有物品装满容量为 j 的背包的方法数。\n\n状态转移方程：考虑第 i 个元素，如果当前背包容量 j<nums[i]，则不能放入第 i 个元素 dp[i][j] = dp[i-1][j]；如果当前背包容量j >= nums[i]，不放入第 i 个元素的方法数为dp[i][j] = dp[i-1][j]，放入第 i 个元素的方法数为dp[i][j] = dp[i-1][j-nums[i]]，那么总的方法数为这两中情况之和即dp[i][j] = dp[i-1][j] + dp[i-1][j-nums[i]]\n\n边界情况：如果(target + sum)不为偶数是无解情况，如果 abs(target) > sum 也是无解情况，没有任何构造方式能够满足题目条件。当数组为空，背包容量为0时dp[0][0] == 1\n\nclass Solution {\npublic:\n    int findTargetSumWays(vector<int>& nums, int target) {\n        int len = nums.size();\n        int sum = accumulate(nums.begin(),nums.end(),0);\n        if((target+sum)&1 || abs(target)>sum){\n            return 0;\n        }\n        int weight = (target + sum)/2;\n        vector<vector<int>> dp(len+1,vector<int>(weight+1));\n        dp[0][0] = 1;\n        for(int i=1;i<=len;++i){\n            for(int j=0;j<=weight;++j){\n                dp[i][j] = dp[i-1][j];\n                if(j>=nums[i-1]){\n                    dp[i][j] = dp[i-1][j] + dp[i-1][j-nums[i-1]];\n                }\n            }\n        }\n        return dp[len][weight];\n    }\n};\n\n\n# 474 一和零\n\n给定 m 个数字 0 和 n 个数字 1，以及一些由 0-1 构成的字符串，求利用这些数字最多可以构成多少个给定的字符串，字符串只可以构成一次。\n\n输入两个整数 m 和 n，表示 0 和 1 的数量，以及一个一维字符串数组，表示待构成的字符串；输出是一个整数，表示最多可以生成的字符串个数。\n\n> 输入：strs = ["10", "0001", "111001", "1", "0"], m = 5, n = 3 输出：4 解释：最多有 5 个 0 和 3 个 1 的最大子集是 {"10","0001","1","0"} ，因此答案是 4 。其他满足题意但较小的子集包括 {"0001","1"} 和 {"10","1","0"} 。{"111001"} 不满足题意，因为它含 4 个 1 ，大于 n 的值 3 。\n\n解析：\n\n本题也是一个01背包问题，而其特点在于它有两个背包，一个装0，另一个装1。\n\n设置状态：dp[i][j][k] 表示装0背包容量为 j，装1背包容量为k的情况下，能够装入前 i 个物品中的几个\n\n状态转移方程：仍旧划为装入当前物品和不装入当前物品两个子问题，不装入则dp[i][j][k]=dp[i-1][j][k]，装入则dp[i][j][k]=max(dp[i-1][j][k],dp[i-1][j-w0[i]][k-w1[i]] + 1)，其中w0表示物品中0的体积，w1表示物品中1的体积。\n\nclass Solution {\npublic:\n\n    // 计算每个str中0和1的数量\n    pair<int,int> countWeight(string str){\n        int count0 = 0, count1 = 0;\n        for(int i=0;i<str.length();++i){\n            if(str[i] == \'0\'){\n                ++count0;\n            }else{\n                ++count1;\n            }\n        }\n        return make_pair(count0,count1);\n    }\n\n    int findMaxForm(vector<string>& strs, int m, int n) {\n        int len = strs.size();\n        // 用一个三维数组表示在前 i 个字符串中，使用 j 个 0 和 k 个 1 的情况下最多可以得到的字符串数量\n        vector<vector<vector<int>>> dp(len+1,vector<vector<int>>(m+1,vector<int>(n+1)));\n        for(int i=1;i<=len;++i){\n            auto count = countWeight(strs[i-1]);\n            // j 和 k 都从零开始，因为str存在\'0\'或\'1\'这种只有一种元素构成的情况\n            for(int j=0;j<=m;++j){\n                for(int k=0;k<=n;++k){\n                    if(j >= count.first && k >= count.second){\n                        dp[i][j][k] = max(dp[i-1][j][k],dp[i-1][j-count.first][k-count.second] + 1);\n                    }else{\n                        dp[i][j][k] = dp[i-1][j][k];\n                    }\n                }\n            }\n        }\n        return dp[len][m][n];\n    }\n};\n\n\n# 322 零钱兑换\n\n给定一些硬币的面额，求最少可以用多少颗硬币组成给定的金额。\n\n输入一个一维整数数组，表示硬币的面额；以及一个整数，表示给定的金额。输出一个整数，表示满足条件的最少的硬币数量。若不存在解，则返回-1。\n\n> 输入：coins = [1, 2, 5], amount = 11\n> 输出：3 \n> 解释：11 = 5 + 5 + 1\n\n解析：\n\n因为每个硬币可以用无限多次，这道题本质上是完全背包问题。完全背包问题还是没搞懂，记录一下，以后仔细琢磨。\n\nclass Solution {\npublic:\n    int coinChange(vector<int>& coins, int amount) {\n        int Max = amount + 1;\n        vector<int> dp(amount + 1, Max);\n        dp[0] = 0;\n        for (int i = 1; i <= amount; ++i) {\n            for (int j = 0; j < (int)coins.size(); ++j) {\n                if (coins[j] <= i) {\n                    dp[i] = min(dp[i], dp[i - coins[j]] + 1);\n                }\n            }\n        }\n        return dp[amount] > amount ? -1 : dp[amount];\n    }\n};\n\n\n\n# 06 字符串编辑问题\n\n# 72 编辑距离\n\n给定两个字符串，已知你可以删除、替换和插入任意字符串的任意字符，求最少编辑几步可以将两个字符串变成相同。\n\n输入是两个字符串，输出是一个整数，表示最少的步骤。\n\n> 输入：word1 = "horse", word2 = "ros" 输出：3 解释： horse -> rorse (将 \'h\' 替换为 \'r\') rorse -> rose (删除 \'r\') rose -> ros (删除 \'e\')\n\n解析：\n\n本题与最长公共子序列类似，两个字符串的对比所以需要使用一个二维数组来设置状态 dp[i][j]\n\n设置状态：dp[i][j] 表示将第一个字符串到位置 i 为止，和第二个字符串到位置 j 为止，最多需要几步编辑。\n\n状态转移方程：当第 i 位和第 j 位对应的字符相同时，dp[i][j] 等于 dp[i-1][j-1]；当二者对应的字符不同时，修改的消耗是 dp[i-1][j-1]+1，插入 i 位置/删除 j 位置的消耗是 dp[i][j-1] + 1，插入 j 位置/删除 i 位置的消耗是 dp[i-1][j] + 1，所以在不同的情况下状态转移方程dp[i][j] = min(dp[i-1][j-1],dp[i-1][j],dp[i][j-1])。\n\n边界情况：word1为空串时，需要插入字符与word2一致，即dp[0][j] = j；同理，word2为空串是dp[i][0] = i\n\nclass Solution {\npublic:\n    int minDistance(string word1, string word2) {\n        int m = word1.length(), n = word2.length();\n        vector<vector<int>> dp(m+1,vector<int>(n+1));\n        // 边界条件 word2为空串\n        for(int i=0;i<=m;++i){\n            dp[i][0] = i;\n        }\n        // 边界条件 word1为空串\n        for(int j=0;j<=n;++j){\n            dp[0][j] = j;\n        }\n        for(int i=1;i<=m;++i){\n            for(int j=1;j<=n;++j){\n                // 状态转移，相等情况不编辑，不等情况选择编辑次数最少的编辑\n                if(word1[i-1] == word2[j-1]){\n                    dp[i][j] = dp[i-1][j-1];\n                }else{\n                    dp[i][j] = min(dp[i-1][j-1],min(dp[i-1][j],dp[i][j-1])) + 1;\n                }\n            }\n        }\n        return dp[m][n];\n    }\n};\n\n\n# 650 只有两个键的键盘\n\n给定一个字母 A，已知你可以每次选择复制全部字符，或者粘贴之前复制的字符，求最少需要几次操作可以把字符串延展到指定长度。\n\n输入是一个正整数，代表指定长度；输出是一个整数，表示最少操作次数。\n\n> 输入：3 输出：3 解释： 最初, 只有一个字符 \'A\'。 第 1 步, 使用 Copy All 操作。 第 2 步, 使用 Paste 操作来获得 \'AA\'。 第 3 步, 使用 Paste 操作来获得 \'AAA\'。\n\n解析：\n\n不同于以往通过加减实现的动态规划，这里需要乘除法来计算位置，因为粘贴操作是倍数增加的。\n\n设置状态：使用一个一维数组 dp[i]，其中位置 i 表示延展到长度 i 的最少操作次数。\n\n状态转移方程：对于每个位置 j，如果 j 可以被 i 整除，那么长度 i 就可以由长度 j 操作得到，其操作次数等价于把一个长度为 1 的 A 延展到长度为 i/j。例如3由1操作得到A A A，6由2操作得到AA AA AA因此可以得到递推公式 dp[i] = dp[j] + dp[i/j]。\n\nclass Solution {\npublic:\n    int minSteps(int n) {\n        vector<int> dp(n+1);\n        for(int i=2;i<=n;++i){\n            dp[i] = i;\n            for(int j=2;j<=i;++j){\n                if(i%j==0){\n                    dp[i] = dp[j] + dp[i/j];\n                    break;\n                }\n            }\n        }\n        return dp[n];\n    }\n};\n\n\n# 10 正则表达式匹配\n\n给定一个字符串和一个正则表达式（regular expression, regex），求该字符串是否可以被匹配，其中\'.\' 匹配任意单个字符；\'*\' 匹配零个或多个前面的那一个元素。\n\n输入是一个待匹配字符串和一个用字符串表示的正则表达式，输出是一个布尔值，表示是否可以匹配成功。\n\n> 输入：s = "aab" p = "cab" 输出：true 解释：因为 \'*\' 表示零个或多个，这里 \'c\' 为 0 个, \'a\' 被重复一次。因此可以匹配字符串 "aab"。\n\n解析：\n\n两个字符串进行匹配，且字符具有特殊含义，本题动态规划的特点在于多种情况下的不同状态转移方程。\n\n设置状态：使用一个布尔类型的二维数组 dp，其中 dp[i][j] 表示以 i 截止的字符串是否可以被以 j 截止的正则表达式匹配。\n\n状态转移方程：根据正则表达式的不同情况，即字符、星号，点号，分情况讨论来更新 dp 数组\n\n * 相等情况：即s[i-1] == p[j-1] || p[j-1] == \'.\'的情况，这种情况下dp[i][j] == dp[i-1][j-1]，即与前 i-1 个子串匹配情况一致\n\n * 不相等情况：\n   \n   >  * s[i-1] != p[j-1] && p[j-1] != \'*\' ，直接不匹配情况dp[i][j] = false\n   >  * p[j-1] == \'*\'：如果匹配0次则dp[i][j-2] == true 则 dp[i][j] = true；如果匹配多次则需要验证\'*\'前一个字符相等情况即s[i-1] == p[j-1] || p[j-1] == \'.\'，相等则dp[i][j] = dp[i-1][j]，否则不匹配\n\n初始情况：空串匹配非空正则表达式，dp[0][0]=true，当p[j-1]==\'*\'是可以匹配0次匹配空串即dp[0][j] =dp[0][j-2]；非空串匹配空正则表达式，dp[0][0]=true，其他情况都无法成功匹配。\n\nclass Solution {\npublic:\n    bool isMatch(string s, string p) {\n        int m = s.size(), n = p.size();\n        vector<vector<bool>> dp(m+1,vector<bool>(n+1,false));\n        dp[0][0] = true;\n        for(int j=1;j<=n;++j){\n            if(p[j-1] == \'*\'){\n                dp[0][j] = dp[0][j-2];\n            }\n        }\n\n        for(int i=1;i<=m;++i){\n            auto chs = s[i-1]; \n            for(int j=1;j<=n;++j){\n                auto chp = p[j-1];\n                if(chs == chp || chp == \'.\'){\n                    dp[i][j] = dp[i-1][j-1];\n                }else if(chp ==  \'*\'){\n                    if(j>1){\n                        if(dp[i][j-2]){\n                            dp[i][j] = true;\n                        }else{\n                            auto prechp = p[j-2];\n                            if(prechp==chs || prechp ==\'.\'){\n                                dp[i][j] = dp[i-1][j];\n                            } \n                        }\n                    }\n                }\n            }\n        }\n        return dp[m][n];\n    }\n};\n\n\n\n# 07 股票交易问题\n\n股票交易类问题通常可以用动态规划来解决。对于稍微复杂一些的股票交易类问题，比如需要冷却时间或者交易费用，则可以用通过动态规划实现的状态机来解决。\n\n题目                  特点\n121 买卖股票的最佳时机       只能买卖一次\n122 买卖股票的最佳时机 II    可以买卖多次\n714 买卖股票的最佳时机含手续费   可以买卖多次，每次都有手续费\n123 买卖股票的最佳时机 III   最多买卖两次\n188 买卖股票的最佳时机 IV    最多买卖 k 次\n309 最佳买卖股票时机含冷冻期    可以买卖多次，但是卖出有一天冷冻期\n\n# 121 买卖股票的最佳时机\n\n给定一段时间内每天的股票价格，已知你只可以买卖各一次，求最大的收益。\n\n输入一个一维整数数组，表示每天的股票价格；输出一个整数，表示最大的收益。\n\n> 输入：[7,1,5,3,6,4] 输出：5 解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5\n\n解析：\n\n求最大利润本质是也是一个优化问题，所以可以采用动态规划的思路解决。\n\n设置状态：用两个动态规划数组buy[i] 表示第 i 天持股时的现金数，sell[i]表示第 i 天不持股时的现金数\n\n状态转移方程：第 i 天持股 buy[i] = max(buy[i-1],-prices[i])，如果第 i-1 天不持股则花费-prices[i]的现金买入股票，如果第i-1天持股，则保持不变；第 i 天不持股 sell[i] = max(sell[i-1],buy[i-1]+prices[i])，如果第 i-1 天也不持股那么情况不变，如果第 i-1 天持股则需要将其卖出产生收益buy[i-1]+prices[i]。\n\n初始情况：第 1 天不持股sell[0] = 0；第 1 天持股buy[0] = -prices[0]\n\nclass Solution {\npublic:\n    int maxProfit(vector<int>& prices) {\n        int len = prices.size();\n        if(len<2) return 0;\n        vector<int> sell(len);\n        vector<int> buy(len);\n        sell[0] = 0;\n        buy[0] = -prices[0];\n        for(int i=1;i<len;++i){\n            buy[i] = max(buy[i-1],-prices[i]);\n            sell[i] = max(sell[i-1],buy[i-1]+prices[i]);\n        }\n        return sell[len-1];\n    }   \n}\n\n\n本题也可以用更直接的方法解决，遍历一遍数组，在每一个位置 i 时，记录 i 位置之前所有价格中的最低价格，然后将当前的价格作为售出价格，查看当前收益是不是最大收益，一遍遍历完成后就可以得到最大收益。\n\nclass Solution {\npublic:\n    int maxProfit(vector<int>& prices) {\n        int sell = 0, buy = INT_MAX;\n        for(int i=0;i<prices.size();++i){\n            buy = min(buy,prices[i]);\n            sell = max(sell,prices[i]-buy);\n        }\n        return sell;\n    }\n};\n\n\n# 122 买卖股票的最佳时机 II\n\n给定一段时间内每天的股票价格，已知你只可以多次买卖一支股票，求最大的收益。\n\n输入一个一维整数数组，表示每天的股票价格；输出一个整数，表示最大的收益。\n\n> 输入：[7,1,5,3,6,4] 输出：5 解释：在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6 - 3 = 3 。\n\n解析：\n\n本题和上一题的区别在于可以多次买卖，也可以采用动态规划的思路来解决。\n\n设置状态：除了用两个数组分别表示股票持股与不持股情况，也可以使用一个二维数组dp[i][j]来表示，其中 i 表示交易的时间，j 表示交易状态即买入或卖出 ，0 表示买入状态、1表示卖出状态；dp[i][0]表示第 i 天持股时的现金数，dp[i][1] 表示第 i 天不持股时的现金数。值得注意的是dp[i][0]，表示的是第i天，买入股票的状态，并不是说一定要第i天买入股票，dp[i][1]亦同\n\n状态转移方程：本题的状态转移方程和上一题的唯一区别在于第 i 天持股的情况，如果第 i-1 天也持股那么保持一致，如果第 i-1 天不持股由于可以进行多次交易，那么就需要在已获得收益的基础上花费-prices[i]的现金买入股票即dp[i][0] = max(dp[i-1][0],dp[i-1][1] - prices[i])。\n\n初始情况：第 1 天持股dp[0][0] = -prices[0]，第 1 天不持股dp[0][1] = 0\n\nclass Solution {\npublic:\n    int maxProfit(vector<int>& prices) {\n        int len = prices.size();\n        if(len<2) return 0;\n        vector<vector<int>> dp(len,vector<int>(2));\n        dp[0][0] = -prices[0];\n        dp[0][1] = 0;\n        for(int i=1;i<len;++i){\n            dp[i][0] = max(dp[i-1][0],dp[i-1][1] - prices[i]);\n            dp[i][1] = max(dp[i-1][1],dp[i-1][0] + prices[i]);\n        }\n        return dp[len-1][1];\n    }\n};\n\n\n本题可以采用贪心策略，由于不限制交易次数，只要今天股价比昨天高，就交易。\n\nclass Solution {\npublic:\n    int maxProfit(vector<int>& prices) {\n        int sum = 0;\n        for(int i=1;i<prices.size();++i){\n            if(prices[i]>prices[i-1]){\n                sum+=(prices[i]-prices[i-1]);\n            }\n        }\n        return sum;\n    }\n};\n\n\n# 714 买卖股票的最佳时机含手续费\n\n给定一段时间内每天的股票价格，已知每次交易都需要扣除fee的手续费，且每次只能拥有一支股票，求最大的收益。\n\n输入一个一维整数数组，表示每天的股票价格；输出一个整数，表示最大的收益。\n\n> 输入：prices = [1, 3, 2, 8, 4, 9], fee = 2 输出：8 解释：能够达到的最大利润 ((8 - 1) - 2) + ((9 - 4) - 2) = 8\n\n解析：\n\n本题本质上和122可多次交易并没有什么差别，主要的问题是需要考虑过多次数的交易可能会产生大量手续费，直接导致总的收益不如交易次数较少的利润。\n\n设置状态：使用一个二维数组dp[i][j]来表示，其中 i 表示交易的时间，j 表示交易状态即买入或卖出 ，0 表示买入状态、1表示卖出状态；dp[i][0]表示第 i 天持股时的现金数，dp[i][1] 表示第 i 天不持股时的现金数。\n\n状态转移方程：本题与122题状态转移方程的主要区别在于第 i 天不持股的情况，如果第 i-1 天也不持股那么保持一致，如果第 i-1 天持股，那么就需要将其卖出产生buy[i-1]+prices[i]的收益，同时需要从收益中扣除fee的手续费。得到第 i 天不持股情况的状态转移方程dp[i][1] = max(dp[i-1][1],dp[i-1][0] + prices[i] - fee)\n\n初始情况：第 1 天持股dp[0][0] = -prices[0]，第 1 天不持股dp[0][1] = 0\n\nclass Solution {\npublic:\n    int maxProfit(vector<int>& prices, int fee) {\n        int len = prices.size();\n        if(len < 2) return 0;\n        vector<vector<int>> dp(len,vector<int>(2));\n        dp[0][0] = -prices[0];\n        dp[0][1] = 0;\n        for(int i=1;i<len;++i){\n            dp[i][0] = max(dp[i-1][0],dp[i-1][1] - prices[i]);\n            dp[i][1] = max(dp[i-1][1],dp[i-1][0] + prices[i] - fee);\n        }\n        return dp[len-1][1];\n    }\n};\n\n\n# 123 买卖股票的最佳时机 III\n\n给定一段时间内每天的股票价格，已知你最多可以进行两次买卖一支股票，求最大的收益。\n\n输入一个一维整数数组，表示每天的股票价格；输出一个整数，表示最大的收益。\n\n> 输入：prices = [3,3,5,0,0,3,1,4] 输出：6 解释：在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。\n\n解析：\n\n本题限制了交易次数最多为两次买卖，那么就要对这两次交易操作进行区分，所以一天的交易就不再是前两题中持股和不持股两种状态，而是要在此基础上区分第一次交易持股状态和第二次交易持股状态。\n\n设置状态：使用一个二维数组dp[i][j]来表示，其中 i 表示交易的时间，j 为0～3表示交易状态。例如dp[i][0]表示第一次买入状态、dp[i][1]表示第一次卖出状态、dp[i][2]表示第二次买入状态、dp[i][3]表示第二次卖出状态。\n\n状态转移方程：\n\n>  * 第一次交易的状态转移方程与121的单次交易一致，如果第一次第 i 天持股dp[i][0] = max(dp[i-1][0],- prices[i])，第 i-1 天不持股则需要花费-prices[i]的现金买入股票达成买入状态，如果第i-1天持股，则保持不变；\n>  * 如果第一次第 i 天不持股dp[i][1] = max(dp[i-1][1],dp[i-1][0] + prices[i])，第 i-1 天也不持股那么情况不变，如果第 i-1 天持股则需要将其卖出达成卖出状态并产生收益prices[i]。\n>  * 第二次交易的状态转移方程则与122的多次交易大致相同，如果第二次交易第 i 天持股dp[i][2] = max(dp[i-1][2],dp[i-1][1] - prices[i])，如果第 i-1 天也持股那么不进行操作，如果第 i-1 天不持股则需要在第一次交易完成的基础上花费prices[i]的现金买入股票达成持股或买入状态；\n>  * 如果第 i 天为卖不持股或卖出状态dp[i][3] = max(dp[i-1][3],dp[i-1][2] + prices[i])，如果第 i-1 天不持股第 i-1 天也不持股那么情况不变，如果第 i-1 天持股则需要将其卖出达成卖出状态并产生收益prices[i]。\n\n初始情况：第 1 天持股dp[0][0] = -prices[0], dp[0][1] = -prices[0]，第 1 天不持股dp[0][1] = 0, dp[0][3] = 0\n\nclass Solution {\npublic:\n    int maxProfit(vector<int>& prices) {\n        int len = prices.size();\n        if(len<2) return 0;\n        vector<vector<int>> dp(len,vector<int>(4));\n        dp[0][0] = -prices[0];\n        dp[0][2] = -prices[0];\n        dp[0][1] = 0;\n        dp[0][3] = 0;\n        for(int i=1;i<len;++i){\n            dp[i][0] = max(dp[i-1][0],-prices[i]);\n            dp[i][1] = max(dp[i-1][1],dp[i-1][0]+prices[i]);\n            dp[i][2] = max(dp[i-1][2],dp[i-1][1]-prices[i]);\n            dp[i][3] = max(dp[i-1][3],dp[i-1][2]+prices[i]);\n        }\n        return dp[len-1][3];\n    }\n};\n\n\n# 188 买卖股票的最佳时机 IV\n\n给定一段时间内每天的股票价格，已知你最多可以进行 k 次买卖一支股票，求最大的收益。\n\n输入一个一维整数数组，表示每天的股票价格；输出一个整数，表示最大的收益。\n\n> 输入：k = 2, prices = [3,2,6,5,0,3] 输出：7 解释：在第 2 天 (股票价格 = 2) 的时候买入，在第 3 天 (股票价格 = 6) 的时候卖出, 这笔交易所能获得利润 = 6-2 = 4 。随后，在第 5 天 (股票价格 = 0) 的时候买入，在第 6 天 (股票价格 = 3) 的时候卖出, 这笔交易所能获得利润 = 3-0 = 3 。\n\n解析：\n\n本题限制了交易次数最多为 k 次，那么就要根据 k 值大小区分不同情况，如果 k 大于数组长度那么就可以类比122题相当于可以不限次数交易；如果 k 小于数组长度那么就可以类比为123题有限次数交易求最大利润。\n\n设置状态：还是使用一个二维数组dp[i][j]来记录所剩余的现金，其中 i 表示交易的时间，j 为表示交易状态。类比123题本题的不同在于交易次数是变化的，交易状态难以表征，但是我们也可以总结出规律，可以使用偶数表示买入状态，奇数表示卖出状态。\n\n状态转移方程：本题的状态转移方程可以直接类比123题，区别在于次数是变化的。\n\n初始情况：即所有交易次数中第一天不持股时为0，持股则为-prices[i]\n\nclass Solution {\npublic:\n    int maxProfit(int k, vector<int>& prices) {\n        int len = prices.size();\n        // 临界情况 k <= 0 || k >= len\n        if(len < 2 || k <= 0) return 0;\n        if(len <= k){\n            return unlimitedTimes(prices);\n        }\n        // 一般情况 0 < k && k < len\n        vector<vector<int>> dp(len,vector<int>(2*k));\n        // 初始情况\n        for(int i=0;i<2*k;++i){\n            if(i&1){\n                dp[0][i] = 0;\n            }else{\n                dp[0][i] = -prices[0];\n            }\n        }\n        \n        for(int i=1;i<len;++i){\n            // 第一次买入状态\n            dp[i][0] = max(dp[i-1][0],-prices[i]);\n            for(int j=1;j<2*k;++j){\n                if(j&1){\n                    // 卖出状态转移方程\n                    dp[i][j] = max(dp[i-1][j],dp[i-1][j-1]+prices[i]);\n                }else{\n                    // 买入状态转移方程\n                    dp[i][j] = max(dp[i-1][j],dp[i-1][j-1]-prices[i]);\n                }\n            }\n        }\n        return dp[len-1][2*k-1];\n    }\n\n    // 可以进行多次交易的贪心实现\n    int unlimitedTimes(vector<int>& prices){\n        int len = prices.size();\n        int sum = 0;\n        for(int i=1;i<len;++i){\n            if(prices[i]>prices[i-1]){\n                sum += (prices[i] - prices[i-1]);\n            }\n        }\n        return sum;\n    }\n};\n\n\n# 309 最佳买卖股票时机含冷冻期\n\n给定一段时间内每天的股票价格，已知每次卖出之后必须冷却一天，且每次只能拥有一支股票，求最大的收益。\n\n输入一个一维整数数组，表示每天的股票价格；输出一个整数，表示最大的收益。\n\n> 输入: [1,2,3,0,2]\n> 输出: 3 \n> 解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]\n\n解析：\n\n我们可以使用状态机来解决这类复杂的状态转移问题，通过建立多个状态以及它们的转移方式，我们可以很容易地推导出各个状态的转移方程。如图所示，我们可以建立四个状态来表示带有冷却的股票交易，以及它们的之间的转移方式。\n\n其中分为买入状态Buy、卖出状态Sell、买入后状态S1和卖出后状态S2（状态的划分本人也没有搞清楚，仅仅凭个人理解进行划分，如有错误感谢指正）\n\n * 买入状态：即通过买入股票达到的买入状态\n * 买入后状态：买入大于等于两天后的持股状态，一直没操作，保持持股\n * 卖出状态：通过卖出持有的股票达到卖出状态，可以从买入状态直接操作卖出股票进入卖出状态，也可以在买入之后的持有多天后卖出股票进入卖出状态，这两个过程都会产生收益\n * 卖出后状态：度过了冷冻期，大于等于两天前就卖出了股票，一直没操作，保持不持股\n\n设置状态：使用一个二维数组dp[i][j]来表示，其中 i 表示交易的时间，j 为0～3表示交易状态。例如dp[i][0]表示买入状态、dp[i][1]表示不操作状态、dp[i][2]表示卖出状态、dp[i][3]表示卖出后状态。\n\n状态转移方程：\n\n>  * 买入状态dp[i][0] = dp[i-1][3] - prices[i]，卖出后状态下所持有的现金中花费prices[i]买入股票达到买入状态。\n>  * 买入后状态dp[i][1] = max(dp[i-1][0],dp[i-1][1])，可以通过买入状态到达，也可以不操作，保持原先持股状态。\n>  * 卖出状态dp[i][2] = max(dp[i-1][0],dp[i-1][1]) + prices[i]，可以买入后第二天直接卖出股票到达卖出状态，也可以持有多天后再卖出股票达到卖出状态。\n>  * 卖出后状态dp[i][3] = max(dp[i-1][2],dp[i-1][3])，可以通过卖出状态到达，也可以不操作，保持原先不持股状态。\n\n初始情况：第一天不持股时为dp[0][2] = 0, dp[0][3] = 0，持股则为dp[0][0] = -prices[i], dp[0][1] = -prices[i]\n\nclass Solution {\npublic:\n    int maxProfit(vector<int>& prices) {\n        int len = prices.size();\n        if(len < 2) return 0;\n        vector<vector<int>> dp(len,vector<int>(4));\n        dp[0][0] = dp[0][1] = -prices[0];\n        dp[0][2] = dp[0][3] = 0;\n        for(int i=1;i<len;++i){\n            dp[i][0] = dp[i-1][3] - prices[i];\n            dp[i][1] = max(dp[i-1][0],dp[i-1][1]);\n            dp[i][2] = max(dp[i-1][0],dp[i-1][1]) + prices[i];\n            dp[i][3] = max(dp[i-1][2],dp[i-1][3]);\n        }\n        return max(dp[len-1][2],dp[len-1][3]);\n    }\n};\n',normalizedContent:'# leetcode刷题笔记 动态规划\n\n\n# 01 一维动态规划\n\n# 70 爬楼梯\n\n给定 n 节台阶，每次可以走一步或走两步，求一共有多少种方式可以走完这些台阶。\n\n输入是一个数字，表示台阶数量；输出是爬台阶的总方式。\n\n> 输入： 2\n> 输出： 2\n> 解释： 有两种方法可以爬到楼顶。\n> 1.  1 阶 + 1 阶\n> 2.  2 阶\n\n解析:\n\n这是十分经典的斐波那契数列题。\n\n设置状态：定义一个数组 dp，dp[i] 表示走到第 i 阶的方法数\n\n状态转移方程：因为我们每次可以走一步或者两步，所以第 i 阶可以从第 i-1 或 i-2 阶到达。换句话说，走到第 i 阶的方法数即为走到第 i-1 阶的方法数加上走到第 i-2 阶的方法数。这样我们就得到了状态转移方程dp[i] = dp[i-1] + dp[i-2]。\n\n初始情况：当阶数小于等于1时，方法数为1\n\nclass solution {\npublic:\n    int climbstairs(int n) {\n        if(n<2) return n;\n        vector<int> dp(n+1);\n        dp[0] = dp[1] = 1;\n        for(int i=2;i<=n;++i){\n            dp[i] = dp[i-1] + dp[i-2];\n        }\n        return dp[n];\n    }\n};\n\n\n# 198 打家劫舍\n\n假如你是一个劫匪，并且决定抢劫一条街上的房子，每个房子内的钱财数量各不相同。如果你抢了两栋相邻的房子，则会触发警报机关。求在不触发机关的情况下最多可以抢劫多少钱。\n\n输入是一个一维数组，表示每个房子的钱财数量；输出是劫匪可以最多抢劫的钱财数量。\n\n> 输入：[1,2,3,1] 输出：4 解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。偷窃到的最高金额 = 1 + 3 = 4 。\n\n解析:\n\n设置状态：定义一个数组 dp，dp[i] 表示抢劫到第 i 个房子时，可以抢劫的最大数量。 状态转移方程：我们考虑 dp[i]，此时可以抢劫的最大数量有两种可能，一种是我们选择不抢劫这个房子，此时累计的金额即为dp[i-1]；另一种是我们选择抢劫这个房子，那么此前累计的最大金额只能是 dp[i-2]，因为我们不能够抢劫第 i-1 个房子，否则会触发警报机关。因此本题的状态转移方程为 dp[i] = max(dp[i-1],nums[i-1] + dp[i-2])。\n\n初始情况：第一个房子的抢劫最大数量 dp[1] = nums[0]\n\nclass solution {\npublic:\n    int rob(vector<int>& nums) {\n        if(nums.empty()){\n            return 0;\n        }\n        int len = nums.size();\n        vector<int> dp(len+1,0);\n        dp[1] = nums[0];\n        for(int i=2;i<=len;++i){\n            dp[i] = max(dp[i-1],dp[i-2]+nums[i-1]);\n        }\n        return dp[len];\n    }\n};\n\n\n# 213 打家劫舍 ii\n\n假如你是一个劫匪，并且决定抢劫一条街上的房子，这条街所有的房屋都 围成一圈 ，这意味着第一个房屋和最后一个房屋是紧挨着的。如果你抢了两栋相邻的房子，则会触发警报机关。求在不触发机关的情况下最多可以抢劫多少钱。\n\n输入是一个一维数组，表示每个房子的钱财数量；输出是劫匪可以最多抢劫的钱财数量。\n\n> 输入：nums = [2,3,2]\n> 输出：3\n> 解释：你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。\n\n解析:\n\n本题与198题的主要区别是输入的一维数组是一个环形数组，所以要分别考虑抢第一个房子和不抢第一个房子的情况。抢第一个房子，那么就不能抢最后一个房子，则可抢的范围为nums[0]~nums[len-2]；不抢第一个房子，那么就可以抢最后一个房子，则可抢的范围为nums[1]~nums[len-1]。\n\n基于上述两种情况使用与198题相同的动态规划方法解决本问题\n\nclass solution {\npublic:\n    int rob(vector<int>& nums) {\n        int len = nums.size();\n        if(len < 1) return 0;\n        vector<int> nums1,nums2;\n        for(int i=0;i<len;++i){\n            if(i==0){\n                nums1.push_back(nums[i]);\n            }else if(i==len-1){\n                nums2.push_back(nums[i]);\n            }else{\n                nums1.push_back(nums[i]);\n                nums2.push_back(nums[i]);\n            }\n        }\n        return max(robrange(nums1),robrange(nums2));\n    }\n\n    int robrange(vector<int>& nums){\n        int len = nums.size();\n        if(len < 1) return 0;\n        vector<int> dp(len+1,0);\n        dp[1] = nums[0];\n        for(int i=2;i<=len;++i){\n            dp[i] = max(dp[i-1],dp[i-2]+nums[i-1]);\n        }\n        return dp[len];\n    }\n};\n\n\n上述解法较为直观，先分情况在计算最大抢劫价值；也可以通过划分区间的方式划分情况如下\n\nclass solution {\npublic:\n    int rob(vector<int>& nums) {\n        int len = nums.size();\n        if(len == 1) return nums[0];\n        return max(robrange(nums,0,len-1),robrange(nums,1,len));\n    }\n\n    int robrange(vector<int>& nums, int start, int end){\n        int len = end - start;\n        if(len < 1) return 0;\n        vector<int> dp(len+1,0);\n        dp[1] = nums[start];\n        for(int i=2;i<=len;++i){\n            dp[i] = max(dp[i-1],dp[i-2]+nums[i+start-1]);\n        }\n        return dp[len];\n    }\n};\n\n\n# 413 等差数列划分\n\n给定一个数组，求这个数组中连续且等差的子数组一共有多少个。\n\n输入是一个一维数组，输出是满足等差条件的连续字数组个数。\n\n> 输入：nums = [1,2,3,4]\n> 输出：3\n> 解释：nums 中有三个子等差数组：[1, 2, 3]、[2, 3, 4] 和 [1,2,3,4] 自身。\n\n解析:\n\n这道题略微特殊，因为要求是等差数列，可以很自然的想到子数组必定满足 num[i] - num[i-1] = num[i-1] - num[i-2]。然而由于我们对于 dp 数组的定义通常为以 i 结尾的，满足某些条件的子数组数量，而等差子数组可以在任意一个位置终结，因此此题在最后需要对 dp 数组求和。\n\nclass solution {\npublic:\n    int numberofarithmeticslices(vector<int>& nums) {\n        int len = nums.size();\n        int res = 0;\n        if(len < 3){\n            return res;\n        }\n        vector<int> dp(len,0);\n        for(int i = 2;i<len;++i){\n            if(nums[i]-nums[i-1] == nums[i-1] - nums[i-2]){\n                dp[i] = dp[i-1] + 1;\n                res += dp[i];\n            }\n        }\n        return res;\n    }\n};\n\n\n# 53 最大子序和\n\n给定一个数组，找出一个具有最大和的连续子数组，并返回其最大和。\n\n输入一个数组，输出一个整数，为连续子数组的最大和\n\n> 输入：nums = [-2,1,-3,4,-1,2,1,-5,4]\n> 输出：6\n> 解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。\n\n解析:\n\n设置状态：使用一维数组dp[i]表示以第 i 个元素结尾的子序列的最大和\n\n状态转移方程：我们考虑 dp[i]，此时构成最大和的子序列有两种可能，一种是我们选择不将第 i 个元素加入子序列，因为要构成连续的子序列，所以自己单独构成新的子序列此时最大和即为自身nums[i-1]；另一种是我们选择将第 i 个元素加入子序列，那么构成子序列的最大和为dp[i-1]+nums[i-1]。所以本题的状态转移方程为 dp[i] = max(nums[i-1],nums[i-1] + dp[i-1])。\n\n初始情况：只有一个元素，dp[1]=nums[0]\n\nclass solution {\npublic:\n    int maxsubarray(vector<int>& nums) {\n        int len = nums.size();\n        if(len < 1) return 0;\n        vector<int> dp(len+1,0);\n        dp[1] = nums[0];\n        int ans = nums[0];\n        for(int i=2;i<=len;++i){\n            dp[i] = max(nums[i-1],dp[i-1]+nums[i-1]);\n            ans = max(ans,dp[i]);\n        }\n        return ans;\n    }\n};\n\n\n\n# 02 二维动态规划\n\n# 64 最小路径和\n\n给定一个 m × n 大小的非负整数矩阵，求从左上角开始到右下角结束的、经过的数字的和最小的路径。每次只能向右或者向下移动。\n\n输入是一个二维数组，输出是最优路径的数字和。\n\n> 输入：grid = [[1,3,1],[1,5,1],[4,2,1]]\n> 输出：7\n> 解释：因为路径 1→3→1→1→1 的总和最小。\n\n解析:\n\n设置状态：使用一个二维的 dp 数组，其中 dp[i][j] 表示从左上角开始到 (i, j) 位置的最 优路径的数字和。\n\n状态转移方程：因为每次只能向下或者向右移动，我们可以很容易得到状态转移方程 dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]，其中 grid 表示原数组。\n\n边界条件：只有一格dp[0][0] = grid[0][0]；第一行的元素只能由前一个元素向右移动得到即dp[0][j] = dp[0][j-1]+grid[0][j]；第一列的元素只能由上一个元素向下移动得到即dp[i][0] = dp[i-1][0]+grid[i][0]\n\nclass solution {\npublic:\n    int minpathsum_old(vector<vector<int>>& grid) {\n        int ans = 0;\n        if(grid.empty()||grid[0].empty()){\n            return ans;\n        }\n        int m = grid.size(), n = grid[0].size();\n        vector<vector<int>> dp(m,vector<int>(n));\n        for(int i=0;i<m;++i){\n            for(int j=0;j<n;++j){\n                if(i==0&&j==0){\n                    dp[i][j] = grid[0][0];\n                }else if(i==0){\n                    dp[i][j] = dp[i][j-1] + grid[i][j];\n                }else if(j==0){\n                    dp[i][j] = dp[i-1][j] + grid[i][j];\n                }else{\n                     dp[i][j] = min(dp[i][j-1],dp[i-1][j]) + grid[i][j];\n                }\n            }\n        }\n        return dp[m-1][n-1];\n    }\n};\n\n\n因为 dp 矩阵的每一个值只和左边和上面的值相关，我们可以使用空间压缩将 dp 数组压缩为一维。对于第 i 行，在遍历到第 j 列的时候，因为第 j-1 列已经更新过了，所以 dp[j-1] 代表 dp[i][j-1]的值；而 dp[j] 待更新，当前存储的值是在第 i-1 行的时候计算的，所以代表 dp[i-1][j]的值。\n\n# 542 01矩阵\n\n给定一个由 0 和 1 组成的二维矩阵，求每个位置到最近的 0 的距离。\n\n输入是一个二维 0-1 数组，输出是一个同样大小的非负整数数组，表示每个位置到最近的 0的距离。\n\n> 输入：mat = [[0,0,0],[0,1,0],[1,1,1]]\n> 输出：[[0,0,0],[0,1,0],[1,2,1]]\n\n解析:\n\n本题涉及到四个方向上的最近搜索，如果使用递归的方法进行搜索在二维数组中将造成极大的时间复杂度。使用动态规划进行存储化，可以使得递归搜索不会重复遍历相同位置；另一种更简单的方法是，从左上到右下进行一次动态搜索，再从右下到左上进行一次动态搜索，这样两次动态搜索即可完成四个方向上的查找。\n\n设置状态：使用一个二维数组 dp[i][j] 表示位置为 (i,j) 的元素与0的距离\n\n状态转移方程：值为0的元素到0的距离为0；从左上到右下进行动态搜索，那么dp[i][j] 可以从dp[i-1][j]、dp[i][j-1]和自身三个状态中转移得到dp[i][j]=min(dp[i][j],min(dp[i-1][j],dp[i][j-1])) + 1； 从右下到左上进行动态搜索的状态转移方程可以类比得到dp[i][j]=min(dp[i][j],min(dp[i+1][j],dp[i][j+1])) + 1\n\n边界情况：当d[i][j]处于矩阵的边界上时其状态转移受到限制，例如，从左上到右下进行动态搜索时处于第一行的元素状态仅能从自身和前一个状态转移得到，而第一列的元素状态仅能从自身和上一个状态转移得到。\n\nclass solution {\npublic:\n    vector<vector<int>> updatematrix(vector<vector<int>>& mat) {\n        if(mat.empty()||mat.empty()){\n            return {};\n        }\n        int m = mat.size(), n = mat[0].size();\n        vector<vector<int>> dp(m, vector<int>(n,int_max-1)); // int_max会在特殊用例中报错\n        // 从左上到右下进行动态搜索\n        for(int i=0;i<m;++i){\n            for(int j=0;j<n;++j){\n                if(mat[i][j]==0){\n                    dp[i][j] = 0;\n                }else{\n                    // 区分边界情况\n                    if(j>0){\n                        dp[i][j] = min(dp[i][j], dp[i][j-1]+1);\n                    }\n                    if(i>0){\n                        dp[i][j] = min(dp[i][j], dp[i-1][j]+1);\n                    }\n                }\n            }\n        }\n        // 从右下到左上进行动态搜索\n        for(int i=m-1;i>=0;--i){\n            for(int j=n-1;j>=0;--j){\n                if(mat[i][j]){\n                    if(j<n-1){\n                        dp[i][j] = min(dp[i][j], dp[i][j+1]+1);\n                    }\n                    if(i<m-1){\n                        dp[i][j] = min(dp[i][j], dp[i+1][j]+1);\n                    }\n                }\n            }\n        }\n        return dp;\n    }\n};\n\n\n# 221 最大正方形\n\n给定一个二维的 0-1 矩阵，求全由 1 构成的最大正方形面积。\n\n输入是一个二维 0-1 数组，输出是最大正方形面积。\n\n> 输入：matrix = [["1","0","1","0","0"],["1","0","1","1","1"],["1","1","1","1","1"],["1","0","0","1","0"]] 输出：4\n\n解析:\n\n对于在矩阵内搜索正方形或长方形的题型，一种常见的做法是定义一个二维 dp 数组，其中dp[i][j]表示满足题目条件的、以 (i, j) 为右下角的正方形或者长方形的属性。对于本题，则表示以 (i, j) 为右下角的全由 1 构成的最大正方形面积。\n\n设置状态：定义一个二维 dp 数组，其中dp[i][j]表示以 (i, j) 为右下角的全由 1 构成的最大正方形面积\n\n状态转移方程：如果当前位置是 0，那么 dp[i][j] 即为 0；如果当前位置是 1，我们假设 dp[i][j] = k^2 ，其充分条件为 dp[i-1][j-1]、dp[i][j-1]和 dp[i-1][j]的值必须都不小于 (k − 1)^2 ，否则 (i, j) 位置不可以构成一个边长为 k 的正方形。同理，如果这三个值中的最小值为 k − 1，则 (i, j) 位置一定且最大可以构成一个边长为 k 的正方形。所以状态转移方程为dp[i][j] = min(dp[i-1][j-1], min(dp[i][j-1], dp[i-1][j])) + 1\n\n初始情况：仅有一个方格构成正方形dp[0][0] = 1\n\nclass solution {\npublic:\n    int maximalsquare(vector<vector<char>>& matrix) {\n        if(matrix.empty()||matrix[0].empty()){\n            return 0;\n        }\n        int m = matrix.size(), n = matrix[0].size();\n        int maxsize = 0;\n        vector<vector<int>> dp(m+1,vector<int>(n+1));\n        for(int i=1;i<=m;++i){\n            for(int j=1;j<=n;++j){\n                if(matrix[i-1][j-1] == \'1\'){\n                \tdp[i][j] = min(min(dp[i][j-1],dp[i-1][j]),dp[i-1][j-1]) + 1;\n                }\n                maxsize = max(dp[i][j],maxsize);\n            }\n        }\n        return maxsize * maxsize;\n    }\n};\n\n\n\n# 03 分割型动态规划\n\n对于分割类型题，动态规划的状态转移方程通常并不依赖相邻的位置，而是依赖于满足分割条件的位置。\n\n# 279 完全平方数\n\n给定一个正整数，求其最少可以由几个完全平方数相加构成。\n\n输入是给定的正整数，输出也是一个正整数，表示输入的数字最少可以由几个完全平方数相加构成。\n\n> 输入：n = 12\n> 输出：3 \n> 解释：12 = 4 + 4 + 4\n\n解析：\n\n设置状态：定义一个一维矩阵 dp，其中 dp[i] 表示数字 i 最少可以由几个完全平方数相加构成\n\n状态转移方程：在本题中，位置 i 只依赖 i - k^2 的位置，如 i - 1、i - 4、i - 9 等等，才能满足完全平方分割的条件。因此数字 i 可以取的最小值为 dp[i] = 1 + min(dp[i-1], dp[i-4], dp[i-9], ....... )\n\n初始情况：0 无法由任一个完全平方数相加构成，即dp[0]=0\n\nclass solution {\npublic:\n    int numsquares(int n) {\n        vector<int> dp(n+1,int_max);\n        dp[0] = 0;\n        for(int i=1;i<=n;++i){\n            for(int j=1;i-j*j>=0;++j){\n                dp[i] = min(dp[i],dp[i-j*j]+1);\n            }\n        }\n        return dp[n];\n    }\n};\n\n\n# 343 整数拆分\n\n给定一个正整数 n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。\n\n输入是给定的正整数，输出也是一个正整数，表示输入的数字拆分获得的最大乘积。\n\n> 输入: 10\n> 输出: 36\n> 解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。\n\n解析：\n\n本题和279题相似，位置 i 依赖于 i - j 的位置\n\n设置状态：定义一个一维矩阵 dp，其中 dp[i] 表示数字 i 拆分可以获得的最大乘积\n\n状态转移方程：将 i 拆分分为两种情况，第一种是仅拆分为两个数即 i 和 i - j，不再拆分为更多正整数，这种情况的乘积为 j*(i-j)；第二种是拆分出第一个正整数 j 后，将 i - j 继续拆分为多个正整数，这种情况乘积为j*dp[i-j]。所以在拆分的第一个数 j 固定的情况下状态转移方程为dp[i] = max(j*(i-j),j*dp[i-j])。由于 j 的取值范围是 1 到 i - 1，需要遍历所有的 j 得到 dp[i] 的最大值，因此可以得到状态转移方程dp[i] = max(dp[i],max(j*(i-j),j*dp[i-j]))。\n\n初始情况：0 不是正整数，1 是最小的正整数，0 和 1 都不能拆分，因此 dp[0] = dp[1] = 0\n\nclass solution {\npublic:\n    int integerbreak(int n) {\n        vector<int> dp(n+1,0);\n        for(int i=2;i<=n;++i){\n            for(int j=1;j<i;++j){\n                dp[i] = max(dp[i],max(j*(i-j),j*dp[i-j]));\n            }\n        }\n        return dp[n];\n    }\n};\n\n\n# 91 解码方法\n\n已知字母 a-z 可以表示成数字 1-26。给定一个数字串，求有多少种不同的字符串等价于这个数字串。\n\n输入是一个由数字组成的字符串，输出是满足条件的解码方式总数。\n\n> 输入：s = "226"\n> 输出：3\n> 解释：它可以解码为 "bz" (2 26), "vf" (22 6), 或者 "bbf" (2 2 6) \n\n解析：\n\n本题的特殊情况较多因为只有 1-26 可以表示字母，所以对于一些特殊情况，比如数字 0 或者当相邻两数字大于 26 时，需要有不同的状态转移方程。本人对此题还存在一些疑惑，仅贴出代码，欢迎解惑。\n\nclass solution {\npublic:\n    int numdecodings(string s) {\n        int n = s.length();\n        if(n==0){\n            return 0;\n        }\n        int prev = s[0] - \'0\';\n        if(!prev){\n            return 0;\n        }\n        if(n==1){\n            return 1;\n        }\n        vector<int> dp(n+1,1);\n        for(int i=2;i<=n;++i){\n            int cur = s[i-1] - \'0\';\n            if((prev==0 || prev>2) && cur == 0){\n                return 0;\n            }\n            if((prev < 2 && prev>0) || prev == 2 && cur < 7){\n                if(cur){\n                    dp[i] = dp[i-2] + dp[i-1];\n                }else{\n                    dp[i] = dp[i-2];\n                }\n            }else{\n                dp[i] = dp[i-1];\n            }\n            prev = cur;\n        }\n        return dp[n];\n    }\n};\n\n\n# 139 单词拆分\n\n给定一个字符串和一个字符串集合，求是否存在一种分割方式，使得原字符串分割后的子字符串都可以在集合内找到。\n\n> 输入: s = "applepenapple", worddict = ["apple", "pen"] 输出: true 解释: 返回 true 因为 "applepenapple" 可以被拆分成 "apple pen apple"；注意你可以重复使用字典中的单词。\n\n解析：\n\n本题类似于完全平方数分割问题，这道题的分割条件由集合内的字符串决定，因此在考虑每个分割位置时，需要遍历字符串集合，以确定当前位置是否可以成功分割。\n\n设置状态：用一个一维数组 dp[i] 表示开头到以 i 位置结束的子串是否能够在集合中找到\n\n状态转移方程：如果开头到以 j 结尾的子串都能在集合中找到，且从 j 到 i 的子串也能够在集合中找到那么 dp[i] = true\n\n初始情况：字符串和集合都为空时为真，dp[0]=true\n\nclass solution {\npublic:\n    bool wordbreak(string s, vector<string>& worddict) {\n        unordered_set<string> worddictset;\n        for(const auto w: worddict){\n            worddictset.insert(w);\n        }\n        int n = s.length();\n        vector<bool> dp(n+1,false);\n        dp[0] = true;\n        for(int i=1;i<=n;++i){\n            for(int j=0;j<i;++j){\n                // 分割类型动态规划：dp[i] = s[0]到s[j-1]为true && s[j]到s[i-j]子串在字典中\n                if(dp[j] && worddictset.find(s.substr(j,i-j)) != worddictset.end()){\n                    dp[i] = true;\n                    // dp[i] 表示的是 s[0]到s[i-1]的子串中单词是否出现在字典中\n                    break;\n                }\n            }\n        }\n        return dp[n];\n    }\n};\n\n\n\n# 04 子序列问题\n\n对于子序列问题，第一种动态规划方法是，定义一个 dp 数组，其中 dp[i]表示以 i 结尾的子序列的性质。在处理好每个位置后，统计一遍各个位置的结果即可得到题目要求的结果。第二种动态规划方法是，定义一个 dp数组，其中 dp[i] 表示到位置 i 为止的子序列的性质，并不必须以 i 结尾。这样 dp 数组的最后一位结果即为题目所求，不需要再对每个位置进行统计。\n\n# 300 最长递增子序列\n\n给定一个未排序的整数数组，求最长的递增子序列。\n\n输入是一个一维数组，输出是一个正整数，表示最长递增子序列的长度。\n\n> 输入：nums = [10,9,2,5,3,7,101,18]\n> 输出：4\n> 解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。\n\n解析:\n\n设置状态：使用一个一维数组dp[i] 可以表示以 i 结尾的、最长子序列长度。\n\n状态转移方程：对于每一个位置 i，如果其之前的某个位置 j 所对应的数字小于位置 i 所对应的数字，则可以获得一个以 i 结尾的、长度为 dp[j] + 1 的子序列，即dp[i] = max(dp[i],dp[j]+1)。为了遍历所有情况，我们需要 i 和 j 进行两层循环，并记录最大值。\n\n初始情况：dp[0] = 0, dp[1] = 1\n\nclass solution {\npublic:\n    int lengthoflis(vector<int>& nums) {\n        int len = nums.size();\n        // 将所有位置初始化为 1, 因为len>=1,所以最短递增子序列就是 1 \n        vector<int> dp(len,1); \n        int ans = 1;\n        // i 控制每一个记录位置\n        for(int i=1;i<len;++i){ \n            // j 扫描 i 之前的子序列\n            for(int j=0;j<i;++j){ \n                // 如果出现递增情况，判断是否增加的子序列长度\n                if(nums[i]>nums[j]){ \n                    dp[i] = max(dp[i],dp[j]+1);\n                }\n            }\n            // 完成一个位置的记录之后，判断是否是较大长度\n            ans = max(ans,dp[i]);\n        }\n        return ans;\n    }\n};\n\n\n# 646 最长数对链\n\n给出 n 个数对，在每一个数对中，第一个数字总是比第二个数字小。对于数对(a,b),(c,d)如果 b < c则这两个数对可以构成数对链\n\n输入一个数对集合，输出一个整数表示能够形成的最长数对链的长度。\n\n> 输入：[[1,2], [2,3], [3,4]]\n> 输出：2\n> 解释：最长的数对链是 [1,2] -> [3,4]\n\n解析:\n\n本题和300题本质上是一样的，不同在于递增序列由数对构成。另外需要考虑数对出现的次序并不影响它是否能够加入数对链，所以在使用类似于300题的动态规划方法计算最长数对链长度之前需要对其进行排序，简化元素选择。本题中以区间（数对）结尾排序。\n\nclass solution {\npublic:\n    int findlongestchain(vector<vector<int>>& pairs) {\n        int len = pairs.size();\n        if(len < 1) return 0; \n        sort(pairs.begin(),pairs.end(),[](vector<int> a, vector<int> b){ return a[1]<b[1];});\n        vector<int> dp(len,1);\n        int ans = 1;\n        for(int i=1;i<len;++i){\n            for(int j=0;j<i;++j){\n                if(pairs[j][1]<pairs[i][0]){\n                    dp[i] = max(dp[i],dp[j]+1);\n                }\n            }\n            ans = max(ans,dp[i]);\n        }\n        return ans;\n    }\n};\n\n\n# 376 摆动序列\n\n如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为摆动序列。给你一个整数数组 nums ，返回 nums 中作为 摆动序列 的 最长子序列的长度 。\n\n输入是一个一维数组，输出是一个正整数，表示作为摆动序列的最长子序列的长度。\n\n> 输入：nums = [1,17,5,10,13,15,10,5,16,8] 输出：7 解释：这个序列包含几个长度为 7 摆动序列。其中一个是 [1, 17, 10, 13, 10, 16, 8] ，各元素之间的差值为 (16, -7, 3, -3, 6, -8) 。\n\n解析:\n\n本题和递增子序列的差别在于摆动序列的元素选择取决于前一个被选元素的大小，既可以上升也可以下降。\n\n设置状态：使用一个二维数组dp[i][j]表示前 i 个元素中的某一个为结尾的最长摆动序列长度，其中 j 取值为 0 和 1分别表示上升摆动序列和下降摆动序列。上升摆动序列是指最后一个元素是呈上升趋势的摆动序列，下降摆动序列同理。d[i][0]表示以前 i 个元素中的某一个为结尾的最长的上升摆动序列的长度；dp[i][1]以前 i 个元素中的某一个为结尾的最长的下降摆动序列的长度。\n\n状态转移方程：考虑第 i 个元素，如果nums[i] > nums[i-1]，则该元素可以加入下降摆动序列形成上升摆动序列dp[i][0] = max(dp[i-1][0],dp[i-1][1] + 1)，但是该元素加入上升摆动序列并不会形成下降摆动序列dp[i][1] = dp[i-1][1]；如果nums[i] < nums[i-1]，则该元素可以加入上升摆动序列形成下降摆动序列dp[i][1] = max(dp[i-1][1],dp[i-1][0] + 1)，如果该元素加入下降摆动序列并不会形成上升摆动序列所以dp[i][0] = dp[i-1][0]；如果nums[i] == nums[i-1]那么可以直接跳过该元素dp[i][0] = dp[i-1][0], dp[i][1] = dp[i-1][1]。\n\n初始情况：当只有一个元素时，该元素既是上升摆动序列也是下降摆动序列，dp[0][j] = 1;\n\nclass solution {\npublic:\n    int wigglemaxlength(vector<int>& nums) {\n        int len = nums.size();\n        if(len < 2) return len;\n        vector<vector<int>> dp(len,vector<int>(2,1));\n        int ans = 1;\n        for(int i=1;i<len;++i){\n            if(nums[i] < nums[i-1]){\n                dp[i][0] = dp[i-1][0];\n                dp[i][1] = max(dp[i-1][1],dp[i-1][0] + 1);\n            }else if(nums[i] > nums[i-1]){\n                dp[i][0] = max(dp[i-1][0],dp[i-1][1] + 1);\n                dp[i][1] = dp[i-1][1];\n            }else{\n                dp[i][0] = dp[i-1][0];\n                dp[i][1] = dp[i-1][1];\n            }\n            ans = max(ans,max(dp[i][0],dp[i][1]));\n        }\n        return ans;\n    }\n};\n\n\n本题也可以采用贪心策略解决，使用极值构成最长摆动序列。\n\n# 1143 最长公共子序列\n\n给定两个字符串，求它们最长的公共子序列长度。\n\n输入是两个字符串，输出是一个整数，表示它们满足题目条件的长度。\n\n> 输入：text1 = "abcde", text2 = "ace" \n> 输出：3  \n> 解释：最长公共子序列是 "ace" ，它的长度为 3 。\n\n解析:\n\n设置状态：建立一个二维数组 dp，其中 dp[i][j] 表示到第一个字符串位置 i 为止、到第二个字符串位置 j 为止、最长的公共子序列长度。\n\n状态转移方程：从1开始计算字符串位置，那么当text1 的第 i 个字符与 text2 的第 j 个字符相等时，其最长公共子串长度为前一状态加1，即 dp[i][j] = dp[i-1][j-1] + 1；如果不相等，dp[i][j] 不会比dp[i-1][j] 和dp[i][j-1] 两者之中任何一个小，也不会比两者都大，即 dp[i][j] = max(dp[i-1][j],dp[i][j-1])\n\n初始情况：任一个字符串为空串则最长公共子序列的长度都为0，即dp[0][j] = dp[i][0] = 0\n\nclass solution {\npublic:\n    int longestcommonsubsequence(string text1, string text2) {\n        int len1 = text1.length(), len2 = text2.length();\n        // 创建len+1行len2+1列的二维数组 dp，其中 dp[i][j] 表示 text1[0:i] 和 text2[0:j] 的最长公共子序列的长度\n        vector<vector<int>> dp(len1+1,vector<int>(len2+1));\n        for(int i=1;i<=len1;++i){\n            for(int j=1;j<=len2;++j){\n                // 相等情况\n                if(text1[i-1]==text2[j-1]){\n                    dp[i][j] = dp[i-1][j-1] + 1;\n                // 不等情况\n                }else{\n                    dp[i][j] = max(dp[i-1][j],dp[i][j-1]);\n                }\n            }\n        }\n        return dp[len1][len2];\n    }\n};\n\n\n# 583 两个字符串的删除操作\n\n给定两个字符串，求它们通过删除操作变成相同的最小步骤。\n\n输入是两个字符串，输出是一个整数，表示它们通过删除操作变成相同的最小步骤数。\n\n> 输入: "sea", "eat"\n> 输出: 2\n> 解释: 第一步将"sea"变为"ea"，第二步将"eat"变为"ea"\n\n解析:\n\n本题是最长公共子序列的一种变种题，可以直接求出最长公共子序列后用较长一个字符串的长度减去最长公共子序列的长度。\n\nclass solution {\npublic:\n    int mindistance(string word1, string word2) {\n        int m = word1.length(), n = word2.length();\n        vector<vector<int>> dp(m+1,vector<int>(n+1));\n        for(int i=1;i<=m;++i){\n            for(int j=1;j<=n;++j){\n                if(word1[i-1] == word2[j-1]){\n                    dp[i][j] = dp[i-1][j-1] + 1;\n                }else{\n                    dp[i][j] = max(dp[i-1][j],dp[i][j-1]);\n                }\n            }\n        }\n        int lcs = dp[m][n];\n        return m+n-2*lcs;\n    }\n};\n\n\n\n# 05 背包问题\n\n背包问题：有 n 个物品和容量为 w 的背包，每个物品都有自己的体积 w 和价值 v，求拿哪些物品可以使得背包所装下物品的总价值最大。如果限定每种物品只能选择 0 个或 1 个，则问题称为 0-1 背包问题；如果不限定每种物品的数量，则问题称为完全背包问题。\n\n0-1 背包问题，我们可以定义一个二维数组 dp 存储最大价值，其中 dp[i][j] 表示前 i 件物品体积不超过 j 的情况下能达到的最大价值。在我们遍历到第 i 件物品时，在当前背包总容量为 j 的情况下，分为两种情况：（1）如果我们不将物品 i 放入背包，即当前背包容量不足或这放入当前物品无法达到最大价值，那么 dp[i][j]= dp[i-1][j]，即前 i 个物品的最大价值等于只取前 i -1 个物品时的最大价值；（2）如果我们将物品 i 放入背包，假设第 i 件物品体积为 w，价值为 v，那么我们得到 dp[i][j] = dp[i-1][j-w] + v。\n\nint knapsack(vector<int> weights, vector<int> values, int n, int w) {\n\tvector<vector<int>> dp(n+1,vector<int>(w+1));\n    // 放置第i个物品\n    for(int i=1;i<=n;++i){\n        // 第 i 个物品的体积w和价值v\n        int w = weights[i-1], v = values[i-1];\n        // 遍历容量\n        for(int j=1;j<=w;++j){\n            if(j>=w){\n                dp[i][j] = max(dp[i-1][j],dp[i-1][j-w]+v);\n            }else{\n                dp[i][j] = dp[i-1][j];\n            }\n        }\n    }\n    return dp[n][w];\n}\n\n\n在完全背包问题中，一个物品可以拿多次。这里直接给出完全背包问题的状态转移方程dp[i][j] = max(dp[i-1][j], dp[i][j-w] + v)，其与 0-1 背包问题的差别仅仅是把状态转移方程中的第二个 i-1 变成了 i。\n\nint knapsack(vector<int> weights, vector<int> values, int n, int w) {\n\tvector<vector<int>> dp(n+1,vector<int>(w+1));\n    // 放置第i个物品\n    for(int i=1;i<=n;++i){\n        // 第 i 个物品的体积w和价值v\n        int w = weights[i-1], v = values[i-1];\n        // 遍历容量\n        for(int j=1;j<=w;++j){\n            if(j>=w){\n                dp[i][j] = max(dp[i-1][j],dp[i][j-w]+v);\n            }else{\n                dp[i][j] = dp[i-1][j];\n            }\n        }\n    }\n    return dp[n][w];\n}\n\n\n# 416 分割等和子集\n\n给定一个正整数数组，求是否可以把这个数组分成和相等的两部分。\n\n输入是一个一维正整数数组，输出时一个布尔值，表示是否可以满足题目要求。\n\n> 输入：nums = [1,5,11,5]\n> 输出：true\n> 解释：数组可以分割成 [1, 5, 5] 和 [11] 。\n\n解析:\n\n本题等价于 0-1 背包问题，设所有数字和为 sum，我们的目标是选取一部分物品，使得它们的总和为 target = sum/2，及用部分物品填满容量为target的背包。同时本题不需要考虑价值，因此我们只需要通过一个布尔值矩阵来表示状态转移矩阵。\n\n设置状态： dp[i][j] 表示 nums 的前 i 个整数是否能够组合成和为 j\n\n状态转移方程：(01背包问题的子问题都很简单只用区分选择当前物品或者不选择当前物品的情况)\n\n * 不选择 nums[i]：nums[i] 大于于当前容量 j 时，容量不够不选择该物品，dp[i][j] = dp[i-1][j]\n\n * 选择 nums[i]：\n   \n   >  * nums[i] 恰好等于当前容量 j，即nums[i]==j时，只放该物品就可以填满容量为 j 的背包，dp[i][j] =true\n   >  * nums[i] 小于当前容量 j，即nums[i]<j时，只放该物品不够填满容量为 j 的背包，检测放入该物品后dp[i-1][j-nums[i]]的情况下是否可以填满背包\n   > \n   > 总的说，当容量足够时，物品nums[i] 可选可不选（在有价值的情况下就需要选择价值较大的情况），则dp[i][j] = dp[i-1][j] || dp[i-1][j-nums[i]]\n\n初始情况：容量为0的时候，不选择任何物品，dp[i][0] = true；只有一个物品的时候，当容量为j == nums[0]时恰好满足，即dp[0][nums[0]] = true\n\n示例的状态转移矩阵根据上述状态转移方程可以得到如下表格：\n\n           0   1   2   3   4   5   6   7   8   9   10   11\n[0] = 1    t   t   f   f   f   f   f   f   f   f   f    f\n[1] = 5    t   t   f   f   f   t   t   f   f   f   f    f\n[2] = 11   t   t   f   f   f   t   t   f   f   f   f    t\n[3] = 5    t   t   f   f   f   t   t   f   f   f   t    t\n\nclass solution {\npublic:\n    bool canpartition(vector<int>& nums) {\n        int sum = accumulate(nums.begin(),nums.end(),0);\n        auto maxpos = max_element(nums.begin(),nums.end());\n        int target = sum/2, len = nums.size();\n        // 注意特殊情况，和为奇数或者元素个数小与2都无法进行有效分割，而元素值大于target直接导致越界\n        if(len<2 || sum&1 || *maxpos > target){\n            return false;\n        }\n        vector<vector<bool>> dp(len,vector<bool>(target+1,false));\n        // 初始情况容量为0\n        for(int i=0;i<len;++i){\n            dp[i][0] = true;\n        }\n        // 初始情况物品只有一个\n        dp[0][nums[0]] = true;\n        for(int i=1;i<len;++i){\n            for(int j=1;j<=target;++j){\n                // 背包容量大于当前扫描物品，可选可不选\n                if(j >= nums[i]){\n                    dp[i][j] = dp[i-1][j] || dp[i-1][j-nums[i]];\n                // 背包容量小于当前扫描物品，没法选\n                }else{\n                    dp[i][j] = dp[i-1][j];\n                }\n            }\n        }\n        return dp[len-1][target];\n    }\n};\n\n\n# 494 目标和\n\n给定义一个整数数组 nums 和一个整数 target 。向数组中的每个整数前添加 \'+\' 或 \'-\' ，然后串联起所有整数，可以构造一个 表达式，返回可以完成表达式构造的、运算结果等于 target 的不同 表达式 的数目。\n\n输入一个一维数组和整数，输出一个整数表示构造表达式结果为target的方法数\n\n> 输入：nums = [1,1,1,1,1], target = 3 输出：5 解释：一共有 5 种方法让最终目标和为 3 。 -1 + 1 + 1 + 1 + 1 = 3 +1 - 1 + 1 + 1 + 1 = 3 +1 + 1 - 1 + 1 + 1 = 3 +1 + 1 + 1 - 1 + 1 = 3 +1 + 1 + 1 + 1 - 1 = 3\n\n解析：\n\n本题可以转化为 01 背包问题，假设数组元素总和为 sum，添加 \'+\'的元素和为 x，那么添加 \'-\'的元素和为 sum - x。由此可以得到 x - (sum - x) = target，即为x = (target + sum) / 2，那么本题就可以转化为使用 nums中的n个物品装满容量为 x 的背包，共有多少种方法，可以看出这时一个组合问题。\n\n设置状态：使用一个二维数组 dp[i][j] 表示数组 nums 中从开头到以 i 位置结尾的所有物品装满容量为 j 的背包的方法数。\n\n状态转移方程：考虑第 i 个元素，如果当前背包容量 j<nums[i]，则不能放入第 i 个元素 dp[i][j] = dp[i-1][j]；如果当前背包容量j >= nums[i]，不放入第 i 个元素的方法数为dp[i][j] = dp[i-1][j]，放入第 i 个元素的方法数为dp[i][j] = dp[i-1][j-nums[i]]，那么总的方法数为这两中情况之和即dp[i][j] = dp[i-1][j] + dp[i-1][j-nums[i]]\n\n边界情况：如果(target + sum)不为偶数是无解情况，如果 abs(target) > sum 也是无解情况，没有任何构造方式能够满足题目条件。当数组为空，背包容量为0时dp[0][0] == 1\n\nclass solution {\npublic:\n    int findtargetsumways(vector<int>& nums, int target) {\n        int len = nums.size();\n        int sum = accumulate(nums.begin(),nums.end(),0);\n        if((target+sum)&1 || abs(target)>sum){\n            return 0;\n        }\n        int weight = (target + sum)/2;\n        vector<vector<int>> dp(len+1,vector<int>(weight+1));\n        dp[0][0] = 1;\n        for(int i=1;i<=len;++i){\n            for(int j=0;j<=weight;++j){\n                dp[i][j] = dp[i-1][j];\n                if(j>=nums[i-1]){\n                    dp[i][j] = dp[i-1][j] + dp[i-1][j-nums[i-1]];\n                }\n            }\n        }\n        return dp[len][weight];\n    }\n};\n\n\n# 474 一和零\n\n给定 m 个数字 0 和 n 个数字 1，以及一些由 0-1 构成的字符串，求利用这些数字最多可以构成多少个给定的字符串，字符串只可以构成一次。\n\n输入两个整数 m 和 n，表示 0 和 1 的数量，以及一个一维字符串数组，表示待构成的字符串；输出是一个整数，表示最多可以生成的字符串个数。\n\n> 输入：strs = ["10", "0001", "111001", "1", "0"], m = 5, n = 3 输出：4 解释：最多有 5 个 0 和 3 个 1 的最大子集是 {"10","0001","1","0"} ，因此答案是 4 。其他满足题意但较小的子集包括 {"0001","1"} 和 {"10","1","0"} 。{"111001"} 不满足题意，因为它含 4 个 1 ，大于 n 的值 3 。\n\n解析：\n\n本题也是一个01背包问题，而其特点在于它有两个背包，一个装0，另一个装1。\n\n设置状态：dp[i][j][k] 表示装0背包容量为 j，装1背包容量为k的情况下，能够装入前 i 个物品中的几个\n\n状态转移方程：仍旧划为装入当前物品和不装入当前物品两个子问题，不装入则dp[i][j][k]=dp[i-1][j][k]，装入则dp[i][j][k]=max(dp[i-1][j][k],dp[i-1][j-w0[i]][k-w1[i]] + 1)，其中w0表示物品中0的体积，w1表示物品中1的体积。\n\nclass solution {\npublic:\n\n    // 计算每个str中0和1的数量\n    pair<int,int> countweight(string str){\n        int count0 = 0, count1 = 0;\n        for(int i=0;i<str.length();++i){\n            if(str[i] == \'0\'){\n                ++count0;\n            }else{\n                ++count1;\n            }\n        }\n        return make_pair(count0,count1);\n    }\n\n    int findmaxform(vector<string>& strs, int m, int n) {\n        int len = strs.size();\n        // 用一个三维数组表示在前 i 个字符串中，使用 j 个 0 和 k 个 1 的情况下最多可以得到的字符串数量\n        vector<vector<vector<int>>> dp(len+1,vector<vector<int>>(m+1,vector<int>(n+1)));\n        for(int i=1;i<=len;++i){\n            auto count = countweight(strs[i-1]);\n            // j 和 k 都从零开始，因为str存在\'0\'或\'1\'这种只有一种元素构成的情况\n            for(int j=0;j<=m;++j){\n                for(int k=0;k<=n;++k){\n                    if(j >= count.first && k >= count.second){\n                        dp[i][j][k] = max(dp[i-1][j][k],dp[i-1][j-count.first][k-count.second] + 1);\n                    }else{\n                        dp[i][j][k] = dp[i-1][j][k];\n                    }\n                }\n            }\n        }\n        return dp[len][m][n];\n    }\n};\n\n\n# 322 零钱兑换\n\n给定一些硬币的面额，求最少可以用多少颗硬币组成给定的金额。\n\n输入一个一维整数数组，表示硬币的面额；以及一个整数，表示给定的金额。输出一个整数，表示满足条件的最少的硬币数量。若不存在解，则返回-1。\n\n> 输入：coins = [1, 2, 5], amount = 11\n> 输出：3 \n> 解释：11 = 5 + 5 + 1\n\n解析：\n\n因为每个硬币可以用无限多次，这道题本质上是完全背包问题。完全背包问题还是没搞懂，记录一下，以后仔细琢磨。\n\nclass solution {\npublic:\n    int coinchange(vector<int>& coins, int amount) {\n        int max = amount + 1;\n        vector<int> dp(amount + 1, max);\n        dp[0] = 0;\n        for (int i = 1; i <= amount; ++i) {\n            for (int j = 0; j < (int)coins.size(); ++j) {\n                if (coins[j] <= i) {\n                    dp[i] = min(dp[i], dp[i - coins[j]] + 1);\n                }\n            }\n        }\n        return dp[amount] > amount ? -1 : dp[amount];\n    }\n};\n\n\n\n# 06 字符串编辑问题\n\n# 72 编辑距离\n\n给定两个字符串，已知你可以删除、替换和插入任意字符串的任意字符，求最少编辑几步可以将两个字符串变成相同。\n\n输入是两个字符串，输出是一个整数，表示最少的步骤。\n\n> 输入：word1 = "horse", word2 = "ros" 输出：3 解释： horse -> rorse (将 \'h\' 替换为 \'r\') rorse -> rose (删除 \'r\') rose -> ros (删除 \'e\')\n\n解析：\n\n本题与最长公共子序列类似，两个字符串的对比所以需要使用一个二维数组来设置状态 dp[i][j]\n\n设置状态：dp[i][j] 表示将第一个字符串到位置 i 为止，和第二个字符串到位置 j 为止，最多需要几步编辑。\n\n状态转移方程：当第 i 位和第 j 位对应的字符相同时，dp[i][j] 等于 dp[i-1][j-1]；当二者对应的字符不同时，修改的消耗是 dp[i-1][j-1]+1，插入 i 位置/删除 j 位置的消耗是 dp[i][j-1] + 1，插入 j 位置/删除 i 位置的消耗是 dp[i-1][j] + 1，所以在不同的情况下状态转移方程dp[i][j] = min(dp[i-1][j-1],dp[i-1][j],dp[i][j-1])。\n\n边界情况：word1为空串时，需要插入字符与word2一致，即dp[0][j] = j；同理，word2为空串是dp[i][0] = i\n\nclass solution {\npublic:\n    int mindistance(string word1, string word2) {\n        int m = word1.length(), n = word2.length();\n        vector<vector<int>> dp(m+1,vector<int>(n+1));\n        // 边界条件 word2为空串\n        for(int i=0;i<=m;++i){\n            dp[i][0] = i;\n        }\n        // 边界条件 word1为空串\n        for(int j=0;j<=n;++j){\n            dp[0][j] = j;\n        }\n        for(int i=1;i<=m;++i){\n            for(int j=1;j<=n;++j){\n                // 状态转移，相等情况不编辑，不等情况选择编辑次数最少的编辑\n                if(word1[i-1] == word2[j-1]){\n                    dp[i][j] = dp[i-1][j-1];\n                }else{\n                    dp[i][j] = min(dp[i-1][j-1],min(dp[i-1][j],dp[i][j-1])) + 1;\n                }\n            }\n        }\n        return dp[m][n];\n    }\n};\n\n\n# 650 只有两个键的键盘\n\n给定一个字母 a，已知你可以每次选择复制全部字符，或者粘贴之前复制的字符，求最少需要几次操作可以把字符串延展到指定长度。\n\n输入是一个正整数，代表指定长度；输出是一个整数，表示最少操作次数。\n\n> 输入：3 输出：3 解释： 最初, 只有一个字符 \'a\'。 第 1 步, 使用 copy all 操作。 第 2 步, 使用 paste 操作来获得 \'aa\'。 第 3 步, 使用 paste 操作来获得 \'aaa\'。\n\n解析：\n\n不同于以往通过加减实现的动态规划，这里需要乘除法来计算位置，因为粘贴操作是倍数增加的。\n\n设置状态：使用一个一维数组 dp[i]，其中位置 i 表示延展到长度 i 的最少操作次数。\n\n状态转移方程：对于每个位置 j，如果 j 可以被 i 整除，那么长度 i 就可以由长度 j 操作得到，其操作次数等价于把一个长度为 1 的 a 延展到长度为 i/j。例如3由1操作得到a a a，6由2操作得到aa aa aa因此可以得到递推公式 dp[i] = dp[j] + dp[i/j]。\n\nclass solution {\npublic:\n    int minsteps(int n) {\n        vector<int> dp(n+1);\n        for(int i=2;i<=n;++i){\n            dp[i] = i;\n            for(int j=2;j<=i;++j){\n                if(i%j==0){\n                    dp[i] = dp[j] + dp[i/j];\n                    break;\n                }\n            }\n        }\n        return dp[n];\n    }\n};\n\n\n# 10 正则表达式匹配\n\n给定一个字符串和一个正则表达式（regular expression, regex），求该字符串是否可以被匹配，其中\'.\' 匹配任意单个字符；\'*\' 匹配零个或多个前面的那一个元素。\n\n输入是一个待匹配字符串和一个用字符串表示的正则表达式，输出是一个布尔值，表示是否可以匹配成功。\n\n> 输入：s = "aab" p = "cab" 输出：true 解释：因为 \'*\' 表示零个或多个，这里 \'c\' 为 0 个, \'a\' 被重复一次。因此可以匹配字符串 "aab"。\n\n解析：\n\n两个字符串进行匹配，且字符具有特殊含义，本题动态规划的特点在于多种情况下的不同状态转移方程。\n\n设置状态：使用一个布尔类型的二维数组 dp，其中 dp[i][j] 表示以 i 截止的字符串是否可以被以 j 截止的正则表达式匹配。\n\n状态转移方程：根据正则表达式的不同情况，即字符、星号，点号，分情况讨论来更新 dp 数组\n\n * 相等情况：即s[i-1] == p[j-1] || p[j-1] == \'.\'的情况，这种情况下dp[i][j] == dp[i-1][j-1]，即与前 i-1 个子串匹配情况一致\n\n * 不相等情况：\n   \n   >  * s[i-1] != p[j-1] && p[j-1] != \'*\' ，直接不匹配情况dp[i][j] = false\n   >  * p[j-1] == \'*\'：如果匹配0次则dp[i][j-2] == true 则 dp[i][j] = true；如果匹配多次则需要验证\'*\'前一个字符相等情况即s[i-1] == p[j-1] || p[j-1] == \'.\'，相等则dp[i][j] = dp[i-1][j]，否则不匹配\n\n初始情况：空串匹配非空正则表达式，dp[0][0]=true，当p[j-1]==\'*\'是可以匹配0次匹配空串即dp[0][j] =dp[0][j-2]；非空串匹配空正则表达式，dp[0][0]=true，其他情况都无法成功匹配。\n\nclass solution {\npublic:\n    bool ismatch(string s, string p) {\n        int m = s.size(), n = p.size();\n        vector<vector<bool>> dp(m+1,vector<bool>(n+1,false));\n        dp[0][0] = true;\n        for(int j=1;j<=n;++j){\n            if(p[j-1] == \'*\'){\n                dp[0][j] = dp[0][j-2];\n            }\n        }\n\n        for(int i=1;i<=m;++i){\n            auto chs = s[i-1]; \n            for(int j=1;j<=n;++j){\n                auto chp = p[j-1];\n                if(chs == chp || chp == \'.\'){\n                    dp[i][j] = dp[i-1][j-1];\n                }else if(chp ==  \'*\'){\n                    if(j>1){\n                        if(dp[i][j-2]){\n                            dp[i][j] = true;\n                        }else{\n                            auto prechp = p[j-2];\n                            if(prechp==chs || prechp ==\'.\'){\n                                dp[i][j] = dp[i-1][j];\n                            } \n                        }\n                    }\n                }\n            }\n        }\n        return dp[m][n];\n    }\n};\n\n\n\n# 07 股票交易问题\n\n股票交易类问题通常可以用动态规划来解决。对于稍微复杂一些的股票交易类问题，比如需要冷却时间或者交易费用，则可以用通过动态规划实现的状态机来解决。\n\n题目                  特点\n121 买卖股票的最佳时机       只能买卖一次\n122 买卖股票的最佳时机 ii    可以买卖多次\n714 买卖股票的最佳时机含手续费   可以买卖多次，每次都有手续费\n123 买卖股票的最佳时机 iii   最多买卖两次\n188 买卖股票的最佳时机 iv    最多买卖 k 次\n309 最佳买卖股票时机含冷冻期    可以买卖多次，但是卖出有一天冷冻期\n\n# 121 买卖股票的最佳时机\n\n给定一段时间内每天的股票价格，已知你只可以买卖各一次，求最大的收益。\n\n输入一个一维整数数组，表示每天的股票价格；输出一个整数，表示最大的收益。\n\n> 输入：[7,1,5,3,6,4] 输出：5 解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5\n\n解析：\n\n求最大利润本质是也是一个优化问题，所以可以采用动态规划的思路解决。\n\n设置状态：用两个动态规划数组buy[i] 表示第 i 天持股时的现金数，sell[i]表示第 i 天不持股时的现金数\n\n状态转移方程：第 i 天持股 buy[i] = max(buy[i-1],-prices[i])，如果第 i-1 天不持股则花费-prices[i]的现金买入股票，如果第i-1天持股，则保持不变；第 i 天不持股 sell[i] = max(sell[i-1],buy[i-1]+prices[i])，如果第 i-1 天也不持股那么情况不变，如果第 i-1 天持股则需要将其卖出产生收益buy[i-1]+prices[i]。\n\n初始情况：第 1 天不持股sell[0] = 0；第 1 天持股buy[0] = -prices[0]\n\nclass solution {\npublic:\n    int maxprofit(vector<int>& prices) {\n        int len = prices.size();\n        if(len<2) return 0;\n        vector<int> sell(len);\n        vector<int> buy(len);\n        sell[0] = 0;\n        buy[0] = -prices[0];\n        for(int i=1;i<len;++i){\n            buy[i] = max(buy[i-1],-prices[i]);\n            sell[i] = max(sell[i-1],buy[i-1]+prices[i]);\n        }\n        return sell[len-1];\n    }   \n}\n\n\n本题也可以用更直接的方法解决，遍历一遍数组，在每一个位置 i 时，记录 i 位置之前所有价格中的最低价格，然后将当前的价格作为售出价格，查看当前收益是不是最大收益，一遍遍历完成后就可以得到最大收益。\n\nclass solution {\npublic:\n    int maxprofit(vector<int>& prices) {\n        int sell = 0, buy = int_max;\n        for(int i=0;i<prices.size();++i){\n            buy = min(buy,prices[i]);\n            sell = max(sell,prices[i]-buy);\n        }\n        return sell;\n    }\n};\n\n\n# 122 买卖股票的最佳时机 ii\n\n给定一段时间内每天的股票价格，已知你只可以多次买卖一支股票，求最大的收益。\n\n输入一个一维整数数组，表示每天的股票价格；输出一个整数，表示最大的收益。\n\n> 输入：[7,1,5,3,6,4] 输出：5 解释：在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6 - 3 = 3 。\n\n解析：\n\n本题和上一题的区别在于可以多次买卖，也可以采用动态规划的思路来解决。\n\n设置状态：除了用两个数组分别表示股票持股与不持股情况，也可以使用一个二维数组dp[i][j]来表示，其中 i 表示交易的时间，j 表示交易状态即买入或卖出 ，0 表示买入状态、1表示卖出状态；dp[i][0]表示第 i 天持股时的现金数，dp[i][1] 表示第 i 天不持股时的现金数。值得注意的是dp[i][0]，表示的是第i天，买入股票的状态，并不是说一定要第i天买入股票，dp[i][1]亦同\n\n状态转移方程：本题的状态转移方程和上一题的唯一区别在于第 i 天持股的情况，如果第 i-1 天也持股那么保持一致，如果第 i-1 天不持股由于可以进行多次交易，那么就需要在已获得收益的基础上花费-prices[i]的现金买入股票即dp[i][0] = max(dp[i-1][0],dp[i-1][1] - prices[i])。\n\n初始情况：第 1 天持股dp[0][0] = -prices[0]，第 1 天不持股dp[0][1] = 0\n\nclass solution {\npublic:\n    int maxprofit(vector<int>& prices) {\n        int len = prices.size();\n        if(len<2) return 0;\n        vector<vector<int>> dp(len,vector<int>(2));\n        dp[0][0] = -prices[0];\n        dp[0][1] = 0;\n        for(int i=1;i<len;++i){\n            dp[i][0] = max(dp[i-1][0],dp[i-1][1] - prices[i]);\n            dp[i][1] = max(dp[i-1][1],dp[i-1][0] + prices[i]);\n        }\n        return dp[len-1][1];\n    }\n};\n\n\n本题可以采用贪心策略，由于不限制交易次数，只要今天股价比昨天高，就交易。\n\nclass solution {\npublic:\n    int maxprofit(vector<int>& prices) {\n        int sum = 0;\n        for(int i=1;i<prices.size();++i){\n            if(prices[i]>prices[i-1]){\n                sum+=(prices[i]-prices[i-1]);\n            }\n        }\n        return sum;\n    }\n};\n\n\n# 714 买卖股票的最佳时机含手续费\n\n给定一段时间内每天的股票价格，已知每次交易都需要扣除fee的手续费，且每次只能拥有一支股票，求最大的收益。\n\n输入一个一维整数数组，表示每天的股票价格；输出一个整数，表示最大的收益。\n\n> 输入：prices = [1, 3, 2, 8, 4, 9], fee = 2 输出：8 解释：能够达到的最大利润 ((8 - 1) - 2) + ((9 - 4) - 2) = 8\n\n解析：\n\n本题本质上和122可多次交易并没有什么差别，主要的问题是需要考虑过多次数的交易可能会产生大量手续费，直接导致总的收益不如交易次数较少的利润。\n\n设置状态：使用一个二维数组dp[i][j]来表示，其中 i 表示交易的时间，j 表示交易状态即买入或卖出 ，0 表示买入状态、1表示卖出状态；dp[i][0]表示第 i 天持股时的现金数，dp[i][1] 表示第 i 天不持股时的现金数。\n\n状态转移方程：本题与122题状态转移方程的主要区别在于第 i 天不持股的情况，如果第 i-1 天也不持股那么保持一致，如果第 i-1 天持股，那么就需要将其卖出产生buy[i-1]+prices[i]的收益，同时需要从收益中扣除fee的手续费。得到第 i 天不持股情况的状态转移方程dp[i][1] = max(dp[i-1][1],dp[i-1][0] + prices[i] - fee)\n\n初始情况：第 1 天持股dp[0][0] = -prices[0]，第 1 天不持股dp[0][1] = 0\n\nclass solution {\npublic:\n    int maxprofit(vector<int>& prices, int fee) {\n        int len = prices.size();\n        if(len < 2) return 0;\n        vector<vector<int>> dp(len,vector<int>(2));\n        dp[0][0] = -prices[0];\n        dp[0][1] = 0;\n        for(int i=1;i<len;++i){\n            dp[i][0] = max(dp[i-1][0],dp[i-1][1] - prices[i]);\n            dp[i][1] = max(dp[i-1][1],dp[i-1][0] + prices[i] - fee);\n        }\n        return dp[len-1][1];\n    }\n};\n\n\n# 123 买卖股票的最佳时机 iii\n\n给定一段时间内每天的股票价格，已知你最多可以进行两次买卖一支股票，求最大的收益。\n\n输入一个一维整数数组，表示每天的股票价格；输出一个整数，表示最大的收益。\n\n> 输入：prices = [3,3,5,0,0,3,1,4] 输出：6 解释：在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。\n\n解析：\n\n本题限制了交易次数最多为两次买卖，那么就要对这两次交易操作进行区分，所以一天的交易就不再是前两题中持股和不持股两种状态，而是要在此基础上区分第一次交易持股状态和第二次交易持股状态。\n\n设置状态：使用一个二维数组dp[i][j]来表示，其中 i 表示交易的时间，j 为0～3表示交易状态。例如dp[i][0]表示第一次买入状态、dp[i][1]表示第一次卖出状态、dp[i][2]表示第二次买入状态、dp[i][3]表示第二次卖出状态。\n\n状态转移方程：\n\n>  * 第一次交易的状态转移方程与121的单次交易一致，如果第一次第 i 天持股dp[i][0] = max(dp[i-1][0],- prices[i])，第 i-1 天不持股则需要花费-prices[i]的现金买入股票达成买入状态，如果第i-1天持股，则保持不变；\n>  * 如果第一次第 i 天不持股dp[i][1] = max(dp[i-1][1],dp[i-1][0] + prices[i])，第 i-1 天也不持股那么情况不变，如果第 i-1 天持股则需要将其卖出达成卖出状态并产生收益prices[i]。\n>  * 第二次交易的状态转移方程则与122的多次交易大致相同，如果第二次交易第 i 天持股dp[i][2] = max(dp[i-1][2],dp[i-1][1] - prices[i])，如果第 i-1 天也持股那么不进行操作，如果第 i-1 天不持股则需要在第一次交易完成的基础上花费prices[i]的现金买入股票达成持股或买入状态；\n>  * 如果第 i 天为卖不持股或卖出状态dp[i][3] = max(dp[i-1][3],dp[i-1][2] + prices[i])，如果第 i-1 天不持股第 i-1 天也不持股那么情况不变，如果第 i-1 天持股则需要将其卖出达成卖出状态并产生收益prices[i]。\n\n初始情况：第 1 天持股dp[0][0] = -prices[0], dp[0][1] = -prices[0]，第 1 天不持股dp[0][1] = 0, dp[0][3] = 0\n\nclass solution {\npublic:\n    int maxprofit(vector<int>& prices) {\n        int len = prices.size();\n        if(len<2) return 0;\n        vector<vector<int>> dp(len,vector<int>(4));\n        dp[0][0] = -prices[0];\n        dp[0][2] = -prices[0];\n        dp[0][1] = 0;\n        dp[0][3] = 0;\n        for(int i=1;i<len;++i){\n            dp[i][0] = max(dp[i-1][0],-prices[i]);\n            dp[i][1] = max(dp[i-1][1],dp[i-1][0]+prices[i]);\n            dp[i][2] = max(dp[i-1][2],dp[i-1][1]-prices[i]);\n            dp[i][3] = max(dp[i-1][3],dp[i-1][2]+prices[i]);\n        }\n        return dp[len-1][3];\n    }\n};\n\n\n# 188 买卖股票的最佳时机 iv\n\n给定一段时间内每天的股票价格，已知你最多可以进行 k 次买卖一支股票，求最大的收益。\n\n输入一个一维整数数组，表示每天的股票价格；输出一个整数，表示最大的收益。\n\n> 输入：k = 2, prices = [3,2,6,5,0,3] 输出：7 解释：在第 2 天 (股票价格 = 2) 的时候买入，在第 3 天 (股票价格 = 6) 的时候卖出, 这笔交易所能获得利润 = 6-2 = 4 。随后，在第 5 天 (股票价格 = 0) 的时候买入，在第 6 天 (股票价格 = 3) 的时候卖出, 这笔交易所能获得利润 = 3-0 = 3 。\n\n解析：\n\n本题限制了交易次数最多为 k 次，那么就要根据 k 值大小区分不同情况，如果 k 大于数组长度那么就可以类比122题相当于可以不限次数交易；如果 k 小于数组长度那么就可以类比为123题有限次数交易求最大利润。\n\n设置状态：还是使用一个二维数组dp[i][j]来记录所剩余的现金，其中 i 表示交易的时间，j 为表示交易状态。类比123题本题的不同在于交易次数是变化的，交易状态难以表征，但是我们也可以总结出规律，可以使用偶数表示买入状态，奇数表示卖出状态。\n\n状态转移方程：本题的状态转移方程可以直接类比123题，区别在于次数是变化的。\n\n初始情况：即所有交易次数中第一天不持股时为0，持股则为-prices[i]\n\nclass solution {\npublic:\n    int maxprofit(int k, vector<int>& prices) {\n        int len = prices.size();\n        // 临界情况 k <= 0 || k >= len\n        if(len < 2 || k <= 0) return 0;\n        if(len <= k){\n            return unlimitedtimes(prices);\n        }\n        // 一般情况 0 < k && k < len\n        vector<vector<int>> dp(len,vector<int>(2*k));\n        // 初始情况\n        for(int i=0;i<2*k;++i){\n            if(i&1){\n                dp[0][i] = 0;\n            }else{\n                dp[0][i] = -prices[0];\n            }\n        }\n        \n        for(int i=1;i<len;++i){\n            // 第一次买入状态\n            dp[i][0] = max(dp[i-1][0],-prices[i]);\n            for(int j=1;j<2*k;++j){\n                if(j&1){\n                    // 卖出状态转移方程\n                    dp[i][j] = max(dp[i-1][j],dp[i-1][j-1]+prices[i]);\n                }else{\n                    // 买入状态转移方程\n                    dp[i][j] = max(dp[i-1][j],dp[i-1][j-1]-prices[i]);\n                }\n            }\n        }\n        return dp[len-1][2*k-1];\n    }\n\n    // 可以进行多次交易的贪心实现\n    int unlimitedtimes(vector<int>& prices){\n        int len = prices.size();\n        int sum = 0;\n        for(int i=1;i<len;++i){\n            if(prices[i]>prices[i-1]){\n                sum += (prices[i] - prices[i-1]);\n            }\n        }\n        return sum;\n    }\n};\n\n\n# 309 最佳买卖股票时机含冷冻期\n\n给定一段时间内每天的股票价格，已知每次卖出之后必须冷却一天，且每次只能拥有一支股票，求最大的收益。\n\n输入一个一维整数数组，表示每天的股票价格；输出一个整数，表示最大的收益。\n\n> 输入: [1,2,3,0,2]\n> 输出: 3 \n> 解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]\n\n解析：\n\n我们可以使用状态机来解决这类复杂的状态转移问题，通过建立多个状态以及它们的转移方式，我们可以很容易地推导出各个状态的转移方程。如图所示，我们可以建立四个状态来表示带有冷却的股票交易，以及它们的之间的转移方式。\n\n其中分为买入状态buy、卖出状态sell、买入后状态s1和卖出后状态s2（状态的划分本人也没有搞清楚，仅仅凭个人理解进行划分，如有错误感谢指正）\n\n * 买入状态：即通过买入股票达到的买入状态\n * 买入后状态：买入大于等于两天后的持股状态，一直没操作，保持持股\n * 卖出状态：通过卖出持有的股票达到卖出状态，可以从买入状态直接操作卖出股票进入卖出状态，也可以在买入之后的持有多天后卖出股票进入卖出状态，这两个过程都会产生收益\n * 卖出后状态：度过了冷冻期，大于等于两天前就卖出了股票，一直没操作，保持不持股\n\n设置状态：使用一个二维数组dp[i][j]来表示，其中 i 表示交易的时间，j 为0～3表示交易状态。例如dp[i][0]表示买入状态、dp[i][1]表示不操作状态、dp[i][2]表示卖出状态、dp[i][3]表示卖出后状态。\n\n状态转移方程：\n\n>  * 买入状态dp[i][0] = dp[i-1][3] - prices[i]，卖出后状态下所持有的现金中花费prices[i]买入股票达到买入状态。\n>  * 买入后状态dp[i][1] = max(dp[i-1][0],dp[i-1][1])，可以通过买入状态到达，也可以不操作，保持原先持股状态。\n>  * 卖出状态dp[i][2] = max(dp[i-1][0],dp[i-1][1]) + prices[i]，可以买入后第二天直接卖出股票到达卖出状态，也可以持有多天后再卖出股票达到卖出状态。\n>  * 卖出后状态dp[i][3] = max(dp[i-1][2],dp[i-1][3])，可以通过卖出状态到达，也可以不操作，保持原先不持股状态。\n\n初始情况：第一天不持股时为dp[0][2] = 0, dp[0][3] = 0，持股则为dp[0][0] = -prices[i], dp[0][1] = -prices[i]\n\nclass solution {\npublic:\n    int maxprofit(vector<int>& prices) {\n        int len = prices.size();\n        if(len < 2) return 0;\n        vector<vector<int>> dp(len,vector<int>(4));\n        dp[0][0] = dp[0][1] = -prices[0];\n        dp[0][2] = dp[0][3] = 0;\n        for(int i=1;i<len;++i){\n            dp[i][0] = dp[i-1][3] - prices[i];\n            dp[i][1] = max(dp[i-1][0],dp[i-1][1]);\n            dp[i][2] = max(dp[i-1][0],dp[i-1][1]) + prices[i];\n            dp[i][3] = max(dp[i-1][2],dp[i-1][3]);\n        }\n        return max(dp[len-1][2],dp[len-1][3]);\n    }\n};\n',charsets:{cjk:!0},lastUpdated:"2023/11/19, 12:55:48",lastUpdatedTimestamp:1700369748e3},{title:"03归并排序",frontmatter:{title:"03归并排序",date:"2023-03-24T18:39:49.000Z",permalink:"/pages/832c90/"},regularPath:"/03.LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/01.%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/03.%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/03.%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F.html",relativePath:"03.LeetCode刷题笔记/01.基础算法/03.排序算法/03.归并排序.md",key:"v-5f9bf296",path:"/pages/832c90/",headers:[{level:2,title:"03 归并排序",slug:"_03-归并排序",normalizedTitle:"03 归并排序",charIndex:2},{level:3,title:"归并排序简介",slug:"归并排序简介",normalizedTitle:"归并排序简介",charIndex:14},{level:4,title:"493 翻转对",slug:"_493-翻转对",normalizedTitle:"493 翻转对",charIndex:1156},{level:4,title:"148 排序链表",slug:"_148-排序链表",normalizedTitle:"148 排序链表",charIndex:4539}],headersStr:"03 归并排序 归并排序简介 493 翻转对 148 排序链表",content:"# 03 归并排序\n\n\n# 归并排序简介\n\n算法思想：\n\n归并排序的核心思想是采用分治策略，将整个数组的排序任务分类为两个子问题，前一半排序和后一半排序，然后整合两个有序部分完成整体排序。即把数组分为若干个子序列，直到单个元素组成一个序列，然后将各阶段得到的序列组合在一起得到最终完整排序序列。\n\n归并排序任务可以如下分治完成：\n\n1. 把前一半排序\n2. 把后一半排序\n3. 把两半归并到一个新的有序数组，然后再拷贝回原数组，排序完成。\n\n\n执行样例：\n\n输入：[29,10,14,37,14,25,10]\n\n\n\n算法实现：\n\n// 将数组 a 的局部 a[s,m] 和 a[m+1,e] 合并到 tmp, 并保证 tmp 有序，然后再拷贝回 a[s,m]\nvoid merge(vector<int>& arr, int start, int mid, int end, vector<int> tmp){\n    int pTmp = 0;\n    int pLeft = start; int pRight = mid+1;\n    while(pLeft<=mid&&pRight<=end){\n        if(arr[pLeft] < arr[pRight]){\n            tmp[pTmp++] = arr[pLeft++];\n        }else{\n            tmp[pTmp++] = arr[pRight++];\n        }\n    }\n    while(pLeft<=mid){\n        tmp[pTmp++] = arr[pLeft++];\n    }\n    while (pRight<=end)\n    {\n        tmp[pTmp++] = arr[pRight++];\n    }\n    for(int i=0;i<pTmp;i++){\n        arr[start+i] = tmp[i];\n    }\n}\n\n// 归并排序递归调用，先排前半部分，在排后半部分，最后将两部分结果合并\nvoid mergeSort(vector<int>& arr, int start, int end, vector<int> tmp){\n    if(start < end){\n        int mid = start + (end-start)/2;\n        mergeSort(arr,start,mid,tmp);\n        mergeSort(arr,mid+1,end,tmp);\n        merge(arr,start,mid,end,tmp);\n    }\n}\n\n\n# 493 翻转对\n\n给定一个数组 nums ，如果 i < j 且 nums[i] > 2*nums[j] 就将 (i,j) 称作一个翻转对，返回给定数组中翻转对的数量。\n\n输入一个数组，输出一个整数表示数组中翻转对的个数\n\n> 输入: [2,4,3,5,1]\n> 输出: 3\n> 解释: (4,1),(3,1),(5,1)三个翻转数对\n\n解析：\n\n本题的实质是求数组中的逆序数，但是本题中对逆序数有新的定义。\n\n我们基于归并排序算法采用分治策略：将排列分为两部分，先求左半部分的翻转对，然后求右半部分的翻转对；最后算两部分之间存在的翻转对，时间复杂度 O(nlogn)。\n\n左半边和右半边都是排好序的。例如，都是从大到小排序的，左右半边只需要从头到尾各扫一遍，就可以找出由两边各取一个数构成的翻转对数。\n\n下面给出了一种较为容易理解的实现方法，在归并排序代码的基础上做了很小的修改，就是当左侧元素大于右侧时开始寻找翻转对。但是，本题的数据规模最大可达到50000，如果使用这种简单循环遍历将导致超时。\n\nclass Solution {\npublic:\n    void mergeAndCount(vector<int>& nums, int start, int mid, int end, vector<int> tmp, int& count){\n        if(start>end) return;\n        int pTmp = 0;\n        int pLeft = start, pRight = mid+1;\n        while(pLeft<=mid && pRight<=end){\n            if(nums[pLeft] < nums[pRight]){\n                tmp[pTmp++] = nums[pLeft++];\n            }else{\n                // 这种循环遍历方法将导致超时\n                for(int i=pLeft;i<=mid;++i){\n                    if(nums[i] > (long long)2*nums[pRight]){\n                        ++count;\n                    }\n                }\n                tmp[pTmp++] = nums[pRight++];\n            }\n        }\n        while(pLeft<=mid){\n            tmp[pTmp++] = nums[pLeft++];\n        }\n        while(pRight<=end){\n            tmp[pTmp++] = nums[pRight++];\n        }\n        for(int i=0;i<pTmp;++i){\n            nums[start+i] = tmp[i];\n        }\n    }\n\n    void mergeSort(vector<int>& nums, int start, int end, vector<int> tmp, int& count){\n        if(start<end){\n            int mid = start + (end-start)/2;\n            mergeSort(nums,start,mid,tmp,count);\n            mergeSort(nums,mid+1,end,tmp,count);\n            mergeAndCount(nums,start,mid,end,tmp,count);\n        }\n    }\n\n    int reversePairs(vector<int>& nums) {\n        int ans = 0;\n        vector<int> tmp(nums.size());\n        mergeSort(nums,0,nums.size()-1,tmp,ans);\n        return ans;\n    }\n};\n\n\n为了降低时间复杂度，我们采用如下策略：如果左半边 A1 和右半边 A2 都是排好序的，我们就可以在线性时间内解决这个问题了。当然，也可以用二分查找来解决，但是时间复杂度就是线性对数的了。\n\n * 初始化两个指针i，j分别指向A1，A2的头部\n\n * 如果 A1[i] > 2*A2[j] ，那么A1[i]及其后面的所有元素都符合要求，更新答案并后移j，否则，后移i\n\n * 最后，合并A1, A2 以备解决后面更大的子问题使用，并返回前结果\n\nclass Solution {\npublic:\n    int find_reversed_pairs(vector<int>& nums, int start, int end){\n        int res = 0,mid = start + (end-start)/2;\n        int i = start,j = mid+1;\n        for(;i <= mid;i++){\n            while(j <= end && (long)nums[i] > 2*(long)nums[j]) {\n                res += mid - i + 1;\n                j++;\n            }\n        }\n        return res;\n    }\n    \n    int merge_sort(vector<int>& nums, int start, int end, vector<int> tmp){\n        if(start >= end) return 0;\n        int mid = start + (end-start) / 2;\n        \n        int res = merge_sort(nums,tmp,start,mid) + \n                  merge_sort(nums,tmp,mid+1,end) + \n                  find_reversed_pairs(nums,start,end);\n        \n        int i = start,j = mid+1,ind = start;\n        \n        while(i <= mid && j <= end){\n            if(nums[i] <= nums[j]) tmp[ind++] = nums[i++];\n            else tmp[ind++] = nums[j++];\n        }\n        while(i <= mid) tmp[ind++] = nums[i++];\n        while(j <= end) tmp[ind++] = nums[j++];\n        \n        for(int ind = start;ind <= end;ind++) nums[ind] = tmp[ind];\n    \n        return res;\n    }\n    \n    int reversePairs(vector<int>& nums) {\n        if(nums.empty()) return 0;\n        vector<int>& tmp(nums.size());\n        return merge_sort(nums,0,nums.size()-1,tmp);\n    }\n};\n\n\n# 148 排序链表\n\n给定链表的头结点 head ，请将其按 升序 排列并返回 排序后的链表 ，要求在 O(nlogn)的时间复杂度内完成。\n\n输入一个链表，输出一个按升序排列的链表。\n\n> 输入：head = [4,2,1,3]\n> 输出：[1,2,3,4]\n\n解析：\n\n在完成本题之前可以先尝试 21 合并两个有序链表、23 合并K个升序链表 两题，也许对你解决本题有帮助。\n\n本题我们可以使用归并排序的思想完成。采用分治策略，先将链表划分为两个部分，然后在每个部分中进行排序。所以，我们需要完成如下两个任务：\n\n * 寻找链表中点划分链表\n * 排序局部链表，并合并结果\n\n第一个任务我们可以使用快慢指针完成，快指针一次走两步，慢指针一次走一步，这样当快指针到达链表末尾时，慢指针刚好指向链表中点。然后，我们递归地采用上诉方法将链表不断划分为更小的子问题，直到不可再分。这里需要注意一个常犯的错误：在寻找中点时不能直接以 nullptr 判断快指针是否达到终点，而是要将其与链表尾节点 tail 进行比较。\n\n第二个任务升序合并链表：分割完成之后，迭代合并两部分链表，将链表按照升序合并，最终形成完整的升序链表。\n\nclass Solution {\npublic:\n\t// 合并两个链表\n    ListNode* merge(ListNode *l1, ListNode *l2){\n        if(!l1 || !l2) return l1?l1:l2;\n        ListNode dummy;\n        ListNode *tail = &dummy;\n        ListNode *p1 = l1, *p2 = l2;\n        while(p1 && p2){\n            if(p1->val < p2->val){\n                tail->next = p1;\n                p1 = p1->next; \n            }else{\n                tail->next = p2;\n                p2 = p2->next;\n            }\n            tail = tail->next;\n        }\n        tail->next = p1?p1:p2;\n        tail = nullptr;\n        return dummy.next;\n    }\n\t\n    // 寻找链表终点并递归划分链表\n    ListNode* mergeSort(ListNode* head, ListNode* tail){\n        if(!head) return nullptr;\n        if(head->next == tail){\n            head->next = nullptr;\n            return head;\n        }\n\n        ListNode *slow = head, *fast = head;\n        // // 错误示范，会导致越界\n        // while(fast&&fast->next){\n        //     fast = fast->next->next;\n        //     slow = slow->next;\n        // }\n        while(fast != tail){\n            slow = slow->next;\n            fast = fast->next;\n            if(fast != tail){\n                fast = fast->next;\n            }\n        }\n        ListNode* mid = slow;\n        return merge(mergeSort(head,mid),mergeSort(mid,tail));\n    }\n\n    ListNode* sortList(ListNode* head) {\n        return mergeSort(head,nullptr);\n    }\n};\n",normalizedContent:"# 03 归并排序\n\n\n# 归并排序简介\n\n算法思想：\n\n归并排序的核心思想是采用分治策略，将整个数组的排序任务分类为两个子问题，前一半排序和后一半排序，然后整合两个有序部分完成整体排序。即把数组分为若干个子序列，直到单个元素组成一个序列，然后将各阶段得到的序列组合在一起得到最终完整排序序列。\n\n归并排序任务可以如下分治完成：\n\n1. 把前一半排序\n2. 把后一半排序\n3. 把两半归并到一个新的有序数组，然后再拷贝回原数组，排序完成。\n\n\n执行样例：\n\n输入：[29,10,14,37,14,25,10]\n\n\n\n算法实现：\n\n// 将数组 a 的局部 a[s,m] 和 a[m+1,e] 合并到 tmp, 并保证 tmp 有序，然后再拷贝回 a[s,m]\nvoid merge(vector<int>& arr, int start, int mid, int end, vector<int> tmp){\n    int ptmp = 0;\n    int pleft = start; int pright = mid+1;\n    while(pleft<=mid&&pright<=end){\n        if(arr[pleft] < arr[pright]){\n            tmp[ptmp++] = arr[pleft++];\n        }else{\n            tmp[ptmp++] = arr[pright++];\n        }\n    }\n    while(pleft<=mid){\n        tmp[ptmp++] = arr[pleft++];\n    }\n    while (pright<=end)\n    {\n        tmp[ptmp++] = arr[pright++];\n    }\n    for(int i=0;i<ptmp;i++){\n        arr[start+i] = tmp[i];\n    }\n}\n\n// 归并排序递归调用，先排前半部分，在排后半部分，最后将两部分结果合并\nvoid mergesort(vector<int>& arr, int start, int end, vector<int> tmp){\n    if(start < end){\n        int mid = start + (end-start)/2;\n        mergesort(arr,start,mid,tmp);\n        mergesort(arr,mid+1,end,tmp);\n        merge(arr,start,mid,end,tmp);\n    }\n}\n\n\n# 493 翻转对\n\n给定一个数组 nums ，如果 i < j 且 nums[i] > 2*nums[j] 就将 (i,j) 称作一个翻转对，返回给定数组中翻转对的数量。\n\n输入一个数组，输出一个整数表示数组中翻转对的个数\n\n> 输入: [2,4,3,5,1]\n> 输出: 3\n> 解释: (4,1),(3,1),(5,1)三个翻转数对\n\n解析：\n\n本题的实质是求数组中的逆序数，但是本题中对逆序数有新的定义。\n\n我们基于归并排序算法采用分治策略：将排列分为两部分，先求左半部分的翻转对，然后求右半部分的翻转对；最后算两部分之间存在的翻转对，时间复杂度 o(nlogn)。\n\n左半边和右半边都是排好序的。例如，都是从大到小排序的，左右半边只需要从头到尾各扫一遍，就可以找出由两边各取一个数构成的翻转对数。\n\n下面给出了一种较为容易理解的实现方法，在归并排序代码的基础上做了很小的修改，就是当左侧元素大于右侧时开始寻找翻转对。但是，本题的数据规模最大可达到50000，如果使用这种简单循环遍历将导致超时。\n\nclass solution {\npublic:\n    void mergeandcount(vector<int>& nums, int start, int mid, int end, vector<int> tmp, int& count){\n        if(start>end) return;\n        int ptmp = 0;\n        int pleft = start, pright = mid+1;\n        while(pleft<=mid && pright<=end){\n            if(nums[pleft] < nums[pright]){\n                tmp[ptmp++] = nums[pleft++];\n            }else{\n                // 这种循环遍历方法将导致超时\n                for(int i=pleft;i<=mid;++i){\n                    if(nums[i] > (long long)2*nums[pright]){\n                        ++count;\n                    }\n                }\n                tmp[ptmp++] = nums[pright++];\n            }\n        }\n        while(pleft<=mid){\n            tmp[ptmp++] = nums[pleft++];\n        }\n        while(pright<=end){\n            tmp[ptmp++] = nums[pright++];\n        }\n        for(int i=0;i<ptmp;++i){\n            nums[start+i] = tmp[i];\n        }\n    }\n\n    void mergesort(vector<int>& nums, int start, int end, vector<int> tmp, int& count){\n        if(start<end){\n            int mid = start + (end-start)/2;\n            mergesort(nums,start,mid,tmp,count);\n            mergesort(nums,mid+1,end,tmp,count);\n            mergeandcount(nums,start,mid,end,tmp,count);\n        }\n    }\n\n    int reversepairs(vector<int>& nums) {\n        int ans = 0;\n        vector<int> tmp(nums.size());\n        mergesort(nums,0,nums.size()-1,tmp,ans);\n        return ans;\n    }\n};\n\n\n为了降低时间复杂度，我们采用如下策略：如果左半边 a1 和右半边 a2 都是排好序的，我们就可以在线性时间内解决这个问题了。当然，也可以用二分查找来解决，但是时间复杂度就是线性对数的了。\n\n * 初始化两个指针i，j分别指向a1，a2的头部\n\n * 如果 a1[i] > 2*a2[j] ，那么a1[i]及其后面的所有元素都符合要求，更新答案并后移j，否则，后移i\n\n * 最后，合并a1, a2 以备解决后面更大的子问题使用，并返回前结果\n\nclass solution {\npublic:\n    int find_reversed_pairs(vector<int>& nums, int start, int end){\n        int res = 0,mid = start + (end-start)/2;\n        int i = start,j = mid+1;\n        for(;i <= mid;i++){\n            while(j <= end && (long)nums[i] > 2*(long)nums[j]) {\n                res += mid - i + 1;\n                j++;\n            }\n        }\n        return res;\n    }\n    \n    int merge_sort(vector<int>& nums, int start, int end, vector<int> tmp){\n        if(start >= end) return 0;\n        int mid = start + (end-start) / 2;\n        \n        int res = merge_sort(nums,tmp,start,mid) + \n                  merge_sort(nums,tmp,mid+1,end) + \n                  find_reversed_pairs(nums,start,end);\n        \n        int i = start,j = mid+1,ind = start;\n        \n        while(i <= mid && j <= end){\n            if(nums[i] <= nums[j]) tmp[ind++] = nums[i++];\n            else tmp[ind++] = nums[j++];\n        }\n        while(i <= mid) tmp[ind++] = nums[i++];\n        while(j <= end) tmp[ind++] = nums[j++];\n        \n        for(int ind = start;ind <= end;ind++) nums[ind] = tmp[ind];\n    \n        return res;\n    }\n    \n    int reversepairs(vector<int>& nums) {\n        if(nums.empty()) return 0;\n        vector<int>& tmp(nums.size());\n        return merge_sort(nums,0,nums.size()-1,tmp);\n    }\n};\n\n\n# 148 排序链表\n\n给定链表的头结点 head ，请将其按 升序 排列并返回 排序后的链表 ，要求在 o(nlogn)的时间复杂度内完成。\n\n输入一个链表，输出一个按升序排列的链表。\n\n> 输入：head = [4,2,1,3]\n> 输出：[1,2,3,4]\n\n解析：\n\n在完成本题之前可以先尝试 21 合并两个有序链表、23 合并k个升序链表 两题，也许对你解决本题有帮助。\n\n本题我们可以使用归并排序的思想完成。采用分治策略，先将链表划分为两个部分，然后在每个部分中进行排序。所以，我们需要完成如下两个任务：\n\n * 寻找链表中点划分链表\n * 排序局部链表，并合并结果\n\n第一个任务我们可以使用快慢指针完成，快指针一次走两步，慢指针一次走一步，这样当快指针到达链表末尾时，慢指针刚好指向链表中点。然后，我们递归地采用上诉方法将链表不断划分为更小的子问题，直到不可再分。这里需要注意一个常犯的错误：在寻找中点时不能直接以 nullptr 判断快指针是否达到终点，而是要将其与链表尾节点 tail 进行比较。\n\n第二个任务升序合并链表：分割完成之后，迭代合并两部分链表，将链表按照升序合并，最终形成完整的升序链表。\n\nclass solution {\npublic:\n\t// 合并两个链表\n    listnode* merge(listnode *l1, listnode *l2){\n        if(!l1 || !l2) return l1?l1:l2;\n        listnode dummy;\n        listnode *tail = &dummy;\n        listnode *p1 = l1, *p2 = l2;\n        while(p1 && p2){\n            if(p1->val < p2->val){\n                tail->next = p1;\n                p1 = p1->next; \n            }else{\n                tail->next = p2;\n                p2 = p2->next;\n            }\n            tail = tail->next;\n        }\n        tail->next = p1?p1:p2;\n        tail = nullptr;\n        return dummy.next;\n    }\n\t\n    // 寻找链表终点并递归划分链表\n    listnode* mergesort(listnode* head, listnode* tail){\n        if(!head) return nullptr;\n        if(head->next == tail){\n            head->next = nullptr;\n            return head;\n        }\n\n        listnode *slow = head, *fast = head;\n        // // 错误示范，会导致越界\n        // while(fast&&fast->next){\n        //     fast = fast->next->next;\n        //     slow = slow->next;\n        // }\n        while(fast != tail){\n            slow = slow->next;\n            fast = fast->next;\n            if(fast != tail){\n                fast = fast->next;\n            }\n        }\n        listnode* mid = slow;\n        return merge(mergesort(head,mid),mergesort(mid,tail));\n    }\n\n    listnode* sortlist(listnode* head) {\n        return mergesort(head,nullptr);\n    }\n};\n",charsets:{cjk:!0},lastUpdated:"2023/11/19, 12:55:48",lastUpdatedTimestamp:1700369748e3},{title:"04桶排序",frontmatter:{title:"04桶排序",date:"2023-03-24T18:39:49.000Z",permalink:"/pages/a40ad8/"},regularPath:"/03.LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/01.%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/03.%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/04.%E6%A1%B6%E6%8E%92%E5%BA%8F.html",relativePath:"03.LeetCode刷题笔记/01.基础算法/03.排序算法/04.桶排序.md",key:"v-9a42f894",path:"/pages/a40ad8/",headers:[{level:2,title:"04 桶排序",slug:"_04-桶排序",normalizedTitle:"04 桶排序",charIndex:2},{level:3,title:"桶排序简介",slug:"桶排序简介",normalizedTitle:"桶排序简介",charIndex:13},{level:4,title:"桶排序",slug:"桶排序",normalizedTitle:"桶排序",charIndex:5},{level:4,title:"计数排序",slug:"计数排序",normalizedTitle:"计数排序",charIndex:24},{level:4,title:"基数排序",slug:"基数排序",normalizedTitle:"基数排序",charIndex:1377},{level:4,title:"347 前 K 个高频元素",slug:"_347-前-k-个高频元素",normalizedTitle:"347 前 k 个高频元素",charIndex:2323},{level:4,title:"451 根据字符出现频率排序",slug:"_451-根据字符出现频率排序",normalizedTitle:"451 根据字符出现频率排序",charIndex:3489}],headersStr:"04 桶排序 桶排序简介 桶排序 计数排序 基数排序 347 前 K 个高频元素 451 根据字符出现频率排序",content:'# 04 桶排序\n\n\n# 桶排序简介\n\n桶排序、计数排序、计数排序，这三种排序算法的时间复杂度都是线性的，它们之所以能够做到线性的时间复杂度，主要原因是这几个算法是非基于比较的排序算法，不涉及元素之间的比较操作。\n\n这几种排序算法的时间复杂度虽然低，但是对要排序的数据要求比较苛刻，所以关键是要知道这些排序算法的适用场景。\n\n# 桶排序\n\n算法思想：\n\n通排序，顾名思义就是为一个值设立一个桶，将要排序的数据分到几个有序的桶里，每个桶里的数据再单独进行排序。桶排序完之后，再把每个桶里的数据按照顺序依次取出，组成的序列就是有序的了。\n\n例如[25,10,14,14,14,25,10]，我们遍历一遍数组可以建立三个桶[25,10,14]，并将相同值的元素放到同一个桶中形成[[25,25],[10,10],[14,14,14]]；然后对三个桶进行排序[10,14,25]，然后依次输出桶中的元素完成排序。\n\n适用场景：\n\n桶排序一般适用于如下场景：\n\n * 待排序的数据具有易区分的属性，能够容易就能划分成多个桶，并且桶与桶之间有着天然顺序。这样每个桶内数据都排序完之后，桶与桶之间的数据不需要在进行排序。\n\n * 待排序的数据具有均匀分布的特性，能够在划分到在各个桶之后，桶中的数据量较为均衡。如果数据经过桶的划分之后，出现极端不平衡情况，那桶排序就相当与只对一个桶进行排序，失去了划分的意义，时间复杂度也随之提高。\n\n# 计数排序\n\n算法思想：\n\n计数排序可以看成是桶排序的一种特殊情况，只是桶的大小粒度不一样。当要排序的 n 个数据，所处的范围并不大的时候，比如最大值是 k，我们就可以把数据划分成 k 个桶。每个桶内的数据值都是相同的，省掉了桶内排序的时间。\n\n适用场景：\n\n * 计数排序只能用在数据范围不大的场景中，如果数据范围 k 比要排序的数据 n 大很多，就不适合用计数排序了。\n\n * 计数排序只能给非负整数排序，如果要排序的数据是其他类型的，要将其在不改变相对大小的情况下，转化为非负整数。\n\n执行样例：\n\n输入：[8,7,9,5,3,6,9]\n\n\n\n算法实现：\n\nvoid countSort(vector<int>& nums) {\n    map<int,int> buckets;\n    // 统计每个数出现的次数\n    for(int i = 0; i < nums.size(); ++i){\n        if(buckets.count(nums[i])){\n            buckets[nums[i]]++;\n        }else{\n            buckets.insert(make_pair(nums[i],1));\n        }\n    }\n    // 写回数组\n    int index = 0;\n    for(const auto bucket:buckets){\n        int count = bucket.second;\n        while(count){\n            nums[index++] = bucket.first;\n            count--;\n        }\n    }   \n}\n\n\n# 基数排序\n\n基数排序就是进行多次桶排序，基数排序中根据进制位数字分配桶，然后根据桶的顺序收集，接着在高进制位继续迭代该过程直到最高进制位完成排序。\n\n当然，基数排序也可以根据其他属性用于其他类型的排序，核心思想都是先按低优先级分配收集排序，再按高优先级分配收集排序。\n\n执行样例：\n\n输入：[8,27,19,15,30,6,9]\n\n\n\n算法实现：\n\nvoid radixSort(vector<int> &nums){\n    // 计算最大位数\n    int maxOne = *max_element(nums.begin(),nums.end());\n    int bit = 1;\n    while(maxOne>=10){\n        maxOne /= 10;\n        ++bit;\n    }\n    // 创建十个桶\n    vector<queue<int>> buckets(10);\n    // 多次桶排序\n    for(int m=0;m<bit;++m){\n        // 分配 一次遍历将根据对应位的数值放到对应桶中\n        for(int i=0;i<nums.size();++i){\n            int tmp = nums[i];\n            for(int j=0;j<m;++j){\n                tmp/=10;\n            }\n            buckets[tmp%10].push(nums[i]);\n        }\n        // 情况原数组内容\n        nums.clear();\n        // 收集 根据桶的顺序收集桶中的元素\n        for(int i=0;i<10;++i){\n            while(!buckets[i].empty()){\n                nums.push_back(buckets[i].front());\n                buckets[i].pop();\n            }\n        }\n    }\n}\n\n\n# 347 前 K 个高频元素\n\n给定一个整数数组 nums 和一个整数 k ，返回其中出现频率前 k 高的元素。\n\n输入是一个数组和一个目标值 k，输出是一个长度为 k 的数组\n\n> 输入: nums = [4,4,4,5,5,6], k = 2\n> 输出: [4,5]\n\n解析：\n\n本题可以使用桶排序，根据元素的频次进行划分。针对样例来说，我们先通过桶排序得到三个桶 [4,5,6]，它们的值分别为 [3,2,1]，表示每个数字出现的次数。\n\n接着，我们对桶的频次进行排序，前 k 大个桶即是前 k 个频繁的数。这里我们可以使用各种排序算法，甚至可以再进行一次桶排序，把每个旧桶根据频次放在不同的新桶内。\n\n针对样例来说，因为目前最大的频次是 3，我们建立 [1,2,3] 三个新桶，它们分别放入的旧桶为 [[6],[5],[4]]，表示不同数字出现的频率。最后，我们从后往前遍历，直到找到 k 个旧桶。\n\nclass Solution {\npublic:\n    vector<int> topKFrequent(vector<int>& nums, int k) {\n        // 统计元素出现频数\n        unordered_map<int,int> counts;\n        int max_cnt = 0;\n        for(const auto num:nums){\n            max_cnt = max(max_cnt,++counts[num]);\n        }\n        // 桶中记录相同出现频数的元素\n        vector<vector<int>> buckets(max_cnt+1);\n        for(const auto count:counts){\n            buckets[count.second].push_back(count.first);\n        }\n        // 从高到低输出出现频率高的元素\n        vector<int> ans;\n        for(int i=max_cnt; i>=0 && ans.size()<k; --i){\n            for(const auto num:buckets[i]){\n                ans.push_back(num);\n                if(ans.size()==k){\n                    break;\n                }\n            }\n        }\n        return ans;\n    }\n};\n\n\n# 451 根据字符出现频率排序\n\n给定一个字符串，请将字符串里的字符按照出现的频率降序排列。\n\n输入一个字符串，输出一个按字符出现频率排列的字符串\n\n> 输入: "Aabb"\n> \n> 输出: "bbAa"\n> \n> 解释: 此外，"bbaA"也是一个有效的答案，但"Aabb"是不正确的。注意\'A\'和\'a\'被认为是两种不同的字符。\n\n解析：\n\n本题可以使用桶排序，根据元素的频次进行划分。针对样例来说，我们先通过桶排序得到三个桶 [A,a,b]，它们的值分别为 [1,1,2]，表示每个数字出现的次数。\n\n接着，我们对桶的频次进行排序，然后根据频次重新拼接字符串。这里我们可以使用各种排序算法，甚至可以再进行一次桶排序，把每个旧桶根据频次放在不同的新桶内。\n\n针对样例来说，因为目前最大的频次是 2，我们建立 [1,2] 两个新桶，它们分别放入的旧桶为 [[A,a],[b]]，表示不同字符出现的频率。最后，我们从后往前遍历，根据频次拼接字符串。\n\nclass Solution {\npublic:\n    string frequencySort(string s) {\n        // 统计元素出现频数\n        unordered_map<char,int> counts;\n        int max_cnt = 0;\n        for(const auto ch:s){\n            max_cnt = max(max_cnt,++counts[ch]);\n        }\n\t\t// 桶中记录相同出现频数的元素\n        vector<vector<char>> buckets(max_cnt+1);\n        for(const auto count:counts){\n            buckets[count.second].push_back(count.first);\n        }\n        // 根据字符频率重新拼接字符串\n        string ans = "";\n        for(int i=buckets.size()-1;i>=0;--i){\n            for(const auto ch:buckets[i]){\n                int cnt = i;\n                while(cnt > 0){\n                    ans += ch;\n                    --cnt;\n                }\n            }\n        }\n        return ans;\n    }\n};\n',normalizedContent:'# 04 桶排序\n\n\n# 桶排序简介\n\n桶排序、计数排序、计数排序，这三种排序算法的时间复杂度都是线性的，它们之所以能够做到线性的时间复杂度，主要原因是这几个算法是非基于比较的排序算法，不涉及元素之间的比较操作。\n\n这几种排序算法的时间复杂度虽然低，但是对要排序的数据要求比较苛刻，所以关键是要知道这些排序算法的适用场景。\n\n# 桶排序\n\n算法思想：\n\n通排序，顾名思义就是为一个值设立一个桶，将要排序的数据分到几个有序的桶里，每个桶里的数据再单独进行排序。桶排序完之后，再把每个桶里的数据按照顺序依次取出，组成的序列就是有序的了。\n\n例如[25,10,14,14,14,25,10]，我们遍历一遍数组可以建立三个桶[25,10,14]，并将相同值的元素放到同一个桶中形成[[25,25],[10,10],[14,14,14]]；然后对三个桶进行排序[10,14,25]，然后依次输出桶中的元素完成排序。\n\n适用场景：\n\n桶排序一般适用于如下场景：\n\n * 待排序的数据具有易区分的属性，能够容易就能划分成多个桶，并且桶与桶之间有着天然顺序。这样每个桶内数据都排序完之后，桶与桶之间的数据不需要在进行排序。\n\n * 待排序的数据具有均匀分布的特性，能够在划分到在各个桶之后，桶中的数据量较为均衡。如果数据经过桶的划分之后，出现极端不平衡情况，那桶排序就相当与只对一个桶进行排序，失去了划分的意义，时间复杂度也随之提高。\n\n# 计数排序\n\n算法思想：\n\n计数排序可以看成是桶排序的一种特殊情况，只是桶的大小粒度不一样。当要排序的 n 个数据，所处的范围并不大的时候，比如最大值是 k，我们就可以把数据划分成 k 个桶。每个桶内的数据值都是相同的，省掉了桶内排序的时间。\n\n适用场景：\n\n * 计数排序只能用在数据范围不大的场景中，如果数据范围 k 比要排序的数据 n 大很多，就不适合用计数排序了。\n\n * 计数排序只能给非负整数排序，如果要排序的数据是其他类型的，要将其在不改变相对大小的情况下，转化为非负整数。\n\n执行样例：\n\n输入：[8,7,9,5,3,6,9]\n\n\n\n算法实现：\n\nvoid countsort(vector<int>& nums) {\n    map<int,int> buckets;\n    // 统计每个数出现的次数\n    for(int i = 0; i < nums.size(); ++i){\n        if(buckets.count(nums[i])){\n            buckets[nums[i]]++;\n        }else{\n            buckets.insert(make_pair(nums[i],1));\n        }\n    }\n    // 写回数组\n    int index = 0;\n    for(const auto bucket:buckets){\n        int count = bucket.second;\n        while(count){\n            nums[index++] = bucket.first;\n            count--;\n        }\n    }   \n}\n\n\n# 基数排序\n\n基数排序就是进行多次桶排序，基数排序中根据进制位数字分配桶，然后根据桶的顺序收集，接着在高进制位继续迭代该过程直到最高进制位完成排序。\n\n当然，基数排序也可以根据其他属性用于其他类型的排序，核心思想都是先按低优先级分配收集排序，再按高优先级分配收集排序。\n\n执行样例：\n\n输入：[8,27,19,15,30,6,9]\n\n\n\n算法实现：\n\nvoid radixsort(vector<int> &nums){\n    // 计算最大位数\n    int maxone = *max_element(nums.begin(),nums.end());\n    int bit = 1;\n    while(maxone>=10){\n        maxone /= 10;\n        ++bit;\n    }\n    // 创建十个桶\n    vector<queue<int>> buckets(10);\n    // 多次桶排序\n    for(int m=0;m<bit;++m){\n        // 分配 一次遍历将根据对应位的数值放到对应桶中\n        for(int i=0;i<nums.size();++i){\n            int tmp = nums[i];\n            for(int j=0;j<m;++j){\n                tmp/=10;\n            }\n            buckets[tmp%10].push(nums[i]);\n        }\n        // 情况原数组内容\n        nums.clear();\n        // 收集 根据桶的顺序收集桶中的元素\n        for(int i=0;i<10;++i){\n            while(!buckets[i].empty()){\n                nums.push_back(buckets[i].front());\n                buckets[i].pop();\n            }\n        }\n    }\n}\n\n\n# 347 前 k 个高频元素\n\n给定一个整数数组 nums 和一个整数 k ，返回其中出现频率前 k 高的元素。\n\n输入是一个数组和一个目标值 k，输出是一个长度为 k 的数组\n\n> 输入: nums = [4,4,4,5,5,6], k = 2\n> 输出: [4,5]\n\n解析：\n\n本题可以使用桶排序，根据元素的频次进行划分。针对样例来说，我们先通过桶排序得到三个桶 [4,5,6]，它们的值分别为 [3,2,1]，表示每个数字出现的次数。\n\n接着，我们对桶的频次进行排序，前 k 大个桶即是前 k 个频繁的数。这里我们可以使用各种排序算法，甚至可以再进行一次桶排序，把每个旧桶根据频次放在不同的新桶内。\n\n针对样例来说，因为目前最大的频次是 3，我们建立 [1,2,3] 三个新桶，它们分别放入的旧桶为 [[6],[5],[4]]，表示不同数字出现的频率。最后，我们从后往前遍历，直到找到 k 个旧桶。\n\nclass solution {\npublic:\n    vector<int> topkfrequent(vector<int>& nums, int k) {\n        // 统计元素出现频数\n        unordered_map<int,int> counts;\n        int max_cnt = 0;\n        for(const auto num:nums){\n            max_cnt = max(max_cnt,++counts[num]);\n        }\n        // 桶中记录相同出现频数的元素\n        vector<vector<int>> buckets(max_cnt+1);\n        for(const auto count:counts){\n            buckets[count.second].push_back(count.first);\n        }\n        // 从高到低输出出现频率高的元素\n        vector<int> ans;\n        for(int i=max_cnt; i>=0 && ans.size()<k; --i){\n            for(const auto num:buckets[i]){\n                ans.push_back(num);\n                if(ans.size()==k){\n                    break;\n                }\n            }\n        }\n        return ans;\n    }\n};\n\n\n# 451 根据字符出现频率排序\n\n给定一个字符串，请将字符串里的字符按照出现的频率降序排列。\n\n输入一个字符串，输出一个按字符出现频率排列的字符串\n\n> 输入: "aabb"\n> \n> 输出: "bbaa"\n> \n> 解释: 此外，"bbaa"也是一个有效的答案，但"aabb"是不正确的。注意\'a\'和\'a\'被认为是两种不同的字符。\n\n解析：\n\n本题可以使用桶排序，根据元素的频次进行划分。针对样例来说，我们先通过桶排序得到三个桶 [a,a,b]，它们的值分别为 [1,1,2]，表示每个数字出现的次数。\n\n接着，我们对桶的频次进行排序，然后根据频次重新拼接字符串。这里我们可以使用各种排序算法，甚至可以再进行一次桶排序，把每个旧桶根据频次放在不同的新桶内。\n\n针对样例来说，因为目前最大的频次是 2，我们建立 [1,2] 两个新桶，它们分别放入的旧桶为 [[a,a],[b]]，表示不同字符出现的频率。最后，我们从后往前遍历，根据频次拼接字符串。\n\nclass solution {\npublic:\n    string frequencysort(string s) {\n        // 统计元素出现频数\n        unordered_map<char,int> counts;\n        int max_cnt = 0;\n        for(const auto ch:s){\n            max_cnt = max(max_cnt,++counts[ch]);\n        }\n\t\t// 桶中记录相同出现频数的元素\n        vector<vector<char>> buckets(max_cnt+1);\n        for(const auto count:counts){\n            buckets[count.second].push_back(count.first);\n        }\n        // 根据字符频率重新拼接字符串\n        string ans = "";\n        for(int i=buckets.size()-1;i>=0;--i){\n            for(const auto ch:buckets[i]){\n                int cnt = i;\n                while(cnt > 0){\n                    ans += ch;\n                    --cnt;\n                }\n            }\n        }\n        return ans;\n    }\n};\n',charsets:{cjk:!0},lastUpdated:"2023/11/19, 12:55:48",lastUpdatedTimestamp:1700369748e3},{title:"03进制转换问题",frontmatter:{title:"03进制转换问题",date:"2023-03-24T18:39:49.000Z",permalink:"/pages/aef702/"},regularPath:"/03.LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/05.%E5%85%B6%E4%BB%96%E5%86%85%E5%AE%B9/01.%E6%95%B0%E5%AD%A6%E9%97%AE%E9%A2%98/03.%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2%E9%97%AE%E9%A2%98.html",relativePath:"03.LeetCode刷题笔记/05.其他内容/01.数学问题/03.进制转换问题.md",key:"v-47781b60",path:"/pages/aef702/",headers:[{level:2,title:"03 进制转换问题",slug:"_03-进制转换问题",normalizedTitle:"03 进制转换问题",charIndex:2},{level:4,title:"504 七进制数",slug:"_504-七进制数",normalizedTitle:"504 七进制数",charIndex:15},{level:4,title:"168 Excel表列名称",slug:"_168-excel表列名称",normalizedTitle:"168 excel表列名称",charIndex:653},{level:4,title:"202 快乐数",slug:"_202-快乐数",normalizedTitle:"202 快乐数",charIndex:1197}],headersStr:"03 进制转换问题 504 七进制数 168 Excel表列名称 202 快乐数",content:'# 03 进制转换问题\n\n# 504 七进制数\n\n给定一个十进制整数，求它在七进制下的表示。\n\n输入一个整数，输出一个字符串，表示其七进制。\n\n> 输入: num = 100\n> 输出: "202"\n> 解释：100 的七进制表示法来源于 100 = 2 * 49 + 0 * 7 + 2 * 1。\n\n解析：\n\n进制转换类型的题，通常是利用除法和取模（mod）来进行计算，同时也要注意一些细节，如负数和零。如果输出是数字类型而非字符串，则也需要考虑是否会超出整数上下界。\n\nclass Solution {\npublic:\n    string convertToBase7(int num) {\n        if(num == 0) return "0";\n        bool isNegatibe = num < 0;\n        num = abs(num);\n        string ans;\n        while(num){\n            int a = num / 7;\n            int b = num % 7;\n            ans = to_string(b) + ans;\n            num = a;\n        }\n        if(isNegatibe){\n            return "-"+ans;\n        }\n        return ans;\n    }\n};\n\n\n# 168 Excel表列名称\n\n给你一个整数 columnNumber ，返回它在 Excel 表中相对应的列名称。\n\n输入一个整数，输出一个字符串表示Excel 表中相对应的列名称\n\n> 输入：columnNumber = 28\n> 输出："AB"\n\n解析：\n\n本题是进制转换题型的变种题，和504七进制转换题十分相似，可以视为26进制转换，但是需要注意的是输入的整数是从 1 开始而不是 0，所以要将输入减1。\n\nclass Solution {\npublic:\n    string convertToTitle(int columnNumber) {\n        string ans;\n        while(columnNumber){\n            int a = (columnNumber-1) / 26;\n            int b = (columnNumber-1) % 26;\n            columnNumber = a;\n            char c = b + \'A\';\n            ans = c + ans;\n        }\n        return ans;\n    }\n};\n\n\n# 202 快乐数\n\n输入一个整数，判断它是否是快乐数，快乐数是指将该数替换为它每个位置上的数字的平方和，如果该数进过上述过程最终变为 1,则称为快乐数\n\n> 输入：19\n> 输出：true\n> 解释：\n> 1^2 + 9^2 = 82\n> 8^2 + 2^2 = 68\n> 6^2 + 8^2 = 100\n> 1^2 + 0^2 + 0^2 = 1\n\n解析：\n\n本题有两个需要注意的地方，和504七进制转换题一样要能够转换出十进制每一位上的数值获取下一个数值。另一个点是，不是快乐数的数可能是 无限循环 但始终变不到 1，看到无限循环就能想到成环，而环路检测最常用的方法就是弗洛伊德判圈算法，可以使用快慢指针实现。\n\nclass Solution {\npublic:\n    int getNext(int num){\n        int nextNum = 0;\n        while(num){\n            int b = num % 10;\n            num = num / 10;\n            nextNum += b*b;\n        }\n        return nextNum;\n    }\n\n    bool isHappy(int n) {\n        int slow = n;\n        int fast = getNext(n);\n        while(fast!=1 && fast!=slow){\n            slow = getNext(slow);\n            fast = getNext(getNext(fast));\n        }\n        return fast == 1;\n    }\n};\n',normalizedContent:'# 03 进制转换问题\n\n# 504 七进制数\n\n给定一个十进制整数，求它在七进制下的表示。\n\n输入一个整数，输出一个字符串，表示其七进制。\n\n> 输入: num = 100\n> 输出: "202"\n> 解释：100 的七进制表示法来源于 100 = 2 * 49 + 0 * 7 + 2 * 1。\n\n解析：\n\n进制转换类型的题，通常是利用除法和取模（mod）来进行计算，同时也要注意一些细节，如负数和零。如果输出是数字类型而非字符串，则也需要考虑是否会超出整数上下界。\n\nclass solution {\npublic:\n    string converttobase7(int num) {\n        if(num == 0) return "0";\n        bool isnegatibe = num < 0;\n        num = abs(num);\n        string ans;\n        while(num){\n            int a = num / 7;\n            int b = num % 7;\n            ans = to_string(b) + ans;\n            num = a;\n        }\n        if(isnegatibe){\n            return "-"+ans;\n        }\n        return ans;\n    }\n};\n\n\n# 168 excel表列名称\n\n给你一个整数 columnnumber ，返回它在 excel 表中相对应的列名称。\n\n输入一个整数，输出一个字符串表示excel 表中相对应的列名称\n\n> 输入：columnnumber = 28\n> 输出："ab"\n\n解析：\n\n本题是进制转换题型的变种题，和504七进制转换题十分相似，可以视为26进制转换，但是需要注意的是输入的整数是从 1 开始而不是 0，所以要将输入减1。\n\nclass solution {\npublic:\n    string converttotitle(int columnnumber) {\n        string ans;\n        while(columnnumber){\n            int a = (columnnumber-1) / 26;\n            int b = (columnnumber-1) % 26;\n            columnnumber = a;\n            char c = b + \'a\';\n            ans = c + ans;\n        }\n        return ans;\n    }\n};\n\n\n# 202 快乐数\n\n输入一个整数，判断它是否是快乐数，快乐数是指将该数替换为它每个位置上的数字的平方和，如果该数进过上述过程最终变为 1,则称为快乐数\n\n> 输入：19\n> 输出：true\n> 解释：\n> 1^2 + 9^2 = 82\n> 8^2 + 2^2 = 68\n> 6^2 + 8^2 = 100\n> 1^2 + 0^2 + 0^2 = 1\n\n解析：\n\n本题有两个需要注意的地方，和504七进制转换题一样要能够转换出十进制每一位上的数值获取下一个数值。另一个点是，不是快乐数的数可能是 无限循环 但始终变不到 1，看到无限循环就能想到成环，而环路检测最常用的方法就是弗洛伊德判圈算法，可以使用快慢指针实现。\n\nclass solution {\npublic:\n    int getnext(int num){\n        int nextnum = 0;\n        while(num){\n            int b = num % 10;\n            num = num / 10;\n            nextnum += b*b;\n        }\n        return nextnum;\n    }\n\n    bool ishappy(int n) {\n        int slow = n;\n        int fast = getnext(n);\n        while(fast!=1 && fast!=slow){\n            slow = getnext(slow);\n            fast = getnext(getnext(fast));\n        }\n        return fast == 1;\n    }\n};\n',charsets:{cjk:!0},lastUpdated:"2023/11/19, 12:55:48",lastUpdatedTimestamp:1700369748e3},{title:"05众数问题",frontmatter:{title:"05众数问题",date:"2023-03-24T18:39:49.000Z",permalink:"/pages/be2fa2/"},regularPath:"/03.LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/05.%E5%85%B6%E4%BB%96%E5%86%85%E5%AE%B9/01.%E6%95%B0%E5%AD%A6%E9%97%AE%E9%A2%98/05.%E4%BC%97%E6%95%B0%E9%97%AE%E9%A2%98.html",relativePath:"03.LeetCode刷题笔记/05.其他内容/01.数学问题/05.众数问题.md",key:"v-0cdcbd20",path:"/pages/be2fa2/",headers:[{level:2,title:"05 众数问题",slug:"_05-众数问题",normalizedTitle:"05 众数问题",charIndex:2},{level:4,title:"169 多数元素",slug:"_169-多数元素",normalizedTitle:"169 多数元素",charIndex:13},{level:4,title:"229 求众数 II",slug:"_229-求众数-ii",normalizedTitle:"229 求众数 ii",charIndex:1368}],headersStr:"05 众数问题 169 多数元素 229 求众数 II",content:"# 05 众数问题\n\n# 169 多数元素\n\n给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数 大于 n / 2 的元素。\n\n输入一个一维数组，输出一个整数，表示数组中个数占多数的元素。\n\n> 输入：[3,2,3]\n> 输出：3\n\n解析：\n\n采用哈希表是一种最为直接的方法，统计数组中每个元素出现的次数，然后找出频次最高的元素即可。\n\nclass Solution {\npublic:\n    int majorityElement(vector<int>& nums) {\n        unordered_map<int,int> counts;\n        for(const auto elem:nums){\n            if(counts.find(elem) != counts.end()){\n                counts[elem]++;\n            }else{\n                counts.insert(make_pair(elem,1));\n            }\n        }\n        int ans = 0;\n        int max = INT_MIN;\n        for(const auto count: counts){\n            if(count.second > max){\n                ans = count.first;\n                max = count.second;\n            }\n        }\n        return ans;\n    }\n};\n\n\n本题也可以采用摩尔投票法更加简洁的解决。摩尔投票法的基本原理是：在数组中找到两个不相同的元素并删除它们，不断重复此过程，直到数组中元素都相同，那么剩下的元素就是主要元素。\n\n这种找主要元素的方法是怎么得以实现的呢？该投票法，遇到相同的元素则票数加 1，遇到不同的元素则票数减 1，当该元素的票数为 0 时更换投票主要元素。在主要元素个数大于 n / 2 的情况下，相当于每个主要元素和其他元素两两相互抵消，抵消到最后肯定还剩余至少 1 个多数元素。\n\nclass Solution {\npublic:\n    int majorityElement(vector<int>& nums) {\n        int major = nums[0];\n        int count = 0;\n        for(int i=0;i<nums.size();++i){\n            if(major == nums[i]){\n                ++count;\n            }else if(count == 0){\n                major = nums[i];\n            }else{\n                --count;\n            }\n        }\n        return major;\n    }\n};\n\n\n# 229 求众数 II\n\n给定一个大小为 n 的整数数组，找出其中所有出现超过 n / 3 次的元素。\n\n输入一个一维数组，输出一个一维数组包含所有频次超过 n/3 的元素\n\n> 输入：[1,1,1,3,3,2,2,2]\n> 输出：[1,2]\n\n解析：\n\n本题是摩尔投票法的进阶用法，摩尔投票法的核心是通过抵消和计票选出多数，可以推出规律：如果至多选一个代表，那他的票数至少要超过一半 1/2 的票数；如果至多选两个代表，那他们的票数至少要超过 1/3 的票数；类推可知，如果至多选 m 个代表，那他们的票数至少要超过 1 / (m+1) 的票数。\n\n回到本题，求频次超过 n/3 的元素，那么最多只有两个，要注意多个主要元素时的抵消情况：（1）A同B不同，A++，B不变；（2）A不同B同，A不变，B++；（3）AB均不同，A--，B--；。\n\nclass Solution {\npublic:\n    vector<int> majorityElement(vector<int>& nums) {\n        vector<int> res;        \n        const int len = nums.size();\t\t\n        int major1, major2;        \n        int count1 = 0, count2 = 0;        \n        for(int i = 0; i < len; i++) {\n            // 存在元素相同\n            if(nums[i] == major1){\n                ++count1;\n            }\n            else if(nums[i] == major2){\n                ++count2;\n            }\n            // 替换主要元素\n            else if(count1 == 0) {\n\t\t\t\tmajor1 = nums[i];\n\t\t\t\tcount1 = 1;\n\t\t\t}\n            else if(count2 == 0) {\n\t\t\t\tmajor2 = nums[i];\n\t\t\t\tcount2 = 1;\n\t\t\t}\n            // 与major1和major2都不同时才抵消，如果只有一个不同的情况是另一个计数增加，不要想成了让不同的那一个去抵消，这里容易出错\n            else {\n\t\t\t\tcount1--;\n\t\t\t\tcount2--;\n\t\t\t}\n        }\n        // 检验结果中元素数目是否超过三分之一\n        count1 = 0, count2 = 0;\n        for(auto &num : nums) {\n            if(num == major1) count1++;\n            else if(num == major2) count2++;\n        }\n\n        if(count1 > len / 3) res.push_back(major1);\n        if(count2 > len / 3) res.push_back(major2);\n        return res;\n    }\n};\n",normalizedContent:"# 05 众数问题\n\n# 169 多数元素\n\n给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数 大于 n / 2 的元素。\n\n输入一个一维数组，输出一个整数，表示数组中个数占多数的元素。\n\n> 输入：[3,2,3]\n> 输出：3\n\n解析：\n\n采用哈希表是一种最为直接的方法，统计数组中每个元素出现的次数，然后找出频次最高的元素即可。\n\nclass solution {\npublic:\n    int majorityelement(vector<int>& nums) {\n        unordered_map<int,int> counts;\n        for(const auto elem:nums){\n            if(counts.find(elem) != counts.end()){\n                counts[elem]++;\n            }else{\n                counts.insert(make_pair(elem,1));\n            }\n        }\n        int ans = 0;\n        int max = int_min;\n        for(const auto count: counts){\n            if(count.second > max){\n                ans = count.first;\n                max = count.second;\n            }\n        }\n        return ans;\n    }\n};\n\n\n本题也可以采用摩尔投票法更加简洁的解决。摩尔投票法的基本原理是：在数组中找到两个不相同的元素并删除它们，不断重复此过程，直到数组中元素都相同，那么剩下的元素就是主要元素。\n\n这种找主要元素的方法是怎么得以实现的呢？该投票法，遇到相同的元素则票数加 1，遇到不同的元素则票数减 1，当该元素的票数为 0 时更换投票主要元素。在主要元素个数大于 n / 2 的情况下，相当于每个主要元素和其他元素两两相互抵消，抵消到最后肯定还剩余至少 1 个多数元素。\n\nclass solution {\npublic:\n    int majorityelement(vector<int>& nums) {\n        int major = nums[0];\n        int count = 0;\n        for(int i=0;i<nums.size();++i){\n            if(major == nums[i]){\n                ++count;\n            }else if(count == 0){\n                major = nums[i];\n            }else{\n                --count;\n            }\n        }\n        return major;\n    }\n};\n\n\n# 229 求众数 ii\n\n给定一个大小为 n 的整数数组，找出其中所有出现超过 n / 3 次的元素。\n\n输入一个一维数组，输出一个一维数组包含所有频次超过 n/3 的元素\n\n> 输入：[1,1,1,3,3,2,2,2]\n> 输出：[1,2]\n\n解析：\n\n本题是摩尔投票法的进阶用法，摩尔投票法的核心是通过抵消和计票选出多数，可以推出规律：如果至多选一个代表，那他的票数至少要超过一半 1/2 的票数；如果至多选两个代表，那他们的票数至少要超过 1/3 的票数；类推可知，如果至多选 m 个代表，那他们的票数至少要超过 1 / (m+1) 的票数。\n\n回到本题，求频次超过 n/3 的元素，那么最多只有两个，要注意多个主要元素时的抵消情况：（1）a同b不同，a++，b不变；（2）a不同b同，a不变，b++；（3）ab均不同，a--，b--；。\n\nclass solution {\npublic:\n    vector<int> majorityelement(vector<int>& nums) {\n        vector<int> res;        \n        const int len = nums.size();\t\t\n        int major1, major2;        \n        int count1 = 0, count2 = 0;        \n        for(int i = 0; i < len; i++) {\n            // 存在元素相同\n            if(nums[i] == major1){\n                ++count1;\n            }\n            else if(nums[i] == major2){\n                ++count2;\n            }\n            // 替换主要元素\n            else if(count1 == 0) {\n\t\t\t\tmajor1 = nums[i];\n\t\t\t\tcount1 = 1;\n\t\t\t}\n            else if(count2 == 0) {\n\t\t\t\tmajor2 = nums[i];\n\t\t\t\tcount2 = 1;\n\t\t\t}\n            // 与major1和major2都不同时才抵消，如果只有一个不同的情况是另一个计数增加，不要想成了让不同的那一个去抵消，这里容易出错\n            else {\n\t\t\t\tcount1--;\n\t\t\t\tcount2--;\n\t\t\t}\n        }\n        // 检验结果中元素数目是否超过三分之一\n        count1 = 0, count2 = 0;\n        for(auto &num : nums) {\n            if(num == major1) count1++;\n            else if(num == major2) count2++;\n        }\n\n        if(count1 > len / 3) res.push_back(major1);\n        if(count2 > len / 3) res.push_back(major2);\n        return res;\n    }\n};\n",charsets:{cjk:!0},lastUpdated:"2023/11/19, 12:55:48",lastUpdatedTimestamp:1700369748e3},{title:"07数字处理问题",frontmatter:{title:"07数字处理问题",date:"2023-03-24T18:39:49.000Z",permalink:"/pages/261fe5/"},regularPath:"/03.LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/05.%E5%85%B6%E4%BB%96%E5%86%85%E5%AE%B9/01.%E6%95%B0%E5%AD%A6%E9%97%AE%E9%A2%98/07.%E6%95%B0%E5%AD%97%E5%A4%84%E7%90%86%E9%97%AE%E9%A2%98.html",relativePath:"03.LeetCode刷题笔记/05.其他内容/01.数学问题/07.数字处理问题.md",key:"v-04db88ef",path:"/pages/261fe5/",headers:[{level:2,title:"07 数字处理问题",slug:"_07-数字处理问题",normalizedTitle:"07 数字处理问题",charIndex:2},{level:4,title:"238 除自身以外数组的乘积",slug:"_238-除自身以外数组的乘积",normalizedTitle:"238 除自身以外数组的乘积",charIndex:15},{level:4,title:"326 3的幂",slug:"_326-3的幂",normalizedTitle:"326 3的幂",charIndex:1306}],headersStr:"07 数字处理问题 238 除自身以外数组的乘积 326 3的幂",content:"# 07 数字处理问题\n\n# 238 除自身以外数组的乘积\n\n给定一个长度为 n 的整数数组 nums，其中 n > 1，返回输出数组 output ，其中 output[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积。\n\n输入一个数组，输出一个数组，其中每个元素数值为除本身之外所有元素的乘积\n\n> 输入: [1,2,3,4]\n> 输出: [24,12,8,6]\n\n解析：\n\n本题与135题分糖果相似，可以先从左到右计算当前元素左侧所有元素的乘积，然后从右到左计算当前元素右侧所有元素的乘积，再将两个元素乘积相乘得到最终结果。\n\nclass Solution {\npublic:\n    vector<int> productExceptSelf(vector<int>& nums) {\n        int len = nums.size();\n        vector<int> output(len,1);\n        vector<int> L(len,1);\n        vector<int> R(len,1);\n        for(int i=1;i<len;++i){\n            L[i] = L[i-1] * nums[i-1];\n        }\n        for(int i=len-2;i>=0;--i){\n            R[i] = R[i+1] * nums[i+1];\n            output[i] = L[i]*R[i];\n        }\n        output[len-1] = L[len-1];\n        return output;\n    }\n};\n\n\n进一步优化空间复杂的，在从左和从右扫描中，用一个全局变量记录 i 之前或 i 之后所有元素的乘积\n\nclass Solution {\npublic:\n    vector<int> productExceptSelf(vector<int>& nums) {\n        int len = nums.size();\n        vector<int> output(len,1);\n        int product = nums[0];\n        for(int i=1;i<len;++i){  \n            output[i] = product;\n            product *= nums[i]; // 记录从开头到当前位置中所有元素的乘积\n        }\n        product = nums[len-1];\n        for(int i=len-2;i>=0;--i){\n            output[i] *= product;\n            product *= nums[i];// 记录从结尾到当前位置中所有元素的乘积\n        }\n        return output;\n    }\n};\n\n\n# 326 3的幂\n\n判断一个数字是否是 3 的次方。\n\n输入一个整数，输出一个布尔值。\n\n> Input: n = 27 Output: true\n\n解析：\n\n第一种方式是使用对数函数以3为底的对数函数，如果 n 是 3 的次方那么其值应该为整数。math库中提供了以 e 为底的log()和以10为底的log10()，根据换底公式有log3(n) = log10(n)/log10(3)。 $$ log_a^b = log_c^b / log_c^a $$\n\nclass Solution {\npublic:\n    bool isPowerOfThree(int n) {\n        if(n == 0) return false;\n        double m = log10(n) / log10(3);\n        // fmod(double x, double y) 用于计算浮点数取模\n        return fmod(m,1) == 0; \n    }\n};\n\n\n另一中方式因为在 int 范围内 3 的最大次方是 3^19 = 1162261467，如果 n 是 3 的整数次方，那么 1162261467 除以 n 的余数一定是零；反之亦然。\n\nclass Solution {\npublic:\n    bool isPowerOfThree(int n) {\n        return n > 0 && 1162261467 % n == 0;\n    }\n};\n",normalizedContent:"# 07 数字处理问题\n\n# 238 除自身以外数组的乘积\n\n给定一个长度为 n 的整数数组 nums，其中 n > 1，返回输出数组 output ，其中 output[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积。\n\n输入一个数组，输出一个数组，其中每个元素数值为除本身之外所有元素的乘积\n\n> 输入: [1,2,3,4]\n> 输出: [24,12,8,6]\n\n解析：\n\n本题与135题分糖果相似，可以先从左到右计算当前元素左侧所有元素的乘积，然后从右到左计算当前元素右侧所有元素的乘积，再将两个元素乘积相乘得到最终结果。\n\nclass solution {\npublic:\n    vector<int> productexceptself(vector<int>& nums) {\n        int len = nums.size();\n        vector<int> output(len,1);\n        vector<int> l(len,1);\n        vector<int> r(len,1);\n        for(int i=1;i<len;++i){\n            l[i] = l[i-1] * nums[i-1];\n        }\n        for(int i=len-2;i>=0;--i){\n            r[i] = r[i+1] * nums[i+1];\n            output[i] = l[i]*r[i];\n        }\n        output[len-1] = l[len-1];\n        return output;\n    }\n};\n\n\n进一步优化空间复杂的，在从左和从右扫描中，用一个全局变量记录 i 之前或 i 之后所有元素的乘积\n\nclass solution {\npublic:\n    vector<int> productexceptself(vector<int>& nums) {\n        int len = nums.size();\n        vector<int> output(len,1);\n        int product = nums[0];\n        for(int i=1;i<len;++i){  \n            output[i] = product;\n            product *= nums[i]; // 记录从开头到当前位置中所有元素的乘积\n        }\n        product = nums[len-1];\n        for(int i=len-2;i>=0;--i){\n            output[i] *= product;\n            product *= nums[i];// 记录从结尾到当前位置中所有元素的乘积\n        }\n        return output;\n    }\n};\n\n\n# 326 3的幂\n\n判断一个数字是否是 3 的次方。\n\n输入一个整数，输出一个布尔值。\n\n> input: n = 27 output: true\n\n解析：\n\n第一种方式是使用对数函数以3为底的对数函数，如果 n 是 3 的次方那么其值应该为整数。math库中提供了以 e 为底的log()和以10为底的log10()，根据换底公式有log3(n) = log10(n)/log10(3)。 $$ log_a^b = log_c^b / log_c^a $$\n\nclass solution {\npublic:\n    bool ispowerofthree(int n) {\n        if(n == 0) return false;\n        double m = log10(n) / log10(3);\n        // fmod(double x, double y) 用于计算浮点数取模\n        return fmod(m,1) == 0; \n    }\n};\n\n\n另一中方式因为在 int 范围内 3 的最大次方是 3^19 = 1162261467，如果 n 是 3 的整数次方，那么 1162261467 除以 n 的余数一定是零；反之亦然。\n\nclass solution {\npublic:\n    bool ispowerofthree(int n) {\n        return n > 0 && 1162261467 % n == 0;\n    }\n};\n",charsets:{cjk:!0},lastUpdated:"2023/11/19, 12:55:48",lastUpdatedTimestamp:1700369748e3},{title:"06中位数问题",frontmatter:{title:"06中位数问题",date:"2023-03-24T18:39:49.000Z",permalink:"/pages/a8b0f0/"},regularPath:"/03.LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/05.%E5%85%B6%E4%BB%96%E5%86%85%E5%AE%B9/01.%E6%95%B0%E5%AD%A6%E9%97%AE%E9%A2%98/06.%E4%B8%AD%E4%BD%8D%E6%95%B0%E9%97%AE%E9%A2%98.html",relativePath:"03.LeetCode刷题笔记/05.其他内容/01.数学问题/06.中位数问题.md",key:"v-3dbcc9aa",path:"/pages/a8b0f0/",headers:[{level:2,title:"06 中位数问题",slug:"_06-中位数问题",normalizedTitle:"06 中位数问题",charIndex:2},{level:4,title:"462 最少移动次数使数组元素相等 II",slug:"_462-最少移动次数使数组元素相等-ii",normalizedTitle:"462 最少移动次数使数组元素相等 ii",charIndex:14}],headersStr:"06 中位数问题 462 最少移动次数使数组元素相等 II",content:"# 06 中位数问题\n\n# 462 最少移动次数使数组元素相等 II\n\n给定一个非空整数数组，找到使所有数组元素相等所需的最小移动数，其中每次移动可将选定的一个元素加1或减1。 您可以假设数组的长度最多为10000。\n\n输入一个数组，输出一个整数表示最少移动的步数。\n\n> 输入: [1,2,3]\n> \n> 输出: 2\n> \n> 解释：只有两个动作是必要的（记得每一步仅可使其中一个元素加1或减1）： [1,2,3] => [2,2,3] => [2,2,2]\n\n解析：\n\n本题的关键是找数组的中位数。\n\nclass Solution {\npublic:\n    int minMoves2(vector<int>& nums) {\n        sort(nums.begin(),nums.end());\n        int len = nums.size();\n        int mid = nums[len/2];\n        int ans = 0;\n        for(int i=0;i<len;++i){\n            ans += abs(nums[i]-mid);\n        }\n        return ans;\n    }\n};\n",normalizedContent:"# 06 中位数问题\n\n# 462 最少移动次数使数组元素相等 ii\n\n给定一个非空整数数组，找到使所有数组元素相等所需的最小移动数，其中每次移动可将选定的一个元素加1或减1。 您可以假设数组的长度最多为10000。\n\n输入一个数组，输出一个整数表示最少移动的步数。\n\n> 输入: [1,2,3]\n> \n> 输出: 2\n> \n> 解释：只有两个动作是必要的（记得每一步仅可使其中一个元素加1或减1）： [1,2,3] => [2,2,3] => [2,2,2]\n\n解析：\n\n本题的关键是找数组的中位数。\n\nclass solution {\npublic:\n    int minmoves2(vector<int>& nums) {\n        sort(nums.begin(),nums.end());\n        int len = nums.size();\n        int mid = nums[len/2];\n        int ans = 0;\n        for(int i=0;i<len;++i){\n            ans += abs(nums[i]-mid);\n        }\n        return ans;\n    }\n};\n",charsets:{cjk:!0},lastUpdated:"2023/11/19, 12:55:48",lastUpdatedTimestamp:1700369748e3},{title:"08随机数问题",frontmatter:{title:"08随机数问题",date:"2023-03-24T18:39:49.000Z",permalink:"/pages/708f52/"},regularPath:"/03.LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/05.%E5%85%B6%E4%BB%96%E5%86%85%E5%AE%B9/01.%E6%95%B0%E5%AD%A6%E9%97%AE%E9%A2%98/08.%E9%9A%8F%E6%9C%BA%E6%95%B0%E9%97%AE%E9%A2%98.html",relativePath:"03.LeetCode刷题笔记/05.其他内容/01.数学问题/08.随机数问题.md",key:"v-48d02f81",path:"/pages/708f52/",headers:[{level:2,title:"08 随机数问题",slug:"_08-随机数问题",normalizedTitle:"08 随机数问题",charIndex:2},{level:4,title:"384 打乱数组",slug:"_384-打乱数组",normalizedTitle:"384 打乱数组",charIndex:14},{level:4,title:"528 按权重随机选择",slug:"_528-按权重随机选择",normalizedTitle:"528 按权重随机选择",charIndex:1502},{level:4,title:"382 链表随机节点",slug:"_382-链表随机节点",normalizedTitle:"382 链表随机节点",charIndex:2949},{level:4,title:"470 用 Rand7() 实现 Rand10()",slug:"_470-用-rand7-实现-rand10",normalizedTitle:"470 用 rand7() 实现 rand10()",charIndex:4149}],headersStr:"08 随机数问题 384 打乱数组 528 按权重随机选择 382 链表随机节点 470 用 Rand7() 实现 Rand10()",content:'# 08 随机数问题\n\n# 384 打乱数组\n\n给定一个数组，要求实现两个指令函数。第一个函数 shuﬄe() 可以随机打乱这个数组，第二个函数 reset() 可以恢复原来的顺序。\n\n输入是一个存有整数数字的数组，和一个包含指令函数名称的数组。输出是一个二维数组，表示每个指令生成的数组。\n\n> 输入: ["Solution", "shuffle", "reset", "shuffle"] [[[1, 2, 3]], [], [], []]\n> \n> 输出: [null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]\n> \n> 解释: Solution solution = new Solution([1, 2, 3]); solution.shuffle(); // 打乱数组 [1,2,3] 并返回结果。任何 [1,2,3]的排列返回的概率应该相同。例如，返回 [3, 1, 2] solution.reset(); // 重设数组到它的初始状态 [1, 2, 3] 。返回 [1, 2, 3] solution.shuffle(); // 随机返回数组 [1, 2, 3] 打乱后的结果。例如，返回 [1, 3, 2]\n\n解析：\n\n本题可以采用经典的 Fisher-Yates 洗牌算法，原理是通过随机交换位置来实现随机打乱，有正向和反向两种写法。在每次迭代中，生成一个范围在当前下标到数组末尾元素下标之间的随机整数。接下来，将当前元素和随机选出的下标所指的元素互相交换，这一步模拟了每次从 “帽子” 里面摸一个元素的过程，其中选取下标范围的依据在于每个被摸出的元素都不可能再被摸出来了。此外还有一个需要注意的细节，当前元素是可以和它本身互相交换的 ，否则生成最后的排列组合的概率就不对了。\n\n注意 reset 函数以及类的构造函数的实现细节，使用成员变量保存原数组。\n\nclass Solution {\nprivate:\n    vector<int> origin;\n\npublic:\n    Solution(vector<int>& nums) {\n        origin = nums;\n    }\n    \n    vector<int> reset() {\n        return origin;\n    }\n    \n    vector<int> shuffle() {\n        // 反向洗牌\n        if(origin.empty()) return {};\n        vector<int> shuffleNum(origin);\n        for(int i=shuffleNum.size()-1;i>=0;--i){\n            int pos = rand()%(i+1);\n            swap(shuffleNum[i],shuffleNum[pos]);\n        }\n        // 正向洗牌\n        /*\n        int len = shuffleNum.size();\n        for(int i=0;i<len;++i){\n            int pos = rand()%(len-i);\n            swap(shuffleNum[i],shuffleNum[i+pos]);\n        }\n        */\n        return shuffleNum;\n    }\n};\n\n\n# 528 按权重随机选择\n\n给定一个数组，数组每个位置的值表示该位置的权重，要求按照权重的概率去随机采样。\n\n输入是一维正整数数组，表示权重；和一个包含指令字符串的一维数组，表示运行几次随机采样。输出是一维整数数组，表示随机采样的整数在数组中的位置。\n\n> 输入: weights = [1,3], actions: ["pickIndex","pickIndex","pickIndex"]\n> \n> 输出: [0,1,1]\n> \n> 解释：在这个样例中，每次选择的位置都是不确定的，但选择第 0 个位置的期望为 1/4，选择第 1个位置的期望为 3/4。\n\n解析：\n\n进一步读懂题目。假设有数组w: [1, 2, 3, 4], 那么这个数组的的和为 1 + 2 + 3 + 4 = 10。对应的得到 index {0,1,2,3} 的概率为 {1/10, 2/10, 3/10, 4/10}。现在要返回 {0,1,2,3} 中的随意一个index，但是要保证pickIndex()函数所得到这个index的概率是根据以上的权重来的。\n\n首先，求出前缀和表。paritial_sum()就是求前缀和，w[0] = W[0], w[1] = W[0] + W[1]...如此推算\n\n然后，求出前缀和表后最后一位数所包含的就是所有数字的和。用以上的例子 w.back() 最终会包含 1 + 2 + 3 + 4 = 10 接着，求出一个随机数，rand() % w.back(); 假设 w.back() = 10, 那么这里产生的数字是 0-9。如果我们继续用以上的例子的话那么其每个数字所对应取到的index便为，0 ：代表取到 index 0；1，2: 代表取到 index 1；3，4，5: 代表取到 index 2；6，7, 8, 9: 代表取到 index 3 最后，用以上的例子产生的前缀和表 [1, 3, 6, 10], 可以发现我们用得到的数字调用 upper_bound() 会刚好使其指向我们的 index 位置。0 的 upper_bound 会指向 index 0, 因为第一个比 0 大的数是 w[0] = 1；1, 2 的 upper_bound 会指向 index 1, 因为第一个比 1 或者 2 大的数是 w[1] = 3；3, 4, 5 的 upper_bound 会指向 index 2, 因为第一个比 {3, 4, 5} 大的数是 w[2] = 6；6, 7, 8, 9 的 upper_bound 会指向 index 3, 因为第一个比 {6，7, 8, 9} 大的数是 w[3] = 10;\n\nclass Solution {\nprivate:\n    vector<int> sums;\npublic:\n    Solution(vector<int>& w) {\n        sums = w;\n        partial_sum(sums.begin(),sums.end(),sums.begin()); \n    }\n    \n    int pickIndex() {\n        int pos = (rand()%sums.back()) + 1;\n        return lower_bound(sums.begin(), sums.end(), pos) - sums.begin();\n    }\n};\n\n\n# 382 链表随机节点\n\n给定一个单向链表，要求设计一个算法，可以随机取得其中的一个数字。\n\n输入是一个单向链表，输出是一个数字，表示链表里其中一个节点的值。\n\n> // 初始化一个单链表 [1,2,3]. ListNode head = new ListNode(1); head.next = new ListNode(2); head.next.next = new ListNode(3); Solution solution = new Solution(head);\n> \n> // getRandom()方法应随机返回1,2,3中的一个，保证每个元素被返回的概率相等。 solution.getRandom();\n\n解析：\n\n不同于数组，在未遍历完链表前，无法知道链表的总长度。这里可以使用水库采样：遍历一次链表，在遍历到第 m 个节点时，有 1/m 的概率选择这个节点覆盖掉之前的节点选择。采用水库算法满足每个点都有均等的概率被选择的随机性。\n\n水库采样，也称为蓄水池抽样算法。概算法常被用于大数据流中的随机抽样问题即：当内存无法加载全部数据时，如何从包含未知大小的数据流中随机选取k个数据，并且要保证每个数据被抽取到的概率相等。该算法每次只保留一个数，当遇到第 i 个数时，以 1/i的概率保留它，(i-1)/i的概率保留原来的数，采用这种方式始终保持每个数被保留的概率是 1/N。例如，{1,2,3} 三个数以数据流的形式读取：1到达时将其以概率为 1/1 保留；2到达时以概率 1/2 保留，1 以 (2-1) / 2 即 1/2 * 1 = 1/2 保留；3 到达时以概率 1/3 保留，1 以 (3-1)/2 * 1/2 = 1/3 保留，同理 2 也以1/3保留。可以看出水库抽样算法可以始终保持每个数被保留的概率都是 1/N。\n\nclass Solution {\n    ListNode* headNode;\npublic:\n    Solution(ListNode* head) {\n        headNode = head;\n    }\n    \n    int getRandom() {\n        int ans = headNode->val;\n        ListNode* node = headNode->next;\n        int i = 2;\n        while(node){\n            if(rand()%i == 0){\n                ans = node->val;\n            }\n            ++i;\n            node = node->next;\n        }\n        return ans;\n    }\n};\n\n\n# 470 用 Rand7() 实现 Rand10()\n\n已有方法 rand7 可生成 1 到 7 范围内的均匀随机整数，试写一个方法 rand10 生成 1 到 10 范围内的均匀随机整数。\n\n解析：\n\n用现有范围随机数生成函数构造新的范围的随机数生成函数。这种问题分为两种情况：一种是缩小原有随机数生成函数的范围，另一种是扩展原有随机数生成函数的范围。\n\n第一种缩小范围情况较为简单，只需要将范围之外的随机数丢弃即可。\n\n第二种扩展范围的情况要用到一个公式，(randM()-1) * M + randM() 可以生成1～M*M范围内的等概率随机数。\n\nclass Solution {\npublic:\n    int rand10() {\n        int num = (rand7()-1)*7+rand7();\n        while(num>10){\n            num = (rand7()-1)*7+rand7();\n        }\n        return num;\n    }\n};\n',normalizedContent:'# 08 随机数问题\n\n# 384 打乱数组\n\n给定一个数组，要求实现两个指令函数。第一个函数 shuﬄe() 可以随机打乱这个数组，第二个函数 reset() 可以恢复原来的顺序。\n\n输入是一个存有整数数字的数组，和一个包含指令函数名称的数组。输出是一个二维数组，表示每个指令生成的数组。\n\n> 输入: ["solution", "shuffle", "reset", "shuffle"] [[[1, 2, 3]], [], [], []]\n> \n> 输出: [null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]\n> \n> 解释: solution solution = new solution([1, 2, 3]); solution.shuffle(); // 打乱数组 [1,2,3] 并返回结果。任何 [1,2,3]的排列返回的概率应该相同。例如，返回 [3, 1, 2] solution.reset(); // 重设数组到它的初始状态 [1, 2, 3] 。返回 [1, 2, 3] solution.shuffle(); // 随机返回数组 [1, 2, 3] 打乱后的结果。例如，返回 [1, 3, 2]\n\n解析：\n\n本题可以采用经典的 fisher-yates 洗牌算法，原理是通过随机交换位置来实现随机打乱，有正向和反向两种写法。在每次迭代中，生成一个范围在当前下标到数组末尾元素下标之间的随机整数。接下来，将当前元素和随机选出的下标所指的元素互相交换，这一步模拟了每次从 “帽子” 里面摸一个元素的过程，其中选取下标范围的依据在于每个被摸出的元素都不可能再被摸出来了。此外还有一个需要注意的细节，当前元素是可以和它本身互相交换的 ，否则生成最后的排列组合的概率就不对了。\n\n注意 reset 函数以及类的构造函数的实现细节，使用成员变量保存原数组。\n\nclass solution {\nprivate:\n    vector<int> origin;\n\npublic:\n    solution(vector<int>& nums) {\n        origin = nums;\n    }\n    \n    vector<int> reset() {\n        return origin;\n    }\n    \n    vector<int> shuffle() {\n        // 反向洗牌\n        if(origin.empty()) return {};\n        vector<int> shufflenum(origin);\n        for(int i=shufflenum.size()-1;i>=0;--i){\n            int pos = rand()%(i+1);\n            swap(shufflenum[i],shufflenum[pos]);\n        }\n        // 正向洗牌\n        /*\n        int len = shufflenum.size();\n        for(int i=0;i<len;++i){\n            int pos = rand()%(len-i);\n            swap(shufflenum[i],shufflenum[i+pos]);\n        }\n        */\n        return shufflenum;\n    }\n};\n\n\n# 528 按权重随机选择\n\n给定一个数组，数组每个位置的值表示该位置的权重，要求按照权重的概率去随机采样。\n\n输入是一维正整数数组，表示权重；和一个包含指令字符串的一维数组，表示运行几次随机采样。输出是一维整数数组，表示随机采样的整数在数组中的位置。\n\n> 输入: weights = [1,3], actions: ["pickindex","pickindex","pickindex"]\n> \n> 输出: [0,1,1]\n> \n> 解释：在这个样例中，每次选择的位置都是不确定的，但选择第 0 个位置的期望为 1/4，选择第 1个位置的期望为 3/4。\n\n解析：\n\n进一步读懂题目。假设有数组w: [1, 2, 3, 4], 那么这个数组的的和为 1 + 2 + 3 + 4 = 10。对应的得到 index {0,1,2,3} 的概率为 {1/10, 2/10, 3/10, 4/10}。现在要返回 {0,1,2,3} 中的随意一个index，但是要保证pickindex()函数所得到这个index的概率是根据以上的权重来的。\n\n首先，求出前缀和表。paritial_sum()就是求前缀和，w[0] = w[0], w[1] = w[0] + w[1]...如此推算\n\n然后，求出前缀和表后最后一位数所包含的就是所有数字的和。用以上的例子 w.back() 最终会包含 1 + 2 + 3 + 4 = 10 接着，求出一个随机数，rand() % w.back(); 假设 w.back() = 10, 那么这里产生的数字是 0-9。如果我们继续用以上的例子的话那么其每个数字所对应取到的index便为，0 ：代表取到 index 0；1，2: 代表取到 index 1；3，4，5: 代表取到 index 2；6，7, 8, 9: 代表取到 index 3 最后，用以上的例子产生的前缀和表 [1, 3, 6, 10], 可以发现我们用得到的数字调用 upper_bound() 会刚好使其指向我们的 index 位置。0 的 upper_bound 会指向 index 0, 因为第一个比 0 大的数是 w[0] = 1；1, 2 的 upper_bound 会指向 index 1, 因为第一个比 1 或者 2 大的数是 w[1] = 3；3, 4, 5 的 upper_bound 会指向 index 2, 因为第一个比 {3, 4, 5} 大的数是 w[2] = 6；6, 7, 8, 9 的 upper_bound 会指向 index 3, 因为第一个比 {6，7, 8, 9} 大的数是 w[3] = 10;\n\nclass solution {\nprivate:\n    vector<int> sums;\npublic:\n    solution(vector<int>& w) {\n        sums = w;\n        partial_sum(sums.begin(),sums.end(),sums.begin()); \n    }\n    \n    int pickindex() {\n        int pos = (rand()%sums.back()) + 1;\n        return lower_bound(sums.begin(), sums.end(), pos) - sums.begin();\n    }\n};\n\n\n# 382 链表随机节点\n\n给定一个单向链表，要求设计一个算法，可以随机取得其中的一个数字。\n\n输入是一个单向链表，输出是一个数字，表示链表里其中一个节点的值。\n\n> // 初始化一个单链表 [1,2,3]. listnode head = new listnode(1); head.next = new listnode(2); head.next.next = new listnode(3); solution solution = new solution(head);\n> \n> // getrandom()方法应随机返回1,2,3中的一个，保证每个元素被返回的概率相等。 solution.getrandom();\n\n解析：\n\n不同于数组，在未遍历完链表前，无法知道链表的总长度。这里可以使用水库采样：遍历一次链表，在遍历到第 m 个节点时，有 1/m 的概率选择这个节点覆盖掉之前的节点选择。采用水库算法满足每个点都有均等的概率被选择的随机性。\n\n水库采样，也称为蓄水池抽样算法。概算法常被用于大数据流中的随机抽样问题即：当内存无法加载全部数据时，如何从包含未知大小的数据流中随机选取k个数据，并且要保证每个数据被抽取到的概率相等。该算法每次只保留一个数，当遇到第 i 个数时，以 1/i的概率保留它，(i-1)/i的概率保留原来的数，采用这种方式始终保持每个数被保留的概率是 1/n。例如，{1,2,3} 三个数以数据流的形式读取：1到达时将其以概率为 1/1 保留；2到达时以概率 1/2 保留，1 以 (2-1) / 2 即 1/2 * 1 = 1/2 保留；3 到达时以概率 1/3 保留，1 以 (3-1)/2 * 1/2 = 1/3 保留，同理 2 也以1/3保留。可以看出水库抽样算法可以始终保持每个数被保留的概率都是 1/n。\n\nclass solution {\n    listnode* headnode;\npublic:\n    solution(listnode* head) {\n        headnode = head;\n    }\n    \n    int getrandom() {\n        int ans = headnode->val;\n        listnode* node = headnode->next;\n        int i = 2;\n        while(node){\n            if(rand()%i == 0){\n                ans = node->val;\n            }\n            ++i;\n            node = node->next;\n        }\n        return ans;\n    }\n};\n\n\n# 470 用 rand7() 实现 rand10()\n\n已有方法 rand7 可生成 1 到 7 范围内的均匀随机整数，试写一个方法 rand10 生成 1 到 10 范围内的均匀随机整数。\n\n解析：\n\n用现有范围随机数生成函数构造新的范围的随机数生成函数。这种问题分为两种情况：一种是缩小原有随机数生成函数的范围，另一种是扩展原有随机数生成函数的范围。\n\n第一种缩小范围情况较为简单，只需要将范围之外的随机数丢弃即可。\n\n第二种扩展范围的情况要用到一个公式，(randm()-1) * m + randm() 可以生成1～m*m范围内的等概率随机数。\n\nclass solution {\npublic:\n    int rand10() {\n        int num = (rand7()-1)*7+rand7();\n        while(num>10){\n            num = (rand7()-1)*7+rand7();\n        }\n        return num;\n    }\n};\n',charsets:{cjk:!0},lastUpdated:"2023/11/19, 12:55:48",lastUpdatedTimestamp:1700369748e3},{title:"MathP",frontmatter:{title:"MathP",date:"2023-03-24T18:39:49.000Z",permalink:"/pages/49deb8/"},regularPath:"/03.LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/05.%E5%85%B6%E4%BB%96%E5%86%85%E5%AE%B9/01.%E6%95%B0%E5%AD%A6%E9%97%AE%E9%A2%98/MathP.html",relativePath:"03.LeetCode刷题笔记/05.其他内容/01.数学问题/MathP.md",key:"v-bc4d0168",path:"/pages/49deb8/",headers:[{level:2,title:"LeetCode刷题笔记 数学问题",slug:"leetcode刷题笔记-数学问题",normalizedTitle:"leetcode刷题笔记 数学问题",charIndex:2},{level:3,title:"01 公倍数与公因数",slug:"_01-公倍数与公因数",normalizedTitle:"01 公倍数与公因数",charIndex:24},{level:3,title:"02 质数问题",slug:"_02-质数问题",normalizedTitle:"02 质数问题",charIndex:507},{level:4,title:"204 计数质数",slug:"_204-计数质数",normalizedTitle:"204 计数质数",charIndex:589},{level:4,title:"172 阶乘后的零",slug:"_172-阶乘后的零",normalizedTitle:"172 阶乘后的零",charIndex:1467},{level:3,title:"03 进制转换问题",slug:"_03-进制转换问题",normalizedTitle:"03 进制转换问题",charIndex:2516},{level:4,title:"504 七进制数",slug:"_504-七进制数",normalizedTitle:"504 七进制数",charIndex:2529},{level:4,title:"168 Excel表列名称",slug:"_168-excel表列名称",normalizedTitle:"168 excel表列名称",charIndex:3167},{level:4,title:"202 快乐数",slug:"_202-快乐数",normalizedTitle:"202 快乐数",charIndex:3711},{level:3,title:"04 数字字符串求和问题",slug:"_04-数字字符串求和问题",normalizedTitle:"04 数字字符串求和问题",charIndex:4486},{level:4,title:"415 字符串相加",slug:"_415-字符串相加",normalizedTitle:"415 字符串相加",charIndex:4502},{level:4,title:"67 二进制求和",slug:"_67-二进制求和",normalizedTitle:"67 二进制求和",charIndex:5519},{level:3,title:"05 众数问题",slug:"_05-众数问题",normalizedTitle:"05 众数问题",charIndex:6342},{level:4,title:"169 多数元素",slug:"_169-多数元素",normalizedTitle:"169 多数元素",charIndex:6353},{level:4,title:"229 求众数 II",slug:"_229-求众数-ii",normalizedTitle:"229 求众数 ii",charIndex:7708},{level:3,title:"06 中位数问题",slug:"_06-中位数问题",normalizedTitle:"06 中位数问题",charIndex:9174},{level:4,title:"462 最少移动次数使数组元素相等 II",slug:"_462-最少移动次数使数组元素相等-ii",normalizedTitle:"462 最少移动次数使数组元素相等 ii",charIndex:9186},{level:3,title:"07 数字处理问题",slug:"_07-数字处理问题",normalizedTitle:"07 数字处理问题",charIndex:9724},{level:4,title:"238 除自身以外数组的乘积",slug:"_238-除自身以外数组的乘积",normalizedTitle:"238 除自身以外数组的乘积",charIndex:9737},{level:4,title:"326 3的幂",slug:"_326-3的幂",normalizedTitle:"326 3的幂",charIndex:11028},{level:3,title:"08 随机数问题",slug:"_08-随机数问题",normalizedTitle:"08 随机数问题",charIndex:11688},{level:4,title:"384 打乱数组",slug:"_384-打乱数组",normalizedTitle:"384 打乱数组",charIndex:11700},{level:4,title:"528 按权重随机选择",slug:"_528-按权重随机选择",normalizedTitle:"528 按权重随机选择",charIndex:13188},{level:4,title:"382 链表随机节点",slug:"_382-链表随机节点",normalizedTitle:"382 链表随机节点",charIndex:14635},{level:4,title:"470 用 Rand7() 实现 Rand10()",slug:"_470-用-rand7-实现-rand10",normalizedTitle:"470 用 rand7() 实现 rand10()",charIndex:15835}],headersStr:"LeetCode刷题笔记 数学问题 01 公倍数与公因数 02 质数问题 204 计数质数 172 阶乘后的零 03 进制转换问题 504 七进制数 168 Excel表列名称 202 快乐数 04 数字字符串求和问题 415 字符串相加 67 二进制求和 05 众数问题 169 多数元素 229 求众数 II 06 中位数问题 462 最少移动次数使数组元素相等 II 07 数字处理问题 238 除自身以外数组的乘积 326 3的幂 08 随机数问题 384 打乱数组 528 按权重随机选择 382 链表随机节点 470 用 Rand7() 实现 Rand10()",content:'# LeetCode刷题笔记 数学问题\n\n\n# 01 公倍数与公因数\n\n公倍数(common multiple)是指在两个或两个以上的自然数中，如果它们有相同的倍数，这些倍数就是它们的公倍数。公倍数中最小的，就称为这些整数的最小公倍数（lowest common multiple，lcm）\n\n公因数，亦称公约数。它是一个能同时整除若干整数的整数 。如果一个整数同时是几个整数的因数，称这个整数为它们的公因数；公因数中最大的称为最大公因数 （greatest common divisor，gcd）\n\n利用辗转相除法，计算公式为gcd(a,b) = gcd(b,a mod b)我们可以很方便地求得两个数的最大公因数；将两个数相乘再除以最大公因数即可得到最小公倍数。\n\nint gcd(int a, int b){\n    if(b==0){\n        return a;\n    }\n    return gcd(b, a % b);\n}\n\nint lcm(int a, int b){\n    int gcdRes = gcd(a,b);\n    return a*b / gcdRes;\n}\n\n\n\n# 02 质数问题\n\n质数又称素数，指的是指在大于 1 的自然数中，除了 1 和它本身以外不再有其他因数的自然数。值得注意的是，每一个数都可以分解成质数的乘积。\n\n# 204 计数质数\n\n给定一个数字 n，求小于 n 的质数的个数。\n\n输入一个整数，输出也是一个整数，表示小于输入数的质数的个数。\n\n> 输入：n = 10\n> 输出：4\n> 解释：小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。\n\n解析：\n\n埃拉托斯特尼筛法（Sieve of Eratosthenes，简称埃氏筛法）是非常常用的，判断一个整数是否是质数的方法。并且它可以在判断一个整数 n 时，同时判断所小于 n 的整数，因此非常适合这道题。其原理也十分易懂：从 1 到 n 遍历，假设当前遍历到 m，则把所有小于 n 的、且是 m 的倍数的整数标为和数；遍历完成后，没有被标为和数的数字即为质数。\n\n一般情况下标记和数时从 2m 开始标记，此处可以进一步优化，对于一个质数 m，如果从 2m 开始标记其实是冗余的，应该直接从 m^2 开始标记，因为 2m, 3m, … 这些数一定在 m^2 之前就被其他数的倍数标记过了，例如 2 的所有倍数，3 的所有倍数等。\n\nclass Solution {\npublic:\n    int countPrimes(int n) {\n        vector<bool> prime(n,true);\n        int ans = 0;\n        for(int i=2;i<n;++i){\n            if(prime[i]){\n                ++ans;\n                if((long long)i*i < n){ // i^2 可能越界 用长整型表示\n                    for(int j=i*i;j<n;j+=i){\n                        prime[j] = false;\n                    }\n                }\n            }\n        }\n        return ans;\n    }\n};\n\n\n# 172 阶乘后的零\n\n给定一个非负整数，判断它的阶乘结果的结尾有几个 0。\n\n输入一个非负整数，输出一个非负整数，表示输入的阶乘结果的结尾有几个 0。\n\n> 输入：n = 5\n> 输出：1\n> 解释：5! = 120 ，有一个尾随 0\n\n解析：\n\n唯一分解定理：任何一个大于1的自然数 N，如果 N 不为质数，那么 N 可以唯一分解成有限个质数的乘积。例如：42 = 2×3×7, 75 = 3×5×5。\n\n每个尾部的 0 由 2 × 5 = 10 而来，因此可以把阶乘的每一个元素拆成质数相乘，统计有多少个 2 和 5 数对。明显的，质因子 2 的数量远多于质因子 5 的数量，因为每 4 个数字算作额外的因子 2，但是只有每 25 个数字算作额外的因子 5，因此可以进一步优化只统计阶乘结果里有多少个质因子 5。\n\n对于一个数的阶乘，就如之前分析的，5 的因子一定是每隔 5 个数出现一次，也就是下边的样子。n! = 1 * 2 * 3 * 4 * (1 * 5) * ... * (2 * 5) * ... * (3 * 5) *... * n。因为每隔 5 个数出现一个 5，所以计算出现了多少个 5，我们只需要用 n/5 就可以算出来。\n\n但还没有结束，继续分析。... * (1 * 5) * ... * (1 * 5 * 5) * ... * (2 * 5 * 5) * ... * (3 * 5 * 5) * ... * n。每隔 25 个数字，出现的是两个 5，所以除了每隔 5 个数算作一个 5，每隔 25 个数，还需要多算一个 5。也就是我们需要再加上 n / 25 个 5。\n\n同理还会有每隔 5 * 5 * 5 = 125 个数字，会出现 3 个 5，所以还需要再加上 n / 125 。\n\n综上，规律就是每隔 5 个数，出现一个 5，每隔 25 个数，出现 2 个 5，每隔 125 个数，出现 3 个 5... 以此类推。最终 5 的个数就是 n / 5 + n / 25 + n / 125 ...\n\nclass Solution {\npublic:\n    int trailingZeroes(int n) {\n        if(n==0){\n            return 0;\n        }\n        int a = n / 5;\n        return a + trailingZeroes(a);\n    }\n};\n\n\n\n# 03 进制转换问题\n\n# 504 七进制数\n\n给定一个十进制整数，求它在七进制下的表示。\n\n输入一个整数，输出一个字符串，表示其七进制。\n\n> 输入: num = 100\n> 输出: "202"\n> 解释：100 的七进制表示法来源于 100 = 2 * 49 + 0 * 7 + 2 * 1。\n\n解析：\n\n进制转换类型的题，通常是利用除法和取模（mod）来进行计算，同时也要注意一些细节，如负数和零。如果输出是数字类型而非字符串，则也需要考虑是否会超出整数上下界。\n\nclass Solution {\npublic:\n    string convertToBase7(int num) {\n        if(num == 0) return "0";\n        bool isNegatibe = num < 0;\n        num = abs(num);\n        string ans;\n        while(num){\n            int a = num / 7;\n            int b = num % 7;\n            ans = to_string(b) + ans;\n            num = a;\n        }\n        if(isNegatibe){\n            return "-"+ans;\n        }\n        return ans;\n    }\n};\n\n\n# 168 Excel表列名称\n\n给你一个整数 columnNumber ，返回它在 Excel 表中相对应的列名称。\n\n输入一个整数，输出一个字符串表示Excel 表中相对应的列名称\n\n> 输入：columnNumber = 28\n> 输出："AB"\n\n解析：\n\n本题是进制转换题型的变种题，和504七进制转换题十分相似，可以视为26进制转换，但是需要注意的是输入的整数是从 1 开始而不是 0，所以要将输入减1。\n\nclass Solution {\npublic:\n    string convertToTitle(int columnNumber) {\n        string ans;\n        while(columnNumber){\n            int a = (columnNumber-1) / 26;\n            int b = (columnNumber-1) % 26;\n            columnNumber = a;\n            char c = b + \'A\';\n            ans = c + ans;\n        }\n        return ans;\n    }\n};\n\n\n# 202 快乐数\n\n输入一个整数，判断它是否是快乐数，快乐数是指将该数替换为它每个位置上的数字的平方和，如果该数进过上述过程最终变为 1,则称为快乐数\n\n> 输入：19\n> 输出：true\n> 解释：\n> 1^2 + 9^2 = 82\n> 8^2 + 2^2 = 68\n> 6^2 + 8^2 = 100\n> 1^2 + 0^2 + 0^2 = 1\n\n解析：\n\n本题有两个需要注意的地方，和504七进制转换题一样要能够转换出十进制每一位上的数值获取下一个数值。另一个点是，不是快乐数的数可能是 无限循环 但始终变不到 1，看到无限循环就能想到成环，而环路检测最常用的方法就是弗洛伊德判圈算法，可以使用快慢指针实现。\n\nclass Solution {\npublic:\n    int getNext(int num){\n        int nextNum = 0;\n        while(num){\n            int b = num % 10;\n            num = num / 10;\n            nextNum += b*b;\n        }\n        return nextNum;\n    }\n\n    bool isHappy(int n) {\n        int slow = n;\n        int fast = getNext(n);\n        while(fast!=1 && fast!=slow){\n            slow = getNext(slow);\n            fast = getNext(getNext(fast));\n        }\n        return fast == 1;\n    }\n};\n\n\n\n# 04 数字字符串求和问题\n\n# 415 字符串相加\n\n给定两个由数字组成的字符串，求它们相加的结果。\n\n输入是两个字符串，输出是一个整数，表示输入的数字和。\n\n> 输入：num1 = "11", num2 = "123"\n> 输出："134"\n\n解析：\n\n因为相加运算是从后往前进行的，所以可以先翻转字符串也可以从字符串尾部开始，再逐位计算。这种类型的题考察的是细节，如进位、位数差等等。\n\n从字符串尾部开始计算和，如果扫描超出其中一个字符串长度则用0值代替，如果两个字符串计算完毕要检查是否还存在进位。字符串的数值计算通过与字符\'0\'比较得到。\n\nclass Solution {\npublic:\n    string addStrings(string num1, string num2) {\n        int tail1 = num1.length()-1, tail2 = num2.length()-1;\n        string ans = "";\n        int addbit = 0;\n        while(tail1>=0 || tail2>=0 || addbit!=0){\n            int x = 0, y = 0;\n            if(tail1 >= 0){\n                x = num1[tail1--] - \'0\';\n            }\n            if(tail2 >=0 ){\n                y = num2[tail2--] - \'0\';\n            }\n            int add = x + y + addbit;\n            // 记录当前位计算结果\n            ans.push_back(add % 10 + \'0\');\n            // 记录进位情况\n            if(add < 10){\n                addbit = 0;\n            }else{\n                addbit = 1;\n            }\n        }\n        reverse(ans.begin(),ans.end());\n        return ans;\n    }\n};\n\n\n# 67 二进制求和\n\n给你两个二进制字符串，返回它们的和（用二进制表示）\n\n输入是两个字符串，输出是一个字符串，表示输入的二进制数字和。\n\n> 输入: a = "1010", b = "1011"\n> 输出: "10101"\n\n解析：\n\n本题和字符串相加类似，从尾部开始逐位运算，要注意进位和两个字符串位数差的情况。\n\nclass Solution {\npublic:\n    string addBinary(string a, string b) {\n        int taila = a.length()-1, tailb = b.length()-1;\n        string ans;\n        int addbit = 0;\n        while(taila>=0 || tailb>=0 || addbit){\n            int x = 0, y = 0;\n            if(taila >= 0){\n                x = a[taila--] - \'0\';\n            }\n            if(tailb >= 0){\n                y = b[tailb--] - \'0\';\n            }\n            int add = x + y + addbit;\n            char c = add % 2 + \'0\';\n            ans = c + ans;\n            if(add < 2){\n                addbit = 0;\n            }else{\n                addbit = 1;\n            }\n        }\n        return ans;\n    }\n};\n\n\n\n# 05 众数问题\n\n# 169 多数元素\n\n给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数 大于 n / 2 的元素。\n\n输入一个一维数组，输出一个整数，表示数组中个数占多数的元素。\n\n> 输入：[3,2,3]\n> 输出：3\n\n解析：\n\n采用哈希表是一种最为直接的方法，统计数组中每个元素出现的次数，然后找出频次最高的元素即可。\n\nclass Solution {\npublic:\n    int majorityElement(vector<int>& nums) {\n        unordered_map<int,int> counts;\n        for(const auto elem:nums){\n            if(counts.find(elem) != counts.end()){\n                counts[elem]++;\n            }else{\n                counts.insert(make_pair(elem,1));\n            }\n        }\n        int ans = 0;\n        int max = INT_MIN;\n        for(const auto count: counts){\n            if(count.second > max){\n                ans = count.first;\n                max = count.second;\n            }\n        }\n        return ans;\n    }\n};\n\n\n本题也可以采用摩尔投票法更加简洁的解决。摩尔投票法的基本原理是：在数组中找到两个不相同的元素并删除它们，不断重复此过程，直到数组中元素都相同，那么剩下的元素就是主要元素。\n\n这种找主要元素的方法是怎么得以实现的呢？该投票法，遇到相同的元素则票数加 1，遇到不同的元素则票数减 1，当该元素的票数为 0 时更换投票主要元素。在主要元素个数大于 n / 2 的情况下，相当于每个主要元素和其他元素两两相互抵消，抵消到最后肯定还剩余至少 1 个多数元素。\n\nclass Solution {\npublic:\n    int majorityElement(vector<int>& nums) {\n        int major = nums[0];\n        int count = 0;\n        for(int i=0;i<nums.size();++i){\n            if(major == nums[i]){\n                ++count;\n            }else if(count == 0){\n                major = nums[i];\n            }else{\n                --count;\n            }\n        }\n        return major;\n    }\n};\n\n\n# 229 求众数 II\n\n给定一个大小为 n 的整数数组，找出其中所有出现超过 n / 3 次的元素。\n\n输入一个一维数组，输出一个一维数组包含所有频次超过 n/3 的元素\n\n> 输入：[1,1,1,3,3,2,2,2]\n> 输出：[1,2]\n\n解析：\n\n本题是摩尔投票法的进阶用法，摩尔投票法的核心是通过抵消和计票选出多数，可以推出规律：如果至多选一个代表，那他的票数至少要超过一半 1/2 的票数；如果至多选两个代表，那他们的票数至少要超过 1/3 的票数；类推可知，如果至多选 m 个代表，那他们的票数至少要超过 1 / (m+1) 的票数。\n\n回到本题，求频次超过 n/3 的元素，那么最多只有两个，要注意多个主要元素时的抵消情况：（1）A同B不同，A++，B不变；（2）A不同B同，A不变，B++；（3）AB均不同，A--，B--；。\n\nclass Solution {\npublic:\n    vector<int> majorityElement(vector<int>& nums) {\n        vector<int> res;        \n        const int len = nums.size();\t\t\n        int major1, major2;        \n        int count1 = 0, count2 = 0;        \n        for(int i = 0; i < len; i++) {\n            // 存在元素相同\n            if(nums[i] == major1){\n                ++count1;\n            }\n            else if(nums[i] == major2){\n                ++count2;\n            }\n            // 替换主要元素\n            else if(count1 == 0) {\n\t\t\t\tmajor1 = nums[i];\n\t\t\t\tcount1 = 1;\n\t\t\t}\n            else if(count2 == 0) {\n\t\t\t\tmajor2 = nums[i];\n\t\t\t\tcount2 = 1;\n\t\t\t}\n            // 与major1和major2都不同时才抵消，如果只有一个不同的情况是另一个计数增加，不要想成了让不同的那一个去抵消，这里容易出错\n            else {\n\t\t\t\tcount1--;\n\t\t\t\tcount2--;\n\t\t\t}\n        }\n        // 检验结果中元素数目是否超过三分之一\n        count1 = 0, count2 = 0;\n        for(auto &num : nums) {\n            if(num == major1) count1++;\n            else if(num == major2) count2++;\n        }\n\n        if(count1 > len / 3) res.push_back(major1);\n        if(count2 > len / 3) res.push_back(major2);\n        return res;\n    }\n};\n\n\n\n# 06 中位数问题\n\n# 462 最少移动次数使数组元素相等 II\n\n给定一个非空整数数组，找到使所有数组元素相等所需的最小移动数，其中每次移动可将选定的一个元素加1或减1。 您可以假设数组的长度最多为10000。\n\n输入一个数组，输出一个整数表示最少移动的步数。\n\n> 输入: [1,2,3]\n> \n> 输出: 2\n> \n> 解释：只有两个动作是必要的（记得每一步仅可使其中一个元素加1或减1）： [1,2,3] => [2,2,3] => [2,2,2]\n\n解析：\n\n本题的关键是找数组的中位数。\n\nclass Solution {\npublic:\n    int minMoves2(vector<int>& nums) {\n        sort(nums.begin(),nums.end());\n        int len = nums.size();\n        int mid = nums[len/2];\n        int ans = 0;\n        for(int i=0;i<len;++i){\n            ans += abs(nums[i]-mid);\n        }\n        return ans;\n    }\n};\n\n\n\n# 07 数字处理问题\n\n# 238 除自身以外数组的乘积\n\n给定一个长度为 n 的整数数组 nums，其中 n > 1，返回输出数组 output ，其中 output[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积。\n\n输入一个数组，输出一个数组，其中每个元素数值为除本身之外所有元素的乘积\n\n> 输入: [1,2,3,4]\n> 输出: [24,12,8,6]\n\n解析：\n\n本题与135题分糖果相似，可以先从左到右计算当前元素左侧所有元素的乘积，然后从右到左计算当前元素右侧所有元素的乘积，再将两个元素乘积相乘得到最终结果。\n\nclass Solution {\npublic:\n    vector<int> productExceptSelf(vector<int>& nums) {\n        int len = nums.size();\n        vector<int> output(len,1);\n        vector<int> L(len,1);\n        vector<int> R(len,1);\n        for(int i=1;i<len;++i){\n            L[i] = L[i-1] * nums[i-1];\n        }\n        for(int i=len-2;i>=0;--i){\n            R[i] = R[i+1] * nums[i+1];\n            output[i] = L[i]*R[i];\n        }\n        output[len-1] = L[len-1];\n        return output;\n    }\n};\n\n\n进一步优化空间复杂的，在从左和从右扫描中，用一个全局变量记录 i 之前或 i 之后所有元素的乘积\n\nclass Solution {\npublic:\n    vector<int> productExceptSelf(vector<int>& nums) {\n        int len = nums.size();\n        vector<int> output(len,1);\n        int product = nums[0];\n        for(int i=1;i<len;++i){  \n            output[i] = product;\n            product *= nums[i]; // 记录从开头到当前位置中所有元素的乘积\n        }\n        product = nums[len-1];\n        for(int i=len-2;i>=0;--i){\n            output[i] *= product;\n            product *= nums[i];// 记录从结尾到当前位置中所有元素的乘积\n        }\n        return output;\n    }\n};\n\n\n# 326 3的幂\n\n判断一个数字是否是 3 的次方。\n\n输入一个整数，输出一个布尔值。\n\n> Input: n = 27 Output: true\n\n解析：\n\n第一种方式是使用对数函数以3为底的对数函数，如果 n 是 3 的次方那么其值应该为整数。math库中提供了以 e 为底的log()和以10为底的log10()，根据换底公式有log3(n) = log10(n)/log10(3)。 $$ log_a^b = log_c^b / log_c^a $$\n\nclass Solution {\npublic:\n    bool isPowerOfThree(int n) {\n        if(n == 0) return false;\n        double m = log10(n) / log10(3);\n        // fmod(double x, double y) 用于计算浮点数取模\n        return fmod(m,1) == 0; \n    }\n};\n\n\n另一中方式因为在 int 范围内 3 的最大次方是 3^19 = 1162261467，如果 n 是 3 的整数次方，那么 1162261467 除以 n 的余数一定是零；反之亦然。\n\nclass Solution {\npublic:\n    bool isPowerOfThree(int n) {\n        return n > 0 && 1162261467 % n == 0;\n    }\n};\n\n\n\n# 08 随机数问题\n\n# 384 打乱数组\n\n给定一个数组，要求实现两个指令函数。第一个函数 shuﬄe() 可以随机打乱这个数组，第二个函数 reset() 可以恢复原来的顺序。\n\n输入是一个存有整数数字的数组，和一个包含指令函数名称的数组。输出是一个二维数组，表示每个指令生成的数组。\n\n> 输入: ["Solution", "shuffle", "reset", "shuffle"] [[[1, 2, 3]], [], [], []]\n> \n> 输出: [null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]\n> \n> 解释: Solution solution = new Solution([1, 2, 3]); solution.shuffle(); // 打乱数组 [1,2,3] 并返回结果。任何 [1,2,3]的排列返回的概率应该相同。例如，返回 [3, 1, 2] solution.reset(); // 重设数组到它的初始状态 [1, 2, 3] 。返回 [1, 2, 3] solution.shuffle(); // 随机返回数组 [1, 2, 3] 打乱后的结果。例如，返回 [1, 3, 2]\n\n解析：\n\n本题可以采用经典的 Fisher-Yates 洗牌算法，原理是通过随机交换位置来实现随机打乱，有正向和反向两种写法。在每次迭代中，生成一个范围在当前下标到数组末尾元素下标之间的随机整数。接下来，将当前元素和随机选出的下标所指的元素互相交换，这一步模拟了每次从 “帽子” 里面摸一个元素的过程，其中选取下标范围的依据在于每个被摸出的元素都不可能再被摸出来了。此外还有一个需要注意的细节，当前元素是可以和它本身互相交换的 ，否则生成最后的排列组合的概率就不对了。\n\n注意 reset 函数以及类的构造函数的实现细节，使用成员变量保存原数组。\n\nclass Solution {\nprivate:\n    vector<int> origin;\n\npublic:\n    Solution(vector<int>& nums) {\n        origin = nums;\n    }\n    \n    vector<int> reset() {\n        return origin;\n    }\n    \n    vector<int> shuffle() {\n        // 反向洗牌\n        if(origin.empty()) return {};\n        vector<int> shuffleNum(origin);\n        for(int i=shuffleNum.size()-1;i>=0;--i){\n            int pos = rand()%(i+1);\n            swap(shuffleNum[i],shuffleNum[pos]);\n        }\n        // 正向洗牌\n        /*\n        int len = shuffleNum.size();\n        for(int i=0;i<len;++i){\n            int pos = rand()%(len-i);\n            swap(shuffleNum[i],shuffleNum[i+pos]);\n        }\n        */\n        return shuffleNum;\n    }\n};\n\n\n# 528 按权重随机选择\n\n给定一个数组，数组每个位置的值表示该位置的权重，要求按照权重的概率去随机采样。\n\n输入是一维正整数数组，表示权重；和一个包含指令字符串的一维数组，表示运行几次随机采样。输出是一维整数数组，表示随机采样的整数在数组中的位置。\n\n> 输入: weights = [1,3], actions: ["pickIndex","pickIndex","pickIndex"]\n> \n> 输出: [0,1,1]\n> \n> 解释：在这个样例中，每次选择的位置都是不确定的，但选择第 0 个位置的期望为 1/4，选择第 1个位置的期望为 3/4。\n\n解析：\n\n进一步读懂题目。假设有数组w: [1, 2, 3, 4], 那么这个数组的的和为 1 + 2 + 3 + 4 = 10。对应的得到 index {0,1,2,3} 的概率为 {1/10, 2/10, 3/10, 4/10}。现在要返回 {0,1,2,3} 中的随意一个index，但是要保证pickIndex()函数所得到这个index的概率是根据以上的权重来的。\n\n首先，求出前缀和表。paritial_sum()就是求前缀和，w[0] = W[0], w[1] = W[0] + W[1]...如此推算\n\n然后，求出前缀和表后最后一位数所包含的就是所有数字的和。用以上的例子 w.back() 最终会包含 1 + 2 + 3 + 4 = 10 接着，求出一个随机数，rand() % w.back(); 假设 w.back() = 10, 那么这里产生的数字是 0-9。如果我们继续用以上的例子的话那么其每个数字所对应取到的index便为，0 ：代表取到 index 0；1，2: 代表取到 index 1；3，4，5: 代表取到 index 2；6，7, 8, 9: 代表取到 index 3 最后，用以上的例子产生的前缀和表 [1, 3, 6, 10], 可以发现我们用得到的数字调用 upper_bound() 会刚好使其指向我们的 index 位置。0 的 upper_bound 会指向 index 0, 因为第一个比 0 大的数是 w[0] = 1；1, 2 的 upper_bound 会指向 index 1, 因为第一个比 1 或者 2 大的数是 w[1] = 3；3, 4, 5 的 upper_bound 会指向 index 2, 因为第一个比 {3, 4, 5} 大的数是 w[2] = 6；6, 7, 8, 9 的 upper_bound 会指向 index 3, 因为第一个比 {6，7, 8, 9} 大的数是 w[3] = 10;\n\nclass Solution {\nprivate:\n    vector<int> sums;\npublic:\n    Solution(vector<int>& w) {\n        sums = w;\n        partial_sum(sums.begin(),sums.end(),sums.begin()); \n    }\n    \n    int pickIndex() {\n        int pos = (rand()%sums.back()) + 1;\n        return lower_bound(sums.begin(), sums.end(), pos) - sums.begin();\n    }\n};\n\n\n# 382 链表随机节点\n\n给定一个单向链表，要求设计一个算法，可以随机取得其中的一个数字。\n\n输入是一个单向链表，输出是一个数字，表示链表里其中一个节点的值。\n\n> // 初始化一个单链表 [1,2,3]. ListNode head = new ListNode(1); head.next = new ListNode(2); head.next.next = new ListNode(3); Solution solution = new Solution(head);\n> \n> // getRandom()方法应随机返回1,2,3中的一个，保证每个元素被返回的概率相等。 solution.getRandom();\n\n解析：\n\n不同于数组，在未遍历完链表前，无法知道链表的总长度。这里可以使用水库采样：遍历一次链表，在遍历到第 m 个节点时，有 1/m 的概率选择这个节点覆盖掉之前的节点选择。采用水库算法满足每个点都有均等的概率被选择的随机性。\n\n水库采样，也称为蓄水池抽样算法。概算法常被用于大数据流中的随机抽样问题即：当内存无法加载全部数据时，如何从包含未知大小的数据流中随机选取k个数据，并且要保证每个数据被抽取到的概率相等。该算法每次只保留一个数，当遇到第 i 个数时，以 1/i的概率保留它，(i-1)/i的概率保留原来的数，采用这种方式始终保持每个数被保留的概率是 1/N。例如，{1,2,3} 三个数以数据流的形式读取：1到达时将其以概率为 1/1 保留；2到达时以概率 1/2 保留，1 以 (2-1) / 2 即 1/2 * 1 = 1/2 保留；3 到达时以概率 1/3 保留，1 以 (3-1)/2 * 1/2 = 1/3 保留，同理 2 也以1/3保留。可以看出水库抽样算法可以始终保持每个数被保留的概率都是 1/N。\n\nclass Solution {\n    ListNode* headNode;\npublic:\n    Solution(ListNode* head) {\n        headNode = head;\n    }\n    \n    int getRandom() {\n        int ans = headNode->val;\n        ListNode* node = headNode->next;\n        int i = 2;\n        while(node){\n            if(rand()%i == 0){\n                ans = node->val;\n            }\n            ++i;\n            node = node->next;\n        }\n        return ans;\n    }\n};\n\n\n# 470 用 Rand7() 实现 Rand10()\n\n已有方法 rand7 可生成 1 到 7 范围内的均匀随机整数，试写一个方法 rand10 生成 1 到 10 范围内的均匀随机整数。\n\n解析：\n\n用现有范围随机数生成函数构造新的范围的随机数生成函数。这种问题分为两种情况：一种是缩小原有随机数生成函数的范围，另一种是扩展原有随机数生成函数的范围。\n\n第一种缩小范围情况较为简单，只需要将范围之外的随机数丢弃即可。\n\n第二种扩展范围的情况要用到一个公式，(randM()-1) * M + randM() 可以生成1～M*M范围内的等概率随机数。\n\nclass Solution {\npublic:\n    int rand10() {\n        int num = (rand7()-1)*7+rand7();\n        while(num>10){\n            num = (rand7()-1)*7+rand7();\n        }\n        return num;\n    }\n};\n',normalizedContent:'# leetcode刷题笔记 数学问题\n\n\n# 01 公倍数与公因数\n\n公倍数(common multiple)是指在两个或两个以上的自然数中，如果它们有相同的倍数，这些倍数就是它们的公倍数。公倍数中最小的，就称为这些整数的最小公倍数（lowest common multiple，lcm）\n\n公因数，亦称公约数。它是一个能同时整除若干整数的整数 。如果一个整数同时是几个整数的因数，称这个整数为它们的公因数；公因数中最大的称为最大公因数 （greatest common divisor，gcd）\n\n利用辗转相除法，计算公式为gcd(a,b) = gcd(b,a mod b)我们可以很方便地求得两个数的最大公因数；将两个数相乘再除以最大公因数即可得到最小公倍数。\n\nint gcd(int a, int b){\n    if(b==0){\n        return a;\n    }\n    return gcd(b, a % b);\n}\n\nint lcm(int a, int b){\n    int gcdres = gcd(a,b);\n    return a*b / gcdres;\n}\n\n\n\n# 02 质数问题\n\n质数又称素数，指的是指在大于 1 的自然数中，除了 1 和它本身以外不再有其他因数的自然数。值得注意的是，每一个数都可以分解成质数的乘积。\n\n# 204 计数质数\n\n给定一个数字 n，求小于 n 的质数的个数。\n\n输入一个整数，输出也是一个整数，表示小于输入数的质数的个数。\n\n> 输入：n = 10\n> 输出：4\n> 解释：小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。\n\n解析：\n\n埃拉托斯特尼筛法（sieve of eratosthenes，简称埃氏筛法）是非常常用的，判断一个整数是否是质数的方法。并且它可以在判断一个整数 n 时，同时判断所小于 n 的整数，因此非常适合这道题。其原理也十分易懂：从 1 到 n 遍历，假设当前遍历到 m，则把所有小于 n 的、且是 m 的倍数的整数标为和数；遍历完成后，没有被标为和数的数字即为质数。\n\n一般情况下标记和数时从 2m 开始标记，此处可以进一步优化，对于一个质数 m，如果从 2m 开始标记其实是冗余的，应该直接从 m^2 开始标记，因为 2m, 3m, … 这些数一定在 m^2 之前就被其他数的倍数标记过了，例如 2 的所有倍数，3 的所有倍数等。\n\nclass solution {\npublic:\n    int countprimes(int n) {\n        vector<bool> prime(n,true);\n        int ans = 0;\n        for(int i=2;i<n;++i){\n            if(prime[i]){\n                ++ans;\n                if((long long)i*i < n){ // i^2 可能越界 用长整型表示\n                    for(int j=i*i;j<n;j+=i){\n                        prime[j] = false;\n                    }\n                }\n            }\n        }\n        return ans;\n    }\n};\n\n\n# 172 阶乘后的零\n\n给定一个非负整数，判断它的阶乘结果的结尾有几个 0。\n\n输入一个非负整数，输出一个非负整数，表示输入的阶乘结果的结尾有几个 0。\n\n> 输入：n = 5\n> 输出：1\n> 解释：5! = 120 ，有一个尾随 0\n\n解析：\n\n唯一分解定理：任何一个大于1的自然数 n，如果 n 不为质数，那么 n 可以唯一分解成有限个质数的乘积。例如：42 = 2×3×7, 75 = 3×5×5。\n\n每个尾部的 0 由 2 × 5 = 10 而来，因此可以把阶乘的每一个元素拆成质数相乘，统计有多少个 2 和 5 数对。明显的，质因子 2 的数量远多于质因子 5 的数量，因为每 4 个数字算作额外的因子 2，但是只有每 25 个数字算作额外的因子 5，因此可以进一步优化只统计阶乘结果里有多少个质因子 5。\n\n对于一个数的阶乘，就如之前分析的，5 的因子一定是每隔 5 个数出现一次，也就是下边的样子。n! = 1 * 2 * 3 * 4 * (1 * 5) * ... * (2 * 5) * ... * (3 * 5) *... * n。因为每隔 5 个数出现一个 5，所以计算出现了多少个 5，我们只需要用 n/5 就可以算出来。\n\n但还没有结束，继续分析。... * (1 * 5) * ... * (1 * 5 * 5) * ... * (2 * 5 * 5) * ... * (3 * 5 * 5) * ... * n。每隔 25 个数字，出现的是两个 5，所以除了每隔 5 个数算作一个 5，每隔 25 个数，还需要多算一个 5。也就是我们需要再加上 n / 25 个 5。\n\n同理还会有每隔 5 * 5 * 5 = 125 个数字，会出现 3 个 5，所以还需要再加上 n / 125 。\n\n综上，规律就是每隔 5 个数，出现一个 5，每隔 25 个数，出现 2 个 5，每隔 125 个数，出现 3 个 5... 以此类推。最终 5 的个数就是 n / 5 + n / 25 + n / 125 ...\n\nclass solution {\npublic:\n    int trailingzeroes(int n) {\n        if(n==0){\n            return 0;\n        }\n        int a = n / 5;\n        return a + trailingzeroes(a);\n    }\n};\n\n\n\n# 03 进制转换问题\n\n# 504 七进制数\n\n给定一个十进制整数，求它在七进制下的表示。\n\n输入一个整数，输出一个字符串，表示其七进制。\n\n> 输入: num = 100\n> 输出: "202"\n> 解释：100 的七进制表示法来源于 100 = 2 * 49 + 0 * 7 + 2 * 1。\n\n解析：\n\n进制转换类型的题，通常是利用除法和取模（mod）来进行计算，同时也要注意一些细节，如负数和零。如果输出是数字类型而非字符串，则也需要考虑是否会超出整数上下界。\n\nclass solution {\npublic:\n    string converttobase7(int num) {\n        if(num == 0) return "0";\n        bool isnegatibe = num < 0;\n        num = abs(num);\n        string ans;\n        while(num){\n            int a = num / 7;\n            int b = num % 7;\n            ans = to_string(b) + ans;\n            num = a;\n        }\n        if(isnegatibe){\n            return "-"+ans;\n        }\n        return ans;\n    }\n};\n\n\n# 168 excel表列名称\n\n给你一个整数 columnnumber ，返回它在 excel 表中相对应的列名称。\n\n输入一个整数，输出一个字符串表示excel 表中相对应的列名称\n\n> 输入：columnnumber = 28\n> 输出："ab"\n\n解析：\n\n本题是进制转换题型的变种题，和504七进制转换题十分相似，可以视为26进制转换，但是需要注意的是输入的整数是从 1 开始而不是 0，所以要将输入减1。\n\nclass solution {\npublic:\n    string converttotitle(int columnnumber) {\n        string ans;\n        while(columnnumber){\n            int a = (columnnumber-1) / 26;\n            int b = (columnnumber-1) % 26;\n            columnnumber = a;\n            char c = b + \'a\';\n            ans = c + ans;\n        }\n        return ans;\n    }\n};\n\n\n# 202 快乐数\n\n输入一个整数，判断它是否是快乐数，快乐数是指将该数替换为它每个位置上的数字的平方和，如果该数进过上述过程最终变为 1,则称为快乐数\n\n> 输入：19\n> 输出：true\n> 解释：\n> 1^2 + 9^2 = 82\n> 8^2 + 2^2 = 68\n> 6^2 + 8^2 = 100\n> 1^2 + 0^2 + 0^2 = 1\n\n解析：\n\n本题有两个需要注意的地方，和504七进制转换题一样要能够转换出十进制每一位上的数值获取下一个数值。另一个点是，不是快乐数的数可能是 无限循环 但始终变不到 1，看到无限循环就能想到成环，而环路检测最常用的方法就是弗洛伊德判圈算法，可以使用快慢指针实现。\n\nclass solution {\npublic:\n    int getnext(int num){\n        int nextnum = 0;\n        while(num){\n            int b = num % 10;\n            num = num / 10;\n            nextnum += b*b;\n        }\n        return nextnum;\n    }\n\n    bool ishappy(int n) {\n        int slow = n;\n        int fast = getnext(n);\n        while(fast!=1 && fast!=slow){\n            slow = getnext(slow);\n            fast = getnext(getnext(fast));\n        }\n        return fast == 1;\n    }\n};\n\n\n\n# 04 数字字符串求和问题\n\n# 415 字符串相加\n\n给定两个由数字组成的字符串，求它们相加的结果。\n\n输入是两个字符串，输出是一个整数，表示输入的数字和。\n\n> 输入：num1 = "11", num2 = "123"\n> 输出："134"\n\n解析：\n\n因为相加运算是从后往前进行的，所以可以先翻转字符串也可以从字符串尾部开始，再逐位计算。这种类型的题考察的是细节，如进位、位数差等等。\n\n从字符串尾部开始计算和，如果扫描超出其中一个字符串长度则用0值代替，如果两个字符串计算完毕要检查是否还存在进位。字符串的数值计算通过与字符\'0\'比较得到。\n\nclass solution {\npublic:\n    string addstrings(string num1, string num2) {\n        int tail1 = num1.length()-1, tail2 = num2.length()-1;\n        string ans = "";\n        int addbit = 0;\n        while(tail1>=0 || tail2>=0 || addbit!=0){\n            int x = 0, y = 0;\n            if(tail1 >= 0){\n                x = num1[tail1--] - \'0\';\n            }\n            if(tail2 >=0 ){\n                y = num2[tail2--] - \'0\';\n            }\n            int add = x + y + addbit;\n            // 记录当前位计算结果\n            ans.push_back(add % 10 + \'0\');\n            // 记录进位情况\n            if(add < 10){\n                addbit = 0;\n            }else{\n                addbit = 1;\n            }\n        }\n        reverse(ans.begin(),ans.end());\n        return ans;\n    }\n};\n\n\n# 67 二进制求和\n\n给你两个二进制字符串，返回它们的和（用二进制表示）\n\n输入是两个字符串，输出是一个字符串，表示输入的二进制数字和。\n\n> 输入: a = "1010", b = "1011"\n> 输出: "10101"\n\n解析：\n\n本题和字符串相加类似，从尾部开始逐位运算，要注意进位和两个字符串位数差的情况。\n\nclass solution {\npublic:\n    string addbinary(string a, string b) {\n        int taila = a.length()-1, tailb = b.length()-1;\n        string ans;\n        int addbit = 0;\n        while(taila>=0 || tailb>=0 || addbit){\n            int x = 0, y = 0;\n            if(taila >= 0){\n                x = a[taila--] - \'0\';\n            }\n            if(tailb >= 0){\n                y = b[tailb--] - \'0\';\n            }\n            int add = x + y + addbit;\n            char c = add % 2 + \'0\';\n            ans = c + ans;\n            if(add < 2){\n                addbit = 0;\n            }else{\n                addbit = 1;\n            }\n        }\n        return ans;\n    }\n};\n\n\n\n# 05 众数问题\n\n# 169 多数元素\n\n给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数 大于 n / 2 的元素。\n\n输入一个一维数组，输出一个整数，表示数组中个数占多数的元素。\n\n> 输入：[3,2,3]\n> 输出：3\n\n解析：\n\n采用哈希表是一种最为直接的方法，统计数组中每个元素出现的次数，然后找出频次最高的元素即可。\n\nclass solution {\npublic:\n    int majorityelement(vector<int>& nums) {\n        unordered_map<int,int> counts;\n        for(const auto elem:nums){\n            if(counts.find(elem) != counts.end()){\n                counts[elem]++;\n            }else{\n                counts.insert(make_pair(elem,1));\n            }\n        }\n        int ans = 0;\n        int max = int_min;\n        for(const auto count: counts){\n            if(count.second > max){\n                ans = count.first;\n                max = count.second;\n            }\n        }\n        return ans;\n    }\n};\n\n\n本题也可以采用摩尔投票法更加简洁的解决。摩尔投票法的基本原理是：在数组中找到两个不相同的元素并删除它们，不断重复此过程，直到数组中元素都相同，那么剩下的元素就是主要元素。\n\n这种找主要元素的方法是怎么得以实现的呢？该投票法，遇到相同的元素则票数加 1，遇到不同的元素则票数减 1，当该元素的票数为 0 时更换投票主要元素。在主要元素个数大于 n / 2 的情况下，相当于每个主要元素和其他元素两两相互抵消，抵消到最后肯定还剩余至少 1 个多数元素。\n\nclass solution {\npublic:\n    int majorityelement(vector<int>& nums) {\n        int major = nums[0];\n        int count = 0;\n        for(int i=0;i<nums.size();++i){\n            if(major == nums[i]){\n                ++count;\n            }else if(count == 0){\n                major = nums[i];\n            }else{\n                --count;\n            }\n        }\n        return major;\n    }\n};\n\n\n# 229 求众数 ii\n\n给定一个大小为 n 的整数数组，找出其中所有出现超过 n / 3 次的元素。\n\n输入一个一维数组，输出一个一维数组包含所有频次超过 n/3 的元素\n\n> 输入：[1,1,1,3,3,2,2,2]\n> 输出：[1,2]\n\n解析：\n\n本题是摩尔投票法的进阶用法，摩尔投票法的核心是通过抵消和计票选出多数，可以推出规律：如果至多选一个代表，那他的票数至少要超过一半 1/2 的票数；如果至多选两个代表，那他们的票数至少要超过 1/3 的票数；类推可知，如果至多选 m 个代表，那他们的票数至少要超过 1 / (m+1) 的票数。\n\n回到本题，求频次超过 n/3 的元素，那么最多只有两个，要注意多个主要元素时的抵消情况：（1）a同b不同，a++，b不变；（2）a不同b同，a不变，b++；（3）ab均不同，a--，b--；。\n\nclass solution {\npublic:\n    vector<int> majorityelement(vector<int>& nums) {\n        vector<int> res;        \n        const int len = nums.size();\t\t\n        int major1, major2;        \n        int count1 = 0, count2 = 0;        \n        for(int i = 0; i < len; i++) {\n            // 存在元素相同\n            if(nums[i] == major1){\n                ++count1;\n            }\n            else if(nums[i] == major2){\n                ++count2;\n            }\n            // 替换主要元素\n            else if(count1 == 0) {\n\t\t\t\tmajor1 = nums[i];\n\t\t\t\tcount1 = 1;\n\t\t\t}\n            else if(count2 == 0) {\n\t\t\t\tmajor2 = nums[i];\n\t\t\t\tcount2 = 1;\n\t\t\t}\n            // 与major1和major2都不同时才抵消，如果只有一个不同的情况是另一个计数增加，不要想成了让不同的那一个去抵消，这里容易出错\n            else {\n\t\t\t\tcount1--;\n\t\t\t\tcount2--;\n\t\t\t}\n        }\n        // 检验结果中元素数目是否超过三分之一\n        count1 = 0, count2 = 0;\n        for(auto &num : nums) {\n            if(num == major1) count1++;\n            else if(num == major2) count2++;\n        }\n\n        if(count1 > len / 3) res.push_back(major1);\n        if(count2 > len / 3) res.push_back(major2);\n        return res;\n    }\n};\n\n\n\n# 06 中位数问题\n\n# 462 最少移动次数使数组元素相等 ii\n\n给定一个非空整数数组，找到使所有数组元素相等所需的最小移动数，其中每次移动可将选定的一个元素加1或减1。 您可以假设数组的长度最多为10000。\n\n输入一个数组，输出一个整数表示最少移动的步数。\n\n> 输入: [1,2,3]\n> \n> 输出: 2\n> \n> 解释：只有两个动作是必要的（记得每一步仅可使其中一个元素加1或减1）： [1,2,3] => [2,2,3] => [2,2,2]\n\n解析：\n\n本题的关键是找数组的中位数。\n\nclass solution {\npublic:\n    int minmoves2(vector<int>& nums) {\n        sort(nums.begin(),nums.end());\n        int len = nums.size();\n        int mid = nums[len/2];\n        int ans = 0;\n        for(int i=0;i<len;++i){\n            ans += abs(nums[i]-mid);\n        }\n        return ans;\n    }\n};\n\n\n\n# 07 数字处理问题\n\n# 238 除自身以外数组的乘积\n\n给定一个长度为 n 的整数数组 nums，其中 n > 1，返回输出数组 output ，其中 output[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积。\n\n输入一个数组，输出一个数组，其中每个元素数值为除本身之外所有元素的乘积\n\n> 输入: [1,2,3,4]\n> 输出: [24,12,8,6]\n\n解析：\n\n本题与135题分糖果相似，可以先从左到右计算当前元素左侧所有元素的乘积，然后从右到左计算当前元素右侧所有元素的乘积，再将两个元素乘积相乘得到最终结果。\n\nclass solution {\npublic:\n    vector<int> productexceptself(vector<int>& nums) {\n        int len = nums.size();\n        vector<int> output(len,1);\n        vector<int> l(len,1);\n        vector<int> r(len,1);\n        for(int i=1;i<len;++i){\n            l[i] = l[i-1] * nums[i-1];\n        }\n        for(int i=len-2;i>=0;--i){\n            r[i] = r[i+1] * nums[i+1];\n            output[i] = l[i]*r[i];\n        }\n        output[len-1] = l[len-1];\n        return output;\n    }\n};\n\n\n进一步优化空间复杂的，在从左和从右扫描中，用一个全局变量记录 i 之前或 i 之后所有元素的乘积\n\nclass solution {\npublic:\n    vector<int> productexceptself(vector<int>& nums) {\n        int len = nums.size();\n        vector<int> output(len,1);\n        int product = nums[0];\n        for(int i=1;i<len;++i){  \n            output[i] = product;\n            product *= nums[i]; // 记录从开头到当前位置中所有元素的乘积\n        }\n        product = nums[len-1];\n        for(int i=len-2;i>=0;--i){\n            output[i] *= product;\n            product *= nums[i];// 记录从结尾到当前位置中所有元素的乘积\n        }\n        return output;\n    }\n};\n\n\n# 326 3的幂\n\n判断一个数字是否是 3 的次方。\n\n输入一个整数，输出一个布尔值。\n\n> input: n = 27 output: true\n\n解析：\n\n第一种方式是使用对数函数以3为底的对数函数，如果 n 是 3 的次方那么其值应该为整数。math库中提供了以 e 为底的log()和以10为底的log10()，根据换底公式有log3(n) = log10(n)/log10(3)。 $$ log_a^b = log_c^b / log_c^a $$\n\nclass solution {\npublic:\n    bool ispowerofthree(int n) {\n        if(n == 0) return false;\n        double m = log10(n) / log10(3);\n        // fmod(double x, double y) 用于计算浮点数取模\n        return fmod(m,1) == 0; \n    }\n};\n\n\n另一中方式因为在 int 范围内 3 的最大次方是 3^19 = 1162261467，如果 n 是 3 的整数次方，那么 1162261467 除以 n 的余数一定是零；反之亦然。\n\nclass solution {\npublic:\n    bool ispowerofthree(int n) {\n        return n > 0 && 1162261467 % n == 0;\n    }\n};\n\n\n\n# 08 随机数问题\n\n# 384 打乱数组\n\n给定一个数组，要求实现两个指令函数。第一个函数 shuﬄe() 可以随机打乱这个数组，第二个函数 reset() 可以恢复原来的顺序。\n\n输入是一个存有整数数字的数组，和一个包含指令函数名称的数组。输出是一个二维数组，表示每个指令生成的数组。\n\n> 输入: ["solution", "shuffle", "reset", "shuffle"] [[[1, 2, 3]], [], [], []]\n> \n> 输出: [null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]\n> \n> 解释: solution solution = new solution([1, 2, 3]); solution.shuffle(); // 打乱数组 [1,2,3] 并返回结果。任何 [1,2,3]的排列返回的概率应该相同。例如，返回 [3, 1, 2] solution.reset(); // 重设数组到它的初始状态 [1, 2, 3] 。返回 [1, 2, 3] solution.shuffle(); // 随机返回数组 [1, 2, 3] 打乱后的结果。例如，返回 [1, 3, 2]\n\n解析：\n\n本题可以采用经典的 fisher-yates 洗牌算法，原理是通过随机交换位置来实现随机打乱，有正向和反向两种写法。在每次迭代中，生成一个范围在当前下标到数组末尾元素下标之间的随机整数。接下来，将当前元素和随机选出的下标所指的元素互相交换，这一步模拟了每次从 “帽子” 里面摸一个元素的过程，其中选取下标范围的依据在于每个被摸出的元素都不可能再被摸出来了。此外还有一个需要注意的细节，当前元素是可以和它本身互相交换的 ，否则生成最后的排列组合的概率就不对了。\n\n注意 reset 函数以及类的构造函数的实现细节，使用成员变量保存原数组。\n\nclass solution {\nprivate:\n    vector<int> origin;\n\npublic:\n    solution(vector<int>& nums) {\n        origin = nums;\n    }\n    \n    vector<int> reset() {\n        return origin;\n    }\n    \n    vector<int> shuffle() {\n        // 反向洗牌\n        if(origin.empty()) return {};\n        vector<int> shufflenum(origin);\n        for(int i=shufflenum.size()-1;i>=0;--i){\n            int pos = rand()%(i+1);\n            swap(shufflenum[i],shufflenum[pos]);\n        }\n        // 正向洗牌\n        /*\n        int len = shufflenum.size();\n        for(int i=0;i<len;++i){\n            int pos = rand()%(len-i);\n            swap(shufflenum[i],shufflenum[i+pos]);\n        }\n        */\n        return shufflenum;\n    }\n};\n\n\n# 528 按权重随机选择\n\n给定一个数组，数组每个位置的值表示该位置的权重，要求按照权重的概率去随机采样。\n\n输入是一维正整数数组，表示权重；和一个包含指令字符串的一维数组，表示运行几次随机采样。输出是一维整数数组，表示随机采样的整数在数组中的位置。\n\n> 输入: weights = [1,3], actions: ["pickindex","pickindex","pickindex"]\n> \n> 输出: [0,1,1]\n> \n> 解释：在这个样例中，每次选择的位置都是不确定的，但选择第 0 个位置的期望为 1/4，选择第 1个位置的期望为 3/4。\n\n解析：\n\n进一步读懂题目。假设有数组w: [1, 2, 3, 4], 那么这个数组的的和为 1 + 2 + 3 + 4 = 10。对应的得到 index {0,1,2,3} 的概率为 {1/10, 2/10, 3/10, 4/10}。现在要返回 {0,1,2,3} 中的随意一个index，但是要保证pickindex()函数所得到这个index的概率是根据以上的权重来的。\n\n首先，求出前缀和表。paritial_sum()就是求前缀和，w[0] = w[0], w[1] = w[0] + w[1]...如此推算\n\n然后，求出前缀和表后最后一位数所包含的就是所有数字的和。用以上的例子 w.back() 最终会包含 1 + 2 + 3 + 4 = 10 接着，求出一个随机数，rand() % w.back(); 假设 w.back() = 10, 那么这里产生的数字是 0-9。如果我们继续用以上的例子的话那么其每个数字所对应取到的index便为，0 ：代表取到 index 0；1，2: 代表取到 index 1；3，4，5: 代表取到 index 2；6，7, 8, 9: 代表取到 index 3 最后，用以上的例子产生的前缀和表 [1, 3, 6, 10], 可以发现我们用得到的数字调用 upper_bound() 会刚好使其指向我们的 index 位置。0 的 upper_bound 会指向 index 0, 因为第一个比 0 大的数是 w[0] = 1；1, 2 的 upper_bound 会指向 index 1, 因为第一个比 1 或者 2 大的数是 w[1] = 3；3, 4, 5 的 upper_bound 会指向 index 2, 因为第一个比 {3, 4, 5} 大的数是 w[2] = 6；6, 7, 8, 9 的 upper_bound 会指向 index 3, 因为第一个比 {6，7, 8, 9} 大的数是 w[3] = 10;\n\nclass solution {\nprivate:\n    vector<int> sums;\npublic:\n    solution(vector<int>& w) {\n        sums = w;\n        partial_sum(sums.begin(),sums.end(),sums.begin()); \n    }\n    \n    int pickindex() {\n        int pos = (rand()%sums.back()) + 1;\n        return lower_bound(sums.begin(), sums.end(), pos) - sums.begin();\n    }\n};\n\n\n# 382 链表随机节点\n\n给定一个单向链表，要求设计一个算法，可以随机取得其中的一个数字。\n\n输入是一个单向链表，输出是一个数字，表示链表里其中一个节点的值。\n\n> // 初始化一个单链表 [1,2,3]. listnode head = new listnode(1); head.next = new listnode(2); head.next.next = new listnode(3); solution solution = new solution(head);\n> \n> // getrandom()方法应随机返回1,2,3中的一个，保证每个元素被返回的概率相等。 solution.getrandom();\n\n解析：\n\n不同于数组，在未遍历完链表前，无法知道链表的总长度。这里可以使用水库采样：遍历一次链表，在遍历到第 m 个节点时，有 1/m 的概率选择这个节点覆盖掉之前的节点选择。采用水库算法满足每个点都有均等的概率被选择的随机性。\n\n水库采样，也称为蓄水池抽样算法。概算法常被用于大数据流中的随机抽样问题即：当内存无法加载全部数据时，如何从包含未知大小的数据流中随机选取k个数据，并且要保证每个数据被抽取到的概率相等。该算法每次只保留一个数，当遇到第 i 个数时，以 1/i的概率保留它，(i-1)/i的概率保留原来的数，采用这种方式始终保持每个数被保留的概率是 1/n。例如，{1,2,3} 三个数以数据流的形式读取：1到达时将其以概率为 1/1 保留；2到达时以概率 1/2 保留，1 以 (2-1) / 2 即 1/2 * 1 = 1/2 保留；3 到达时以概率 1/3 保留，1 以 (3-1)/2 * 1/2 = 1/3 保留，同理 2 也以1/3保留。可以看出水库抽样算法可以始终保持每个数被保留的概率都是 1/n。\n\nclass solution {\n    listnode* headnode;\npublic:\n    solution(listnode* head) {\n        headnode = head;\n    }\n    \n    int getrandom() {\n        int ans = headnode->val;\n        listnode* node = headnode->next;\n        int i = 2;\n        while(node){\n            if(rand()%i == 0){\n                ans = node->val;\n            }\n            ++i;\n            node = node->next;\n        }\n        return ans;\n    }\n};\n\n\n# 470 用 rand7() 实现 rand10()\n\n已有方法 rand7 可生成 1 到 7 范围内的均匀随机整数，试写一个方法 rand10 生成 1 到 10 范围内的均匀随机整数。\n\n解析：\n\n用现有范围随机数生成函数构造新的范围的随机数生成函数。这种问题分为两种情况：一种是缩小原有随机数生成函数的范围，另一种是扩展原有随机数生成函数的范围。\n\n第一种缩小范围情况较为简单，只需要将范围之外的随机数丢弃即可。\n\n第二种扩展范围的情况要用到一个公式，(randm()-1) * m + randm() 可以生成1～m*m范围内的等概率随机数。\n\nclass solution {\npublic:\n    int rand10() {\n        int num = (rand7()-1)*7+rand7();\n        while(num>10){\n            num = (rand7()-1)*7+rand7();\n        }\n        return num;\n    }\n};\n',charsets:{cjk:!0},lastUpdated:"2023/11/19, 12:55:48",lastUpdatedTimestamp:1700369748e3},{title:"01公倍数与公因数",frontmatter:{title:"01公倍数与公因数",date:"2023-03-24T18:39:49.000Z",permalink:"/pages/1a23eb/"},regularPath:"/03.LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/05.%E5%85%B6%E4%BB%96%E5%86%85%E5%AE%B9/01.%E6%95%B0%E5%AD%A6%E9%97%AE%E9%A2%98/01.%E5%85%AC%E5%80%8D%E6%95%B0%E4%B8%8E%E5%85%AC%E5%9B%A0%E6%95%B0.html",relativePath:"03.LeetCode刷题笔记/05.其他内容/01.数学问题/01.公倍数与公因数.md",key:"v-4604aeb0",path:"/pages/1a23eb/",headers:[{level:2,title:"01 公倍数与公因数",slug:"_01-公倍数与公因数",normalizedTitle:"01 公倍数与公因数",charIndex:2}],headersStr:"01 公倍数与公因数",content:"# 01 公倍数与公因数\n\n公倍数(common multiple)是指在两个或两个以上的自然数中，如果它们有相同的倍数，这些倍数就是它们的公倍数。公倍数中最小的，就称为这些整数的最小公倍数（lowest common multiple，lcm）\n\n公因数，亦称公约数。它是一个能同时整除若干整数的整数 。如果一个整数同时是几个整数的因数，称这个整数为它们的公因数；公因数中最大的称为最大公因数 （greatest common divisor，gcd）\n\n利用辗转相除法，计算公式为gcd(a,b) = gcd(b,a mod b)我们可以很方便地求得两个数的最大公因数；将两个数相乘再除以最大公因数即可得到最小公倍数。\n\nint gcd(int a, int b){\n    if(b==0){\n        return a;\n    }\n    return gcd(b, a % b);\n}\n\nint lcm(int a, int b){\n    int gcdRes = gcd(a,b);\n    return a*b / gcdRes;\n}\n",normalizedContent:"# 01 公倍数与公因数\n\n公倍数(common multiple)是指在两个或两个以上的自然数中，如果它们有相同的倍数，这些倍数就是它们的公倍数。公倍数中最小的，就称为这些整数的最小公倍数（lowest common multiple，lcm）\n\n公因数，亦称公约数。它是一个能同时整除若干整数的整数 。如果一个整数同时是几个整数的因数，称这个整数为它们的公因数；公因数中最大的称为最大公因数 （greatest common divisor，gcd）\n\n利用辗转相除法，计算公式为gcd(a,b) = gcd(b,a mod b)我们可以很方便地求得两个数的最大公因数；将两个数相乘再除以最大公因数即可得到最小公倍数。\n\nint gcd(int a, int b){\n    if(b==0){\n        return a;\n    }\n    return gcd(b, a % b);\n}\n\nint lcm(int a, int b){\n    int gcdres = gcd(a,b);\n    return a*b / gcdres;\n}\n",charsets:{cjk:!0},lastUpdated:"2023/11/19, 12:55:48",lastUpdatedTimestamp:1700369748e3},{title:"03二进制特性",frontmatter:{title:"03二进制特性",date:"2023-03-24T18:39:49.000Z",permalink:"/pages/d88bb5/"},regularPath:"/03.LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/05.%E5%85%B6%E4%BB%96%E5%86%85%E5%AE%B9/02.%E4%BD%8D%E8%BF%90%E7%AE%97/03.%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%89%B9%E6%80%A7.html",relativePath:"03.LeetCode刷题笔记/05.其他内容/02.位运算/03.二进制特性.md",key:"v-f90fe7f6",path:"/pages/d88bb5/",headers:[{level:2,title:"03 二进制特性",slug:"_03-二进制特性",normalizedTitle:"03 二进制特性",charIndex:2},{level:4,title:"342 4的幂",slug:"_342-4的幂",normalizedTitle:"342 4的幂",charIndex:133},{level:4,title:"318 最大单词长度乘积",slug:"_318-最大单词长度乘积",normalizedTitle:"318 最大单词长度乘积",charIndex:1069},{level:4,title:"338 比特位计数",slug:"_338-比特位计数",normalizedTitle:"338 比特位计数",charIndex:2514}],headersStr:"03 二进制特性 342 4的幂 318 最大单词长度乘积 338 比特位计数",content:'# 03 二进制特性\n\n利用二进制的一些特性，可以把位运算使用到更多问题上。例如，可以利用二进制和位运算输出一个数组的所有子集。假设有一个长度为 n 的数组，可以生成长度为 n 的所有二进制，1 表示选取该数字，0 表示不选取。这样就获得了 2^n 个子集。\n\n# 342 4的幂\n\n给定一个整数，判断它是否是 4 的次方。\n\n输入是一个整数，输出是一个布尔值，表示判断结果。\n\n> 输入：n = 16\n> 输出：true\n\n解析：\n\n本题可以采用按位与运算简单实现判断数是否为4的幂。如果 n 是 4 的幂，那么 n 的二进制表示中有且仅有一个 1 ，且其位置必须为奇数位，例如16 = (10000)，从右向左且从1开始计数的话，16的二进制表示中 1 位于第5位。根据此规律可以将 n 和二进制01010101010101010101010101010101或者十六进制的0x55555555做按位与，如果得到的结果不为零，那么说明这个数可能是 4 的幂。\n\n为什么说是可能呢？可以看出上述条件是充分条件而非充要条件，1 与0x55555555做按位与的结果也是非0的。\n\n所以需要进一步考虑该数 n 也是 2 的幂，才能保证上述条件判断结果为该数是 4 的幂。如果 n 是 2 的幂，那么 n 的二进制表示中也有且仅有一个 1，假设其位置为 pos ；那么 n - 1 二进制表示由第 1 位到第 pos-1 位全部为 1构成。例如16 = 10000; 15 = 01111 ，所以可以得出：如果 n & (n - 1) == 0，那么 n 是 2 的幂。\n\n最终得到：如果(n&(n-1))==0 && (n & 0x55555555)!=0，那么n 是 4 的幂。\n\nclass Solution {\npublic:\n    bool isPowerOfFour(int n) {\n        return n > 0 && !(n&(n-1)) && (n&0x55555555);\n    }\n};\n\n\n当然，本题也可以采用类似求 326. 3的幂 的方法直接使用对数函数的换底公式构造log4(n)，然后使用fmod()函数判断该值是否为整数，进而判断 n 是否是 4 的幂。\n\nclass Solution {\npublic:\n    bool isPowerOfFour(int n) {\n        return fmod(log10(n)/log10(4),1) == 0;\n    }\n};\n\n\n# 318 最大单词长度乘积\n\n给定多个字母串，求其中任意两个字母串的长度乘积的最大值，且这两个字母串不能含有相同字母。\n\n输入一个包含多个字母串的一维数组，输出一个整数，表示长度乘积的最大值。\n\n> 输入: ["a","ab","abc","d","cd","bcd","abcd"]\n> 输出: 4 \n> 解释: 这两个单词为 "ab", "cd"。\n\n解析：\n\n怎样快速判断两个字母串是否含有重复数字呢？可以为每个字母串建立一个长度为 26 的二进制数字 mask，用于表示从右到左每个位置表示是否存在a-z对应的字母。例如abc:111, abd:1011，如果两个字母串含有重复数字，那它们的二进制表示的按位与不为 0，例如abc,adbe存在相同的字母，将它们按位与的结果是1011!=0。\n\n怎么实现对字符串的编号记录呢？也可以通过位运算实现：首先将 mask 置为 0，然后遍历字符串的所有字符，每一次遍历中计算当前字符串所处的位置，然后使用算术左移，将标识 1 移动到指定位置，移动完成后将其与mask按位与运算，将位置记录在mask中。\n\n为了求长度乘积的最大值，可以建立一个哈希表记录字符串与其自身的长度。在计算长度乘积最大值时，遍历哈希表将不存在相同字母的字符串长度相乘并取最大值。\n\nclass Solution {\npublic:\n    int maxProduct(vector<string>& words) {\n        unordered_map<int,int> hash;\n        int ans = 0;\n        for(const auto& word: words){\n            int mask = 0;\n            int wordLen = word.length();\n            // 为当前字符串编码\n            for(const auto c:word){\n                // 考虑字符串中每一个字符时，将 1 左移 (c-\'a\') 位\n                int cPos = 1 << (c-\'a\');\n                // 与mask按位与，将当前字符的位置保存到mask中，如果当前字符已经存在不影响mask\n                mask = mask | cPos;\n            }\n            // 更新mask对应的长度时要考虑到：字符串中元素重复出现的情况，这种情况下字符串长度不一致 \n            hash[mask] = max(hash[mask],wordLen);\n            // 遍历所有已经记录的字符串，如果有不存在相同字符 （mask & h_mask）== 0 的字符串计算当前长度乘积\n            for(const auto& [h_mask,h_len]: hash){\n                if(!(mask & h_mask)){\n                    ans = max(ans,wordLen*h_len);\n                }\n            }\n        }\n        return ans;\n    }\n};\n\n\n# 338 比特位计数\n\n给定一个非负整数 n，求从 0 到 n 的所有数字的二进制表达中，分别有多少个 1。\n\n输入是一个非负整数 n，输出是长度为 n + 1 的非负整数数组，每个位置 m 表示 m 的二进制里有多少个 1。\n\n> 输入：n = 5 输出：[0,1,1,2,1,2] 解释：0 --\x3e 0, 1 --\x3e 1, 2 --\x3e 10, 3 --\x3e 11, 4 --\x3e 100, 5 --\x3e 101\n\n解析：\n\n本题如果使用双层循环逐个统计每个数二进制表示中1的个数会出现超时的情况。为了优化可以考虑使用动态规划来解题。\n\n设置状态：使用一个一维数组dp[i]表示第 i 个数的二进制表示中 1 的个数\n\n状态转移方程：对于第 i 个数字，如果该数为奇数即其二进制表示的末位为1，那么该数二进制表示中 1 的个数直接与前一个偶数相关为dp[i]=dp[i-1]+1；如果该数为偶数即其二进制表示的末位为0，那么该数二进制表示中 1 的个数与其算术右移一位结果相同，因为其算术右移一位将末位0移出后与对应数的二进制表示一致，即dp[i]=dp[i>>1]\n\n边界条件：当 n = 0时，dp[0]=0\n\nclass Solution {\npublic:\n    vector<int> countBits(int n) {\n        vector<int> dp(n+1,0);\n        for(int i=1;i<=n;++i){\n            if(i&1){\n                dp[i] = dp[i-1] + 1;\n            }else{\n                dp[i] = dp[i>>1];\n            }\n        }\n        return dp;\n    }\n};\n',normalizedContent:'# 03 二进制特性\n\n利用二进制的一些特性，可以把位运算使用到更多问题上。例如，可以利用二进制和位运算输出一个数组的所有子集。假设有一个长度为 n 的数组，可以生成长度为 n 的所有二进制，1 表示选取该数字，0 表示不选取。这样就获得了 2^n 个子集。\n\n# 342 4的幂\n\n给定一个整数，判断它是否是 4 的次方。\n\n输入是一个整数，输出是一个布尔值，表示判断结果。\n\n> 输入：n = 16\n> 输出：true\n\n解析：\n\n本题可以采用按位与运算简单实现判断数是否为4的幂。如果 n 是 4 的幂，那么 n 的二进制表示中有且仅有一个 1 ，且其位置必须为奇数位，例如16 = (10000)，从右向左且从1开始计数的话，16的二进制表示中 1 位于第5位。根据此规律可以将 n 和二进制01010101010101010101010101010101或者十六进制的0x55555555做按位与，如果得到的结果不为零，那么说明这个数可能是 4 的幂。\n\n为什么说是可能呢？可以看出上述条件是充分条件而非充要条件，1 与0x55555555做按位与的结果也是非0的。\n\n所以需要进一步考虑该数 n 也是 2 的幂，才能保证上述条件判断结果为该数是 4 的幂。如果 n 是 2 的幂，那么 n 的二进制表示中也有且仅有一个 1，假设其位置为 pos ；那么 n - 1 二进制表示由第 1 位到第 pos-1 位全部为 1构成。例如16 = 10000; 15 = 01111 ，所以可以得出：如果 n & (n - 1) == 0，那么 n 是 2 的幂。\n\n最终得到：如果(n&(n-1))==0 && (n & 0x55555555)!=0，那么n 是 4 的幂。\n\nclass solution {\npublic:\n    bool ispoweroffour(int n) {\n        return n > 0 && !(n&(n-1)) && (n&0x55555555);\n    }\n};\n\n\n当然，本题也可以采用类似求 326. 3的幂 的方法直接使用对数函数的换底公式构造log4(n)，然后使用fmod()函数判断该值是否为整数，进而判断 n 是否是 4 的幂。\n\nclass solution {\npublic:\n    bool ispoweroffour(int n) {\n        return fmod(log10(n)/log10(4),1) == 0;\n    }\n};\n\n\n# 318 最大单词长度乘积\n\n给定多个字母串，求其中任意两个字母串的长度乘积的最大值，且这两个字母串不能含有相同字母。\n\n输入一个包含多个字母串的一维数组，输出一个整数，表示长度乘积的最大值。\n\n> 输入: ["a","ab","abc","d","cd","bcd","abcd"]\n> 输出: 4 \n> 解释: 这两个单词为 "ab", "cd"。\n\n解析：\n\n怎样快速判断两个字母串是否含有重复数字呢？可以为每个字母串建立一个长度为 26 的二进制数字 mask，用于表示从右到左每个位置表示是否存在a-z对应的字母。例如abc:111, abd:1011，如果两个字母串含有重复数字，那它们的二进制表示的按位与不为 0，例如abc,adbe存在相同的字母，将它们按位与的结果是1011!=0。\n\n怎么实现对字符串的编号记录呢？也可以通过位运算实现：首先将 mask 置为 0，然后遍历字符串的所有字符，每一次遍历中计算当前字符串所处的位置，然后使用算术左移，将标识 1 移动到指定位置，移动完成后将其与mask按位与运算，将位置记录在mask中。\n\n为了求长度乘积的最大值，可以建立一个哈希表记录字符串与其自身的长度。在计算长度乘积最大值时，遍历哈希表将不存在相同字母的字符串长度相乘并取最大值。\n\nclass solution {\npublic:\n    int maxproduct(vector<string>& words) {\n        unordered_map<int,int> hash;\n        int ans = 0;\n        for(const auto& word: words){\n            int mask = 0;\n            int wordlen = word.length();\n            // 为当前字符串编码\n            for(const auto c:word){\n                // 考虑字符串中每一个字符时，将 1 左移 (c-\'a\') 位\n                int cpos = 1 << (c-\'a\');\n                // 与mask按位与，将当前字符的位置保存到mask中，如果当前字符已经存在不影响mask\n                mask = mask | cpos;\n            }\n            // 更新mask对应的长度时要考虑到：字符串中元素重复出现的情况，这种情况下字符串长度不一致 \n            hash[mask] = max(hash[mask],wordlen);\n            // 遍历所有已经记录的字符串，如果有不存在相同字符 （mask & h_mask）== 0 的字符串计算当前长度乘积\n            for(const auto& [h_mask,h_len]: hash){\n                if(!(mask & h_mask)){\n                    ans = max(ans,wordlen*h_len);\n                }\n            }\n        }\n        return ans;\n    }\n};\n\n\n# 338 比特位计数\n\n给定一个非负整数 n，求从 0 到 n 的所有数字的二进制表达中，分别有多少个 1。\n\n输入是一个非负整数 n，输出是长度为 n + 1 的非负整数数组，每个位置 m 表示 m 的二进制里有多少个 1。\n\n> 输入：n = 5 输出：[0,1,1,2,1,2] 解释：0 --\x3e 0, 1 --\x3e 1, 2 --\x3e 10, 3 --\x3e 11, 4 --\x3e 100, 5 --\x3e 101\n\n解析：\n\n本题如果使用双层循环逐个统计每个数二进制表示中1的个数会出现超时的情况。为了优化可以考虑使用动态规划来解题。\n\n设置状态：使用一个一维数组dp[i]表示第 i 个数的二进制表示中 1 的个数\n\n状态转移方程：对于第 i 个数字，如果该数为奇数即其二进制表示的末位为1，那么该数二进制表示中 1 的个数直接与前一个偶数相关为dp[i]=dp[i-1]+1；如果该数为偶数即其二进制表示的末位为0，那么该数二进制表示中 1 的个数与其算术右移一位结果相同，因为其算术右移一位将末位0移出后与对应数的二进制表示一致，即dp[i]=dp[i>>1]\n\n边界条件：当 n = 0时，dp[0]=0\n\nclass solution {\npublic:\n    vector<int> countbits(int n) {\n        vector<int> dp(n+1,0);\n        for(int i=1;i<=n;++i){\n            if(i&1){\n                dp[i] = dp[i-1] + 1;\n            }else{\n                dp[i] = dp[i>>1];\n            }\n        }\n        return dp;\n    }\n};\n',charsets:{cjk:!0},lastUpdated:"2023/11/19, 12:55:48",lastUpdatedTimestamp:1700369748e3},{title:"基本Linux命令",frontmatter:{title:"基本Linux命令",date:"2023-04-30T14:46:33.000Z",permalink:"/pages/bcf4de/"},regularPath:"/04.Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/01.Linux%20%E5%9F%BA%E7%A1%80/01.%E5%9F%BA%E6%9C%AC%20Linux%20%E5%91%BD%E4%BB%A4.html",relativePath:"04.Linux操作系统编程/01.Linux 基础/01.基本 Linux 命令.md",key:"v-48c7850e",path:"/pages/bcf4de/",headers:[{level:2,title:"基本LINUX命令",slug:"基本linux命令",normalizedTitle:"基本linux命令",charIndex:2},{level:3,title:"命令分类",slug:"命令分类",normalizedTitle:"命令分类",charIndex:16},{level:3,title:"文件目录类命令",slug:"文件目录类命令",normalizedTitle:"文件目录类命令",charIndex:25},{level:3,title:"进程控制类命令",slug:"进程控制类命令",normalizedTitle:"进程控制类命令",charIndex:36},{level:3,title:"用户和权限管理类命令",slug:"用户和权限管理类命令",normalizedTitle:"用户和权限管理类命令",charIndex:47}],headersStr:"基本LINUX命令 命令分类 文件目录类命令 进程控制类命令 用户和权限管理类命令",content:"# 基本LINUX命令\n\n\n# 命令分类\n\n * 文件目录类命令\n * 进程控制类命令\n * 用户和权限管理类命令\n\n\n# 文件目录类命令\n\n浏览目录命令\n\n * ls：list 显示目录文件\n * pwd：print working directory 显示当前所在的工作目录\n\n目录操作命令\n\n * cd：change directory 切换目录\n * mkdir：make directory 创建新目录\n * rmdir：remove directory 删除空目录\n\n浏览文件命令\n\n * cat：concatenate and display files 链接文件并打印到标准输出设备上\n * more/less：分页显示文件内容，使用space和enter换页换行\n * head/tail：显示文件前几行的内容；显示文件后几行的内容（多用于日志文件）\n\n文件操作命令\n\n * cp：copy 将文件从一处复制到另一处 cp param orpath depath\n * rm：remove 删除文件或目录\n * find：寻找文件或目录\n * grep：在文件中搜索匹配的字符并输出 grep param deString depath\n * tar：tape archive 打包文件和压缩解压文件\n\n\n# 进程控制类命令\n\n查看进程命令\n\n * ps：显示系统响应命令时的用户的进程信息\n * top：动态监视系统任务的工具，相当于任务管理器\n\n控制进程命令\n\n * kill：向某个进程传送一个信号 kill -signal PID\n * killall：使用进程的名称来杀死进程，区别于kill使用ps查看进程在使用grep查找进程过程\n * nice：改变进程的优先级，使得系统分配资源更加公平\n * renice：改变一个正在运行进程的优先级（nice值）\n\n进程的挂起和恢复\n\n * Ctrl+Z：挂起进程\n * jobs：查看被挂起的进程列表\n * fg/bg：将挂起进程恢复到前台/后台继续运行\n * Ctrl+C：终止进程\n\n\n# 用户和权限管理类命令\n\n用户管理命令\n\n * useradd：新建用户账号\n * passwd：设置或修改用户的口令和口令属性\n * usermod：user modify 修改用户的属性\n * userdel：user delete 删除指定用户账号\n * su：切换用户身份 exit退出超级用户\n\n用户组管理命令\n\n * groupadd：添加用户组\n * groupmod：修改用户组属性\n * groupdel：删除指定用户组\n\n文件权限命令\n\n * 权限：读取r、写入w、执行x\n * chmod：修改文件的访问权限\n * chown：change owner 改变文件所属的用户",normalizedContent:"# 基本linux命令\n\n\n# 命令分类\n\n * 文件目录类命令\n * 进程控制类命令\n * 用户和权限管理类命令\n\n\n# 文件目录类命令\n\n浏览目录命令\n\n * ls：list 显示目录文件\n * pwd：print working directory 显示当前所在的工作目录\n\n目录操作命令\n\n * cd：change directory 切换目录\n * mkdir：make directory 创建新目录\n * rmdir：remove directory 删除空目录\n\n浏览文件命令\n\n * cat：concatenate and display files 链接文件并打印到标准输出设备上\n * more/less：分页显示文件内容，使用space和enter换页换行\n * head/tail：显示文件前几行的内容；显示文件后几行的内容（多用于日志文件）\n\n文件操作命令\n\n * cp：copy 将文件从一处复制到另一处 cp param orpath depath\n * rm：remove 删除文件或目录\n * find：寻找文件或目录\n * grep：在文件中搜索匹配的字符并输出 grep param destring depath\n * tar：tape archive 打包文件和压缩解压文件\n\n\n# 进程控制类命令\n\n查看进程命令\n\n * ps：显示系统响应命令时的用户的进程信息\n * top：动态监视系统任务的工具，相当于任务管理器\n\n控制进程命令\n\n * kill：向某个进程传送一个信号 kill -signal pid\n * killall：使用进程的名称来杀死进程，区别于kill使用ps查看进程在使用grep查找进程过程\n * nice：改变进程的优先级，使得系统分配资源更加公平\n * renice：改变一个正在运行进程的优先级（nice值）\n\n进程的挂起和恢复\n\n * ctrl+z：挂起进程\n * jobs：查看被挂起的进程列表\n * fg/bg：将挂起进程恢复到前台/后台继续运行\n * ctrl+c：终止进程\n\n\n# 用户和权限管理类命令\n\n用户管理命令\n\n * useradd：新建用户账号\n * passwd：设置或修改用户的口令和口令属性\n * usermod：user modify 修改用户的属性\n * userdel：user delete 删除指定用户账号\n * su：切换用户身份 exit退出超级用户\n\n用户组管理命令\n\n * groupadd：添加用户组\n * groupmod：修改用户组属性\n * groupdel：删除指定用户组\n\n文件权限命令\n\n * 权限：读取r、写入w、执行x\n * chmod：修改文件的访问权限\n * chown：change owner 改变文件所属的用户",charsets:{cjk:!0},lastUpdated:"2023/11/19, 12:55:48",lastUpdatedTimestamp:1700369748e3},{title:"02妙用异或运算",frontmatter:{title:"02妙用异或运算",date:"2023-03-24T18:39:49.000Z",permalink:"/pages/bec6ef/"},regularPath:"/03.LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/05.%E5%85%B6%E4%BB%96%E5%86%85%E5%AE%B9/02.%E4%BD%8D%E8%BF%90%E7%AE%97/02.%E5%A6%99%E7%94%A8%E5%BC%82%E6%88%96%E8%BF%90%E7%AE%97.html",relativePath:"03.LeetCode刷题笔记/05.其他内容/02.位运算/02.妙用异或运算.md",key:"v-dbe28e3a",path:"/pages/bec6ef/",headers:[{level:2,title:"02 妙用异或运算",slug:"_02-妙用异或运算",normalizedTitle:"02 妙用异或运算",charIndex:2},{level:4,title:"476 数字的补数",slug:"_476-数字的补数",normalizedTitle:"476 数字的补数",charIndex:101},{level:4,title:"136 只出现一次的数字",slug:"_136-只出现一次的数字",normalizedTitle:"136 只出现一次的数字",charIndex:760},{level:4,title:"268 丢失的数字",slug:"_268-丢失的数字",normalizedTitle:"268 丢失的数字",charIndex:1272},{level:4,title:"260 只出现一次的数字 III",slug:"_260-只出现一次的数字-iii",normalizedTitle:"260 只出现一次的数字 iii",charIndex:2065},{level:4,title:"693 交替位二进制数",slug:"_693-交替位二进制数",normalizedTitle:"693 交替位二进制数",charIndex:3808}],headersStr:"02 妙用异或运算 476 数字的补数 136 只出现一次的数字 268 丢失的数字 260 只出现一次的数字 III 693 交替位二进制数",content:"# 02 妙用异或运算\n\n异或运算的特性十分重要 (1) x ^ 0000 = x; (2) x ^ 1111 = ~x; (3) x ^ x = 0，它的这些特性被广泛用于取返、去重等问题中。\n\n# 476 数字的补数\n\n给你一个 正 整数 num ，输出它的补数。补数是对该数的二进制表示取反。\n\n输入一个整数，输出一个整数表示原整数的补数\n\n> 输入：num = 5\n> 输出：2\n> 解释：5 的二进制表示为 101（没有前导零位），其补数为 010。所以你需要输出 2 。\n\n解析：\n\n看到二进制位取返就可以想到异或运算x^1111 = ~x，所以本题可以采用异或运算。本题的关键点在于怎样让参与异或运算的 1 所占位置与 num 二进制有效表示位置一致，一种方法是通过算术左移将 1 移动到有效位，同时怎么判断是否已经移到完整区间呢？可以采用与运算，如果 num 的最大有效位被覆盖，进行与运算的结果为0。\n\n变量            二进制表示\nnum           00000101\nmask          11111000\n~mask         00000111\n~mask ^ num   00000010\n\nclass Solution {\npublic:\n    int findComplement(int num) {\n        // 注意mask要用无符号，不然无法算术左移  -1 = 0xFFFFFFFF\n        unsigned mask = -1; \n        while(mask & num){\n            mask <<=1;\n        }\n        return ~mask^num;\n    }\n};\n\n\n# 136 只出现一次的数字\n\n给定一个整数数组，这个数组里只有一个数字出现了一次，其余数字出现了两次，求这个只出现一次的数字。\n\n输入是一个一维整数数组，输出是该数组内的一个整数。\n\n> 输入: [4,1,2,1,2]\n> 输出: 4\n\n解析：\n\n本题可以利用异或运算的特性快速找出唯一出现一次的数字，应为x^x=0, x^0=x。所以在数组中出现两次的所有数字按位异或的结果是 0，出现一次的数字与0按位异或运算的结果是其本身。例如[4,1,2,1,2]，进行异或运算有4^1^2^1^2 = 4^0 = 4。\n\n这类统计频次的题使用哈希表实现也有很好的效果。\n\nclass Solution {\npublic:\n    int singleNumber(vector<int>& nums) {\n        int ans = 0;\n        // 将数组中所有元素逐个按位异或运算\n        for(int i=0;i<nums.size();++i){\n            ans = ans^nums[i];\n        }\n        return ans;\n    }\n};\n\n\n# 268 丢失的数字\n\n给定一个包含 [0, n] 中 n 个数的数组 nums ，找出 [0, n] 这个范围内没有出现在数组中的那个数。\n\n输入一个数组，输出一个整数表示数组中没有出现的数。\n\n> 输入：nums = [3,0,1] 输出：2 解释：n = 3，因为有 3 个数字，所以所有的数字都在范围 [0,3] 内。2 是丢失的数字，因为它没有出现在 nums 中。\n\n解析：\n\n本题是136 只出现一次的数字的变种题，如果将 0 到 n 的所有数字都添加到 nums 中是不是就直接转换成了136题一样的题。例如nums = [3,0,1]，其长度为3那么添加0到3的所有元素构成nums = [3,0,1,0,1,2,3]，这样一看是不是就是找只出现一次的数字了。\n\n当然，我们不需要真的需要取重新构造 nums，在遍历 nums 时元素对应的索引就是要添加的元素。利用异或运算的特性x^x=0, x^0=x，将元素与索引进行按位异或运算最终就可以得到只出现一次的那个数了，例如3^1^0^2^1^2^3 = 2。当然，别忘了要将nums.size()这个元素加入异或运算。\n\nclass Solution {\npublic:\n    int missingNumber(vector<int>& nums) {\n        // 将nums.size()作为第一个参与异或运算的元素，当然将它放在最后参与效果是一样的\n        int ans = nums.size();\n        for(int i=0;i<nums.size();++i){\n            // 元素与索引进行按位异或运算\n            ans ^= (nums[i]^i);\n        }\n        return ans;\n    }\n};\n\n\n# 260 只出现一次的数字 III\n\n给定一个整数数组 nums，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素。\n\n输入一个一维数组，输出一个一维数组包含只出现一次的那两个元素\n\n> 输入：nums = [1,2,1,3,2,5]\n> 输出：[3,5]\n> 解释：[5, 3] 也是有效的答案。\n\n解析：\n\n本题是136 只出现一次的数字题的扩展，本题也可以使用异或运算解决，但是要考虑分组的情况。\n\n首先，遍历数组的所有元素，逐一进行异或运算的到只出现一次的那两个元素的异或运算结果，例如1^2^1^3^2^5 = 3^5\n\n只出现一次的那两个元素肯定不一样，所以他们的异或运算结果二进制表示中至少包含一个1。而整个数组就可以根据这个为1的二进制位进行划分，将数组中元素该位为0的划分为一组，该位为1的划分为另一组。采用这种策略就能将只出现一次的那两个元素划分到不同的组中。例如对数组1,2,1,3,2,5进行划分，3^5=(110)，根据第二位进行划分有：第一组：1(001), 1(001), 5(101)；第二组：2(010), 2(010), 3(011)\n\n然后在两组中分别进行如136 只出现一次的数字题的异或运算，分别得出只出现一次的那两个元素\n\n另一个难点在于怎么找到只出现一次的那两个元素的异或运算结果中1的位置，可以采用与476 数字的补数相似的方法。用mask = 0001不断的算术左移，直到mask & num != 0，那么mask中1的位置就是该划分位。\n\n根据mask划分元素也可以直接使用按位与运算，结果为0的一组，不为0的一组。\n\n    vector<int> singleNumber(vector<int>& nums) {\n        int res = 0;\n        // 计算只出现一次的那两个元素的异或运算结果\n        for(const auto num: nums){\n            res ^= num;\n        }\n        // 找划分位\n        int mask = 1;\n        while(!(mask & res)){\n            mask <<= 1;\n        }\n        // 分组异或运算\n        int a = 0, b = 0;\n        for(const auto num: nums){\n            if(mask&num){\n                a^=num;\n            }else{\n                b^=num;\n            }\n        }\n        return vector<int>{a,b};\n    }\n\n\n这种统计频次的题目，如果对空间复杂度没有要求的话，使用哈希表解决往往有较高的效率。\n\nclass Solution {\npublic:\n    vector<int> singleNumber(vector<int>& nums) {\n        unordered_map<int,int> hash;\n        vector<int> ans;\n        for(const auto num: nums){\n            if(hash.find(num) == hash.end()){\n                hash[num] = 1;\n            }else{\n                ++hash[num];\n            }\n        }\n        for(const auto [h_num,h_cnt]:hash){\n            if(h_cnt==1){\n                ans.push_back(h_num);\n            }\n        }\n        return ans;\n    }\n};\n\n\n# 693 交替位二进制数\n\n给定一个正整数，检查它的二进制表示是否总是 0、1 交替出现\n\n输入一个整数，输出一个布尔类型表示二进制表示是否总是 0、1 交替出现\n\n> 输入：n = 10\n> 输出：true\n> 解释：10 的二进制表示是：1010\n\n解析：\n\n一种简单的思路是不断使用算术右移将n的二进制表示末位移出，使用按位与运算获取末位是0还是1，并且比较第 i 个和第 i-1 个末位是否相同，如果相同则直接返回false，检查完成则返回true。\n\nclass Solution {\npublic:\n    bool hasAlternatingBits(int n) {\n        // 记录第一个末位\n        int pre = n & 1;\n        n>>=1;\n        while(n){\n            // 比较第 i 个和第 i-1 个末位\n            int now = n & 1;\n            if(now == pre){\n                return false;\n            }else{\n                // 更新前一个状态\n                pre = now;\n            }\n            n >>= 1;\n        }\n        return true;\n    }\n};\n",normalizedContent:"# 02 妙用异或运算\n\n异或运算的特性十分重要 (1) x ^ 0000 = x; (2) x ^ 1111 = ~x; (3) x ^ x = 0，它的这些特性被广泛用于取返、去重等问题中。\n\n# 476 数字的补数\n\n给你一个 正 整数 num ，输出它的补数。补数是对该数的二进制表示取反。\n\n输入一个整数，输出一个整数表示原整数的补数\n\n> 输入：num = 5\n> 输出：2\n> 解释：5 的二进制表示为 101（没有前导零位），其补数为 010。所以你需要输出 2 。\n\n解析：\n\n看到二进制位取返就可以想到异或运算x^1111 = ~x，所以本题可以采用异或运算。本题的关键点在于怎样让参与异或运算的 1 所占位置与 num 二进制有效表示位置一致，一种方法是通过算术左移将 1 移动到有效位，同时怎么判断是否已经移到完整区间呢？可以采用与运算，如果 num 的最大有效位被覆盖，进行与运算的结果为0。\n\n变量            二进制表示\nnum           00000101\nmask          11111000\n~mask         00000111\n~mask ^ num   00000010\n\nclass solution {\npublic:\n    int findcomplement(int num) {\n        // 注意mask要用无符号，不然无法算术左移  -1 = 0xffffffff\n        unsigned mask = -1; \n        while(mask & num){\n            mask <<=1;\n        }\n        return ~mask^num;\n    }\n};\n\n\n# 136 只出现一次的数字\n\n给定一个整数数组，这个数组里只有一个数字出现了一次，其余数字出现了两次，求这个只出现一次的数字。\n\n输入是一个一维整数数组，输出是该数组内的一个整数。\n\n> 输入: [4,1,2,1,2]\n> 输出: 4\n\n解析：\n\n本题可以利用异或运算的特性快速找出唯一出现一次的数字，应为x^x=0, x^0=x。所以在数组中出现两次的所有数字按位异或的结果是 0，出现一次的数字与0按位异或运算的结果是其本身。例如[4,1,2,1,2]，进行异或运算有4^1^2^1^2 = 4^0 = 4。\n\n这类统计频次的题使用哈希表实现也有很好的效果。\n\nclass solution {\npublic:\n    int singlenumber(vector<int>& nums) {\n        int ans = 0;\n        // 将数组中所有元素逐个按位异或运算\n        for(int i=0;i<nums.size();++i){\n            ans = ans^nums[i];\n        }\n        return ans;\n    }\n};\n\n\n# 268 丢失的数字\n\n给定一个包含 [0, n] 中 n 个数的数组 nums ，找出 [0, n] 这个范围内没有出现在数组中的那个数。\n\n输入一个数组，输出一个整数表示数组中没有出现的数。\n\n> 输入：nums = [3,0,1] 输出：2 解释：n = 3，因为有 3 个数字，所以所有的数字都在范围 [0,3] 内。2 是丢失的数字，因为它没有出现在 nums 中。\n\n解析：\n\n本题是136 只出现一次的数字的变种题，如果将 0 到 n 的所有数字都添加到 nums 中是不是就直接转换成了136题一样的题。例如nums = [3,0,1]，其长度为3那么添加0到3的所有元素构成nums = [3,0,1,0,1,2,3]，这样一看是不是就是找只出现一次的数字了。\n\n当然，我们不需要真的需要取重新构造 nums，在遍历 nums 时元素对应的索引就是要添加的元素。利用异或运算的特性x^x=0, x^0=x，将元素与索引进行按位异或运算最终就可以得到只出现一次的那个数了，例如3^1^0^2^1^2^3 = 2。当然，别忘了要将nums.size()这个元素加入异或运算。\n\nclass solution {\npublic:\n    int missingnumber(vector<int>& nums) {\n        // 将nums.size()作为第一个参与异或运算的元素，当然将它放在最后参与效果是一样的\n        int ans = nums.size();\n        for(int i=0;i<nums.size();++i){\n            // 元素与索引进行按位异或运算\n            ans ^= (nums[i]^i);\n        }\n        return ans;\n    }\n};\n\n\n# 260 只出现一次的数字 iii\n\n给定一个整数数组 nums，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素。\n\n输入一个一维数组，输出一个一维数组包含只出现一次的那两个元素\n\n> 输入：nums = [1,2,1,3,2,5]\n> 输出：[3,5]\n> 解释：[5, 3] 也是有效的答案。\n\n解析：\n\n本题是136 只出现一次的数字题的扩展，本题也可以使用异或运算解决，但是要考虑分组的情况。\n\n首先，遍历数组的所有元素，逐一进行异或运算的到只出现一次的那两个元素的异或运算结果，例如1^2^1^3^2^5 = 3^5\n\n只出现一次的那两个元素肯定不一样，所以他们的异或运算结果二进制表示中至少包含一个1。而整个数组就可以根据这个为1的二进制位进行划分，将数组中元素该位为0的划分为一组，该位为1的划分为另一组。采用这种策略就能将只出现一次的那两个元素划分到不同的组中。例如对数组1,2,1,3,2,5进行划分，3^5=(110)，根据第二位进行划分有：第一组：1(001), 1(001), 5(101)；第二组：2(010), 2(010), 3(011)\n\n然后在两组中分别进行如136 只出现一次的数字题的异或运算，分别得出只出现一次的那两个元素\n\n另一个难点在于怎么找到只出现一次的那两个元素的异或运算结果中1的位置，可以采用与476 数字的补数相似的方法。用mask = 0001不断的算术左移，直到mask & num != 0，那么mask中1的位置就是该划分位。\n\n根据mask划分元素也可以直接使用按位与运算，结果为0的一组，不为0的一组。\n\n    vector<int> singlenumber(vector<int>& nums) {\n        int res = 0;\n        // 计算只出现一次的那两个元素的异或运算结果\n        for(const auto num: nums){\n            res ^= num;\n        }\n        // 找划分位\n        int mask = 1;\n        while(!(mask & res)){\n            mask <<= 1;\n        }\n        // 分组异或运算\n        int a = 0, b = 0;\n        for(const auto num: nums){\n            if(mask&num){\n                a^=num;\n            }else{\n                b^=num;\n            }\n        }\n        return vector<int>{a,b};\n    }\n\n\n这种统计频次的题目，如果对空间复杂度没有要求的话，使用哈希表解决往往有较高的效率。\n\nclass solution {\npublic:\n    vector<int> singlenumber(vector<int>& nums) {\n        unordered_map<int,int> hash;\n        vector<int> ans;\n        for(const auto num: nums){\n            if(hash.find(num) == hash.end()){\n                hash[num] = 1;\n            }else{\n                ++hash[num];\n            }\n        }\n        for(const auto [h_num,h_cnt]:hash){\n            if(h_cnt==1){\n                ans.push_back(h_num);\n            }\n        }\n        return ans;\n    }\n};\n\n\n# 693 交替位二进制数\n\n给定一个正整数，检查它的二进制表示是否总是 0、1 交替出现\n\n输入一个整数，输出一个布尔类型表示二进制表示是否总是 0、1 交替出现\n\n> 输入：n = 10\n> 输出：true\n> 解释：10 的二进制表示是：1010\n\n解析：\n\n一种简单的思路是不断使用算术右移将n的二进制表示末位移出，使用按位与运算获取末位是0还是1，并且比较第 i 个和第 i-1 个末位是否相同，如果相同则直接返回false，检查完成则返回true。\n\nclass solution {\npublic:\n    bool hasalternatingbits(int n) {\n        // 记录第一个末位\n        int pre = n & 1;\n        n>>=1;\n        while(n){\n            // 比较第 i 个和第 i-1 个末位\n            int now = n & 1;\n            if(now == pre){\n                return false;\n            }else{\n                // 更新前一个状态\n                pre = now;\n            }\n            n >>= 1;\n        }\n        return true;\n    }\n};\n",charsets:{cjk:!0},lastUpdated:"2023/11/19, 12:55:48",lastUpdatedTimestamp:1700369748e3},{title:"BitOp",frontmatter:{title:"BitOp",date:"2023-03-24T18:39:49.000Z",permalink:"/pages/0c3d5e/"},regularPath:"/03.LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/05.%E5%85%B6%E4%BB%96%E5%86%85%E5%AE%B9/02.%E4%BD%8D%E8%BF%90%E7%AE%97/BitOp.html",relativePath:"03.LeetCode刷题笔记/05.其他内容/02.位运算/BitOp.md",key:"v-4f96c767",path:"/pages/0c3d5e/",headers:[{level:2,title:"LeetCode刷题笔记 位运算",slug:"leetcode刷题笔记-位运算",normalizedTitle:"leetcode刷题笔记 位运算",charIndex:2},{level:3,title:"01 位运算基础",slug:"_01-位运算基础",normalizedTitle:"01 位运算基础",charIndex:23},{level:4,title:"461 汉明距离",slug:"_461-汉明距离",normalizedTitle:"461 汉明距离",charIndex:743},{level:4,title:"190 颠倒二进制位",slug:"_190-颠倒二进制位",normalizedTitle:"190 颠倒二进制位",charIndex:1328},{level:4,title:"476 数字的补数",slug:"_476-数字的补数",normalizedTitle:"476 数字的补数",charIndex:2101},{level:4,title:"136 只出现一次的数字",slug:"_136-只出现一次的数字",normalizedTitle:"136 只出现一次的数字",charIndex:2760},{level:4,title:"268 丢失的数字",slug:"_268-丢失的数字",normalizedTitle:"268 丢失的数字",charIndex:3247},{level:4,title:"260 只出现一次的数字 III",slug:"_260-只出现一次的数字-iii",normalizedTitle:"260 只出现一次的数字 iii",charIndex:4040},{level:4,title:"693 交替位二进制数",slug:"_693-交替位二进制数",normalizedTitle:"693 交替位二进制数",charIndex:5783},{level:3,title:"02 二进制特性",slug:"_02-二进制特性",normalizedTitle:"02 二进制特性",charIndex:6425},{level:4,title:"342 4的幂",slug:"_342-4的幂",normalizedTitle:"342 4的幂",charIndex:6556},{level:4,title:"318 最大单词长度乘积",slug:"_318-最大单词长度乘积",normalizedTitle:"318 最大单词长度乘积",charIndex:7492},{level:4,title:"338 比特位计数",slug:"_338-比特位计数",normalizedTitle:"338 比特位计数",charIndex:8937}],headersStr:"LeetCode刷题笔记 位运算 01 位运算基础 461 汉明距离 190 颠倒二进制位 476 数字的补数 136 只出现一次的数字 268 丢失的数字 260 只出现一次的数字 III 693 交替位二进制数 02 二进制特性 342 4的幂 318 最大单词长度乘积 338 比特位计数",content:'# LeetCode刷题笔记 位运算\n\n\n# 01 位运算基础\n\n位运算是算法题里比较特殊的一种类型，它们利用二进制位运算的特性进行一些奇妙的优化和计算。常用的位运算符号包括：“∧” 按位异或、“&” 按位与、“|” 按位或、“∼” 取反、“<<” 算术左移和 “>>” 算术右移。以下是一些常见的位运算特性：\n\n异或              与              或\nx ^ 0000 = x    x & 0000 = 0   x | 0000 = x\nx ^ 1111 = ~x   x & 1111 = x   x | 1111 = 1111\nx ^ x = 0       x & x = x      x | x = x\n\n除此之外， n & (n - 1) 可以去除 n 的位级表示中最低的那一位，例如对于二进制表示 11110100，减去 1 得到 11110011，这两个数按位与得到 11110000。\n\nn & (-n) 可以仅保留 n 的位级表示中最低的那一位，例如对于二进制表示 11110100，取负得到 00001100，这两个数按位与得到 00000100。\n\n回顾一下移位操作，移位操作是一种基本操作，是一种直接对二进制数据的位运算操作，移位运算又包含了逻辑移位（logical shift）和算术移位（arithmetic shift）两种。\n\n * 逻辑移位：移出去的位丢弃，空缺位（vacant bit）用 0 填充。\n * 算术移位：移出去的位丢弃，空缺位（vacant bit）用“符号位”来填充，所以一般用在右移运算中。\n\n无符号数，不管是左移还是右移都是逻辑移位；有符号数，做左移运算是逻辑移位，而做右移运算是算术移位。\n\n# 461 汉明距离\n\n给定两个十进制数字，求它们二进制表示的汉明距离（Hamming distance，即不同位的个数）。\n\n输入是两个十进制整数，输出是一个十进制整数，表示两个输入数字的汉明距离。\n\n> 输入：x = 1, y = 4 输出：2 解释：1 (0 0 0 1)；4 (0 1 0 0)\n\n解析：\n\n求二进制数不同位的个数，直接使用将俩个数进行按位异或操作，不同位的结果就是 1，所以最终统计异或结果中的 1 的个数即可。\n\n计算二进制数 1 的个数的方法：不断将二进制数算数右移，将其与 1 进行与运算，如果末位是 1 则加入计数。\n\nclass Solution {\npublic:\n    int hammingDistance(int x, int y) {\n        // 异或运算\n        int diff = x^y;\n        int ans = 0;\n        while(diff){\n            // 与运算 判断末位是否为 1\n            ans += diff & 1;\n            // 算术右移动 将已经被统计的 1 移出\n            diff = diff>>1;\n        }\n        return ans;\n    }\n};\n\n\n# 190 颠倒二进制位\n\n给定一个十进制整数，输出它在二进制下的翻转结果。\n\n输入和输出都是十进制整数。\n\n> 输入：n = 00000010100101000001111010011100\n> \n> 输出：964176192 (00111001011110000010100101000000)\n> \n> 解释：将 n 的二进制串倒转\n\n解析：\n\n使用算术左移和右移，可以很轻易地实现二进制的翻转。保存结果的二进制串每次向左移动一位腾出末位，然后将 n 与 1 取出 n 的末位并放入结果腾出的末位，放入之后 n 向右移动一位将已放入的位移出。\n\n一个简单的示例：\n\n             1      2      3      4      5\nans (算术左移)   0000   0000   0001   0010   0101\nn (算术右移)     1010   0101   0010   0001   0000\n\nclass Solution {\npublic:\n    uint32_t reverseBits(uint32_t n) {\n        // 无符号32位整型\n        uint32_t ans = 0;\n        for(int i=0;i<32;++i){\n            // 每次先将结果左移一位腾出位置\n            ans <<= 1;\n            // 将 n 当前的最后一位放到上一步ans腾出的位置（末位）\n            ans += n&1;\n            // 将已经放入结果的位移出\n            n >>= 1;\n        }\n        return ans;\n    }\n};\n\n\n# 476 数字的补数\n\n给你一个 正 整数 num ，输出它的补数。补数是对该数的二进制表示取反。\n\n输入一个整数，输出一个整数表示原整数的补数\n\n> 输入：num = 5\n> 输出：2\n> 解释：5 的二进制表示为 101（没有前导零位），其补数为 010。所以你需要输出 2 。\n\n解析：\n\n看到二进制位取返就可以想到异或运算x^1111 = ~x，所以本题可以采用异或运算。本题的关键点在于怎样让参与异或运算的 1 所占位置与 num 二进制有效表示位置一致，一种方法是通过算术左移将 1 移动到有效位，同时怎么判断是否已经移到完整区间呢？可以采用与运算，如果 num 的最大有效位被覆盖，进行与运算的结果为0。\n\n变量            二进制表示\nnum           00000101\nmask          11111000\n~mask         00000111\n~mask ^ num   00000010\n\nclass Solution {\npublic:\n    int findComplement(int num) {\n        // 注意mask要用无符号，不然无法算术左移  -1 = 0xFFFFFFFF\n        unsigned mask = -1; \n        while(mask & num){\n            mask <<=1;\n        }\n        return ~mask^num;\n    }\n};\n\n\n# 136 只出现一次的数字\n\n给定一个整数数组，这个数组里只有一个数字出现了一次，其余数字出现了两次，求这个只出现一次的数字。\n\n输入是一个一维整数数组，输出是该数组内的一个整数。\n\n> 输入: [4,1,2,1,2]\n> 输出: 4\n\n解析：\n\n本题可以利用异或运算的特性快速找出唯一出现一次的数字，应为x^x=0, x^0=x。所以在数组中出现两次的所有数字按位异或的结果是 0，出现一次的数字与0按位异或运算的结果是其本身。例如[4,1,2,1,2]，进行异或运算有4^1^2^1^2 = 4^0 = 4。\n\nclass Solution {\npublic:\n    int singleNumber(vector<int>& nums) {\n        int ans = 0;\n        // 将数组中所有元素逐个按位异或运算\n        for(int i=0;i<nums.size();++i){\n            ans = ans^nums[i];\n        }\n        return ans;\n    }\n};\n\n\n# 268 丢失的数字\n\n给定一个包含 [0, n] 中 n 个数的数组 nums ，找出 [0, n] 这个范围内没有出现在数组中的那个数。\n\n输入一个数组，输出一个整数表示数组中没有出现的数。\n\n> 输入：nums = [3,0,1] 输出：2 解释：n = 3，因为有 3 个数字，所以所有的数字都在范围 [0,3] 内。2 是丢失的数字，因为它没有出现在 nums 中。\n\n解析：\n\n本题是136 只出现一次的数字的变种题，如果将 0 到 n 的所有数字都添加到 nums 中是不是就直接转换成了136题一样的题。例如nums = [3,0,1]，其长度为3那么添加0到3的所有元素构成nums = [3,0,1,0,1,2,3]，这样一看是不是就是找只出现一次的数字了。\n\n当然，我们不需要真的需要取重新构造 nums，在遍历 nums 时元素对应的索引就是要添加的元素。利用异或运算的特性x^x=0, x^0=x，将元素与索引进行按位异或运算最终就可以得到只出现一次的那个数了，例如3^1^0^2^1^2^3 = 2。当然，别忘了要将nums.size()这个元素加入异或运算。\n\nclass Solution {\npublic:\n    int missingNumber(vector<int>& nums) {\n        // 将nums.size()作为第一个参与异或运算的元素，当然将它放在最后参与效果是一样的\n        int ans = nums.size();\n        for(int i=0;i<nums.size();++i){\n            // 元素与索引进行按位异或运算\n            ans ^= (nums[i]^i);\n        }\n        return ans;\n    }\n};\n\n\n# 260 只出现一次的数字 III\n\n给定一个整数数组 nums，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素。\n\n输入一个一维数组，输出一个一维数组包含只出现一次的那两个元素\n\n> 输入：nums = [1,2,1,3,2,5]\n> 输出：[3,5]\n> 解释：[5, 3] 也是有效的答案。\n\n解析：\n\n本题是136 只出现一次的数字题的扩展，本题也可以使用异或运算解决，但是要考虑分组的情况。\n\n首先，遍历数组的所有元素，逐一进行异或运算的到只出现一次的那两个元素的异或运算结果，例如1^2^1^3^2^5 = 3^5\n\n只出现一次的那两个元素肯定不一样，所以他们的异或运算结果二进制表示中至少包含一个1。而整个数组就可以根据这个为1的二进制位进行划分，将数组中元素该位为0的划分为一组，该位为1的划分为另一组。采用这种策略就能将只出现一次的那两个元素划分到不同的组中。例如对数组1,2,1,3,2,5进行划分，3^5=(110)，根据第二位进行划分有：第一组：1(001), 1(001), 5(101)；第二组：2(010), 2(010), 3(011)\n\n然后在两组中分别进行如136 只出现一次的数字题的异或运算，分别得出只出现一次的那两个元素\n\n另一个难点在于怎么找到只出现一次的那两个元素的异或运算结果中1的位置，可以采用与476 数字的补数相似的方法。用mask = 0001不断的算术左移，直到mask & num != 0，那么mask中1的位置就是该划分位。\n\n根据mask划分元素也可以直接使用按位与运算，结果为0的一组，不为0的一组。\n\n    vector<int> singleNumber(vector<int>& nums) {\n        int res = 0;\n        // 计算只出现一次的那两个元素的异或运算结果\n        for(const auto num: nums){\n            res ^= num;\n        }\n        // 找划分位\n        int mask = 1;\n        while(!(mask & res)){\n            mask <<= 1;\n        }\n        // 分组异或运算\n        int a = 0, b = 0;\n        for(const auto num: nums){\n            if(mask&num){\n                a^=num;\n            }else{\n                b^=num;\n            }\n        }\n        return vector<int>{a,b};\n    }\n\n\n这种统计频次的题目，如果对空间复杂度没有要求的话，使用哈希表解决往往有较高的效率。\n\nclass Solution {\npublic:\n    vector<int> singleNumber(vector<int>& nums) {\n        unordered_map<int,int> hash;\n        vector<int> ans;\n        for(const auto num: nums){\n            if(hash.find(num) == hash.end()){\n                hash[num] = 1;\n            }else{\n                ++hash[num];\n            }\n        }\n        for(const auto [h_num,h_cnt]:hash){\n            if(h_cnt==1){\n                ans.push_back(h_num);\n            }\n        }\n        return ans;\n    }\n};\n\n\n# 693 交替位二进制数\n\n给定一个正整数，检查它的二进制表示是否总是 0、1 交替出现\n\n输入一个整数，输出一个布尔类型表示二进制表示是否总是 0、1 交替出现\n\n> 输入：n = 10\n> 输出：true\n> 解释：10 的二进制表示是：1010\n\n解析：\n\n一种简单的思路是不断使用算术右移将n的二进制表示末位移出，使用按位与运算获取末位是0还是1，并且比较第 i 个和第 i-1 个末位是否相同，如果相同则直接返回false，检查完成则返回true。\n\nclass Solution {\npublic:\n    bool hasAlternatingBits(int n) {\n        // 记录第一个末位\n        int pre = n & 1;\n        n>>=1;\n        while(n){\n            // 比较第 i 个和第 i-1 个末位\n            int now = n & 1;\n            if(now == pre){\n                return false;\n            }else{\n                // 更新前一个状态\n                pre = now;\n            }\n            n >>= 1;\n        }\n        return true;\n    }\n};\n\n\n\n# 02 二进制特性\n\n利用二进制的一些特性，可以把位运算使用到更多问题上。例如，可以利用二进制和位运算输出一个数组的所有子集。假设有一个长度为 n 的数组，可以生成长度为 n 的所有二进制，1 表示选取该数字，0 表示不选取。这样就获得了 2^n 个子集。\n\n# 342 4的幂\n\n给定一个整数，判断它是否是 4 的次方。\n\n输入是一个整数，输出是一个布尔值，表示判断结果。\n\n> 输入：n = 16\n> 输出：true\n\n解析：\n\n本题可以采用按位与运算简单实现判断数是否为4的幂。如果 n 是 4 的幂，那么 n 的二进制表示中有且仅有一个 1 ，且其位置必须为奇数位，例如16 = (10000)，从右向左且从1开始计数的话，16的二进制表示中 1 位于第5位。根据此规律可以将 n 和二进制01010101010101010101010101010101或者十六进制的0x55555555做按位与，如果得到的结果不为零，那么说明这个数可能是 4 的幂。\n\n为什么说是可能呢？可以看出上述条件是充分条件而非充要条件，1 与0x55555555做按位与的结果也是非0的。\n\n所以需要进一步考虑该数 n 也是 2 的幂，才能保证上述条件判断结果为该数是 4 的幂。如果 n 是 2 的幂，那么 n 的二进制表示中也有且仅有一个 1，假设其位置为 pos ；那么 n - 1 二进制表示由第 1 位到第 pos-1 位全部为 1构成。例如16 = 10000; 15 = 01111 ，所以可以得出：如果 n & (n - 1) == 0，那么 n 是 2 的幂。\n\n最终得到：如果(n&(n-1))==0 && (n & 0x55555555)!=0，那么n 是 4 的幂。\n\nclass Solution {\npublic:\n    bool isPowerOfFour(int n) {\n        return n > 0 && !(n&(n-1)) && (n&0x55555555);\n    }\n};\n\n\n当然，本题也可以采用类似求 326. 3的幂 的方法直接使用对数函数的换底公式构造log4(n)，然后使用fmod()函数判断该值是否为整数，进而判断 n 是否是 4 的幂。\n\nclass Solution {\npublic:\n    bool isPowerOfFour(int n) {\n        return fmod(log10(n)/log10(4),1) == 0;\n    }\n};\n\n\n# 318 最大单词长度乘积\n\n给定多个字母串，求其中任意两个字母串的长度乘积的最大值，且这两个字母串不能含有相同字母。\n\n输入一个包含多个字母串的一维数组，输出一个整数，表示长度乘积的最大值。\n\n> 输入: ["a","ab","abc","d","cd","bcd","abcd"]\n> 输出: 4 \n> 解释: 这两个单词为 "ab", "cd"。\n\n解析：\n\n怎样快速判断两个字母串是否含有重复数字呢？可以为每个字母串建立一个长度为 26 的二进制数字 mask，用于表示从右到左每个位置表示是否存在a-z对应的字母。例如abc:111, abd:1011，如果两个字母串含有重复数字，那它们的二进制表示的按位与不为 0，例如abc,adbe存在相同的字母，将它们按位与的结果是1011!=0。\n\n怎么实现对字符串的编号记录呢？也可以通过位运算实现：首先将 mask 置为 0，然后遍历字符串的所有字符，每一次遍历中计算当前字符串所处的位置，然后使用算术左移，将标识 1 移动到指定位置，移动完成后将其与mask按位与运算，将位置记录在mask中。\n\n为了求长度乘积的最大值，可以建立一个哈希表记录字符串与其自身的长度。在计算长度乘积最大值时，遍历哈希表将不存在相同字母的字符串长度相乘并取最大值。\n\nclass Solution {\npublic:\n    int maxProduct(vector<string>& words) {\n        unordered_map<int,int> hash;\n        int ans = 0;\n        for(const auto& word: words){\n            int mask = 0;\n            int wordLen = word.length();\n            // 为当前字符串编码\n            for(const auto c:word){\n                // 考虑字符串中每一个字符时，将 1 左移 (c-\'a\') 位\n                int cPos = 1 << (c-\'a\');\n                // 与mask按位与，将当前字符的位置保存到mask中，如果当前字符已经存在不影响mask\n                mask = mask | cPos;\n            }\n            // 更新mask对应的长度时要考虑到：字符串中元素重复出现的情况，这种情况下字符串长度不一致 \n            hash[mask] = max(hash[mask],wordLen);\n            // 遍历所有已经记录的字符串，如果有不存在相同字符 （mask & h_mask）== 0 的字符串计算当前长度乘积\n            for(const auto& [h_mask,h_len]: hash){\n                if(!(mask & h_mask)){\n                    ans = max(ans,wordLen*h_len);\n                }\n            }\n        }\n        return ans;\n    }\n};\n\n\n# 338 比特位计数\n\n给定一个非负整数 n，求从 0 到 n 的所有数字的二进制表达中，分别有多少个 1。\n\n输入是一个非负整数 n，输出是长度为 n + 1 的非负整数数组，每个位置 m 表示 m 的二进制里有多少个 1。\n\n> 输入：n = 5 输出：[0,1,1,2,1,2] 解释：0 --\x3e 0, 1 --\x3e 1, 2 --\x3e 10, 3 --\x3e 11, 4 --\x3e 100, 5 --\x3e 101\n\n解析：\n\n本题如果使用双层循环逐个统计每个数二进制表示中1的个数会出现超时的情况。为了优化可以考虑使用动态规划来解题。\n\n设置状态：使用一个一维数组dp[i]表示第 i 个数的二进制表示中 1 的个数\n\n状态转移方程：对于第 i 个数字，如果该数为奇数即其二进制表示的末位为1，那么该数二进制表示中 1 的个数直接与前一个偶数相关为dp[i]=dp[i-1]+1；如果该数为偶数即其二进制表示的末位为0，那么该数二进制表示中 1 的个数与其算术右移一位结果相同，因为其算术右移一位将末位0移出后与对应数的二进制表示一致，即dp[i]=dp[i>>1]\n\n边界条件：当 n = 0时，dp[0]=0\n\nclass Solution {\npublic:\n    vector<int> countBits(int n) {\n        vector<int> dp(n+1,0);\n        for(int i=1;i<=n;++i){\n            if(i&1){\n                dp[i] = dp[i-1] + 1;\n            }else{\n                dp[i] = dp[i>>1];\n            }\n        }\n        return dp;\n    }\n};\n',normalizedContent:'# leetcode刷题笔记 位运算\n\n\n# 01 位运算基础\n\n位运算是算法题里比较特殊的一种类型，它们利用二进制位运算的特性进行一些奇妙的优化和计算。常用的位运算符号包括：“∧” 按位异或、“&” 按位与、“|” 按位或、“∼” 取反、“<<” 算术左移和 “>>” 算术右移。以下是一些常见的位运算特性：\n\n异或              与              或\nx ^ 0000 = x    x & 0000 = 0   x | 0000 = x\nx ^ 1111 = ~x   x & 1111 = x   x | 1111 = 1111\nx ^ x = 0       x & x = x      x | x = x\n\n除此之外， n & (n - 1) 可以去除 n 的位级表示中最低的那一位，例如对于二进制表示 11110100，减去 1 得到 11110011，这两个数按位与得到 11110000。\n\nn & (-n) 可以仅保留 n 的位级表示中最低的那一位，例如对于二进制表示 11110100，取负得到 00001100，这两个数按位与得到 00000100。\n\n回顾一下移位操作，移位操作是一种基本操作，是一种直接对二进制数据的位运算操作，移位运算又包含了逻辑移位（logical shift）和算术移位（arithmetic shift）两种。\n\n * 逻辑移位：移出去的位丢弃，空缺位（vacant bit）用 0 填充。\n * 算术移位：移出去的位丢弃，空缺位（vacant bit）用“符号位”来填充，所以一般用在右移运算中。\n\n无符号数，不管是左移还是右移都是逻辑移位；有符号数，做左移运算是逻辑移位，而做右移运算是算术移位。\n\n# 461 汉明距离\n\n给定两个十进制数字，求它们二进制表示的汉明距离（hamming distance，即不同位的个数）。\n\n输入是两个十进制整数，输出是一个十进制整数，表示两个输入数字的汉明距离。\n\n> 输入：x = 1, y = 4 输出：2 解释：1 (0 0 0 1)；4 (0 1 0 0)\n\n解析：\n\n求二进制数不同位的个数，直接使用将俩个数进行按位异或操作，不同位的结果就是 1，所以最终统计异或结果中的 1 的个数即可。\n\n计算二进制数 1 的个数的方法：不断将二进制数算数右移，将其与 1 进行与运算，如果末位是 1 则加入计数。\n\nclass solution {\npublic:\n    int hammingdistance(int x, int y) {\n        // 异或运算\n        int diff = x^y;\n        int ans = 0;\n        while(diff){\n            // 与运算 判断末位是否为 1\n            ans += diff & 1;\n            // 算术右移动 将已经被统计的 1 移出\n            diff = diff>>1;\n        }\n        return ans;\n    }\n};\n\n\n# 190 颠倒二进制位\n\n给定一个十进制整数，输出它在二进制下的翻转结果。\n\n输入和输出都是十进制整数。\n\n> 输入：n = 00000010100101000001111010011100\n> \n> 输出：964176192 (00111001011110000010100101000000)\n> \n> 解释：将 n 的二进制串倒转\n\n解析：\n\n使用算术左移和右移，可以很轻易地实现二进制的翻转。保存结果的二进制串每次向左移动一位腾出末位，然后将 n 与 1 取出 n 的末位并放入结果腾出的末位，放入之后 n 向右移动一位将已放入的位移出。\n\n一个简单的示例：\n\n             1      2      3      4      5\nans (算术左移)   0000   0000   0001   0010   0101\nn (算术右移)     1010   0101   0010   0001   0000\n\nclass solution {\npublic:\n    uint32_t reversebits(uint32_t n) {\n        // 无符号32位整型\n        uint32_t ans = 0;\n        for(int i=0;i<32;++i){\n            // 每次先将结果左移一位腾出位置\n            ans <<= 1;\n            // 将 n 当前的最后一位放到上一步ans腾出的位置（末位）\n            ans += n&1;\n            // 将已经放入结果的位移出\n            n >>= 1;\n        }\n        return ans;\n    }\n};\n\n\n# 476 数字的补数\n\n给你一个 正 整数 num ，输出它的补数。补数是对该数的二进制表示取反。\n\n输入一个整数，输出一个整数表示原整数的补数\n\n> 输入：num = 5\n> 输出：2\n> 解释：5 的二进制表示为 101（没有前导零位），其补数为 010。所以你需要输出 2 。\n\n解析：\n\n看到二进制位取返就可以想到异或运算x^1111 = ~x，所以本题可以采用异或运算。本题的关键点在于怎样让参与异或运算的 1 所占位置与 num 二进制有效表示位置一致，一种方法是通过算术左移将 1 移动到有效位，同时怎么判断是否已经移到完整区间呢？可以采用与运算，如果 num 的最大有效位被覆盖，进行与运算的结果为0。\n\n变量            二进制表示\nnum           00000101\nmask          11111000\n~mask         00000111\n~mask ^ num   00000010\n\nclass solution {\npublic:\n    int findcomplement(int num) {\n        // 注意mask要用无符号，不然无法算术左移  -1 = 0xffffffff\n        unsigned mask = -1; \n        while(mask & num){\n            mask <<=1;\n        }\n        return ~mask^num;\n    }\n};\n\n\n# 136 只出现一次的数字\n\n给定一个整数数组，这个数组里只有一个数字出现了一次，其余数字出现了两次，求这个只出现一次的数字。\n\n输入是一个一维整数数组，输出是该数组内的一个整数。\n\n> 输入: [4,1,2,1,2]\n> 输出: 4\n\n解析：\n\n本题可以利用异或运算的特性快速找出唯一出现一次的数字，应为x^x=0, x^0=x。所以在数组中出现两次的所有数字按位异或的结果是 0，出现一次的数字与0按位异或运算的结果是其本身。例如[4,1,2,1,2]，进行异或运算有4^1^2^1^2 = 4^0 = 4。\n\nclass solution {\npublic:\n    int singlenumber(vector<int>& nums) {\n        int ans = 0;\n        // 将数组中所有元素逐个按位异或运算\n        for(int i=0;i<nums.size();++i){\n            ans = ans^nums[i];\n        }\n        return ans;\n    }\n};\n\n\n# 268 丢失的数字\n\n给定一个包含 [0, n] 中 n 个数的数组 nums ，找出 [0, n] 这个范围内没有出现在数组中的那个数。\n\n输入一个数组，输出一个整数表示数组中没有出现的数。\n\n> 输入：nums = [3,0,1] 输出：2 解释：n = 3，因为有 3 个数字，所以所有的数字都在范围 [0,3] 内。2 是丢失的数字，因为它没有出现在 nums 中。\n\n解析：\n\n本题是136 只出现一次的数字的变种题，如果将 0 到 n 的所有数字都添加到 nums 中是不是就直接转换成了136题一样的题。例如nums = [3,0,1]，其长度为3那么添加0到3的所有元素构成nums = [3,0,1,0,1,2,3]，这样一看是不是就是找只出现一次的数字了。\n\n当然，我们不需要真的需要取重新构造 nums，在遍历 nums 时元素对应的索引就是要添加的元素。利用异或运算的特性x^x=0, x^0=x，将元素与索引进行按位异或运算最终就可以得到只出现一次的那个数了，例如3^1^0^2^1^2^3 = 2。当然，别忘了要将nums.size()这个元素加入异或运算。\n\nclass solution {\npublic:\n    int missingnumber(vector<int>& nums) {\n        // 将nums.size()作为第一个参与异或运算的元素，当然将它放在最后参与效果是一样的\n        int ans = nums.size();\n        for(int i=0;i<nums.size();++i){\n            // 元素与索引进行按位异或运算\n            ans ^= (nums[i]^i);\n        }\n        return ans;\n    }\n};\n\n\n# 260 只出现一次的数字 iii\n\n给定一个整数数组 nums，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素。\n\n输入一个一维数组，输出一个一维数组包含只出现一次的那两个元素\n\n> 输入：nums = [1,2,1,3,2,5]\n> 输出：[3,5]\n> 解释：[5, 3] 也是有效的答案。\n\n解析：\n\n本题是136 只出现一次的数字题的扩展，本题也可以使用异或运算解决，但是要考虑分组的情况。\n\n首先，遍历数组的所有元素，逐一进行异或运算的到只出现一次的那两个元素的异或运算结果，例如1^2^1^3^2^5 = 3^5\n\n只出现一次的那两个元素肯定不一样，所以他们的异或运算结果二进制表示中至少包含一个1。而整个数组就可以根据这个为1的二进制位进行划分，将数组中元素该位为0的划分为一组，该位为1的划分为另一组。采用这种策略就能将只出现一次的那两个元素划分到不同的组中。例如对数组1,2,1,3,2,5进行划分，3^5=(110)，根据第二位进行划分有：第一组：1(001), 1(001), 5(101)；第二组：2(010), 2(010), 3(011)\n\n然后在两组中分别进行如136 只出现一次的数字题的异或运算，分别得出只出现一次的那两个元素\n\n另一个难点在于怎么找到只出现一次的那两个元素的异或运算结果中1的位置，可以采用与476 数字的补数相似的方法。用mask = 0001不断的算术左移，直到mask & num != 0，那么mask中1的位置就是该划分位。\n\n根据mask划分元素也可以直接使用按位与运算，结果为0的一组，不为0的一组。\n\n    vector<int> singlenumber(vector<int>& nums) {\n        int res = 0;\n        // 计算只出现一次的那两个元素的异或运算结果\n        for(const auto num: nums){\n            res ^= num;\n        }\n        // 找划分位\n        int mask = 1;\n        while(!(mask & res)){\n            mask <<= 1;\n        }\n        // 分组异或运算\n        int a = 0, b = 0;\n        for(const auto num: nums){\n            if(mask&num){\n                a^=num;\n            }else{\n                b^=num;\n            }\n        }\n        return vector<int>{a,b};\n    }\n\n\n这种统计频次的题目，如果对空间复杂度没有要求的话，使用哈希表解决往往有较高的效率。\n\nclass solution {\npublic:\n    vector<int> singlenumber(vector<int>& nums) {\n        unordered_map<int,int> hash;\n        vector<int> ans;\n        for(const auto num: nums){\n            if(hash.find(num) == hash.end()){\n                hash[num] = 1;\n            }else{\n                ++hash[num];\n            }\n        }\n        for(const auto [h_num,h_cnt]:hash){\n            if(h_cnt==1){\n                ans.push_back(h_num);\n            }\n        }\n        return ans;\n    }\n};\n\n\n# 693 交替位二进制数\n\n给定一个正整数，检查它的二进制表示是否总是 0、1 交替出现\n\n输入一个整数，输出一个布尔类型表示二进制表示是否总是 0、1 交替出现\n\n> 输入：n = 10\n> 输出：true\n> 解释：10 的二进制表示是：1010\n\n解析：\n\n一种简单的思路是不断使用算术右移将n的二进制表示末位移出，使用按位与运算获取末位是0还是1，并且比较第 i 个和第 i-1 个末位是否相同，如果相同则直接返回false，检查完成则返回true。\n\nclass solution {\npublic:\n    bool hasalternatingbits(int n) {\n        // 记录第一个末位\n        int pre = n & 1;\n        n>>=1;\n        while(n){\n            // 比较第 i 个和第 i-1 个末位\n            int now = n & 1;\n            if(now == pre){\n                return false;\n            }else{\n                // 更新前一个状态\n                pre = now;\n            }\n            n >>= 1;\n        }\n        return true;\n    }\n};\n\n\n\n# 02 二进制特性\n\n利用二进制的一些特性，可以把位运算使用到更多问题上。例如，可以利用二进制和位运算输出一个数组的所有子集。假设有一个长度为 n 的数组，可以生成长度为 n 的所有二进制，1 表示选取该数字，0 表示不选取。这样就获得了 2^n 个子集。\n\n# 342 4的幂\n\n给定一个整数，判断它是否是 4 的次方。\n\n输入是一个整数，输出是一个布尔值，表示判断结果。\n\n> 输入：n = 16\n> 输出：true\n\n解析：\n\n本题可以采用按位与运算简单实现判断数是否为4的幂。如果 n 是 4 的幂，那么 n 的二进制表示中有且仅有一个 1 ，且其位置必须为奇数位，例如16 = (10000)，从右向左且从1开始计数的话，16的二进制表示中 1 位于第5位。根据此规律可以将 n 和二进制01010101010101010101010101010101或者十六进制的0x55555555做按位与，如果得到的结果不为零，那么说明这个数可能是 4 的幂。\n\n为什么说是可能呢？可以看出上述条件是充分条件而非充要条件，1 与0x55555555做按位与的结果也是非0的。\n\n所以需要进一步考虑该数 n 也是 2 的幂，才能保证上述条件判断结果为该数是 4 的幂。如果 n 是 2 的幂，那么 n 的二进制表示中也有且仅有一个 1，假设其位置为 pos ；那么 n - 1 二进制表示由第 1 位到第 pos-1 位全部为 1构成。例如16 = 10000; 15 = 01111 ，所以可以得出：如果 n & (n - 1) == 0，那么 n 是 2 的幂。\n\n最终得到：如果(n&(n-1))==0 && (n & 0x55555555)!=0，那么n 是 4 的幂。\n\nclass solution {\npublic:\n    bool ispoweroffour(int n) {\n        return n > 0 && !(n&(n-1)) && (n&0x55555555);\n    }\n};\n\n\n当然，本题也可以采用类似求 326. 3的幂 的方法直接使用对数函数的换底公式构造log4(n)，然后使用fmod()函数判断该值是否为整数，进而判断 n 是否是 4 的幂。\n\nclass solution {\npublic:\n    bool ispoweroffour(int n) {\n        return fmod(log10(n)/log10(4),1) == 0;\n    }\n};\n\n\n# 318 最大单词长度乘积\n\n给定多个字母串，求其中任意两个字母串的长度乘积的最大值，且这两个字母串不能含有相同字母。\n\n输入一个包含多个字母串的一维数组，输出一个整数，表示长度乘积的最大值。\n\n> 输入: ["a","ab","abc","d","cd","bcd","abcd"]\n> 输出: 4 \n> 解释: 这两个单词为 "ab", "cd"。\n\n解析：\n\n怎样快速判断两个字母串是否含有重复数字呢？可以为每个字母串建立一个长度为 26 的二进制数字 mask，用于表示从右到左每个位置表示是否存在a-z对应的字母。例如abc:111, abd:1011，如果两个字母串含有重复数字，那它们的二进制表示的按位与不为 0，例如abc,adbe存在相同的字母，将它们按位与的结果是1011!=0。\n\n怎么实现对字符串的编号记录呢？也可以通过位运算实现：首先将 mask 置为 0，然后遍历字符串的所有字符，每一次遍历中计算当前字符串所处的位置，然后使用算术左移，将标识 1 移动到指定位置，移动完成后将其与mask按位与运算，将位置记录在mask中。\n\n为了求长度乘积的最大值，可以建立一个哈希表记录字符串与其自身的长度。在计算长度乘积最大值时，遍历哈希表将不存在相同字母的字符串长度相乘并取最大值。\n\nclass solution {\npublic:\n    int maxproduct(vector<string>& words) {\n        unordered_map<int,int> hash;\n        int ans = 0;\n        for(const auto& word: words){\n            int mask = 0;\n            int wordlen = word.length();\n            // 为当前字符串编码\n            for(const auto c:word){\n                // 考虑字符串中每一个字符时，将 1 左移 (c-\'a\') 位\n                int cpos = 1 << (c-\'a\');\n                // 与mask按位与，将当前字符的位置保存到mask中，如果当前字符已经存在不影响mask\n                mask = mask | cpos;\n            }\n            // 更新mask对应的长度时要考虑到：字符串中元素重复出现的情况，这种情况下字符串长度不一致 \n            hash[mask] = max(hash[mask],wordlen);\n            // 遍历所有已经记录的字符串，如果有不存在相同字符 （mask & h_mask）== 0 的字符串计算当前长度乘积\n            for(const auto& [h_mask,h_len]: hash){\n                if(!(mask & h_mask)){\n                    ans = max(ans,wordlen*h_len);\n                }\n            }\n        }\n        return ans;\n    }\n};\n\n\n# 338 比特位计数\n\n给定一个非负整数 n，求从 0 到 n 的所有数字的二进制表达中，分别有多少个 1。\n\n输入是一个非负整数 n，输出是长度为 n + 1 的非负整数数组，每个位置 m 表示 m 的二进制里有多少个 1。\n\n> 输入：n = 5 输出：[0,1,1,2,1,2] 解释：0 --\x3e 0, 1 --\x3e 1, 2 --\x3e 10, 3 --\x3e 11, 4 --\x3e 100, 5 --\x3e 101\n\n解析：\n\n本题如果使用双层循环逐个统计每个数二进制表示中1的个数会出现超时的情况。为了优化可以考虑使用动态规划来解题。\n\n设置状态：使用一个一维数组dp[i]表示第 i 个数的二进制表示中 1 的个数\n\n状态转移方程：对于第 i 个数字，如果该数为奇数即其二进制表示的末位为1，那么该数二进制表示中 1 的个数直接与前一个偶数相关为dp[i]=dp[i-1]+1；如果该数为偶数即其二进制表示的末位为0，那么该数二进制表示中 1 的个数与其算术右移一位结果相同，因为其算术右移一位将末位0移出后与对应数的二进制表示一致，即dp[i]=dp[i>>1]\n\n边界条件：当 n = 0时，dp[0]=0\n\nclass solution {\npublic:\n    vector<int> countbits(int n) {\n        vector<int> dp(n+1,0);\n        for(int i=1;i<=n;++i){\n            if(i&1){\n                dp[i] = dp[i-1] + 1;\n            }else{\n                dp[i] = dp[i>>1];\n            }\n        }\n        return dp;\n    }\n};\n',charsets:{cjk:!0},lastUpdated:"2023/11/19, 12:55:48",lastUpdatedTimestamp:1700369748e3},{title:"文件与目录操作",frontmatter:{title:"文件与目录操作",date:"2023-04-30T14:46:33.000Z",permalink:"/pages/f56384/"},regularPath:"/04.Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/01.Linux%20%E5%9F%BA%E7%A1%80/02.%E6%96%87%E4%BB%B6%E4%B8%8E%E7%9B%AE%E5%BD%95%E6%93%8D%E4%BD%9C.html",relativePath:"04.Linux操作系统编程/01.Linux 基础/02.文件与目录操作.md",key:"v-f4f09eee",path:"/pages/f56384/",headers:[{level:2,title:"文件与目录操作",slug:"文件与目录操作",normalizedTitle:"文件与目录操作",charIndex:2},{level:3,title:"LINUX文件系统",slug:"linux文件系统",normalizedTitle:"linux文件系统",charIndex:14},{level:3,title:"LINUX文件IO操作",slug:"linux文件io操作",normalizedTitle:"linux文件io操作",charIndex:215},{level:3,title:"LINUX文件定位与共享",slug:"linux文件定位与共享",normalizedTitle:"linux文件定位与共享",charIndex:592}],headersStr:"文件与目录操作 LINUX文件系统 LINUX文件IO操作 LINUX文件定位与共享",content:'# 文件与目录操作\n\n\n# LINUX文件系统\n\n * Linux中一切皆为文件，这样保证了操作的一致性\n * Linux文件系统是根目录结构，而Windows文件系统是多根目录结构\n\n虚拟文件系统VFS\n\n * super block超级块：对一个文件系统的描述\n * inode索引节点：对一个文件物理属性的描述\n * dentry目录现对象：对一个文件逻辑属性的描述\n * file文件对象：保存文件位置的文件描述\n\n\n# LINUX文件IO操作\n\n系统调用\n\n * Linux包含的系统调用包含在libc库中\n\n * 调用实现：系统命令 >> API >> 系统调用\n\n * Linux文件IO操作函数：\n   \n   >  * open() : 打开或者创建文件\n   >  * create() : 打开一个文件，若不存在则创建文件\n   >  * close() : 关闭文件\n   >  * read() : 读文件内容\n   >  * write() : 写文件\n\n * 文件IO是直接IO效率高于有缓存的标准IO\n\n标准IO库\n\n * fopen() : 打开一个文件\n * setbuf() / setvbuf() ：打开和关闭缓冲机制\n * fdopen() : 常用于创建管道及网络通信通道函数返回的描述符\n * fclose() : 关闭一个文件\n\n\n# LINUX文件定位与共享\n\n文件定位\n\n * lseek() : 常用于找文件开头或文件末端，判定文件描述符的当前位置（仅仅将但其那文件的偏移量记录在内核中），将文件指针推进到末端之后的位置，并用0填充形成空洞，可以提高系统性能。2.3.1.c\n   \n   //lseek实现空洞\n   int main(int argc, char const *argv[])\n   {\n       int fd;\n       int ret;\n       fd = open("hello.txt",O_WRONLY|O_CREAT|O_TRUNC,0644);\n       if(fd == -1)\n           R_EXIT("open error");\n       write(fd,"hello",5);\n       ret = lseek(fd,1024*1024*1024,SEEK_CUR);\n       if(ret == -1)\n           ERR_EXIT("lseek error");\n       write(fd,"world",5);\n       close(fd);\n       return 0;\n   }\n   /*\n   *./2.3.1\n   *ls -lh hello.txt\n   *du -h hello.txt  //文件大小\n   *od -c hello.txt  //文件ASCII码\n   *cat hello.txt  //只显示hello而不显示world因为他们在不同的存储空间\n   */\n   \n\n * pread() : 根据给定的偏移量读取一个文件描述符。由于lseek和read调用之间，内核可能会临时挂起进程，影响进程同步，调用pread相当于顺序调用lseek和read，作为一个原子操作。\n\n * pwrite() : 根据给定的偏移量写入一个文件描述符。由于lseek和write调用之间，内核可能会临时挂起进程，影响进程同步，调用pread相当于顺序调用lseek和write，作为一个原子操作。（可避免竞争条件）\n\n文件共享\n\n * 不同进程共享文件实现\n   \n   >  * 文件描述符表：存在与进程表中，每个表项指向一个文件表\n   >  * 文件表：包含文件的状态标志、文件当前位置、指向该文件索引节点表的指针\n   >  * 索引节点表：包含文件的类型属性和文件数据，每个文件仅仅对应唯一的索引节点表\n\n * dup() 和 dup2() 函数实现文件共享：通过复制文件的描述符，使得在同一个进程中描述符指向相同的文件表\n\n * 线程共享文件：CLONE_VS CLONE_FS CLONE_FILES CLONE_SIGHAND',normalizedContent:'# 文件与目录操作\n\n\n# linux文件系统\n\n * linux中一切皆为文件，这样保证了操作的一致性\n * linux文件系统是根目录结构，而windows文件系统是多根目录结构\n\n虚拟文件系统vfs\n\n * super block超级块：对一个文件系统的描述\n * inode索引节点：对一个文件物理属性的描述\n * dentry目录现对象：对一个文件逻辑属性的描述\n * file文件对象：保存文件位置的文件描述\n\n\n# linux文件io操作\n\n系统调用\n\n * linux包含的系统调用包含在libc库中\n\n * 调用实现：系统命令 >> api >> 系统调用\n\n * linux文件io操作函数：\n   \n   >  * open() : 打开或者创建文件\n   >  * create() : 打开一个文件，若不存在则创建文件\n   >  * close() : 关闭文件\n   >  * read() : 读文件内容\n   >  * write() : 写文件\n\n * 文件io是直接io效率高于有缓存的标准io\n\n标准io库\n\n * fopen() : 打开一个文件\n * setbuf() / setvbuf() ：打开和关闭缓冲机制\n * fdopen() : 常用于创建管道及网络通信通道函数返回的描述符\n * fclose() : 关闭一个文件\n\n\n# linux文件定位与共享\n\n文件定位\n\n * lseek() : 常用于找文件开头或文件末端，判定文件描述符的当前位置（仅仅将但其那文件的偏移量记录在内核中），将文件指针推进到末端之后的位置，并用0填充形成空洞，可以提高系统性能。2.3.1.c\n   \n   //lseek实现空洞\n   int main(int argc, char const *argv[])\n   {\n       int fd;\n       int ret;\n       fd = open("hello.txt",o_wronly|o_creat|o_trunc,0644);\n       if(fd == -1)\n           r_exit("open error");\n       write(fd,"hello",5);\n       ret = lseek(fd,1024*1024*1024,seek_cur);\n       if(ret == -1)\n           err_exit("lseek error");\n       write(fd,"world",5);\n       close(fd);\n       return 0;\n   }\n   /*\n   *./2.3.1\n   *ls -lh hello.txt\n   *du -h hello.txt  //文件大小\n   *od -c hello.txt  //文件ascii码\n   *cat hello.txt  //只显示hello而不显示world因为他们在不同的存储空间\n   */\n   \n\n * pread() : 根据给定的偏移量读取一个文件描述符。由于lseek和read调用之间，内核可能会临时挂起进程，影响进程同步，调用pread相当于顺序调用lseek和read，作为一个原子操作。\n\n * pwrite() : 根据给定的偏移量写入一个文件描述符。由于lseek和write调用之间，内核可能会临时挂起进程，影响进程同步，调用pread相当于顺序调用lseek和write，作为一个原子操作。（可避免竞争条件）\n\n文件共享\n\n * 不同进程共享文件实现\n   \n   >  * 文件描述符表：存在与进程表中，每个表项指向一个文件表\n   >  * 文件表：包含文件的状态标志、文件当前位置、指向该文件索引节点表的指针\n   >  * 索引节点表：包含文件的类型属性和文件数据，每个文件仅仅对应唯一的索引节点表\n\n * dup() 和 dup2() 函数实现文件共享：通过复制文件的描述符，使得在同一个进程中描述符指向相同的文件表\n\n * 线程共享文件：clone_vs clone_fs clone_files clone_sighand',charsets:{cjk:!0},lastUpdated:"2023/11/19, 12:55:48",lastUpdatedTimestamp:1700369748e3},{title:"进程与线程",frontmatter:{title:"进程与线程",date:"2023-04-30T14:46:33.000Z",permalink:"/pages/0b3143/"},regularPath:"/04.Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/01.Linux%20%E5%9F%BA%E7%A1%80/03.%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B.html",relativePath:"04.Linux操作系统编程/01.Linux 基础/03.进程与线程.md",key:"v-c39fe9c4",path:"/pages/0b3143/",headers:[{level:2,title:"进程与线程",slug:"进程与线程",normalizedTitle:"进程与线程",charIndex:2},{level:3,title:"进程",slug:"进程",normalizedTitle:"进程",charIndex:2},{level:3,title:"线程",slug:"线程",normalizedTitle:"线程",charIndex:5}],headersStr:"进程与线程 进程 线程",content:'# 进程与线程\n\n\n# 进程\n\n进程基本概念\n\n * 进程：操作系统对程序的加载并运行的动态概念\n\n * 进程在内核中的组织形式：进程控制块PCB\n\n * 进程控制块的组织结构\n   \n   * 物理组织结构：进程pcb调度队列\n   * 逻辑组织结构：进程创建过程中形成的前后逻辑树关系\n\n * 进程状态以及状态切换\n   \n   >  * TASK_RUNNING\n   >  * TASK_INTERRUPTIBLE\n   >  * TASK_UNINTERTUPTIBLE\n   >  * TASK_SOTPPED\n   >  * TASK_ZOMBILE\n\n * 进程的文件管理：task_struct索引机制\n\n * 进程的内存管理：task_struct索引机制\n\n * 进程的主要特点：\n   \n   * 调度和执行：进程状态转换\n   * 资源\n     * 内核空间：PCB进程控制块\n     * 用户空间：正文段、数据段、堆栈段和打开的文件等\n\n进程基本属性\n\n * ps -aux： process status 查看系统正在运行的所有进程的详细属性\n\n * 进程ID：获取进程IDgetpid(void)\n\n * 进程真实用户和真实用户组：获取进程真实用户ID getuid(void)，获取进程真实用户组IDgetgid(void)\n\n * 进程有效用户和有效用户组：获取进程有效用户ID geteuid(void)，获取进程有效用户组IDgetegid(void)\n\n * 有效用户与真实用户实例3.1.1.c\n   \n   #include <stdio.h>\n   #include <stdlib.h>\n   #incldue <unistd.h>\n   #include <sys/types.h>\n   int main(int argc, char const *argv[])\n   {\n       printf("real uid: %d,real gid: %d \\n",getuid(),getgid());\n       printf("effective uid: %d, effective gid: %d\\n",geteuid(),getegid());\n       exit(0);\n   }\n   /*\n   ./3.1.1         //查看真实用户和有效用户的ID\n   ls -l 3.1.1     //查看是否设置了用户ID\n   chmod u+s 3.1.1 //添加文件特殊属性用户ID位\n   su              //切换到root权限\n   chown root 3.1.1//改变文件的所有者\n   ./3.1.1         //查看有效用户ID是否发生变化 有效用户ID会变成其所有者的用户ID\n   */\n   \n\n * 用户密码\n   \n   * /etc/password：存储所有用户信息\n   * etc/shadow：存储用户密码\n   * password：修改用户密码命令，其有效用户ID为root\n   * LINUX根据进程的的有效用户进行权限检查\n\n进程生命周期\n\n * 进程的启动：进程代码的入口main(int argc,char const *argv[])，内核启动C程序是，在调用main函数之前调用特殊的启动函数获取main函数地址和传递给它的参数，并将这些信息写入pcb\n\n * 进程的终止\n   \n   * 正常终止，从main函数返回；调用exit()或者_exit()终止；最后一个线程从其启动例程中返回；最后一个线程调用pthread_exit()终止\n   * 异常终止，调用abort()终止\n\n * 进程的生命周期\n   \n   >  * 调用：C启动例程 >> main() >> 用户函数 返回：用户函数 >> main() >> C例程\n   >  * 调用exit() >> 终止处理函数 >> 标准I/O清理函数 >> 调用_exit()返回到kernel\n\n * 终止进程的函数\n   \n   * void exit(int status)：执行完终止处理函数和标准I/O处理函数之后才会返回内核\n   \n   * void _exit(int status)：终止当前进程的生命周期，并立即返回内核\n   \n   * exit与return的区别：\n     \n     >  1. return是关键字，exit()是API\n     >  2. 在main函数中两者产生相同的效果\n     >  3. return退出的是函数，从子函数中返回；而exit()则会终止进程\n   \n   * 终止处理函数：日志登记、资源释放等善后工作，通过atexit()/on_exit()注册若干个终止处理函数\n\n创建进程\n\n * 进程0：内核创建的进程，进程0创建init进程（进程1）后转为交换进程或者空闲进程\n\n * 进程1：init进程是系统中所有其他进程的祖先pstree\n\n * 创建子进程fork()：在子进程中返回值为0提示正在子进程中，在父进程中返回值为子进程pid\n   \n   * 子进程拷贝父进程的PCB和数据空间（数据段和堆栈）\n   * 子进程和父进程共享正文段\n   * 子进程和父进程都会执行调用fork()之后的代码3.1.2.c\n   \n   int main(int argc, char const *argv[])\n   {\n       pid_t pid;\n       pid = fork();\n       if(pid == -1)\n           printf("fork error\\n");\n       else if(pid == 0){\n       \tprintf("the returned value is %d \\n",pid);\n           printf("in child process\\n");\n           printf("My pid is %d\\n",getpid());\n       }else{\n           printf("the returned value is %d \\n",pid);\n           printf("in father process\\n");\n           printf("My pid is %d\\n",getpid());\n       }\n       return 0;\n   }\n   \n\n * 创建进程的操作：\n   \n   * 为进程分配内核空间即进程控制块PCB\n   * 为进程分配用户空间报告正文段、数据段、堆（动态分配的空间）、栈（函数调用）\n\n * 父子进程的异同\n   \n   > 相同\n   > \n   >  * 真实和有效用户ID相同\n   >  * 环境变量相同\n   >  * 数据空间相同\n   >  * 打开的文件相同（父子进程文件共享）\n   > \n   > 不同\n   > \n   >  * fork()函数的返回值不同\n   >  * 进程ID不同\n   >  * 子进程的时间时钟数据会被清零\n\n * 创建独立进程vfork()：fork创建新进程将拥有自己的地址空间，但是在调用exec或exit离开父进程之前是在父进程的地址空间中运行，并在此期间子进程优先执行而父进程处于阻塞状态\n\n * exec系列函数：进程调用exec系列函数后，进程会变成执行该函数的进程，exec程序将改变进程的用户空间内容包括正文段、数据段和堆栈，并从加载的可执行文件的main函数开始重新执行。调用exec系列函数不改变进程的PCB所以不产生新的进程。\n   \n   >  * exec系列函数作用是提供可执行文件的命令行参数或者环境变量\n   > \n   >  * execl : int execl(const char *pathname, const char *argv0,...,NULL); 3.1.3.c\n   > \n   >  * int main(int argc,char const *argv[])\n   >    {\n   >     \tprintf("entering main process \\n");\n   >        if(fork()==0)\n   >        {\n   >            execl("/bin/ls","ls","-l",NULL);//参数个数根据NULL结尾获得\n   >            printf("exiting main process\\n");//execl可执行文件的代码会覆盖父进程的正文段，execl以后的代码都不会执行且不会有返回值\n   >        }\n   >        return 0;\n   >    }\n   >    \n   > \n   >  * execle : int execle(const char *pathname, const char *argv0,...,NULL,char *envp[]);\n   > \n   >  * #include <unistd.h>\n   >    #include <stdio.h>\n   >    #include <stdlib.h>\n   >    \n   >    int main()\n   >    {\n   >        char *envp[] = {"PATH=/tmp","USER=shan",NULL};//环境变量字符串\n   >        if(fork()==0)\n   >        {\n   >            if(execle("/bin/ls","ls","-l",NULL,evnp)<0)\n   >                perror("execle error\\n");\n   >        }\n   >        return 0;\n   >    }\n   >    \n   > \n   >  * execlp : int execle(const char *pathname, const char *argv0,...,NULL,char *envp[]);\n   > \n   >  * execv : int execv(const char *pathname,char *const argv[]);\n   > \n   >  * int main(int argc,char const *argv[])\n   >    {\n   >        int ret;\n   >        char *argv[] = {"ls","-l",NULL};\n   >     \tprintf("entering main process \\n");\n   >        if(fork()==0)\n   >        {\n   >            ret = execv("/bin/ls",argv);\n   >            if(ret == -1)\n   >                perror("execv error");\n   >            printf("exiting main process\\n");\n   >        }\n   >        return 0;\n   >    }\n   >    \n   > \n   >  * execve : int execve(const char *pathname, char *const argv[],char *envp[]);\n   > \n   >  * execvp: int execvp(const char *pathname,char *const argv[]);\n   > \n   >  * l : list 提供一系列命令行参数\n   > \n   >  * v：vector 命令行参数放在一个数组中\n   > \n   >  * e：由函数调用者提供环境变量表\n   > \n   >  * p：path 指定环境变量路径，查找可执行文件\n\n\n# 线程\n\n线程的基本概念\n\n * 线程：进程内的独立执行代码的实体和调度单元\n\n * 一个进程内的多个线程的关系：\n   \n   >  * 共享：共享打开的文件、全局变量等资源\n   >  * 私有：线程ID、存放局部变量的栈、寄存器集合（PC指针和上下文环境）等\n\n * 没有通过代码显示创建线程的进程看作只有一个线程的进程\n\n * 线程ID：pthread_t仅仅在进程环境中是唯一的\n\n线程和进程的操作\n\n操作     进程操作API            线程操作API\n线程创建   fork(),vfork()     pthread_create()\n终止     exit()             pthread_exit(),pthread_cancel()\n等待     wait(),waitpid()   pthread_join()\n获取ID   getpid()           pthread_self()\n\n * 创建子线程实例3.2.1.c\n   \n   void *childthread(void)\n   {\n       int i;\n       for(i=0;i<10;i++)\n       {\n           printf("childthread message\\n");\n           sleep(100);\n       }\n   }\n   \n   int main(int argc,char const *argv[])\n   {\n       pthread_t tid;\n       printf("create childthread\\n");\n       pthread_create(&tid,NULL,(void*)childthread,NULL);\n       pthread_join(tid,NULL);\n       printf("childthread exit\\n");\n       return 0;\n   }\n   ',normalizedContent:'# 进程与线程\n\n\n# 进程\n\n进程基本概念\n\n * 进程：操作系统对程序的加载并运行的动态概念\n\n * 进程在内核中的组织形式：进程控制块pcb\n\n * 进程控制块的组织结构\n   \n   * 物理组织结构：进程pcb调度队列\n   * 逻辑组织结构：进程创建过程中形成的前后逻辑树关系\n\n * 进程状态以及状态切换\n   \n   >  * task_running\n   >  * task_interruptible\n   >  * task_unintertuptible\n   >  * task_sotpped\n   >  * task_zombile\n\n * 进程的文件管理：task_struct索引机制\n\n * 进程的内存管理：task_struct索引机制\n\n * 进程的主要特点：\n   \n   * 调度和执行：进程状态转换\n   * 资源\n     * 内核空间：pcb进程控制块\n     * 用户空间：正文段、数据段、堆栈段和打开的文件等\n\n进程基本属性\n\n * ps -aux： process status 查看系统正在运行的所有进程的详细属性\n\n * 进程id：获取进程idgetpid(void)\n\n * 进程真实用户和真实用户组：获取进程真实用户id getuid(void)，获取进程真实用户组idgetgid(void)\n\n * 进程有效用户和有效用户组：获取进程有效用户id geteuid(void)，获取进程有效用户组idgetegid(void)\n\n * 有效用户与真实用户实例3.1.1.c\n   \n   #include <stdio.h>\n   #include <stdlib.h>\n   #incldue <unistd.h>\n   #include <sys/types.h>\n   int main(int argc, char const *argv[])\n   {\n       printf("real uid: %d,real gid: %d \\n",getuid(),getgid());\n       printf("effective uid: %d, effective gid: %d\\n",geteuid(),getegid());\n       exit(0);\n   }\n   /*\n   ./3.1.1         //查看真实用户和有效用户的id\n   ls -l 3.1.1     //查看是否设置了用户id\n   chmod u+s 3.1.1 //添加文件特殊属性用户id位\n   su              //切换到root权限\n   chown root 3.1.1//改变文件的所有者\n   ./3.1.1         //查看有效用户id是否发生变化 有效用户id会变成其所有者的用户id\n   */\n   \n\n * 用户密码\n   \n   * /etc/password：存储所有用户信息\n   * etc/shadow：存储用户密码\n   * password：修改用户密码命令，其有效用户id为root\n   * linux根据进程的的有效用户进行权限检查\n\n进程生命周期\n\n * 进程的启动：进程代码的入口main(int argc,char const *argv[])，内核启动c程序是，在调用main函数之前调用特殊的启动函数获取main函数地址和传递给它的参数，并将这些信息写入pcb\n\n * 进程的终止\n   \n   * 正常终止，从main函数返回；调用exit()或者_exit()终止；最后一个线程从其启动例程中返回；最后一个线程调用pthread_exit()终止\n   * 异常终止，调用abort()终止\n\n * 进程的生命周期\n   \n   >  * 调用：c启动例程 >> main() >> 用户函数 返回：用户函数 >> main() >> c例程\n   >  * 调用exit() >> 终止处理函数 >> 标准i/o清理函数 >> 调用_exit()返回到kernel\n\n * 终止进程的函数\n   \n   * void exit(int status)：执行完终止处理函数和标准i/o处理函数之后才会返回内核\n   \n   * void _exit(int status)：终止当前进程的生命周期，并立即返回内核\n   \n   * exit与return的区别：\n     \n     >  1. return是关键字，exit()是api\n     >  2. 在main函数中两者产生相同的效果\n     >  3. return退出的是函数，从子函数中返回；而exit()则会终止进程\n   \n   * 终止处理函数：日志登记、资源释放等善后工作，通过atexit()/on_exit()注册若干个终止处理函数\n\n创建进程\n\n * 进程0：内核创建的进程，进程0创建init进程（进程1）后转为交换进程或者空闲进程\n\n * 进程1：init进程是系统中所有其他进程的祖先pstree\n\n * 创建子进程fork()：在子进程中返回值为0提示正在子进程中，在父进程中返回值为子进程pid\n   \n   * 子进程拷贝父进程的pcb和数据空间（数据段和堆栈）\n   * 子进程和父进程共享正文段\n   * 子进程和父进程都会执行调用fork()之后的代码3.1.2.c\n   \n   int main(int argc, char const *argv[])\n   {\n       pid_t pid;\n       pid = fork();\n       if(pid == -1)\n           printf("fork error\\n");\n       else if(pid == 0){\n       \tprintf("the returned value is %d \\n",pid);\n           printf("in child process\\n");\n           printf("my pid is %d\\n",getpid());\n       }else{\n           printf("the returned value is %d \\n",pid);\n           printf("in father process\\n");\n           printf("my pid is %d\\n",getpid());\n       }\n       return 0;\n   }\n   \n\n * 创建进程的操作：\n   \n   * 为进程分配内核空间即进程控制块pcb\n   * 为进程分配用户空间报告正文段、数据段、堆（动态分配的空间）、栈（函数调用）\n\n * 父子进程的异同\n   \n   > 相同\n   > \n   >  * 真实和有效用户id相同\n   >  * 环境变量相同\n   >  * 数据空间相同\n   >  * 打开的文件相同（父子进程文件共享）\n   > \n   > 不同\n   > \n   >  * fork()函数的返回值不同\n   >  * 进程id不同\n   >  * 子进程的时间时钟数据会被清零\n\n * 创建独立进程vfork()：fork创建新进程将拥有自己的地址空间，但是在调用exec或exit离开父进程之前是在父进程的地址空间中运行，并在此期间子进程优先执行而父进程处于阻塞状态\n\n * exec系列函数：进程调用exec系列函数后，进程会变成执行该函数的进程，exec程序将改变进程的用户空间内容包括正文段、数据段和堆栈，并从加载的可执行文件的main函数开始重新执行。调用exec系列函数不改变进程的pcb所以不产生新的进程。\n   \n   >  * exec系列函数作用是提供可执行文件的命令行参数或者环境变量\n   > \n   >  * execl : int execl(const char *pathname, const char *argv0,...,null); 3.1.3.c\n   > \n   >  * int main(int argc,char const *argv[])\n   >    {\n   >     \tprintf("entering main process \\n");\n   >        if(fork()==0)\n   >        {\n   >            execl("/bin/ls","ls","-l",null);//参数个数根据null结尾获得\n   >            printf("exiting main process\\n");//execl可执行文件的代码会覆盖父进程的正文段，execl以后的代码都不会执行且不会有返回值\n   >        }\n   >        return 0;\n   >    }\n   >    \n   > \n   >  * execle : int execle(const char *pathname, const char *argv0,...,null,char *envp[]);\n   > \n   >  * #include <unistd.h>\n   >    #include <stdio.h>\n   >    #include <stdlib.h>\n   >    \n   >    int main()\n   >    {\n   >        char *envp[] = {"path=/tmp","user=shan",null};//环境变量字符串\n   >        if(fork()==0)\n   >        {\n   >            if(execle("/bin/ls","ls","-l",null,evnp)<0)\n   >                perror("execle error\\n");\n   >        }\n   >        return 0;\n   >    }\n   >    \n   > \n   >  * execlp : int execle(const char *pathname, const char *argv0,...,null,char *envp[]);\n   > \n   >  * execv : int execv(const char *pathname,char *const argv[]);\n   > \n   >  * int main(int argc,char const *argv[])\n   >    {\n   >        int ret;\n   >        char *argv[] = {"ls","-l",null};\n   >     \tprintf("entering main process \\n");\n   >        if(fork()==0)\n   >        {\n   >            ret = execv("/bin/ls",argv);\n   >            if(ret == -1)\n   >                perror("execv error");\n   >            printf("exiting main process\\n");\n   >        }\n   >        return 0;\n   >    }\n   >    \n   > \n   >  * execve : int execve(const char *pathname, char *const argv[],char *envp[]);\n   > \n   >  * execvp: int execvp(const char *pathname,char *const argv[]);\n   > \n   >  * l : list 提供一系列命令行参数\n   > \n   >  * v：vector 命令行参数放在一个数组中\n   > \n   >  * e：由函数调用者提供环境变量表\n   > \n   >  * p：path 指定环境变量路径，查找可执行文件\n\n\n# 线程\n\n线程的基本概念\n\n * 线程：进程内的独立执行代码的实体和调度单元\n\n * 一个进程内的多个线程的关系：\n   \n   >  * 共享：共享打开的文件、全局变量等资源\n   >  * 私有：线程id、存放局部变量的栈、寄存器集合（pc指针和上下文环境）等\n\n * 没有通过代码显示创建线程的进程看作只有一个线程的进程\n\n * 线程id：pthread_t仅仅在进程环境中是唯一的\n\n线程和进程的操作\n\n操作     进程操作api            线程操作api\n线程创建   fork(),vfork()     pthread_create()\n终止     exit()             pthread_exit(),pthread_cancel()\n等待     wait(),waitpid()   pthread_join()\n获取id   getpid()           pthread_self()\n\n * 创建子线程实例3.2.1.c\n   \n   void *childthread(void)\n   {\n       int i;\n       for(i=0;i<10;i++)\n       {\n           printf("childthread message\\n");\n           sleep(100);\n       }\n   }\n   \n   int main(int argc,char const *argv[])\n   {\n       pthread_t tid;\n       printf("create childthread\\n");\n       pthread_create(&tid,null,(void*)childthread,null);\n       pthread_join(tid,null);\n       printf("childthread exit\\n");\n       return 0;\n   }\n   ',charsets:{cjk:!0},lastUpdated:"2023/11/19, 12:55:48",lastUpdatedTimestamp:1700369748e3},{title:"线程同步与进程通信",frontmatter:{title:"线程同步与进程通信",date:"2023-04-30T14:46:33.000Z",permalink:"/pages/ff5e65/"},regularPath:"/04.Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/01.Linux%20%E5%9F%BA%E7%A1%80/04.%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B8%8E%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1.html",relativePath:"04.Linux操作系统编程/01.Linux 基础/04.线程同步与进程通信.md",key:"v-4081237d",path:"/pages/ff5e65/",headers:[{level:2,title:"线程同步与进程通信",slug:"线程同步与进程通信",normalizedTitle:"线程同步与进程通信",charIndex:2},{level:3,title:"线程同步",slug:"线程同步",normalizedTitle:"线程同步",charIndex:2},{level:3,title:"进程通信",slug:"进程通信",normalizedTitle:"进程通信",charIndex:7}],headersStr:"线程同步与进程通信 线程同步 进程通信",content:'# 线程同步与进程通信\n\n\n# 线程同步\n\n互斥量\n\n * 临界资源：在一段时间内只允许一个任务（线程或进程）访问资源。任务之间采用互斥的方式访问临界资源\n\n * 互斥量：pthread_mutex_t mutex; 初始化、加锁、解锁、销毁\n   \n   >  * 加锁：int pthread_mutex_lock(); int pthread_mutex_trylock();在访问临界资源前，对互斥量进行加锁。trylock()未加锁则加锁，加锁后不重复加锁。\n   >  * 解锁：int pthread_mutex_unlock();访问完成后对互斥量解锁\n   >  * 销毁：int pthread_mutex_destory();互斥量使用完毕后对互斥量进行销毁，释放资源。\n\n条件变量\n\n * 任务同步：多个线程都要访问临界资源又要相互合作，一个任务的执行依赖与另一个任务的执行情况。\n\n * 条件变量：pthread_cond_t cond;和互斥量一起使用，允许线程以互斥的方式阻塞等待条件的发生即为同步关系\n   \n   >  * 触发条件变量的线程：互斥量加锁>>某一操作>>触发条件变量>>互斥量解锁\n   >  * 等待条件变量的线程：互斥量加锁>>等待条件变量>>某一操作>>互斥量解锁\n   >  * 销毁：pthread_cond_destory();条件变量不再使用后进行销毁，释放空间\n   >  * 等待条件变量：pthread_cond_wait();使得调用进程进入阻塞状态，直到条件触发\n   >  * 触发条件变量：pthread_cond_signal();/pthread_cond_broadcast();可触发并唤醒等待条件变量的线程\n\n * 条件变量与互斥量要配合使用\n   \n   >  * 条件变量的使用场景伴随着临界资源的使用\n   > \n   >  * 在调用pthread_cond_wait();前需要使互斥量处于加锁状态，通过原子操作将调用线程放到该条件变量等待线程队列（临界资源）中\n   >    \n   >    //等待条件变量的操作\n   >    pthread_mutex_lock();\n   >    pthread_cond_wait();\n   >    pthread_mutex_unlock();\n   >    \n\n * 条件变量的使用4.1.1.c\n\n读写锁\n\n * 读写关系：读写互斥、写写互斥、读读不互斥\n\n * 读写锁：pthread_rwlock_t;\n   \n   >  * 加读锁：阻塞加锁pthread_rwlock_rdlock();/非阻塞加锁pthread_rwlock_tryrdlock();/限时加读锁pthread_rwlock_timedrdlock();\n   >  * 加写锁：阻塞加锁pthread_rwlock_wrlock();/非阻塞加锁pthread_rwlock_trywrlock();/限时加读锁pthread_rwlock_timedwrlock();\n   >  * 解锁：统一解锁函数，最近配对原则解锁pthread_rwlock_unlock();\n\n\n# 进程通信\n\n * 管道和命名管道：文件的形式实现不同进程共享资源\n\n * XSI IPC机制：LINUX系统使用的进程通信机制\n   \n   功能                              信号量      共享内存          消息队列\n   创建或打开一个IPC对象，获得对IPC机制的访问权       semget   shmget        msgget\n   IPC操作：信号量操作；连接/释放共享内存；发送/接收消息   semop    shmat/shmdt   msgsnd/msgrcv\n   IPC控制：获得/修改IPC对象状态，“删除”IPC对象    semctl   shmctl        msgctl\n\n消息队列\n\n * 消息队列：消息的链表，有写或者读权限的进程可以按照一定的规则添加或者读取消息\n\n * 消息队列的操作sys/types.h sys/ipc.h sys/msg.h 4.2.1\n   \n   >  * 打开或创建消息队列对象：int msgget();\n   >  * 从消息队列接收消息：int msgrcv();\n   >  * 向消息队列发送消息：int msgsnd();\n   >  * 消息队列控制操作：int msgctl();\n\n信号量\n\n * 互斥信号量：任务之间互斥访问临界资源 初始值为1\n\n * 计数信号量：任务之间竞争访问共享资源 初始值大于1，表示共享资源个数\n\n * 二值信号量：任务之间的同步机制 初始值为0\n\n * 信号量的数据结构\n   \n   struct s\n   {\n       int count; //资源计数\n       Queue queue; //任务阻塞队列\n   };\n   \n   int init(); // 初始化\n   int P(); // P操作\n   int V(); // V操作\n   \n\n * P操作：分配资源\n   \n   --s.count;\n   if(s.count < 0)\n   {\n   \t调用进程进入s.queue;\n   \t阻塞调用进程；\n   }\n   \n\n * V操作：释放资源\n   \n   ++s.count;\n   if(s.count <= 0 )\n   {\n   \t从阻塞队列s.queue中取出一个进程P;\n   \t进程P进入就绪队列;\n   }\n   \n\n * 信号量集的操作sys/types.h sys/ipc.h sys/sem.h\n   \n   >  * 创建或者打开信号量集对象int semget();\n   >    \n   >    #include<stdio.h>\n   >    #include<sys/sem.h>\n   >    #define MYKEY 0x1a0a //定一个ipc的key值\n   >    int main()\n   >    {\n   >    \tint semid;\n   >    \tsemid = semget(MYKEY,1,IPC_CREAT|IPC_R|IPC_W|IPC_M); //创建一个信号量集对象\n   >    \tprintf("semid = %d\\n",semid);\n   >        return 0;\n   >    }\n   >    \n   > \n   >  * 信号量PV操作int semop();：根据参数short sem_op;判断执行的操作类型\n   >    \n   >    * sem_op > 0：信号量V操作，增加信号量的值\n   >    * sem_op < 0：信号量P操作，减少信号量的值\n   >    * sem_op = 0：对信号量的当前值是否为0的测试\n   >    \n   >    //实现P操作\n   >    static int semaphore_v(void)\n   >    {\n   >    \tstruct sembuf sem_b;\n   >    \tsem_b.sem_num = 0; //信号量编号\n   >    \tsem_b.sem_op = -1; // P操作\n   >    \tsem_b.sem_fg = SEM_UNDO; //在进程没释放信号量而退出时，系统自动释放该进程中未释放的信号量\n   >    \tif(semop(sem_id, &sem_b,1) == -1)\n   >    \t{\n   >    \t\tfprintf(stderr,"semaphore_p failed\\n");\n   >    \t\treturn 0;\n   >    \t}\n   >    \treturn 1;\n   >    }\n   >    \n   >    //实现V操作\n   >    static int semaphore_v(void)\n   >    {\n   >    \tstruct sembuf sem_b;\n   >    \tsem_b.sem_num = 0;\n   >    \tsem_b.sem_op = 1; // V操作\n   >    \tsem_b.sem_fg = SEM_UNDO;\n   >    \tif(semop(sem_id, &sem_b,1) == -1)\n   >    \t{\n   >    \t\tfprintf(stderr,"semaphore_v failed\\n");\n   >    \t\treturn 0;\n   >    \t}\n   >    \treturn 1;\n   >    }\n   >    \n   > \n   >  * 信号量控制int semctl(); ：int cmd;控制命令参数\n   >    \n   >    * 对信号量集的控制命令：IPC_RMID删除；IPC_SET设置参数；IPC_STAT获取参数；IPC_INFO获取系统信息\n   >    * 对信号量的控制命令：SETVAL设置信号量的值；GETVAL获取信号量的值；GETPID获取信号量拥有者的PID值\n   >    \n   >    //信号量初始化\n   >    int init_sem(int sem_id, int init_value)\n   >    {\n   >    \tunion semun_sem_union;\n   >    \tsem_union.val = init_value;\n   >    \tif(semctl(sem_id,0,SETVAL,sem_union) == -1)\n   >    \t{\n   >    \t\tperror("Initialize semaphore");\n   >    \t\treturn -1;\n   >    \t}\n   >    \treturn 0;\n   >    }\n   >    \n   >    //从系统中删除信号量\n   >    int del_sem(int sem_id)\n   >    {\n   >    \tunion semun sem_union;\n   >    \tif(semctl(sem_id,0,IPC_RMID,sem_union) == -1)\n   >    \t{\n   >    \t\tperror("Initialize semaphore");\n   >    \t\treturn -1;\n   >    \t}\n   >    }\n   >    \n\n共享内存\n\n * 共享内存：不同进程可以将同一段内存空间链接到自己的地址空间中，类似物理空间中的全局变量\n\n * 共享内存的操作sys/types.h sys/ipc.h sys/shm.h\n   \n   >  * 创建或者打开共享内存对象int shmget();\n   >  * 将共享内存链接到调用的进程的地址空间void *shmat();\n   >  * 删除进程的共享内存链接int shmdt();\n   >  * 对共享内存的操作int shmctl();\n\n * 共享内存应用--生产者/消费者问题4.2.2.c\n   \n   //缓存池结构\n   struct BufferPool\n   {\n   \tchar Buffer[5][100];\n   \tint index[5];\n   };\n   ',normalizedContent:'# 线程同步与进程通信\n\n\n# 线程同步\n\n互斥量\n\n * 临界资源：在一段时间内只允许一个任务（线程或进程）访问资源。任务之间采用互斥的方式访问临界资源\n\n * 互斥量：pthread_mutex_t mutex; 初始化、加锁、解锁、销毁\n   \n   >  * 加锁：int pthread_mutex_lock(); int pthread_mutex_trylock();在访问临界资源前，对互斥量进行加锁。trylock()未加锁则加锁，加锁后不重复加锁。\n   >  * 解锁：int pthread_mutex_unlock();访问完成后对互斥量解锁\n   >  * 销毁：int pthread_mutex_destory();互斥量使用完毕后对互斥量进行销毁，释放资源。\n\n条件变量\n\n * 任务同步：多个线程都要访问临界资源又要相互合作，一个任务的执行依赖与另一个任务的执行情况。\n\n * 条件变量：pthread_cond_t cond;和互斥量一起使用，允许线程以互斥的方式阻塞等待条件的发生即为同步关系\n   \n   >  * 触发条件变量的线程：互斥量加锁>>某一操作>>触发条件变量>>互斥量解锁\n   >  * 等待条件变量的线程：互斥量加锁>>等待条件变量>>某一操作>>互斥量解锁\n   >  * 销毁：pthread_cond_destory();条件变量不再使用后进行销毁，释放空间\n   >  * 等待条件变量：pthread_cond_wait();使得调用进程进入阻塞状态，直到条件触发\n   >  * 触发条件变量：pthread_cond_signal();/pthread_cond_broadcast();可触发并唤醒等待条件变量的线程\n\n * 条件变量与互斥量要配合使用\n   \n   >  * 条件变量的使用场景伴随着临界资源的使用\n   > \n   >  * 在调用pthread_cond_wait();前需要使互斥量处于加锁状态，通过原子操作将调用线程放到该条件变量等待线程队列（临界资源）中\n   >    \n   >    //等待条件变量的操作\n   >    pthread_mutex_lock();\n   >    pthread_cond_wait();\n   >    pthread_mutex_unlock();\n   >    \n\n * 条件变量的使用4.1.1.c\n\n读写锁\n\n * 读写关系：读写互斥、写写互斥、读读不互斥\n\n * 读写锁：pthread_rwlock_t;\n   \n   >  * 加读锁：阻塞加锁pthread_rwlock_rdlock();/非阻塞加锁pthread_rwlock_tryrdlock();/限时加读锁pthread_rwlock_timedrdlock();\n   >  * 加写锁：阻塞加锁pthread_rwlock_wrlock();/非阻塞加锁pthread_rwlock_trywrlock();/限时加读锁pthread_rwlock_timedwrlock();\n   >  * 解锁：统一解锁函数，最近配对原则解锁pthread_rwlock_unlock();\n\n\n# 进程通信\n\n * 管道和命名管道：文件的形式实现不同进程共享资源\n\n * xsi ipc机制：linux系统使用的进程通信机制\n   \n   功能                              信号量      共享内存          消息队列\n   创建或打开一个ipc对象，获得对ipc机制的访问权       semget   shmget        msgget\n   ipc操作：信号量操作；连接/释放共享内存；发送/接收消息   semop    shmat/shmdt   msgsnd/msgrcv\n   ipc控制：获得/修改ipc对象状态，“删除”ipc对象    semctl   shmctl        msgctl\n\n消息队列\n\n * 消息队列：消息的链表，有写或者读权限的进程可以按照一定的规则添加或者读取消息\n\n * 消息队列的操作sys/types.h sys/ipc.h sys/msg.h 4.2.1\n   \n   >  * 打开或创建消息队列对象：int msgget();\n   >  * 从消息队列接收消息：int msgrcv();\n   >  * 向消息队列发送消息：int msgsnd();\n   >  * 消息队列控制操作：int msgctl();\n\n信号量\n\n * 互斥信号量：任务之间互斥访问临界资源 初始值为1\n\n * 计数信号量：任务之间竞争访问共享资源 初始值大于1，表示共享资源个数\n\n * 二值信号量：任务之间的同步机制 初始值为0\n\n * 信号量的数据结构\n   \n   struct s\n   {\n       int count; //资源计数\n       queue queue; //任务阻塞队列\n   };\n   \n   int init(); // 初始化\n   int p(); // p操作\n   int v(); // v操作\n   \n\n * p操作：分配资源\n   \n   --s.count;\n   if(s.count < 0)\n   {\n   \t调用进程进入s.queue;\n   \t阻塞调用进程；\n   }\n   \n\n * v操作：释放资源\n   \n   ++s.count;\n   if(s.count <= 0 )\n   {\n   \t从阻塞队列s.queue中取出一个进程p;\n   \t进程p进入就绪队列;\n   }\n   \n\n * 信号量集的操作sys/types.h sys/ipc.h sys/sem.h\n   \n   >  * 创建或者打开信号量集对象int semget();\n   >    \n   >    #include<stdio.h>\n   >    #include<sys/sem.h>\n   >    #define mykey 0x1a0a //定一个ipc的key值\n   >    int main()\n   >    {\n   >    \tint semid;\n   >    \tsemid = semget(mykey,1,ipc_creat|ipc_r|ipc_w|ipc_m); //创建一个信号量集对象\n   >    \tprintf("semid = %d\\n",semid);\n   >        return 0;\n   >    }\n   >    \n   > \n   >  * 信号量pv操作int semop();：根据参数short sem_op;判断执行的操作类型\n   >    \n   >    * sem_op > 0：信号量v操作，增加信号量的值\n   >    * sem_op < 0：信号量p操作，减少信号量的值\n   >    * sem_op = 0：对信号量的当前值是否为0的测试\n   >    \n   >    //实现p操作\n   >    static int semaphore_v(void)\n   >    {\n   >    \tstruct sembuf sem_b;\n   >    \tsem_b.sem_num = 0; //信号量编号\n   >    \tsem_b.sem_op = -1; // p操作\n   >    \tsem_b.sem_fg = sem_undo; //在进程没释放信号量而退出时，系统自动释放该进程中未释放的信号量\n   >    \tif(semop(sem_id, &sem_b,1) == -1)\n   >    \t{\n   >    \t\tfprintf(stderr,"semaphore_p failed\\n");\n   >    \t\treturn 0;\n   >    \t}\n   >    \treturn 1;\n   >    }\n   >    \n   >    //实现v操作\n   >    static int semaphore_v(void)\n   >    {\n   >    \tstruct sembuf sem_b;\n   >    \tsem_b.sem_num = 0;\n   >    \tsem_b.sem_op = 1; // v操作\n   >    \tsem_b.sem_fg = sem_undo;\n   >    \tif(semop(sem_id, &sem_b,1) == -1)\n   >    \t{\n   >    \t\tfprintf(stderr,"semaphore_v failed\\n");\n   >    \t\treturn 0;\n   >    \t}\n   >    \treturn 1;\n   >    }\n   >    \n   > \n   >  * 信号量控制int semctl(); ：int cmd;控制命令参数\n   >    \n   >    * 对信号量集的控制命令：ipc_rmid删除；ipc_set设置参数；ipc_stat获取参数；ipc_info获取系统信息\n   >    * 对信号量的控制命令：setval设置信号量的值；getval获取信号量的值；getpid获取信号量拥有者的pid值\n   >    \n   >    //信号量初始化\n   >    int init_sem(int sem_id, int init_value)\n   >    {\n   >    \tunion semun_sem_union;\n   >    \tsem_union.val = init_value;\n   >    \tif(semctl(sem_id,0,setval,sem_union) == -1)\n   >    \t{\n   >    \t\tperror("initialize semaphore");\n   >    \t\treturn -1;\n   >    \t}\n   >    \treturn 0;\n   >    }\n   >    \n   >    //从系统中删除信号量\n   >    int del_sem(int sem_id)\n   >    {\n   >    \tunion semun sem_union;\n   >    \tif(semctl(sem_id,0,ipc_rmid,sem_union) == -1)\n   >    \t{\n   >    \t\tperror("initialize semaphore");\n   >    \t\treturn -1;\n   >    \t}\n   >    }\n   >    \n\n共享内存\n\n * 共享内存：不同进程可以将同一段内存空间链接到自己的地址空间中，类似物理空间中的全局变量\n\n * 共享内存的操作sys/types.h sys/ipc.h sys/shm.h\n   \n   >  * 创建或者打开共享内存对象int shmget();\n   >  * 将共享内存链接到调用的进程的地址空间void *shmat();\n   >  * 删除进程的共享内存链接int shmdt();\n   >  * 对共享内存的操作int shmctl();\n\n * 共享内存应用--生产者/消费者问题4.2.2.c\n   \n   //缓存池结构\n   struct bufferpool\n   {\n   \tchar buffer[5][100];\n   \tint index[5];\n   };\n   ',charsets:{cjk:!0},lastUpdated:"2023/11/19, 12:55:48",lastUpdatedTimestamp:1700369748e3},{title:"Linux 文件权限",frontmatter:{title:"Linux 文件权限",date:"2023-05-01T11:54:27.000Z",permalink:"/pages/5d33e8/"},regularPath:"/04.Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/01.Linux%20%E5%9F%BA%E7%A1%80/05.Linux%20%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90.html",relativePath:"04.Linux操作系统编程/01.Linux 基础/05.Linux 文件权限.md",key:"v-3dee8977",path:"/pages/5d33e8/",headers:[{level:2,title:"01 用户与用户组",slug:"_01-用户与用户组",normalizedTitle:"01 用户与用户组",charIndex:2},{level:3,title:"1.1 用户身份",slug:"_1-1-用户身份",normalizedTitle:"1.1 用户身份",charIndex:169},{level:4,title:"1.1.1 文件所有者 owner",slug:"_1-1-1-文件所有者-owner",normalizedTitle:"1.1.1 文件所有者 owner",charIndex:181},{level:4,title:"1.1.2 用户组成员 group",slug:"_1-1-2-用户组成员-group",normalizedTitle:"1.1.2 用户组成员 group",charIndex:311},{level:4,title:"1.1.3 其他人 others",slug:"_1-1-3-其他人-others",normalizedTitle:"1.1.3 其他人 others",charIndex:541},{level:3,title:"1.2 用户管理",slug:"_1-2-用户管理",normalizedTitle:"1.2 用户管理",charIndex:769},{level:4,title:"1.2.1 用户管理相关文件",slug:"_1-2-1-用户管理相关文件",normalizedTitle:"1.2.1 用户管理相关文件",charIndex:781},{level:4,title:"1.2.2 用户管理相关命令",slug:"_1-2-2-用户管理相关命令",normalizedTitle:"1.2.2 用户管理相关命令",charIndex:1858},{level:2,title:"02 文件权限",slug:"_02-文件权限",normalizedTitle:"02 文件权限",charIndex:2533},{level:3,title:"2.1 文件属性",slug:"_2-1-文件属性",normalizedTitle:"2.1 文件属性",charIndex:2755},{level:3,title:"2.2 文件属性修改命令",slug:"_2-2-文件属性修改命令",normalizedTitle:"2.2 文件属性修改命令",charIndex:3950},{level:2,title:"03 命令与文件权限",slug:"_03-命令与文件权限",normalizedTitle:"03 命令与文件权限",charIndex:5552},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:6196}],headersStr:"01 用户与用户组 1.1 用户身份 1.1.1 文件所有者 owner 1.1.2 用户组成员 group 1.1.3 其他人 others 1.2 用户管理 1.2.1 用户管理相关文件 1.2.2 用户管理相关命令 02 文件权限 2.1 文件属性 2.2 文件属性修改命令 03 命令与文件权限 参考资料",content:"# 01 用户与用户组\n\nLinux 是一个多用户系统，它允许多个用户同时登陆主机，并为他们分配不同的资源和工作环境进行使用。当然，不同的用户都有文件的私有需求，所以设置不同用户文件的权限管理十分重要。\n\nLinux 中一般将文件访问权限的身份分为三种角色：文件所有者、用户组成员、其他人（owner/group/others）\n\n\n# 1.1 用户身份\n\n# 1.1.1 文件所有者 owner\n\n文件所有者角色是 Linux 系统保护用户私有空间的重要方式。\n\n当多个用户同时登录主机时，文件所有者对文件具有绝对访问权限并可以限制其他用户对该文件的访问权限，其他用户如需访问该文件，需要文件所有者授权才可访问。\n\n# 1.1.2 用户组成员 group\n\n用户组成员角色是为了方便用户在局部范围内共享文件内容。\n\n例如，在团队开发中，如果 Linux 系统仅提供 owner 和 others 角色，那么当文件所有者想给其他团队成员开放文件访问权限时，就会出现文件直接对团队之外角色公开的情况。\n\n将文件所有者之外的用户角色区分为用户组成员 group 和其他人 others，可以在向与文件所有者划分在一个用户组的用户组成员开放文件访问权限的同时，对其他用户保持私用。\n\n# 1.1.3 其他人 others\n\n其他人角色是用户公开文件访问权限的方式。\n\n文件所有者可以通过向 others 角色开放文件访问权限，向与文件所有者没有任何联系的其他用户共享文件。\n\n当然，除了 owner/group/others 三种用户之外，还有掌控一切的系统用户 root，root 用户可以访问主机中的一切文件。root 用户所在的用户组称为 root组，处于 root 组的普通用户，能够通过 sudo 命令获取 root 权限。\n\n\n# 1.2 用户管理\n\n# 1.2.1 用户管理相关文件\n\n在 Linux 系统中，默认情况下，系统上所有的用户账号通过用户 ID (User ID ，简称 UID)、一个是用户组 ID (Group ID ，简称 GID)标识，并都记录在 /etc/passwd 这个文件内的，对应的密码则是记录在 /etc/shadow 文件下。 此外，Linux 所有的用户组信息和密码都纪录在 /etc/group 与 /etc/gshadow 内。\n\n这些文件中，每一行表示一条记录，每条记录中个属性字段通过冒号 :分隔。\n\n 1. /etc/passwd\n\n> 该文件管理用户 UID 和 GID 等重要参数。\n> \n> 每一行都代表一个用户账号，其中包括一些系统正常运行所必须的系统账号，例如 bin, daemon, adm, nobody 等。\n> \n> 冒号 :分隔开的 7 个字段含义是：\n> \n>  * 账号名称：用户账号的 username\n>  * 口令：即账号密码，但是现在的账号密码都保持在 /etc/shadow 文件中了，此处使用 x 符号占位\n>  * UID：用户标识符 User ID，root 用户的 UID 是 0\n>  * GID：用户组标识符 Group ID\n>  * 用户账号描述：没实际含义\n>  * 用户目录：用户空间\n>  * shell：用户登录系统后与主机进行交互的命令行工具，默认是 /bin/bash\n\n 2. /etc/shadow\n\n> 该文件管理用户的登录口令。\n> \n> 冒号 :分隔开的 9 个字段含义是：\n> \n>  * 账号名称：用户账号的 username\n>  * 口令：经过编码加密的账号密码\n>  * 最近更动口令的日期\n>  * 口令不可被更动的天数\n>  * 口令需要重新变更的天数\n>  * 口令需要变更期限前的警告天数\n>  * 口令过期后的账号宽限时间\n>  * 账号失效日期\n\n 3. /etc/group\n\n> 该文件管理用户组信息，与 /etc/passwd 中的 GID 对应。\n> \n> 每一行代表一个群组，冒号 :分隔开的 7 个字段含义是：\n> \n>  * 用户组名称\n>  * 用户组口令：一般不需配置，用不到\n>  * GID：用户组标识符 Group ID\n>  * 用户组包含的用户名称：一个账号可以加入多个群组，那某个账号想要加入此群组时，将该账号填入这个字段即可。\n\n 4. /etc/gshadow\n\n> 用户组口令都不咋用，这个文件的存在感也比较弱......\n\n# 1.2.2 用户管理相关命令\n\nLinux 提供了一组用户账号和用户组管理命令对账号进行新增、 移除与更改\n\n 1. 用户管理命令\n\n>  * useradd：新建用户\n>    \n>    useradd [options] [username]\n>    \n> \n>  * passwd：设置或修改用户的口令和口令属性\n>    \n>    passwd [options] [username]\n>    \n> \n>  * usermod：user modify 修改用户的属性\n>    \n>    usermod [options] [username]\n>    \n> \n>  * userdel：user delete 删除指定用户账号\n>    \n>    userdel [options] [username]\n>    \n> \n>  * su：切换用户身份；exit 退出超级用户\n>    \n>    su [options] [username]\n>    \n\n 2. 用户组管理命令\n\n>  * groupadd：添加用户组\n>    \n>    groupadd [options] [groupname]\n>    \n> \n>  * groupmod：修改用户组属性\n>    \n>    groupmod [options] [groupname]\n>    \n> \n>  * groupdel：删除指定用户组\n>    \n>    groupdel [options] [groupname]\n>    \n\n\n# 02 文件权限\n\nLinux 系统中文件有第一节中的三种访问角色 owner/group/others，对于文件这三种身份还各有 read/write/execute 三种访问权限。通过这三种角色和访问权限控制可以到来 Linux 系统的如下优势：\n\n * 系统保护：关于系统服务的文件通常只有 root 角色能访问，可以有效保护系统中的重要文件。\n * 团队开发文件共享：通过设置用户组权限，让团队成员能够共享指定目录下的文件数据。\n\n\n# 2.1 文件属性\n\n在 Linux 系统中进入任意目录，然后使用 ls 命令查看当前目录下文件的文件名与相关属性，也可以增加选项参数 ls -la 显示所有的文件详细的权限与属性。\n\n如上图所示，list 命令显示的内容中每一行即是一个文件的相关属性，每一条记录的 7 个字段含义如下：\n\n 1. 文件类型与权限\n\n> 文件类型与权限由 10 个字符构成：\n> \n> 第一个字符代表该文件的类型：\n> \n>  * [ d ] 表示目录\n>  * [ - ] 表示文件\n>  * [ l ] 表示链接\n>  * [ b ] 表示装置文件里面的可供储存的接口设备，即可随机存取装置\n>  * [ c ] 表示装置文件里面的串行端口设备，例如键盘、鼠标等一次性读取装置\n> \n> 剩下的 9 个字符，三个为一组分别表示 owner/group/others 三种角色的 read/write/execute 三种访问权限\n> \n> 权限对于文件的意义：\n> \n>  * r (read)：可读取此一文件的实际内容，如读取文本文件的文字内容等；\n>  * w (write)：可以编辑、新增或者是修改该文件的内容(但不含删除该文件)；\n>  * x (execute)：该文件具有可以被系统执行的权限。\n> \n> 权限对于目录的意义：\n> \n>  * r (read contents in directory)：表示具有读取目录结构列表的权限，即表示可以查询该目录下的文件名数据（ls 命令查看目录信息）。\n>  * w (modify contents of directory)：表示具有向目录写入内容的权限，即可以修改目录的结构列表。例如，创建新的文件或目录、删除文件或目录、修改文件或目录的名称、移动文件或目录到其他位置等。\n>  * x (access directory)：表示用户具有进入该目录成为工作目录的权限（cd 命令进入到目录中）。\n\n 2. 文件链接数\n\n> Linux 文件系统 Ext2 使用的是以 inode 为基础的文件系统，inode 的内容在记录文件的权限与相关属性，block 区块中才是记录文件实际内容的位置。\n> \n> 文件属性的这个字段就是记录的有多少不同的文件连结到相同的一个 inode 号码\n\n 3. 文件所有者\n\n> 表示文件或目录的所有者名称\n\n 4. 所属用户组\n\n> 表示文件或目录所属用户组的名称\n\n 5. 文件大小\n\n> 表示文件的容量大小，默认单位为字节 bytes\n\n 6. 时间戳\n\n> 记录文件的创建日期或者是最近的修改日期。\n> \n> 记录的时间一般为 月/日/时间 的形式，如果这个文件被修改的时间跨度过大，那么时间部分会仅显示年份。\n\n 7. 文件名称\n\n> 文件的名称，如果文件名以 .开头则说明他是隐藏文件\n\n\n# 2.2 文件属性修改命令\n\n文件属性的修改命令分别针对文件所有者和所属用户组有 chown, chgrp，文件权限修改命名则是 chmod\n\n * chown ：改变文件拥有者\n * chgrp ：改变文件所属群组\n * chmod ：改变文件的权限\n\n 1. chown\n\n> 文件在创建的时候就指定了文件所有者，当将文件复制或移动到其他用户目录下时，就需要变更文件的所有者了，因为复制操作会根据执行命令的用户确定拷贝的文件文件所有者。\n> \n> chown [options] [owner] [filename/directory]\n> \n> \n> 使用该命令修改目录时，可以通过添加 -R 选项进行递归的持续变更，即连同次目录下的所有文件都变更文件所有者。\n> \n> chown -R [owner] [irectory]\n> \n> \n> chown 目录还可以顺带修改用户组，使用冒号连接 用户:用户组 同时修改文件所有者和所属用户组。\n> \n> chown [options] [owner:group] [filename/directory]\n\n 2. chgrp\n\n> 仅修改文件所属的用户组可以使用 chgrp 命令实现，当然修改时要确保用户组是存在的。\n> \n> chgrp [options] [group] [filename/directory]\n> \n> \n> 如果要修改目录下所有文件的所属用户组，同样的使用 -R 参数进行递归的持续变更。\n> \n> chgrp -R [group] [directory]\n\n 3. chmod\n\n> 修改文件权限的命令则是 chmod，该命令可以通过数字类型和符号类型两种形式设定文件权限。\n> \n> 数字类型：\n> \n> Linux 系统中 read/write/execute 三种访问权限分别对应的数字分数是：read(4), write(2), execute(1)\n> \n> 每个用户角色的权限可以用三种访问权限的数字分数累加结果表示，例如文件权限 -rwxr-x---的数字分数表示是 750：\n> \n> owner = rwx = 4+2+1 = 7\n> group = r-x = 4+0+1 = 5\n> others= --- = 0+0+0 = 0\n> \n> \n> 使用数字类型的 chmod 权限修改命令形式为：\n> \n> chmod [options] [number] [filename/directory]\n> # example:\n> chmod -R 770 /data/share\n> \n> \n> 符号类型：\n> \n> 另一种修改文件权限的方式就是使用符号类型，owner/group/others 三种角色对应的符号表示是：owner(u), group(g), others(o)，还有同时表示三种角色的符号：all(a)。read/write/execute 三种访问权限的符号表示是：read(r), write(w), execute(x)。\n> \n> 基于用户角色和文件权限的符号表示，使用符号 +, -, = 为不同的用户角色添加、除去和设定不同的文件权限：\n> \n> 命令      角色        操作      权限      对象\n> chmod   u/g/o/a   +/-/=   r/w/x   文件或目录\n> \n> 例如，要使用 chmod 命令设置文件所有者权限为可读、可写、可执行，所属用户组和其他用户具有可读与执行的权限，即 -rwxr-xr-x：\n> \n> chmod u=rwx,go=rx fliename\n> \n> \n> 如果又要除去其他用户的可读与执行的权限是，即 -rwxr-x--：\n> \n> chmod o-rx fliename\n\n\n# 03 命令与文件权限\n\n文件权限限制了用户对文件或目录进行读取/创建/删除/修改等操作，我们进一步理解这操作命令是怎么和文件和目录权限对应起来的。\n\n切换工作目录：\n\n * 可使用的命令：例如 cd 等变换工作目录的命令；\n * 目录所需权限：用户需要对该目录具有可执行权限 (x)；如果还需要查阅目录结构信息，用户还需要可读权限（r）。\n\n读取文件内容：\n\n * 可使用的命令：例如 cat，more，less，head，tail 等查阅命令\n * 目录所需权限：用户需要对工作目录（当前目录）具有可执行权限 (x)；\n * 文件所需权限：用户需要对该文件具有可读权限（r）；\n\n修改文件内容：\n\n * 可使用的命令：例如 echo+重定向符号，vim 等文件修改命令\n * 目录所需权限：用户需要对工作目录（当前目录）具有可执行权限 (x)；\n * 文件所需权限：用户需要对该文件具有可读、可写权限（r，w）；\n\n新建文件/目录：\n\n * 可使用的命令：例如 touch，mkdir 等文件或目录创建命令\n * 目录所需权限：用户需要对工作目录（当前目录）具有可执行权限 (x) 进入到该目录，还需要对工作目录具有可写权限 (w) 修改目录结构新建文件\n\n运行可执行文件：\n\n * 可使用的命令：例如 ./，bash 等文件执行命令\n * 目录所需权限：用户需要对工作目录（当前目录）具有可执行权限 (x)；\n * 文件所需权限：用户需要对该文件具有具有可执行权限 (x)；\n\n\n# 参考资料\n\n一篇读懂 Linux 用户管理与操作\n\n鸟哥的 Linux 私房菜 -- Linux 的文件权限与目录配置-1\n\n鸟哥的 Linux 私房菜 -- Linux 的文件权限与目录配置-2\n\n鸟哥的 Linux 私房菜 -- Linux 账号管理-1\n\n鸟哥的 Linux 私房菜 -- Linux 账号管理-2\n\n鸟哥的 Linux 私房菜 -- 文件与目录管理",normalizedContent:"# 01 用户与用户组\n\nlinux 是一个多用户系统，它允许多个用户同时登陆主机，并为他们分配不同的资源和工作环境进行使用。当然，不同的用户都有文件的私有需求，所以设置不同用户文件的权限管理十分重要。\n\nlinux 中一般将文件访问权限的身份分为三种角色：文件所有者、用户组成员、其他人（owner/group/others）\n\n\n# 1.1 用户身份\n\n# 1.1.1 文件所有者 owner\n\n文件所有者角色是 linux 系统保护用户私有空间的重要方式。\n\n当多个用户同时登录主机时，文件所有者对文件具有绝对访问权限并可以限制其他用户对该文件的访问权限，其他用户如需访问该文件，需要文件所有者授权才可访问。\n\n# 1.1.2 用户组成员 group\n\n用户组成员角色是为了方便用户在局部范围内共享文件内容。\n\n例如，在团队开发中，如果 linux 系统仅提供 owner 和 others 角色，那么当文件所有者想给其他团队成员开放文件访问权限时，就会出现文件直接对团队之外角色公开的情况。\n\n将文件所有者之外的用户角色区分为用户组成员 group 和其他人 others，可以在向与文件所有者划分在一个用户组的用户组成员开放文件访问权限的同时，对其他用户保持私用。\n\n# 1.1.3 其他人 others\n\n其他人角色是用户公开文件访问权限的方式。\n\n文件所有者可以通过向 others 角色开放文件访问权限，向与文件所有者没有任何联系的其他用户共享文件。\n\n当然，除了 owner/group/others 三种用户之外，还有掌控一切的系统用户 root，root 用户可以访问主机中的一切文件。root 用户所在的用户组称为 root组，处于 root 组的普通用户，能够通过 sudo 命令获取 root 权限。\n\n\n# 1.2 用户管理\n\n# 1.2.1 用户管理相关文件\n\n在 linux 系统中，默认情况下，系统上所有的用户账号通过用户 id (user id ，简称 uid)、一个是用户组 id (group id ，简称 gid)标识，并都记录在 /etc/passwd 这个文件内的，对应的密码则是记录在 /etc/shadow 文件下。 此外，linux 所有的用户组信息和密码都纪录在 /etc/group 与 /etc/gshadow 内。\n\n这些文件中，每一行表示一条记录，每条记录中个属性字段通过冒号 :分隔。\n\n 1. /etc/passwd\n\n> 该文件管理用户 uid 和 gid 等重要参数。\n> \n> 每一行都代表一个用户账号，其中包括一些系统正常运行所必须的系统账号，例如 bin, daemon, adm, nobody 等。\n> \n> 冒号 :分隔开的 7 个字段含义是：\n> \n>  * 账号名称：用户账号的 username\n>  * 口令：即账号密码，但是现在的账号密码都保持在 /etc/shadow 文件中了，此处使用 x 符号占位\n>  * uid：用户标识符 user id，root 用户的 uid 是 0\n>  * gid：用户组标识符 group id\n>  * 用户账号描述：没实际含义\n>  * 用户目录：用户空间\n>  * shell：用户登录系统后与主机进行交互的命令行工具，默认是 /bin/bash\n\n 2. /etc/shadow\n\n> 该文件管理用户的登录口令。\n> \n> 冒号 :分隔开的 9 个字段含义是：\n> \n>  * 账号名称：用户账号的 username\n>  * 口令：经过编码加密的账号密码\n>  * 最近更动口令的日期\n>  * 口令不可被更动的天数\n>  * 口令需要重新变更的天数\n>  * 口令需要变更期限前的警告天数\n>  * 口令过期后的账号宽限时间\n>  * 账号失效日期\n\n 3. /etc/group\n\n> 该文件管理用户组信息，与 /etc/passwd 中的 gid 对应。\n> \n> 每一行代表一个群组，冒号 :分隔开的 7 个字段含义是：\n> \n>  * 用户组名称\n>  * 用户组口令：一般不需配置，用不到\n>  * gid：用户组标识符 group id\n>  * 用户组包含的用户名称：一个账号可以加入多个群组，那某个账号想要加入此群组时，将该账号填入这个字段即可。\n\n 4. /etc/gshadow\n\n> 用户组口令都不咋用，这个文件的存在感也比较弱......\n\n# 1.2.2 用户管理相关命令\n\nlinux 提供了一组用户账号和用户组管理命令对账号进行新增、 移除与更改\n\n 1. 用户管理命令\n\n>  * useradd：新建用户\n>    \n>    useradd [options] [username]\n>    \n> \n>  * passwd：设置或修改用户的口令和口令属性\n>    \n>    passwd [options] [username]\n>    \n> \n>  * usermod：user modify 修改用户的属性\n>    \n>    usermod [options] [username]\n>    \n> \n>  * userdel：user delete 删除指定用户账号\n>    \n>    userdel [options] [username]\n>    \n> \n>  * su：切换用户身份；exit 退出超级用户\n>    \n>    su [options] [username]\n>    \n\n 2. 用户组管理命令\n\n>  * groupadd：添加用户组\n>    \n>    groupadd [options] [groupname]\n>    \n> \n>  * groupmod：修改用户组属性\n>    \n>    groupmod [options] [groupname]\n>    \n> \n>  * groupdel：删除指定用户组\n>    \n>    groupdel [options] [groupname]\n>    \n\n\n# 02 文件权限\n\nlinux 系统中文件有第一节中的三种访问角色 owner/group/others，对于文件这三种身份还各有 read/write/execute 三种访问权限。通过这三种角色和访问权限控制可以到来 linux 系统的如下优势：\n\n * 系统保护：关于系统服务的文件通常只有 root 角色能访问，可以有效保护系统中的重要文件。\n * 团队开发文件共享：通过设置用户组权限，让团队成员能够共享指定目录下的文件数据。\n\n\n# 2.1 文件属性\n\n在 linux 系统中进入任意目录，然后使用 ls 命令查看当前目录下文件的文件名与相关属性，也可以增加选项参数 ls -la 显示所有的文件详细的权限与属性。\n\n如上图所示，list 命令显示的内容中每一行即是一个文件的相关属性，每一条记录的 7 个字段含义如下：\n\n 1. 文件类型与权限\n\n> 文件类型与权限由 10 个字符构成：\n> \n> 第一个字符代表该文件的类型：\n> \n>  * [ d ] 表示目录\n>  * [ - ] 表示文件\n>  * [ l ] 表示链接\n>  * [ b ] 表示装置文件里面的可供储存的接口设备，即可随机存取装置\n>  * [ c ] 表示装置文件里面的串行端口设备，例如键盘、鼠标等一次性读取装置\n> \n> 剩下的 9 个字符，三个为一组分别表示 owner/group/others 三种角色的 read/write/execute 三种访问权限\n> \n> 权限对于文件的意义：\n> \n>  * r (read)：可读取此一文件的实际内容，如读取文本文件的文字内容等；\n>  * w (write)：可以编辑、新增或者是修改该文件的内容(但不含删除该文件)；\n>  * x (execute)：该文件具有可以被系统执行的权限。\n> \n> 权限对于目录的意义：\n> \n>  * r (read contents in directory)：表示具有读取目录结构列表的权限，即表示可以查询该目录下的文件名数据（ls 命令查看目录信息）。\n>  * w (modify contents of directory)：表示具有向目录写入内容的权限，即可以修改目录的结构列表。例如，创建新的文件或目录、删除文件或目录、修改文件或目录的名称、移动文件或目录到其他位置等。\n>  * x (access directory)：表示用户具有进入该目录成为工作目录的权限（cd 命令进入到目录中）。\n\n 2. 文件链接数\n\n> linux 文件系统 ext2 使用的是以 inode 为基础的文件系统，inode 的内容在记录文件的权限与相关属性，block 区块中才是记录文件实际内容的位置。\n> \n> 文件属性的这个字段就是记录的有多少不同的文件连结到相同的一个 inode 号码\n\n 3. 文件所有者\n\n> 表示文件或目录的所有者名称\n\n 4. 所属用户组\n\n> 表示文件或目录所属用户组的名称\n\n 5. 文件大小\n\n> 表示文件的容量大小，默认单位为字节 bytes\n\n 6. 时间戳\n\n> 记录文件的创建日期或者是最近的修改日期。\n> \n> 记录的时间一般为 月/日/时间 的形式，如果这个文件被修改的时间跨度过大，那么时间部分会仅显示年份。\n\n 7. 文件名称\n\n> 文件的名称，如果文件名以 .开头则说明他是隐藏文件\n\n\n# 2.2 文件属性修改命令\n\n文件属性的修改命令分别针对文件所有者和所属用户组有 chown, chgrp，文件权限修改命名则是 chmod\n\n * chown ：改变文件拥有者\n * chgrp ：改变文件所属群组\n * chmod ：改变文件的权限\n\n 1. chown\n\n> 文件在创建的时候就指定了文件所有者，当将文件复制或移动到其他用户目录下时，就需要变更文件的所有者了，因为复制操作会根据执行命令的用户确定拷贝的文件文件所有者。\n> \n> chown [options] [owner] [filename/directory]\n> \n> \n> 使用该命令修改目录时，可以通过添加 -r 选项进行递归的持续变更，即连同次目录下的所有文件都变更文件所有者。\n> \n> chown -r [owner] [irectory]\n> \n> \n> chown 目录还可以顺带修改用户组，使用冒号连接 用户:用户组 同时修改文件所有者和所属用户组。\n> \n> chown [options] [owner:group] [filename/directory]\n\n 2. chgrp\n\n> 仅修改文件所属的用户组可以使用 chgrp 命令实现，当然修改时要确保用户组是存在的。\n> \n> chgrp [options] [group] [filename/directory]\n> \n> \n> 如果要修改目录下所有文件的所属用户组，同样的使用 -r 参数进行递归的持续变更。\n> \n> chgrp -r [group] [directory]\n\n 3. chmod\n\n> 修改文件权限的命令则是 chmod，该命令可以通过数字类型和符号类型两种形式设定文件权限。\n> \n> 数字类型：\n> \n> linux 系统中 read/write/execute 三种访问权限分别对应的数字分数是：read(4), write(2), execute(1)\n> \n> 每个用户角色的权限可以用三种访问权限的数字分数累加结果表示，例如文件权限 -rwxr-x---的数字分数表示是 750：\n> \n> owner = rwx = 4+2+1 = 7\n> group = r-x = 4+0+1 = 5\n> others= --- = 0+0+0 = 0\n> \n> \n> 使用数字类型的 chmod 权限修改命令形式为：\n> \n> chmod [options] [number] [filename/directory]\n> # example:\n> chmod -r 770 /data/share\n> \n> \n> 符号类型：\n> \n> 另一种修改文件权限的方式就是使用符号类型，owner/group/others 三种角色对应的符号表示是：owner(u), group(g), others(o)，还有同时表示三种角色的符号：all(a)。read/write/execute 三种访问权限的符号表示是：read(r), write(w), execute(x)。\n> \n> 基于用户角色和文件权限的符号表示，使用符号 +, -, = 为不同的用户角色添加、除去和设定不同的文件权限：\n> \n> 命令      角色        操作      权限      对象\n> chmod   u/g/o/a   +/-/=   r/w/x   文件或目录\n> \n> 例如，要使用 chmod 命令设置文件所有者权限为可读、可写、可执行，所属用户组和其他用户具有可读与执行的权限，即 -rwxr-xr-x：\n> \n> chmod u=rwx,go=rx fliename\n> \n> \n> 如果又要除去其他用户的可读与执行的权限是，即 -rwxr-x--：\n> \n> chmod o-rx fliename\n\n\n# 03 命令与文件权限\n\n文件权限限制了用户对文件或目录进行读取/创建/删除/修改等操作，我们进一步理解这操作命令是怎么和文件和目录权限对应起来的。\n\n切换工作目录：\n\n * 可使用的命令：例如 cd 等变换工作目录的命令；\n * 目录所需权限：用户需要对该目录具有可执行权限 (x)；如果还需要查阅目录结构信息，用户还需要可读权限（r）。\n\n读取文件内容：\n\n * 可使用的命令：例如 cat，more，less，head，tail 等查阅命令\n * 目录所需权限：用户需要对工作目录（当前目录）具有可执行权限 (x)；\n * 文件所需权限：用户需要对该文件具有可读权限（r）；\n\n修改文件内容：\n\n * 可使用的命令：例如 echo+重定向符号，vim 等文件修改命令\n * 目录所需权限：用户需要对工作目录（当前目录）具有可执行权限 (x)；\n * 文件所需权限：用户需要对该文件具有可读、可写权限（r，w）；\n\n新建文件/目录：\n\n * 可使用的命令：例如 touch，mkdir 等文件或目录创建命令\n * 目录所需权限：用户需要对工作目录（当前目录）具有可执行权限 (x) 进入到该目录，还需要对工作目录具有可写权限 (w) 修改目录结构新建文件\n\n运行可执行文件：\n\n * 可使用的命令：例如 ./，bash 等文件执行命令\n * 目录所需权限：用户需要对工作目录（当前目录）具有可执行权限 (x)；\n * 文件所需权限：用户需要对该文件具有具有可执行权限 (x)；\n\n\n# 参考资料\n\n一篇读懂 linux 用户管理与操作\n\n鸟哥的 linux 私房菜 -- linux 的文件权限与目录配置-1\n\n鸟哥的 linux 私房菜 -- linux 的文件权限与目录配置-2\n\n鸟哥的 linux 私房菜 -- linux 账号管理-1\n\n鸟哥的 linux 私房菜 -- linux 账号管理-2\n\n鸟哥的 linux 私房菜 -- 文件与目录管理",charsets:{cjk:!0},lastUpdated:"2023/11/19, 12:55:48",lastUpdatedTimestamp:1700369748e3},{title:"Linux 命令行快捷键",frontmatter:{title:"Linux 命令行快捷键",date:"2023-07-14T23:20:14.000Z",permalink:"/pages/154d65/"},regularPath:"/04.Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/01.Linux%20%E5%9F%BA%E7%A1%80/06.Linux%20%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%BF%AB%E6%8D%B7%E9%94%AE.html",relativePath:"04.Linux操作系统编程/01.Linux 基础/06.Linux 命令行快捷键.md",key:"v-5501acb0",path:"/pages/154d65/",headers:[{level:2,title:"01 快速移动",slug:"_01-快速移动",normalizedTitle:"01 快速移动",charIndex:2},{level:2,title:"02 快捷执行",slug:"_02-快捷执行",normalizedTitle:"02 快捷执行",charIndex:111},{level:2,title:"03 高效编辑",slug:"_03-高效编辑",normalizedTitle:"03 高效编辑",charIndex:528},{level:2,title:"04 窗口管理",slug:"_04-窗口管理",normalizedTitle:"04 窗口管理",charIndex:843}],headersStr:"01 快速移动 02 快捷执行 03 高效编辑 04 窗口管理",content:"# 01 快速移动\n\n 1. ctrl + a ：光标迅速回到行首 ⭐️\n 2. ctrl + e ：光标迅速回到行尾 ⭐️\n 3. alt + f ：光标前进一个单词\n 4. alt + b ：光标后退一格单词\n\n\n# 02 快捷执行\n\n 1. history ：查看历史命令，按顺序全部显示出来，有对应的编号\n 2. !num ：执行history历史命令列表中第 num 条命令 ⭐️\n 3. !prefix：执行以 prefix 前缀开头的最新命令，例如执行 !cp 表示执行以 cp 开头的最新命令\n 4. !! ：执行上一条命令，最常用的场景就是执行一条命令发现需要 root 权限，那么直接使用 sudo !! 更加快捷\n 5. !$ ：重新使用上一个命令中的最后一项，这个使用场景通常出现在命令使用混淆，比如你要看某个目录但是使用了 cd 命令，这时直接使用 ls !$ 可以快捷修正\n 6. ctrl + r：搜索命令行使用过的历史命令记录 ⭐️\n 7. ctrl + g：从 ctrl+r 的搜索历史命令模式中退出\n 8. cd 命令 ：cd ~ 直接切换到用户目录；cd / 切换到根目录；cd - 切换到操作过的上一个目录\n\n\n# 03 高效编辑\n\n 1. ctrl + insert ：复制命令行内容\n 2. shift + insert ：粘贴命令行内容\n 3. ctrl + k ：剪切（删除）光标处到行尾的所有字符 ⭐️\n 4. ctrl + u ：剪切（删除）输入的所有字符 ⭐️\n 5. ctrl + w ：剪切（删除）光标前的一个字符\n 6. alt + d ：剪切（删除）光标后的一个字符\n 7. ctrl + y：与剪切对应，粘贴 ctrl+k、ctrl+u、ctrl+w 删除的字符 ⭐️\n 8. alt + u ：从当前字符开始的一个字符串，字母替换为大写\n 9. alt + c ：当前字符变为大写，向后的一个字符串全部变为小写\n\n\n# 04 窗口管理\n\n 1. ctrl + s ：锁定终端，任何人无法输入\n 2. ctrl + q ：退出 ctrl+s 的锁定状态\n 3. ctrl + c ：中断并杀死，程序终止\n 4. ctrl + z ：暂停在终端运行的任务，使用 fg 命令可以使暂停恢复 ⭐️\n 5. ctrl + l : 清空屏幕并重新显示当前命令行内容 ⭐️",normalizedContent:"# 01 快速移动\n\n 1. ctrl + a ：光标迅速回到行首 ⭐️\n 2. ctrl + e ：光标迅速回到行尾 ⭐️\n 3. alt + f ：光标前进一个单词\n 4. alt + b ：光标后退一格单词\n\n\n# 02 快捷执行\n\n 1. history ：查看历史命令，按顺序全部显示出来，有对应的编号\n 2. !num ：执行history历史命令列表中第 num 条命令 ⭐️\n 3. !prefix：执行以 prefix 前缀开头的最新命令，例如执行 !cp 表示执行以 cp 开头的最新命令\n 4. !! ：执行上一条命令，最常用的场景就是执行一条命令发现需要 root 权限，那么直接使用 sudo !! 更加快捷\n 5. !$ ：重新使用上一个命令中的最后一项，这个使用场景通常出现在命令使用混淆，比如你要看某个目录但是使用了 cd 命令，这时直接使用 ls !$ 可以快捷修正\n 6. ctrl + r：搜索命令行使用过的历史命令记录 ⭐️\n 7. ctrl + g：从 ctrl+r 的搜索历史命令模式中退出\n 8. cd 命令 ：cd ~ 直接切换到用户目录；cd / 切换到根目录；cd - 切换到操作过的上一个目录\n\n\n# 03 高效编辑\n\n 1. ctrl + insert ：复制命令行内容\n 2. shift + insert ：粘贴命令行内容\n 3. ctrl + k ：剪切（删除）光标处到行尾的所有字符 ⭐️\n 4. ctrl + u ：剪切（删除）输入的所有字符 ⭐️\n 5. ctrl + w ：剪切（删除）光标前的一个字符\n 6. alt + d ：剪切（删除）光标后的一个字符\n 7. ctrl + y：与剪切对应，粘贴 ctrl+k、ctrl+u、ctrl+w 删除的字符 ⭐️\n 8. alt + u ：从当前字符开始的一个字符串，字母替换为大写\n 9. alt + c ：当前字符变为大写，向后的一个字符串全部变为小写\n\n\n# 04 窗口管理\n\n 1. ctrl + s ：锁定终端，任何人无法输入\n 2. ctrl + q ：退出 ctrl+s 的锁定状态\n 3. ctrl + c ：中断并杀死，程序终止\n 4. ctrl + z ：暂停在终端运行的任务，使用 fg 命令可以使暂停恢复 ⭐️\n 5. ctrl + l : 清空屏幕并重新显示当前命令行内容 ⭐️",charsets:{cjk:!0},lastUpdated:"2023/11/19, 12:55:48",lastUpdatedTimestamp:1700369748e3},{title:"Vim常用技巧",frontmatter:{title:"Vim常用技巧",date:"2023-04-30T14:47:00.000Z",permalink:"/pages/875f14/"},regularPath:"/04.Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/02.Vim%20%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/00.Vim%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7.html",relativePath:"04.Linux操作系统编程/02.Vim 实用技巧/00.Vim常用技巧.md",key:"v-03606fac",path:"/pages/875f14/",headers:[{level:2,title:"Vim 全局替换",slug:"vim-全局替换",normalizedTitle:"vim 全局替换",charIndex:2},{level:2,title:"Vim 文本替换",slug:"vim-文本替换",normalizedTitle:"vim 文本替换",charIndex:290},{level:2,title:"Vim 多行同时操作",slug:"vim-多行同时操作",normalizedTitle:"vim 多行同时操作",charIndex:851},{level:2,title:"Vim 快捷删除括号内所有文本",slug:"vim-快捷删除括号内所有文本",normalizedTitle:"vim 快捷删除括号内所有文本",charIndex:1041},{level:2,title:"Vim 回到上一次编辑的位置",slug:"vim-回到上一次编辑的位置",normalizedTitle:"vim 回到上一次编辑的位置",charIndex:1096},{level:2,title:"Vim快速移动",slug:"vim快速移动",normalizedTitle:"vim快速移动",charIndex:1293}],headersStr:"Vim 全局替换 Vim 文本替换 Vim 多行同时操作 Vim 快捷删除括号内所有文本 Vim 回到上一次编辑的位置 Vim快速移动",content:"# Vim 全局替换\n\n语法为 :[addr]s/源字符串/目的字符串/[option]\n全局替换命令为：:%s/源字符串/目的字符串/g\n\n[addr] 表示检索范围，省略时表示当前行。\n如：“1，20” ：表示从第1行到20行；\n“%” ：表示整个文件，同“1,”；“.,” ：从当前行到文件尾；\n\ns : 表示替换操作\n\n[option] : 表示操作类型\n如：g 表示全局替换;\nc 表示进行确认\np 表示替代结果逐行显示（Ctrl + L恢复屏幕）；\n省略option时仅对每行第一个匹配串进行替换；\n如果在源字符串和目的字符串中出现特殊字符，需要用”\\”转义\n\n\n# Vim 文本替换\n\nVIM文本替换命令_@Turbo@的博客-CSDN博客\n\n替换命令的完整形式：:[range]s/src/dest/[flags]\n\n[range]\n\n> 不写range ：默认为光标所在的行。 . ：光标所在的行。 1 ：第一行。 $ ：最后一行。 33 ：第33行。 'a ：标记a所在的行（之前要使用ma做过标记）。 .+1 ：当前光标所在行的下面一行。 $-1 ：倒数第二行。（这里说明我们可以对某一行加减某个数值来取得相对的行）。 22,33 ：第22～33行。 1,$ ：第1行 到 最后一行。 1,. ：第1行 到 当前行。 .,$ ：当前行 到 最后一行。 'a,'b ：标记a所在的行 到 标记b所在的行。 % ：所有行（与 1,$ 等价）。 ?chapter? ：从当前位置向上搜索，找到的第一个chapter所在的行。其中chapter可以是任何字符串或者正则表达式。 /chapter/ ：从当前位置向下搜索，找到的第一个chapter所在的行。其中chapter可以是任何字符串或者正则表达式。\n\n[flags]\n\n> 无 ：只对指定范围内的第一个匹配项进行替换。 g ：对指定范围内的所有匹配项进行替换。 c ：在替换前请求用户确认。 e ：忽略执行过程中的错误。\n\n\n# Vim 多行同时操作\n\n首先，在VIM的命令行模式下，按 Ctrl + v 即可进入区块模式。用方向键可以选择需要操作的文本区域。该模式下常用于多行的文本增删操作，如Tab、注释等\n\n操作\n\n * 多行复制、粘贴：按y复制，按p粘贴\n\n * 多行插入：按I（大写i）进入插入模式\n\n * 多行删除：按d即可\n\n * 多行替换：按s即可\n\n操作完毕即可按Esc退出区块模式\n\n\n# Vim 快捷删除括号内所有文本\n\n选中\",(,[,{左括弧\n\n输入命令di+\",(,[,{其中的字符\n\n\n# Vim 回到上一次编辑的位置\n\n有些时候，我们需要快速回到上次打开文件的位置，下面是两种不同场景下的实现方式：\n\n 1. 已经打开上次编辑的文件，需要回到上次编辑的位置，可以直接使用命令gi\n\n 2. 已经打开上次编辑的文件，但是要打开更早编辑的文件，可以使用命令^Coo\n\n即按住 Ctrl+o，这条命令可以重复使用，打开更多历史编辑过的文件。\n\nCtrl+i，是上诉命令的方向操作\n\n\n# Vim快速移动\n\nhttps://zhuanlan.zhihu.com/p/30132173",normalizedContent:"# vim 全局替换\n\n语法为 :[addr]s/源字符串/目的字符串/[option]\n全局替换命令为：:%s/源字符串/目的字符串/g\n\n[addr] 表示检索范围，省略时表示当前行。\n如：“1，20” ：表示从第1行到20行；\n“%” ：表示整个文件，同“1,”；“.,” ：从当前行到文件尾；\n\ns : 表示替换操作\n\n[option] : 表示操作类型\n如：g 表示全局替换;\nc 表示进行确认\np 表示替代结果逐行显示（ctrl + l恢复屏幕）；\n省略option时仅对每行第一个匹配串进行替换；\n如果在源字符串和目的字符串中出现特殊字符，需要用”\\”转义\n\n\n# vim 文本替换\n\nvim文本替换命令_@turbo@的博客-csdn博客\n\n替换命令的完整形式：:[range]s/src/dest/[flags]\n\n[range]\n\n> 不写range ：默认为光标所在的行。 . ：光标所在的行。 1 ：第一行。 $ ：最后一行。 33 ：第33行。 'a ：标记a所在的行（之前要使用ma做过标记）。 .+1 ：当前光标所在行的下面一行。 $-1 ：倒数第二行。（这里说明我们可以对某一行加减某个数值来取得相对的行）。 22,33 ：第22～33行。 1,$ ：第1行 到 最后一行。 1,. ：第1行 到 当前行。 .,$ ：当前行 到 最后一行。 'a,'b ：标记a所在的行 到 标记b所在的行。 % ：所有行（与 1,$ 等价）。 ?chapter? ：从当前位置向上搜索，找到的第一个chapter所在的行。其中chapter可以是任何字符串或者正则表达式。 /chapter/ ：从当前位置向下搜索，找到的第一个chapter所在的行。其中chapter可以是任何字符串或者正则表达式。\n\n[flags]\n\n> 无 ：只对指定范围内的第一个匹配项进行替换。 g ：对指定范围内的所有匹配项进行替换。 c ：在替换前请求用户确认。 e ：忽略执行过程中的错误。\n\n\n# vim 多行同时操作\n\n首先，在vim的命令行模式下，按 ctrl + v 即可进入区块模式。用方向键可以选择需要操作的文本区域。该模式下常用于多行的文本增删操作，如tab、注释等\n\n操作\n\n * 多行复制、粘贴：按y复制，按p粘贴\n\n * 多行插入：按i（大写i）进入插入模式\n\n * 多行删除：按d即可\n\n * 多行替换：按s即可\n\n操作完毕即可按esc退出区块模式\n\n\n# vim 快捷删除括号内所有文本\n\n选中\",(,[,{左括弧\n\n输入命令di+\",(,[,{其中的字符\n\n\n# vim 回到上一次编辑的位置\n\n有些时候，我们需要快速回到上次打开文件的位置，下面是两种不同场景下的实现方式：\n\n 1. 已经打开上次编辑的文件，需要回到上次编辑的位置，可以直接使用命令gi\n\n 2. 已经打开上次编辑的文件，但是要打开更早编辑的文件，可以使用命令^coo\n\n即按住 ctrl+o，这条命令可以重复使用，打开更多历史编辑过的文件。\n\nctrl+i，是上诉命令的方向操作\n\n\n# vim快速移动\n\nhttps://zhuanlan.zhihu.com/p/30132173",charsets:{cjk:!0},lastUpdated:"2023/11/19, 12:55:48",lastUpdatedTimestamp:1700369748e3},{title:"Vim插入模式",frontmatter:{title:"Vim插入模式",date:"2023-04-30T14:47:00.000Z",permalink:"/pages/aab584/"},regularPath:"/04.Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/02.Vim%20%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/03.Vim%E6%8F%92%E5%85%A5%E6%A8%A1%E5%BC%8F.html",relativePath:"04.Linux操作系统编程/02.Vim 实用技巧/03.Vim插入模式.md",key:"v-3b3a9bf2",path:"/pages/aab584/",headers:[{level:2,title:"插入模式",slug:"插入模式",normalizedTitle:"插入模式",charIndex:2},{level:3,title:"技巧13 插入模式中更正输入错误",slug:"技巧13-插入模式中更正输入错误",normalizedTitle:"技巧13 插入模式中更正输入错误",charIndex:11},{level:3,title:"技巧14 返回普通模式",slug:"技巧14-返回普通模式",normalizedTitle:"技巧14 返回普通模式",charIndex:166},{level:3,title:"技巧15 不离开插入模式，粘贴寄存器中的文本",slug:"技巧15-不离开插入模式-粘贴寄存器中的文本",normalizedTitle:"技巧15 不离开插入模式，粘贴寄存器中的文本",charIndex:368},{level:3,title:"技巧16 使用表达式寄存器随时随地做运算",slug:"技巧16-使用表达式寄存器随时随地做运算",normalizedTitle:"技巧16 使用表达式寄存器随时随地做运算",charIndex:653},{level:3,title:"技巧17 用字符编码插入不常用字符",slug:"技巧17-用字符编码插入不常用字符",normalizedTitle:"技巧17 用字符编码插入不常用字符",charIndex:920},{level:3,title:"技巧19 用替换模式替换以后文本",slug:"技巧19-用替换模式替换以后文本",normalizedTitle:"技巧19 用替换模式替换以后文本",charIndex:1195}],headersStr:"插入模式 技巧13 插入模式中更正输入错误 技巧14 返回普通模式 技巧15 不离开插入模式，粘贴寄存器中的文本 技巧16 使用表达式寄存器随时随地做运算 技巧17 用字符编码插入不常用字符 技巧19 用替换模式替换以后文本",content:"# 插入模式\n\n\n# 技巧13 插入模式中更正输入错误\n\n插入模式中一些删除操作\n\n在输入内容时发现输入错误时，一般会用到退格键删除内容并修改，除了这一方式外也可以用到一些通用快捷键来完成删除操作。\n\n快捷键      作用\nCtrl+h   删除前一个字符\nCtrl+w   删除前一个单词\nCtrl+u   删除至行首\n\n\n# 技巧14 返回普通模式\n\n切换回普通模式\n\n插入模式仅仅专注一件事，那就是输入文字，在频繁的模式切换中提高速度将极大提高效率。切换回普通模式可以使用<Esc>或者Ctrl+[两种方式，除此之外，当你不需要使用复杂的操作命令是也可以使用插入-普通模式来完成单次操作命令的使用。使用Ctrl+o可以从插入模式切换到插入-普通模式，在这种模式中可以支持执行一次操作命令，执行完成后自动返回到插入模式。\n\n\n# 技巧15 不离开插入模式，粘贴寄存器中的文本\n\n使用Ctrl+r+{register}命令粘贴面向字符的寄存器中内容\n\n在插入模式中，可以使用Ctrl+r+{register}命令方便的粘贴几个单词，{register}的内容是寄存器的编号0、1、2...如果想粘贴多个文本行，切换到普通模式使用一些粘贴命令操作效率会更高。\n\n使用示例\n\n例如，想将Hello, world!逗号前的内容复制粘贴到下一行末尾，可以先使用命令yt,将Hello复制到寄存器中，然后使用jA命令进入插入模式，最后使用Ctrl+r+0将寄存器中的文本在插入模式下复制到光标所在位置。\n\n\n# 技巧16 使用表达式寄存器随时随地做运算\n\n表达式寄存器\n\nVim中有许多寄存器，它们能够作为复制内容的暂存区，也有可以作为计算器的寄存器那就是表达式寄存器。表达式寄存器的{register}符号是=，在插入模式中使用Ctrl+r+=就可以访问这一寄存器，然后输入表达式，最后敲下回车键就可以得到表达式的计算结果。\n\n使用示例\n\n例如，在6 chairs, each costing $35, totals $中需要计算总价格时，可以使用Ctrl r = 6*35 Enter命令完成计算并得到totals $210的结果。\n\n\n# 技巧17 用字符编码插入不常用字符\n\nVim可以用字符编码插入任意字符，在插入模式中使用Ctrl v {code}完成任意字符的插入，其中code是插入字符的编码它的一些表示方式如下表所示。\n\n命令                      作用\nCtrl v 123              以十进制字符编码插入字符\nCtrl v u123             以十六进制字符编码插入字符\nCtrl v {非数字}            按原意插入非数字字符\nCtrl k {char1}{char2}   插入以二合字母表示的字符\n\n\n# 技巧19 用替换模式替换以后文本\n\n替换模式\n\n使用R命令可以切换到替换模式，在替换模式中输入内容会逐一替换文档中已存在的文本内容。\n\n使用示例\n\n例如，想将文本Hello, world!修改为Hello World!，可以先使用f,命令将光标移动到逗号下，然后使用R命令进入替换模式，并输入{space}{space}W两个空格和大写W将, w替换完成修改工作。",normalizedContent:"# 插入模式\n\n\n# 技巧13 插入模式中更正输入错误\n\n插入模式中一些删除操作\n\n在输入内容时发现输入错误时，一般会用到退格键删除内容并修改，除了这一方式外也可以用到一些通用快捷键来完成删除操作。\n\n快捷键      作用\nctrl+h   删除前一个字符\nctrl+w   删除前一个单词\nctrl+u   删除至行首\n\n\n# 技巧14 返回普通模式\n\n切换回普通模式\n\n插入模式仅仅专注一件事，那就是输入文字，在频繁的模式切换中提高速度将极大提高效率。切换回普通模式可以使用<esc>或者ctrl+[两种方式，除此之外，当你不需要使用复杂的操作命令是也可以使用插入-普通模式来完成单次操作命令的使用。使用ctrl+o可以从插入模式切换到插入-普通模式，在这种模式中可以支持执行一次操作命令，执行完成后自动返回到插入模式。\n\n\n# 技巧15 不离开插入模式，粘贴寄存器中的文本\n\n使用ctrl+r+{register}命令粘贴面向字符的寄存器中内容\n\n在插入模式中，可以使用ctrl+r+{register}命令方便的粘贴几个单词，{register}的内容是寄存器的编号0、1、2...如果想粘贴多个文本行，切换到普通模式使用一些粘贴命令操作效率会更高。\n\n使用示例\n\n例如，想将hello, world!逗号前的内容复制粘贴到下一行末尾，可以先使用命令yt,将hello复制到寄存器中，然后使用ja命令进入插入模式，最后使用ctrl+r+0将寄存器中的文本在插入模式下复制到光标所在位置。\n\n\n# 技巧16 使用表达式寄存器随时随地做运算\n\n表达式寄存器\n\nvim中有许多寄存器，它们能够作为复制内容的暂存区，也有可以作为计算器的寄存器那就是表达式寄存器。表达式寄存器的{register}符号是=，在插入模式中使用ctrl+r+=就可以访问这一寄存器，然后输入表达式，最后敲下回车键就可以得到表达式的计算结果。\n\n使用示例\n\n例如，在6 chairs, each costing $35, totals $中需要计算总价格时，可以使用ctrl r = 6*35 enter命令完成计算并得到totals $210的结果。\n\n\n# 技巧17 用字符编码插入不常用字符\n\nvim可以用字符编码插入任意字符，在插入模式中使用ctrl v {code}完成任意字符的插入，其中code是插入字符的编码它的一些表示方式如下表所示。\n\n命令                      作用\nctrl v 123              以十进制字符编码插入字符\nctrl v u123             以十六进制字符编码插入字符\nctrl v {非数字}            按原意插入非数字字符\nctrl k {char1}{char2}   插入以二合字母表示的字符\n\n\n# 技巧19 用替换模式替换以后文本\n\n替换模式\n\n使用r命令可以切换到替换模式，在替换模式中输入内容会逐一替换文档中已存在的文本内容。\n\n使用示例\n\n例如，想将文本hello, world!修改为hello world!，可以先使用f,命令将光标移动到逗号下，然后使用r命令进入替换模式，并输入{space}{space}w两个空格和大写w将, w替换完成修改工作。",charsets:{cjk:!0},lastUpdated:"2023/11/19, 12:55:48",lastUpdatedTimestamp:1700369748e3},{title:"Vim普通模式",frontmatter:{title:"Vim普通模式",date:"2023-04-30T14:47:00.000Z",permalink:"/pages/7fbd14/"},regularPath:"/04.Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/02.Vim%20%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/02.Vim%E6%99%AE%E9%80%9A%E6%A8%A1%E5%BC%8F.html",relativePath:"04.Linux操作系统编程/02.Vim 实用技巧/02.Vim普通模式.md",key:"v-3dd5939c",path:"/pages/7fbd14/",headers:[{level:2,title:"普通模式",slug:"普通模式",normalizedTitle:"普通模式",charIndex:2},{level:3,title:"技巧7 停顿时请移开画笔",slug:"技巧7-停顿时请移开画笔",normalizedTitle:"技巧7 停顿时请移开画笔",charIndex:49},{level:3,title:"技巧8 把撤销单元切成块",slug:"技巧8-把撤销单元切成块",normalizedTitle:"技巧8 把撤销单元切成块",charIndex:171},{level:3,title:"技巧9 构造可重复的修改",slug:"技巧9-构造可重复的修改",normalizedTitle:"技巧9 构造可重复的修改",charIndex:540},{level:3,title:"技巧10 用次数做简单的算术运算",slug:"技巧10-用次数做简单的算术运算",normalizedTitle:"技巧10 用次数做简单的算术运算",charIndex:959},{level:3,title:"技巧11 能够重复就不用次数",slug:"技巧11-能够重复就不用次数",normalizedTitle:"技巧11 能够重复就不用次数",charIndex:1052},{level:3,title:"技巧12 操作符 + 动作命令 = 操作",slug:"技巧12-操作符-动作命令-操作",normalizedTitle:"技巧12 操作符 + 动作命令 = 操作",charIndex:1497}],headersStr:"普通模式 技巧7 停顿时请移开画笔 技巧8 把撤销单元切成块 技巧9 构造可重复的修改 技巧10 用次数做简单的算术运算 技巧11 能够重复就不用次数 技巧12 操作符 + 动作命令 = 操作",content:"# 普通模式\n\nVim普通模式的强大，很大程度上源于它可以把操作符与动作命令结合在一起。\n\n\n# 技巧7 停顿时请移开画笔\n\n程序员与画家\n\n程序员的编程过程和画家的画画过程类比，程序员往往只花一小部分时间编写代码，而绝大多数时间是在思考、阅读，以及在代码中穿梭浏览。而且即使是要修改内容也可以通过普通模式下的各种工具完成修改工作。\n\n\n# 技巧8 把撤销单元切成块\n\n停顿是自然断点\n\nu命令可以撤销最近一次修改，而这个修改可以包括普通模式、可视模式以及命令行模式中促发的命令，当命令触发了插入模式时，这次修改也将包括在插入模式中输入的文本内容。这种相对广泛的修改的定义，让我们能够自己控制一次撤销操作的细粒度，在Vim中从插入模式开始到返回普通模式为止，在此期间的修改内容被视为一次修改，因此对撤销操作细粒度的控制在于返回普通模式的<ESC>键的使用。那么，多久进行一次修改内容保存构成一个撤销块成为一个关键问题。通常，在编写过程中的每次停顿便是一个最好的自然断点，例如每写完一句话，在思考下一句时就可以离开插入模式，当需要继续写的时候A命令返回插入模式继续编写。\n\n当你想控制更细粒度的撤销操作时，可以考虑使用<ESC>o完成<Enter>键完成的另起一行的工作。\n\n\n# 技巧9 构造可重复的修改\n\nVimGolf\n\n在Vim中完成一件事可以有很多种方式，用于评估这些方式的效率的指标是方式所需按键次数最少(VimGolf)。而最有效率的事件完成方式，很大程度上便于我们构造可重复的修改，可以充分利用.命令提高效率。\n\n使用示例\n\n例如，想要删除行尾的一个单词时，首先可以想到反向删除，使用db命令删除从光标开始到单词开头的内容，但是这会留下单词的开头字母还需要使用x命令删除它。正向删除首先使用b命令将光标移动到单词开头，然后使用dw命令删除整个单词。删除整个单词，使用更为精确的aw命令寻找文本对象，当光标停留在对应单词上时，使用daw命令删除整个单词。\n\n这三种方式都可以完成删除一个单词的工作，但是存在重复操作情况是，使用.命令它们效率的差别就会显现，dbx方式仅会重复x命令，bdw方式仅会重复dw命令且无法移动光标，daw方式则不需要考虑光标位置使用.命令可以完全重复删除整个单词的工作。\n\n\n# 技巧10 用次数做简单的算术运算\n\n指定执行次数\n\n大多数普通模式命令可以在执行时指定次数，可以利用这一功能来做简单的算术运算，使用Ctrl+a/x命令分别对数字执行加减操作。\n\n\n# 技巧11 能够重复就不用次数\n\n什么情况下使用次数\n\n使用次数执行命令的特点在于它能够保留一个连贯的撤销历史记录，一个u命令就可以撤销整个修改。但是这也带来一个问题，它无法提供更加细粒度的操作，降低了修改的灵活性，重复命令.可以提高操作的灵活性。所以在不需要重复操作的使用场景下次数效率更高。\n\n使用示例\n\n例如，当需要删除一个文本行中的多个单词时，这种场景下可以为dw命令加上次数前缀3dw完成从光标开始连续删除3个单词；也可以使用dw命令触发单词删除操作之后使用3次.命令重复删除操作。前面已经提到，这两种方式的区别在于后者可以提供更加细粒度的操作，当出现次数判断错误时，撤销次数执行会回到最原始的状态，使用重复操作可以提供更灵活的撤销重复操作。\n\n当需要修改一个文本行中的多个单词时，这种情况下单词内容不同导致使用重复操作的作用很小，而次数操作的优势就得以显现，例如文本行one two three可以使用3cw+four three two<Esc>一次操作完成内容修改。\n\n\n# 技巧12 操作符 + 动作命令 = 操作\n\nVim的词汇\n\n操作符和动作命令的结合形成了一种语法，操作符确定执行的操作，动作命令确定操作符作用的范围形成一个完整的操作。例如d{motion}可以是删除一个字符的dl命令、可以是删除一个完整单词的daw命令、也可以是删除一整个段落的dap命令。一些常见的操作符如下表所示。\n\n命令   操作\nc    修改\nd    删除\ny    复制\ng~   反转大小写\ngu   转换为小写\ngU   转换为大写\n>    增加缩进\n<    减少缩进\n=    自动缩进\n!    过滤跨越的行\n\nVim的语法只有一条额外的规则，即当一个操作符命令被连续调用两次是，表示该操作的作用范围是当前行。例如dd是删除当前行，yy是复制当前行，>>缩进当前行等。",normalizedContent:"# 普通模式\n\nvim普通模式的强大，很大程度上源于它可以把操作符与动作命令结合在一起。\n\n\n# 技巧7 停顿时请移开画笔\n\n程序员与画家\n\n程序员的编程过程和画家的画画过程类比，程序员往往只花一小部分时间编写代码，而绝大多数时间是在思考、阅读，以及在代码中穿梭浏览。而且即使是要修改内容也可以通过普通模式下的各种工具完成修改工作。\n\n\n# 技巧8 把撤销单元切成块\n\n停顿是自然断点\n\nu命令可以撤销最近一次修改，而这个修改可以包括普通模式、可视模式以及命令行模式中促发的命令，当命令触发了插入模式时，这次修改也将包括在插入模式中输入的文本内容。这种相对广泛的修改的定义，让我们能够自己控制一次撤销操作的细粒度，在vim中从插入模式开始到返回普通模式为止，在此期间的修改内容被视为一次修改，因此对撤销操作细粒度的控制在于返回普通模式的<esc>键的使用。那么，多久进行一次修改内容保存构成一个撤销块成为一个关键问题。通常，在编写过程中的每次停顿便是一个最好的自然断点，例如每写完一句话，在思考下一句时就可以离开插入模式，当需要继续写的时候a命令返回插入模式继续编写。\n\n当你想控制更细粒度的撤销操作时，可以考虑使用<esc>o完成<enter>键完成的另起一行的工作。\n\n\n# 技巧9 构造可重复的修改\n\nvimgolf\n\n在vim中完成一件事可以有很多种方式，用于评估这些方式的效率的指标是方式所需按键次数最少(vimgolf)。而最有效率的事件完成方式，很大程度上便于我们构造可重复的修改，可以充分利用.命令提高效率。\n\n使用示例\n\n例如，想要删除行尾的一个单词时，首先可以想到反向删除，使用db命令删除从光标开始到单词开头的内容，但是这会留下单词的开头字母还需要使用x命令删除它。正向删除首先使用b命令将光标移动到单词开头，然后使用dw命令删除整个单词。删除整个单词，使用更为精确的aw命令寻找文本对象，当光标停留在对应单词上时，使用daw命令删除整个单词。\n\n这三种方式都可以完成删除一个单词的工作，但是存在重复操作情况是，使用.命令它们效率的差别就会显现，dbx方式仅会重复x命令，bdw方式仅会重复dw命令且无法移动光标，daw方式则不需要考虑光标位置使用.命令可以完全重复删除整个单词的工作。\n\n\n# 技巧10 用次数做简单的算术运算\n\n指定执行次数\n\n大多数普通模式命令可以在执行时指定次数，可以利用这一功能来做简单的算术运算，使用ctrl+a/x命令分别对数字执行加减操作。\n\n\n# 技巧11 能够重复就不用次数\n\n什么情况下使用次数\n\n使用次数执行命令的特点在于它能够保留一个连贯的撤销历史记录，一个u命令就可以撤销整个修改。但是这也带来一个问题，它无法提供更加细粒度的操作，降低了修改的灵活性，重复命令.可以提高操作的灵活性。所以在不需要重复操作的使用场景下次数效率更高。\n\n使用示例\n\n例如，当需要删除一个文本行中的多个单词时，这种场景下可以为dw命令加上次数前缀3dw完成从光标开始连续删除3个单词；也可以使用dw命令触发单词删除操作之后使用3次.命令重复删除操作。前面已经提到，这两种方式的区别在于后者可以提供更加细粒度的操作，当出现次数判断错误时，撤销次数执行会回到最原始的状态，使用重复操作可以提供更灵活的撤销重复操作。\n\n当需要修改一个文本行中的多个单词时，这种情况下单词内容不同导致使用重复操作的作用很小，而次数操作的优势就得以显现，例如文本行one two three可以使用3cw+four three two<esc>一次操作完成内容修改。\n\n\n# 技巧12 操作符 + 动作命令 = 操作\n\nvim的词汇\n\n操作符和动作命令的结合形成了一种语法，操作符确定执行的操作，动作命令确定操作符作用的范围形成一个完整的操作。例如d{motion}可以是删除一个字符的dl命令、可以是删除一个完整单词的daw命令、也可以是删除一整个段落的dap命令。一些常见的操作符如下表所示。\n\n命令   操作\nc    修改\nd    删除\ny    复制\ng~   反转大小写\ngu   转换为小写\ngu   转换为大写\n>    增加缩进\n<    减少缩进\n=    自动缩进\n!    过滤跨越的行\n\nvim的语法只有一条额外的规则，即当一个操作符命令被连续调用两次是，表示该操作的作用范围是当前行。例如dd是删除当前行，yy是复制当前行，>>缩进当前行等。",charsets:{cjk:!0},lastUpdated:"2023/11/19, 12:55:48",lastUpdatedTimestamp:1700369748e3},{title:"Vim解决问题的方式",frontmatter:{title:"Vim解决问题的方式",date:"2023-04-30T14:47:00.000Z",permalink:"/pages/dfff1a/"},regularPath:"/04.Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/02.Vim%20%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/01.Vim%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98%E7%9A%84%E6%96%B9%E5%BC%8F.html",relativePath:"04.Linux操作系统编程/02.Vim 实用技巧/01.Vim解决问题的方式.md",key:"v-6e30d232",path:"/pages/dfff1a/",headers:[{level:2,title:"Vim解决问题的方式",slug:"vim解决问题的方式",normalizedTitle:"vim解决问题的方式",charIndex:2},{level:3,title:"技巧1 . 命令",slug:"技巧1-命令",normalizedTitle:"技巧1 . 命令",charIndex:96},{level:3,title:"技巧2 不要自我重复",slug:"技巧2-不要自我重复",normalizedTitle:"技巧2 不要自我重复",charIndex:273},{level:3,title:"技巧3 以退为进",slug:"技巧3-以退为进",normalizedTitle:"技巧3 以退为进",charIndex:699},{level:3,title:"技巧4 重复与回退",slug:"技巧4-重复与回退",normalizedTitle:"技巧4 重复与回退",charIndex:1e3},{level:3,title:"技巧5 查找并手动替换",slug:"技巧5-查找并手动替换",normalizedTitle:"技巧5 查找并手动替换",charIndex:1465},{level:3,title:"技巧6 ·命令范式",slug:"技巧6-·命令范式",normalizedTitle:"技巧6 ·命令范式",charIndex:1984}],headersStr:"Vim解决问题的方式 技巧1 . 命令 技巧2 不要自我重复 技巧3 以退为进 技巧4 重复与回退 技巧5 查找并手动替换 技巧6 ·命令范式",content:'# Vim解决问题的方式\n\nVim的特点在于它能够高效的简化工作中的重复内容，成倍的节省时间。而它能够高效的重复是应为它能够记录最近的操作，让使用者可以用一次按键就能重复上次的修改。\n\n\n# 技巧1 . 命令\n\n. 命令的作用\n\n.命令实现的是重复上一次修改，而修改内容可以指代很多东西，一次修改的单位可以是字符、整行，甚至是整个文件。\n\n使用示例\n\n例如字符删除命令x、文本行删除命令dd都可以配合.命令来重复操作，而文档缩进命令>配合到文档末尾处命令G实现从当前行到末尾行整体的缩进，这种对文档整体操作的命令也可以通过.命令来重复。\n\n\n# 技巧2 不要自我重复\n\n避免自我重复\n\n在合适的使用场景中，尽量使用复合的单键命令来代替其等效的长命令，然后配合·命令可以极大提高效率。一些常用的符合命令如下表。\n\n复合命令   等效的长命令   复合命令   等效的长命令\nC      c$       A      $a\ns      cl       o      A\nS      ^c       O      ko\nI      ^i              \n\n使用示例\n\n例如在代码中需要为每一行末尾添加;，首先想到的是可以使用$命令将光标移动到行末，然后使用a命令在当前光标之后添加分号后退出编辑模式。接下来就使用j命令移动到下一行并在此使用$命令移动到行末然后使用.命令重复a;<Esc>这三步动作。\n\n显然，在上述的重复过程中，移动过程较为繁琐，为了减少这无关的移动可以使用在当前行末尾添加内容的A命令来代替a命令，这样就可以简化重复过程中的移动不需要再使用$命令。\n\n\n# 技巧3 以退为进\n\n替换操作\n\n当需要对某个字符或单词进行替换时，考虑在全文都进行替换的情况下就要进行重复操作，那就要使得修改和移动都可以重复。vim中的实现可以使用替换字符串的s命令配合·命令使得修改操作可重复，然后使用查找下一处指定字符位置的f{char}命令配合用于重复上次f命令操作的;命令使得移动可重复，将他们合二为一便可以简化替换操作。\n\n使用示例\n\n例如要在printf("%d+%d+%d=%d",a,b,c,a+b+c);代码中将+替换成前后带空格的+。首先需要使用f+命令找到+号的位置，然后使用s命令替换内容并退出编辑模式，这样就可以使用;.的组合命令完成重复替换操作。\n\n\n# 技巧4 重复与回退\n\n可重复的操作以及如何回退\n\n在使用可重复操作进行重复性工作时可能出现命令使用错误导致的错误操作，这时候就需要回退到上一步操作，一般可重复的操作都是可以回退的，它们都是成对出现的，一些可重复的操作和其回退方式如下表所示。\n\n含义             操作                重复命令   回退命令\n做出一个修改         {edit}            .      u\n文本行内查找下一指定字符   f{char}/t{char}   ;      ,\n文本行内查找上一指定字符   F{char}/T{char}   ;      ,\n文档内查找下一处匹配项    /{pattern}        n      N\n文档内查找上一处匹配项    ?{pattern}        n      N\n替换             s{replacements}   &      u\n执行一系列修改        qx{changes}q      @x     u\n\n\n# 技巧5 查找并手动替换\n\n无输入的查找命令\n\n前面已经提到文本行内字符查找可以使用f{char}/t{char}等命令，文档内的匹配项查找可以使用查找提示符/命令并输入完整的目标匹配项进行查找/pattern。除了这些方法，还可以使用*命令实现无输入的查找，只需要将光标移到目标匹配项上然后按下*键。使用*命令会产生两个结果，一是光标会从当前匹配项跳到下一个匹配项，二是文档中所有的匹配项都会高亮显示。和/查找提示符一样也可以使用n/N实现重复和回退。\n\n替换\n\n匹配项的替换无法使用s命令实现，但是也有对应的替换命令cw，使用该命令会删除从光标到单词结尾的所有字符，并进入插入模式。cw实现的替换操作和其他修改操作一样，vim编辑器会将从进入插入模式到离开的全部操作记录下来视为一次修改操作，可以使用·命令实现重复。\n\n使用示例\n\n例如要将文档中多个content替换为copy，首先将光标移动到任一content匹配项的开头，然后使用*命令查找所有匹配项。在第一个要修改的匹配项使用cw命令进行替换并退出插入模式。完成了查找和修改的可重复设定，就可以使用n/N命令来查找想要修改的匹配项，然后使用.重复修改操作完成替换任务。\n\n\n# 技巧6 ·命令范式\n\n一键移动 一键执行\n\n本章中所有提到的使用示例都是基于这种一键移动 一键执行的·命令范式实现的，让在文档中的光标移动可重复，然后让修改操作可重复，这样便是一个较为理想的重复工作解决方案，把繁琐的重复操作简化到一键移动 一键执行的范式。',normalizedContent:'# vim解决问题的方式\n\nvim的特点在于它能够高效的简化工作中的重复内容，成倍的节省时间。而它能够高效的重复是应为它能够记录最近的操作，让使用者可以用一次按键就能重复上次的修改。\n\n\n# 技巧1 . 命令\n\n. 命令的作用\n\n.命令实现的是重复上一次修改，而修改内容可以指代很多东西，一次修改的单位可以是字符、整行，甚至是整个文件。\n\n使用示例\n\n例如字符删除命令x、文本行删除命令dd都可以配合.命令来重复操作，而文档缩进命令>配合到文档末尾处命令g实现从当前行到末尾行整体的缩进，这种对文档整体操作的命令也可以通过.命令来重复。\n\n\n# 技巧2 不要自我重复\n\n避免自我重复\n\n在合适的使用场景中，尽量使用复合的单键命令来代替其等效的长命令，然后配合·命令可以极大提高效率。一些常用的符合命令如下表。\n\n复合命令   等效的长命令   复合命令   等效的长命令\nc      c$       a      $a\ns      cl       o      a\ns      ^c       o      ko\ni      ^i              \n\n使用示例\n\n例如在代码中需要为每一行末尾添加;，首先想到的是可以使用$命令将光标移动到行末，然后使用a命令在当前光标之后添加分号后退出编辑模式。接下来就使用j命令移动到下一行并在此使用$命令移动到行末然后使用.命令重复a;<esc>这三步动作。\n\n显然，在上述的重复过程中，移动过程较为繁琐，为了减少这无关的移动可以使用在当前行末尾添加内容的a命令来代替a命令，这样就可以简化重复过程中的移动不需要再使用$命令。\n\n\n# 技巧3 以退为进\n\n替换操作\n\n当需要对某个字符或单词进行替换时，考虑在全文都进行替换的情况下就要进行重复操作，那就要使得修改和移动都可以重复。vim中的实现可以使用替换字符串的s命令配合·命令使得修改操作可重复，然后使用查找下一处指定字符位置的f{char}命令配合用于重复上次f命令操作的;命令使得移动可重复，将他们合二为一便可以简化替换操作。\n\n使用示例\n\n例如要在printf("%d+%d+%d=%d",a,b,c,a+b+c);代码中将+替换成前后带空格的+。首先需要使用f+命令找到+号的位置，然后使用s命令替换内容并退出编辑模式，这样就可以使用;.的组合命令完成重复替换操作。\n\n\n# 技巧4 重复与回退\n\n可重复的操作以及如何回退\n\n在使用可重复操作进行重复性工作时可能出现命令使用错误导致的错误操作，这时候就需要回退到上一步操作，一般可重复的操作都是可以回退的，它们都是成对出现的，一些可重复的操作和其回退方式如下表所示。\n\n含义             操作                重复命令   回退命令\n做出一个修改         {edit}            .      u\n文本行内查找下一指定字符   f{char}/t{char}   ;      ,\n文本行内查找上一指定字符   f{char}/t{char}   ;      ,\n文档内查找下一处匹配项    /{pattern}        n      n\n文档内查找上一处匹配项    ?{pattern}        n      n\n替换             s{replacements}   &      u\n执行一系列修改        qx{changes}q      @x     u\n\n\n# 技巧5 查找并手动替换\n\n无输入的查找命令\n\n前面已经提到文本行内字符查找可以使用f{char}/t{char}等命令，文档内的匹配项查找可以使用查找提示符/命令并输入完整的目标匹配项进行查找/pattern。除了这些方法，还可以使用*命令实现无输入的查找，只需要将光标移到目标匹配项上然后按下*键。使用*命令会产生两个结果，一是光标会从当前匹配项跳到下一个匹配项，二是文档中所有的匹配项都会高亮显示。和/查找提示符一样也可以使用n/n实现重复和回退。\n\n替换\n\n匹配项的替换无法使用s命令实现，但是也有对应的替换命令cw，使用该命令会删除从光标到单词结尾的所有字符，并进入插入模式。cw实现的替换操作和其他修改操作一样，vim编辑器会将从进入插入模式到离开的全部操作记录下来视为一次修改操作，可以使用·命令实现重复。\n\n使用示例\n\n例如要将文档中多个content替换为copy，首先将光标移动到任一content匹配项的开头，然后使用*命令查找所有匹配项。在第一个要修改的匹配项使用cw命令进行替换并退出插入模式。完成了查找和修改的可重复设定，就可以使用n/n命令来查找想要修改的匹配项，然后使用.重复修改操作完成替换任务。\n\n\n# 技巧6 ·命令范式\n\n一键移动 一键执行\n\n本章中所有提到的使用示例都是基于这种一键移动 一键执行的·命令范式实现的，让在文档中的光标移动可重复，然后让修改操作可重复，这样便是一个较为理想的重复工作解决方案，把繁琐的重复操作简化到一键移动 一键执行的范式。',charsets:{cjk:!0},lastUpdated:"2023/11/19, 12:55:48",lastUpdatedTimestamp:1700369748e3},{title:"Vim可视模式",frontmatter:{title:"Vim可视模式",date:"2023-04-30T14:47:00.000Z",permalink:"/pages/2a0740/"},regularPath:"/04.Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/02.Vim%20%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/04.Vim%E5%8F%AF%E8%A7%86%E6%A8%A1%E5%BC%8F.html",relativePath:"04.Linux操作系统编程/02.Vim 实用技巧/04.Vim可视模式.md",key:"v-e354f03c",path:"/pages/2a0740/",headers:[{level:2,title:"可视模式",slug:"可视模式",normalizedTitle:"可视模式",charIndex:2},{level:3,title:"技巧20 深入理解可视模式",slug:"技巧20-深入理解可视模式",normalizedTitle:"技巧20 深入理解可视模式",charIndex:11},{level:3,title:"技巧21 选择高亮选区",slug:"技巧21-选择高亮选区",normalizedTitle:"技巧21 选择高亮选区",charIndex:395},{level:3,title:"技巧22 重复对高亮选区进行操作",slug:"技巧22-重复对高亮选区进行操作",normalizedTitle:"技巧22 重复对高亮选区进行操作",charIndex:710},{level:3,title:"技巧23 操作符命令优先级高于可视命令",slug:"技巧23-操作符命令优先级高于可视命令",normalizedTitle:"技巧23 操作符命令优先级高于可视命令",charIndex:899},{level:3,title:"技巧24-26 运用面向列块的可视模式",slug:"技巧24-26-运用面向列块的可视模式",normalizedTitle:"技巧24-26 运用面向列块的可视模式",charIndex:1096}],headersStr:"可视模式 技巧20 深入理解可视模式 技巧21 选择高亮选区 技巧22 重复对高亮选区进行操作 技巧23 操作符命令优先级高于可视命令 技巧24-26 运用面向列块的可视模式",content:"# 可视模式\n\n\n# 技巧20 深入理解可视模式\n\n“选区”操作\n\nVim的可视模式允许我们在自己选中的一个文本区域上进行操作，普通模式中的许多操作命令都可以在可视模式中生效，但是也存在一些操作上的细微变化。插入模式中有操作符+动作命令完成一个操作，可视模式中也是通过操作符确定操作类别，但是不是通过动作命令确定作用范围，而是与普通模式相反的逻辑，它先有了被选中的区域然后在使用操作符命令完成操作。\n\n使用示例\n\n例如，当需要将文本中的单词March替换成April时，一般情况下，我们会考虑使用退格键删除单词再输入新内容，或者鼠标双击选中单词再用退格键删除再添加内容。这一问题在可视模式下可以选择鼠标双击的处理逻辑，把光标移动到目标单词后，使用v命令进入可视模式，然后使用iw命令选中目标单词，然后使用c命令删除选中内容并切换到插入模式，接着就可以输入April完成修改操作了。\n\n\n# 技巧21 选择高亮选区\n\n可视模式的三种子模式\n\n可视模式有面向字符、面向行、面想列块三种子模式，它们可以分别用于处理不同类型的文本。从普通模式切换到这三种子模式的命令如下表所示。\n\n命令       用途\nv        进入面向字符的可视模式\nV        进入面向行的可视模式\nCtrl v   进入面向列块的可视模式\ngv       返回到上次的高亮选区\no        切换高亮选区的活动端\n\n其中的gv和o命令是可视模式的操作命令，gv命令撤销当前的高亮选区回退到上一个高亮选区，而o命令则是在构造高亮选区时可以更加灵活的控制活动端，当发现选区划分错误时，使用o命令改变活动端然后重新调整选区边界。\n\n\n# 技巧22 重复对高亮选区进行操作\n\n针对选区重复操作\n\n在可视模式中，每当执行以此操作命令之后，会被切换到普通模式下，如果想再次对该选区进行操作，避免重复划定选区可以使用gv命令直接回到相同范围的高亮选区。有些应用场景也可以使用·命令完成重复操作，例如想将一个文本块缩进多次，在可视模式下选择文本块之后使用>命令缩进一次文本块，之后可以直接使用·命令完成重复缩进任务。\n\n\n# 技巧23 操作符命令优先级高于可视命令\n\n能用操作符命令不用可视命令\n\n和数字前缀的次数命令与.命令之间的抉择一样，能用操作符命令完成的任务不用可视命令完成，因为在一键操作，一键移动的范式之中，操作符命令更易实践。可视命令中高亮选区的固定可能在一些操作中缺乏灵活性，导致在使用.命令重复操作时作用范围不能够灵活改变，而由操作符+动作命令完成的操作在作用范围上具有一定灵活性，更具优势。\n\n\n# 技巧24-26 运用面向列块的可视模式\n\n用面向列块的可视模式编辑表格数据\n\n例如，想要在三行内容中间为他们添加|符号，构成一个表格。先使用Ctrl v命令进入面向列块的可视模式，然后使用j/k命令划分列块选区，最后使用r|命令为三行内容都添加|符号。\n\none       1\ntow       2\nthree     3\n\n\n修改列文本\n\n例如，想要修改同列块中的相同内容，可以直接使用Ctrl v命令进入列块可视模式，然后使用h/l命令选择文本，再用j/k命令选择列块，然后使用c命令替换内容并输入新的内容，所有行的内容都会被同时修改。\n\n在长短不一的高亮块后添加文本\n\n例如，多行长短不一的代码都需要添加;，前面已经使用过A;然后使用j.一键移动，一键操作完成内容添加工作。这一工作使用列块可视模式可以更加方便的完成，使用Ctrl v进入可视模式，然后使用j/h以及移动至行尾$命令选中所有行末端文本，然后使用A;命令完成文本添加工作。",normalizedContent:"# 可视模式\n\n\n# 技巧20 深入理解可视模式\n\n“选区”操作\n\nvim的可视模式允许我们在自己选中的一个文本区域上进行操作，普通模式中的许多操作命令都可以在可视模式中生效，但是也存在一些操作上的细微变化。插入模式中有操作符+动作命令完成一个操作，可视模式中也是通过操作符确定操作类别，但是不是通过动作命令确定作用范围，而是与普通模式相反的逻辑，它先有了被选中的区域然后在使用操作符命令完成操作。\n\n使用示例\n\n例如，当需要将文本中的单词march替换成april时，一般情况下，我们会考虑使用退格键删除单词再输入新内容，或者鼠标双击选中单词再用退格键删除再添加内容。这一问题在可视模式下可以选择鼠标双击的处理逻辑，把光标移动到目标单词后，使用v命令进入可视模式，然后使用iw命令选中目标单词，然后使用c命令删除选中内容并切换到插入模式，接着就可以输入april完成修改操作了。\n\n\n# 技巧21 选择高亮选区\n\n可视模式的三种子模式\n\n可视模式有面向字符、面向行、面想列块三种子模式，它们可以分别用于处理不同类型的文本。从普通模式切换到这三种子模式的命令如下表所示。\n\n命令       用途\nv        进入面向字符的可视模式\nv        进入面向行的可视模式\nctrl v   进入面向列块的可视模式\ngv       返回到上次的高亮选区\no        切换高亮选区的活动端\n\n其中的gv和o命令是可视模式的操作命令，gv命令撤销当前的高亮选区回退到上一个高亮选区，而o命令则是在构造高亮选区时可以更加灵活的控制活动端，当发现选区划分错误时，使用o命令改变活动端然后重新调整选区边界。\n\n\n# 技巧22 重复对高亮选区进行操作\n\n针对选区重复操作\n\n在可视模式中，每当执行以此操作命令之后，会被切换到普通模式下，如果想再次对该选区进行操作，避免重复划定选区可以使用gv命令直接回到相同范围的高亮选区。有些应用场景也可以使用·命令完成重复操作，例如想将一个文本块缩进多次，在可视模式下选择文本块之后使用>命令缩进一次文本块，之后可以直接使用·命令完成重复缩进任务。\n\n\n# 技巧23 操作符命令优先级高于可视命令\n\n能用操作符命令不用可视命令\n\n和数字前缀的次数命令与.命令之间的抉择一样，能用操作符命令完成的任务不用可视命令完成，因为在一键操作，一键移动的范式之中，操作符命令更易实践。可视命令中高亮选区的固定可能在一些操作中缺乏灵活性，导致在使用.命令重复操作时作用范围不能够灵活改变，而由操作符+动作命令完成的操作在作用范围上具有一定灵活性，更具优势。\n\n\n# 技巧24-26 运用面向列块的可视模式\n\n用面向列块的可视模式编辑表格数据\n\n例如，想要在三行内容中间为他们添加|符号，构成一个表格。先使用ctrl v命令进入面向列块的可视模式，然后使用j/k命令划分列块选区，最后使用r|命令为三行内容都添加|符号。\n\none       1\ntow       2\nthree     3\n\n\n修改列文本\n\n例如，想要修改同列块中的相同内容，可以直接使用ctrl v命令进入列块可视模式，然后使用h/l命令选择文本，再用j/k命令选择列块，然后使用c命令替换内容并输入新的内容，所有行的内容都会被同时修改。\n\n在长短不一的高亮块后添加文本\n\n例如，多行长短不一的代码都需要添加;，前面已经使用过a;然后使用j.一键移动，一键操作完成内容添加工作。这一工作使用列块可视模式可以更加方便的完成，使用ctrl v进入可视模式，然后使用j/h以及移动至行尾$命令选中所有行末端文本，然后使用a;命令完成文本添加工作。",charsets:{cjk:!0},lastUpdated:"2023/11/19, 12:55:48",lastUpdatedTimestamp:1700369748e3},{title:"01位运算基础",frontmatter:{title:"01位运算基础",date:"2023-03-24T18:39:49.000Z",permalink:"/pages/296a65/"},regularPath:"/03.LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/05.%E5%85%B6%E4%BB%96%E5%86%85%E5%AE%B9/02.%E4%BD%8D%E8%BF%90%E7%AE%97/01.%E4%BD%8D%E8%BF%90%E7%AE%97%E5%9F%BA%E7%A1%80.html",relativePath:"03.LeetCode刷题笔记/05.其他内容/02.位运算/01.位运算基础.md",key:"v-511ed1c1",path:"/pages/296a65/",headers:[{level:2,title:"01 位运算基础",slug:"_01-位运算基础",normalizedTitle:"01 位运算基础",charIndex:2},{level:4,title:"461 汉明距离",slug:"_461-汉明距离",normalizedTitle:"461 汉明距离",charIndex:722},{level:4,title:"190 颠倒二进制位",slug:"_190-颠倒二进制位",normalizedTitle:"190 颠倒二进制位",charIndex:1307},{level:4,title:"693 交替位二进制数",slug:"_693-交替位二进制数",normalizedTitle:"693 交替位二进制数",charIndex:2080}],headersStr:"01 位运算基础 461 汉明距离 190 颠倒二进制位 693 交替位二进制数",content:"# 01 位运算基础\n\n位运算是算法题里比较特殊的一种类型，它们利用二进制位运算的特性进行一些奇妙的优化和计算。常用的位运算符号包括：“∧” 按位异或、“&” 按位与、“|” 按位或、“∼” 取反、“<<” 算术左移和 “>>” 算术右移。以下是一些常见的位运算特性：\n\n异或              与              或\nx ^ 0000 = x    x & 0000 = 0   x | 0000 = x\nx ^ 1111 = ~x   x & 1111 = x   x | 1111 = 1111\nx ^ x = 0       x & x = x      x | x = x\n\n除此之外， n & (n - 1) 可以去除 n 的位级表示中最低的那一位，例如对于二进制表示 11110100，减去 1 得到 11110011，这两个数按位与得到 11110000。\n\nn & (-n) 可以仅保留 n 的位级表示中最低的那一位，例如对于二进制表示 11110100，取负得到 00001100，这两个数按位与得到 00000100。\n\n回顾一下移位操作，移位操作是一种基本操作，是一种直接对二进制数据的位运算操作，移位运算又包含了逻辑移位（logical shift）和算术移位（arithmetic shift）两种。\n\n * 逻辑移位：移出去的位丢弃，空缺位（vacant bit）用 0 填充。\n * 算术移位：移出去的位丢弃，空缺位（vacant bit）用“符号位”来填充，所以一般用在右移运算中。\n\n无符号数，不管是左移还是右移都是逻辑移位；有符号数，做左移运算是逻辑移位，而做右移运算是算术移位。\n\n# 461 汉明距离\n\n给定两个十进制数字，求它们二进制表示的汉明距离（Hamming distance，即不同位的个数）。\n\n输入是两个十进制整数，输出是一个十进制整数，表示两个输入数字的汉明距离。\n\n> 输入：x = 1, y = 4 输出：2 解释：1 (0 0 0 1)；4 (0 1 0 0)\n\n解析：\n\n求二进制数不同位的个数，直接使用将俩个数进行按位异或操作，不同位的结果就是 1，所以最终统计异或结果中的 1 的个数即可。\n\n计算二进制数 1 的个数的方法：不断将二进制数算数右移，将其与 1 进行与运算，如果末位是 1 则加入计数。\n\nclass Solution {\npublic:\n    int hammingDistance(int x, int y) {\n        // 异或运算\n        int diff = x^y;\n        int ans = 0;\n        while(diff){\n            // 与运算 判断末位是否为 1\n            ans += diff & 1;\n            // 算术右移动 将已经被统计的 1 移出\n            diff = diff>>1;\n        }\n        return ans;\n    }\n};\n\n\n# 190 颠倒二进制位\n\n给定一个十进制整数，输出它在二进制下的翻转结果。\n\n输入和输出都是十进制整数。\n\n> 输入：n = 00000010100101000001111010011100\n> \n> 输出：964176192 (00111001011110000010100101000000)\n> \n> 解释：将 n 的二进制串倒转\n\n解析：\n\n使用算术左移和右移，可以很轻易地实现二进制的翻转。保存结果的二进制串每次向左移动一位腾出末位，然后将 n 与 1 取出 n 的末位并放入结果腾出的末位，放入之后 n 向右移动一位将已放入的位移出。\n\n一个简单的示例：\n\n             1      2      3      4      5\nans (算术左移)   0000   0000   0001   0010   0101\nn (算术右移)     1010   0101   0010   0001   0000\n\nclass Solution {\npublic:\n    uint32_t reverseBits(uint32_t n) {\n        // 无符号32位整型\n        uint32_t ans = 0;\n        for(int i=0;i<32;++i){\n            // 每次先将结果左移一位腾出位置\n            ans <<= 1;\n            // 将 n 当前的最后一位放到上一步ans腾出的位置（末位）\n            ans += n&1;\n            // 将已经放入结果的位移出\n            n >>= 1;\n        }\n        return ans;\n    }\n};\n\n\n# 693 交替位二进制数\n\n给定一个正整数，检查它的二进制表示是否总是 0、1 交替出现\n\n输入一个整数，输出一个布尔类型表示二进制表示是否总是 0、1 交替出现\n\n> 输入：n = 10\n> 输出：true\n> 解释：10 的二进制表示是：1010\n\n解析：\n\n一种简单的思路是不断使用算术右移将n的二进制表示末位移出，使用按位与运算获取末位是0还是1，并且比较第 i 个和第 i-1 个末位是否相同，如果相同则直接返回false，检查完成则返回true。\n\nclass Solution {\npublic:\n    bool hasAlternatingBits(int n) {\n        // 记录第一个末位\n        int pre = n & 1;\n        n>>=1;\n        while(n){\n            // 比较第 i 个和第 i-1 个末位\n            int now = n & 1;\n            if(now == pre){\n                return false;\n            }else{\n                // 更新前一个状态\n                pre = now;\n            }\n            n >>= 1;\n        }\n        return true;\n    }\n};\n",normalizedContent:"# 01 位运算基础\n\n位运算是算法题里比较特殊的一种类型，它们利用二进制位运算的特性进行一些奇妙的优化和计算。常用的位运算符号包括：“∧” 按位异或、“&” 按位与、“|” 按位或、“∼” 取反、“<<” 算术左移和 “>>” 算术右移。以下是一些常见的位运算特性：\n\n异或              与              或\nx ^ 0000 = x    x & 0000 = 0   x | 0000 = x\nx ^ 1111 = ~x   x & 1111 = x   x | 1111 = 1111\nx ^ x = 0       x & x = x      x | x = x\n\n除此之外， n & (n - 1) 可以去除 n 的位级表示中最低的那一位，例如对于二进制表示 11110100，减去 1 得到 11110011，这两个数按位与得到 11110000。\n\nn & (-n) 可以仅保留 n 的位级表示中最低的那一位，例如对于二进制表示 11110100，取负得到 00001100，这两个数按位与得到 00000100。\n\n回顾一下移位操作，移位操作是一种基本操作，是一种直接对二进制数据的位运算操作，移位运算又包含了逻辑移位（logical shift）和算术移位（arithmetic shift）两种。\n\n * 逻辑移位：移出去的位丢弃，空缺位（vacant bit）用 0 填充。\n * 算术移位：移出去的位丢弃，空缺位（vacant bit）用“符号位”来填充，所以一般用在右移运算中。\n\n无符号数，不管是左移还是右移都是逻辑移位；有符号数，做左移运算是逻辑移位，而做右移运算是算术移位。\n\n# 461 汉明距离\n\n给定两个十进制数字，求它们二进制表示的汉明距离（hamming distance，即不同位的个数）。\n\n输入是两个十进制整数，输出是一个十进制整数，表示两个输入数字的汉明距离。\n\n> 输入：x = 1, y = 4 输出：2 解释：1 (0 0 0 1)；4 (0 1 0 0)\n\n解析：\n\n求二进制数不同位的个数，直接使用将俩个数进行按位异或操作，不同位的结果就是 1，所以最终统计异或结果中的 1 的个数即可。\n\n计算二进制数 1 的个数的方法：不断将二进制数算数右移，将其与 1 进行与运算，如果末位是 1 则加入计数。\n\nclass solution {\npublic:\n    int hammingdistance(int x, int y) {\n        // 异或运算\n        int diff = x^y;\n        int ans = 0;\n        while(diff){\n            // 与运算 判断末位是否为 1\n            ans += diff & 1;\n            // 算术右移动 将已经被统计的 1 移出\n            diff = diff>>1;\n        }\n        return ans;\n    }\n};\n\n\n# 190 颠倒二进制位\n\n给定一个十进制整数，输出它在二进制下的翻转结果。\n\n输入和输出都是十进制整数。\n\n> 输入：n = 00000010100101000001111010011100\n> \n> 输出：964176192 (00111001011110000010100101000000)\n> \n> 解释：将 n 的二进制串倒转\n\n解析：\n\n使用算术左移和右移，可以很轻易地实现二进制的翻转。保存结果的二进制串每次向左移动一位腾出末位，然后将 n 与 1 取出 n 的末位并放入结果腾出的末位，放入之后 n 向右移动一位将已放入的位移出。\n\n一个简单的示例：\n\n             1      2      3      4      5\nans (算术左移)   0000   0000   0001   0010   0101\nn (算术右移)     1010   0101   0010   0001   0000\n\nclass solution {\npublic:\n    uint32_t reversebits(uint32_t n) {\n        // 无符号32位整型\n        uint32_t ans = 0;\n        for(int i=0;i<32;++i){\n            // 每次先将结果左移一位腾出位置\n            ans <<= 1;\n            // 将 n 当前的最后一位放到上一步ans腾出的位置（末位）\n            ans += n&1;\n            // 将已经放入结果的位移出\n            n >>= 1;\n        }\n        return ans;\n    }\n};\n\n\n# 693 交替位二进制数\n\n给定一个正整数，检查它的二进制表示是否总是 0、1 交替出现\n\n输入一个整数，输出一个布尔类型表示二进制表示是否总是 0、1 交替出现\n\n> 输入：n = 10\n> 输出：true\n> 解释：10 的二进制表示是：1010\n\n解析：\n\n一种简单的思路是不断使用算术右移将n的二进制表示末位移出，使用按位与运算获取末位是0还是1，并且比较第 i 个和第 i-1 个末位是否相同，如果相同则直接返回false，检查完成则返回true。\n\nclass solution {\npublic:\n    bool hasalternatingbits(int n) {\n        // 记录第一个末位\n        int pre = n & 1;\n        n>>=1;\n        while(n){\n            // 比较第 i 个和第 i-1 个末位\n            int now = n & 1;\n            if(now == pre){\n                return false;\n            }else{\n                // 更新前一个状态\n                pre = now;\n            }\n            n >>= 1;\n        }\n        return true;\n    }\n};\n",charsets:{cjk:!0},lastUpdated:"2023/11/19, 12:55:48",lastUpdatedTimestamp:1700369748e3},{title:"Vim命令行模式",frontmatter:{title:"Vim命令行模式",date:"2023-04-30T14:47:00.000Z",permalink:"/pages/d598a0/"},regularPath:"/04.Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/02.Vim%20%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/05.Vim%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%A8%A1%E5%BC%8F.html",relativePath:"04.Linux操作系统编程/02.Vim 实用技巧/05.Vim命令行模式.md",key:"v-5789cebf",path:"/pages/d598a0/",headers:[{level:2,title:"命令行模式",slug:"命令行模式",normalizedTitle:"命令行模式",charIndex:2},{level:3,title:"技巧27 结识Vim的命令行模式",slug:"技巧27-结识vim的命令行模式",normalizedTitle:"技巧27 结识vim的命令行模式",charIndex:12}],headersStr:"命令行模式 技巧27 结识Vim的命令行模式",content:"# 命令行模式\n\n\n# 技巧27 结识Vim的命令行模式\n\n命令行模式\n\n命令行模式会提示我们输入一条Ex命令、一个查找模式或者是一个表达式。一般情况下，Vim是使用:命令切换到命令行模式的，在这个状态下和shell类似，我们可以输入一条命令，然后使用Enter键执行命令。除此之外，一些特殊情况也是在命令行模式中，例如使用/命令进行查找或者使用Ctrl r =访问寄存器等操作中都是处于命令行模式中。命令行模式主要使用Ex命令完成操作的，其中一些用于编辑文本的常见Ex命令如下表所示。\n\n命令                                       作用\n:[range]delete [x]                       删除指定范围内的行并暂存到寄存器x中\n:[range]yank [x]                         复制指定范围内的行并暂存到寄存器x中\n:[line]put [x]                           在指定行后粘贴寄存器x中的内容\n:[range]copy {address}                   把指定范围内的行拷贝到地址{address}所指定的行下\n:[range]move {address}                   把指定范围内的行移动到地址{address}所指定的行下\n:[range]join                             连接指定范围内的行\n:[range]normal {commands}                对指定范围内的每一行执行普通模式命令{commands}\n:[range]subsititute/{pattern}/{string}   把指定范围内的{pattern}替换为{string}\n:[range]global/{pattern}/[cmd]           对指定范围内匹配的{pattern}的所有行执行Ex命令[cmd]\n\n命令行模式中的一大特点在于，在一些情况下使用Ex命令能够比普通模式命令更加快捷地完成同样的工作，应为Ex命令的影响范围广且距离远。",normalizedContent:"# 命令行模式\n\n\n# 技巧27 结识vim的命令行模式\n\n命令行模式\n\n命令行模式会提示我们输入一条ex命令、一个查找模式或者是一个表达式。一般情况下，vim是使用:命令切换到命令行模式的，在这个状态下和shell类似，我们可以输入一条命令，然后使用enter键执行命令。除此之外，一些特殊情况也是在命令行模式中，例如使用/命令进行查找或者使用ctrl r =访问寄存器等操作中都是处于命令行模式中。命令行模式主要使用ex命令完成操作的，其中一些用于编辑文本的常见ex命令如下表所示。\n\n命令                                       作用\n:[range]delete [x]                       删除指定范围内的行并暂存到寄存器x中\n:[range]yank [x]                         复制指定范围内的行并暂存到寄存器x中\n:[line]put [x]                           在指定行后粘贴寄存器x中的内容\n:[range]copy {address}                   把指定范围内的行拷贝到地址{address}所指定的行下\n:[range]move {address}                   把指定范围内的行移动到地址{address}所指定的行下\n:[range]join                             连接指定范围内的行\n:[range]normal {commands}                对指定范围内的每一行执行普通模式命令{commands}\n:[range]subsititute/{pattern}/{string}   把指定范围内的{pattern}替换为{string}\n:[range]global/{pattern}/[cmd]           对指定范围内匹配的{pattern}的所有行执行ex命令[cmd]\n\n命令行模式中的一大特点在于，在一些情况下使用ex命令能够比普通模式命令更加快捷地完成同样的工作，应为ex命令的影响范围广且距离远。",charsets:{cjk:!0},lastUpdated:"2023/11/19, 12:55:48",lastUpdatedTimestamp:1700369748e3},{title:"GDB调试Coredump",frontmatter:{title:"GDB调试Coredump",date:"2023-11-18T16:27:52.000Z",permalink:"/pages/2f33c0/"},regularPath:"/04.Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/04.GDB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/02.GDB%E8%B0%83%E8%AF%95Coredump.html",relativePath:"04.Linux操作系统编程/04.GDB学习笔记/02.GDB调试Coredump.md",key:"v-c7498540",path:"/pages/2f33c0/",headers:[{level:2,title:"01 什么是 coredump",slug:"_01-什么是-coredump",normalizedTitle:"01 什么是 coredump",charIndex:112},{level:3,title:"1.1 ulimit 命令",slug:"_1-1-ulimit-命令",normalizedTitle:"1.1 ulimit 命令",charIndex:313},{level:3,title:"1.2 coredump 实例",slug:"_1-2-coredump-实例",normalizedTitle:"1.2 coredump 实例",charIndex:1176},{level:2,title:"02 coredump 是怎么发生的",slug:"_02-coredump-是怎么发生的",normalizedTitle:"02 coredump 是怎么发生的",charIndex:2567},{level:3,title:"2.1 程序运行错误导致 coredump",slug:"_2-1-程序运行错误导致-coredump",normalizedTitle:"2.1 程序运行错误导致 coredump",charIndex:2632},{level:3,title:"2.2 coredump 文件生成原理",slug:"_2-2-coredump-文件生成原理",normalizedTitle:"2.2 coredump 文件生成原理",charIndex:3913},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:6464}],headersStr:"01 什么是 coredump 1.1 ulimit 命令 1.2 coredump 实例 02 coredump 是怎么发生的 2.1 程序运行错误导致 coredump 2.2 coredump 文件生成原理 参考资料",content:'在计算机系统中运行程序时，问题经常发生，而且通常很难找到根源。幸运的是，有一种叫做 coredump 的文件可以帮助我们找到问题的源头。本文将解释什么是 coredump，它是如何工作的，以及如何利用它来定位问题。\n\n\n# 01 什么是 coredump\n\n----------------------------------------\n\nCore dump（核心转储）是指在程序运行过程中发生错误或异常时，操作系统将程序的内存内容保存到磁盘上的一种文件。这个文件包含了程序崩溃时的内存状态，包括变量的值、函数调用栈、寄存器状态等信息。通过分析 coredump 文件，可以了解程序崩溃的原因，以便进行调试和修复。\n\n\n# 1.1 ulimit 命令\n\n要生成 core dump 文件，通常需要在操作系统中设置相应的配置。在 Linux 和 Unix 系统中，可以使用 ulimit 命令设置 core dump 文件的大小限制，并使用 gcore 或 kill -SIGQUIT 命令生成 core dump 文件。\n\nulimit 是 Unix 和 Linux 系统中的内置命令，用于控制用户级别的系统资源限制。这些资源包括文件大小、进程数、核心文件大小、堆栈大小等等。以下是一些使用 ulimit 的基础知识。\n\n使用 ulimit -a 可以列出所有的限制，每一行都对应一个资源类型和其对应的限制。 以下是一些比较常用的 ulimit 选项：\n\n * ulimit -u : 查看用户可以用的最大进程数。\n * ulimit -n : 文件描述符的最大个数，即一个进程可以同时打开的最大文件数。\n * ulimit -d : 一个进程可以使用的最大数据段大小，单位为KB。\n * ulimit -s : 最大堆栈大小，单位为KB。\n * ulimit -c : 生成coredump文件的最大大小，单位为KB。\n * ulimit -v : 进程虚拟内存的最大值，单位KB。\n\n我们可以在命令后添加具体的数值来设置对应的资源限制，例如：\n\n * ulimit -n 1024 : 设置最大可以打开的文件描述符数为1024。\n * ulimit -c unlimited : 设置coredump的大小为无限。\n\n需要注意的是，ulimit 命令设置的资源限制是以 Shell 环境为单位的，而不是全局性的。也就是说，在一个 Shell 环境中设置的资源限制，并不会影响到其他的 Shell 环境。同时，这些限制只对当前 Shell 环境以及它派生出来的子进程生效，对已经存在的其他进程没有影响。\n\n总的来说，ulimit 命令是一个很有用的工具，它可以帮助我们控制进程对系统资源的使用，从而防止一些程序错误导致系统资源的耗尽。 3\n\n\n# 1.2 coredump 实例\n\n1. ulimit 查看资源限制\n\n一般情况下如果 coredump 文件没有生成，很大可能是由于受到资源限制，使用 ulimit命令查看和设置资源限制\n\nulimit -c\t\t\t\t\t\t # 查看是否开启 core，0 表示关闭 \nulimit -c [filesize] # 设置 core 文件大小\nulimit -c unlimited  # 设置 core 文件大小为无限\n\n\n2. 设置 core 文件路径\n\n在 Linux 系统中，core dump 文件的路径是由 /proc/sys/kernel/core_pattern 定义的，如果这个文件不存在，或者内容为空，那么 core dump 文件就会生成在当前目录下\n\n也可以通过修改 /proc/sys/kernel/core_pattern 指定 core 文件生成的路径和文件名\n\n# 查看当前 core 文件路径\ncat /proc/sys/kernel/core_pattern \n\n# 指定 core 文件路径\nsudo echo "yourpath/core.%e.%p.%h.%t" > /proc/sys/kernel/core_pattern\nsudo sysctl -w kernel.core_pattern=yourpath/core.%e.%p.%h.%t  # # 也可以使用 sysctl 修改 kernel.core_pattern 来指定 core 文件路径\n\n\n其中 core 文件名称定义中，可以使用占位符保留一些有用信息\n\n%p: pid\n%u: uid\n%g: gid\n%s: signal number\n%t: UNIX time of dump\n%h: hostname\n%e: executable filename\n\n\n3. 空指针 core 示例\n\n下面这个例子中试图通过一个 NULL 指针来访问内存，这是非法的，因为 NULL 指针并没有指向任何有效的内存位置，因而在运行时，操作系统将识别这个非法操作，并生成一个 Coredump 文件。\n\n#include <stdio.h>\n\nint main() {\n    int *ptr = NULL;\n    printf("%d", *ptr);\n    return 0;\n}\n\n\n编译运行这段程序如下，可以看到触发了 core dumped\n\n需要注意的是编译的时候记得加上 -g 参数保留调试信息，否则使用 GDB 调试时会找不到函数名或者变量名\n\n$ gcc -g main.c -o main\n$ ./main\n[1]    277 segmentation fault (core dumped)  ./main\n\n\n4. 使用 GDB 调试 core 文件\n\n找到 core 文件，然后使用命令 gdb [exec file] [core file] 调试 core 文件\n\n$ cd your-core-path\n$ ls\ncore.main\n$ gdb ~/main ./core.main\n\n\nGDB 运行后会停止在发生异常的代码处，并且将发生异常的代码打印出来，如下图中指出了异常位于 mian.c 的第 5 行代码 *ptr 是一个空指针\n\n\n# 02 coredump 是怎么发生的\n\n----------------------------------------\n\n\n# 2.1 程序运行错误导致 coredump\n\n程序执行非法操作时，例如解引用空指针，除数为零，或者访问越界的内存，操作系统就会生成一个 coredump 文件并终止程序运行。以下是一些常见导致 core dump 发生的原因：\n\n * 空指针引用：当程序试图访问一个空指针时，操作系统会捕获这个错误并生成 core dump 文件\n * 内存越界：当程序试图访问超出其分配内存范围的位置时，可能会导致内存越界错误，从而触发 core dump\n * 栈溢出：当程序的函数调用栈超过其允许的最大深度时，可能会发生栈溢出错误，导致 core dump 发生\n * 除零错误：当程序试图除以零时，会触发除零错误，操作系统可能会生成 core dump 文件\n * 非法指令：当程序执行了无效或非法的机器指令时，操作系统通常会生成 core dump 文件\n * 内存分配错误：当程序遇到内存分配错误，如申请内存失败或释放已释放的内存时，可能会触发 core dump\n\n这些程序执行非法操作时，操作系统会向指定进程发送特定信号（signal）终止程序运行并生成 coredump，一些常见信号有：\n\n * SIGSEGV (信号值 11)：当一个进程由于无效的内存访问，如解引用空指针，或访问受保护的内存区域时，系统会向它发送此信号。这是生成coredump最常见的原因\n * SIGABRT (信号值 6)：当进程自身检测到一个无法恢复的问题，并选择主动终止时，它会发送这个信号给自己。例如，C库函数abort()就会发送这个信号\n * SIGILL (信号值 4)：当CPU检测到进程试图执行一条无效或未定义的指令时，系统会发送此信号。一个可能的原因是代码的内存被错误地当作数据修改\n * SIGFPE (信号值 8)：在数学运算错误时发送，比如除以零或浮点溢出\n * SIGBUS (信号值 7)：用于处理错误的内存访问，但这个信号在不同的系统和架构下含义可能会有所不同。在某些系统中，它用于处理对齐（alignment）问题\n * SIGQUIT (信号值 3)：用户通过控制台（通常是按Ctrl+\\）向进程发送此信号，它不仅会停止进程的运行，还会生成coredump\n\nSIGNAL    VALUE   ACTION   COMMENT\nSIGSEGV   11      Core     Invalid memory reference\nSIGABRT   6       Core     Abort signal from abort\nSIGILL    4       Core     Illegal Instruction\nSIGFPE    8       Core     Floating point exception\nSIGBUS    7       Core     Bus error (bad memory access)\nSIGQUIT   3       Core     Quit from keyboard\n\n\n# 2.2 coredump 文件生成原理\n\n> 本节参考如有侵权，请告知：https://cloud.tencent.com/developer/article/1860631\n\ncoredump 文件的产生过程如下图所示：\n\nLinux 内核实现中使用一个复杂的任务结构（task_struct）结构体来代表系统中的每个进程或线程，这个结构体被定义在 include/linux/sched.h 文件中，其中也包含了记录信号处理相关的属性，如用于存放待处理信号的 pending 信号队列和阻塞信号 blocked 等。\n\n当一个信号被发送到进程时，它首先被添加到该进程的 pending 信号队列中。而内核在进程切换的上下文切换中，在运行被调用进程时会先检查这个 pending 信号队列。如果有待处理的信号，内核会在恢复进程运行前，调用信号的处理函数。这个过程大多数发生在 do_signal 函数中，这个函数在每次中断返回，系统调用返回，或者任何可能会改变进程状态的操作后执行。\n\n如果一个信号是致命的（如 SIGSEGV, SIGABRT），并且进程并没有注册处理函数来处理它，那么内核会根据这个信号的默认行为来操作，比如可能会终止进程，或者产生 coredump 文件等。 通过上述分析，coredump 文件生成的过程可以总结为：程序运行产生 core 相关的信号 signal；do_signal 函数处理信号；如果默认行为是 Core 则调用 do_coredump 函数生成 core 文件。下面结合源码进一步分析该过程\n\n1. 信号处理过程\n\n在进程切换的上下文切换时，检查信号队列 pending 是否有待处理信号，有则调用 do_singal 函数处理，该函数中使用 get_signal_to_deliver 函数从进程的信号队列 pending 中获取一个信号，然后根据信号的类型来进行不同的操作。\n\nget_signal_to_deliver 函数中处理 coredump 相关信号的代码实现如下，首先使用 dequeue_signal 函数获取信号，然后使用 sig_kernel_coredump 函数判断该信号是否为 coredump 相关信号，如果是则执行 core 相关动作\n\nint get_signal_to_deliver(siginfo_t *info, struct k_sigaction *return_ka,\n                          struct pt_regs *regs, void *cookie)\n{\n    sigset_t *mask = &current->blocked;\n    int signr = 0;\n\n    ...\n    for (;;) {\n        ...\n        // 1. 从进程信号队列中获取一个信号\n        signr = dequeue_signal(current, mask, info); \n\n        ...\n        // 2. 判断是否会生成 coredump 文件的信号\n        if (sig_kernel_coredump(signr)) {\n            // 3. 调用 do_coredump() 函数生成 coredump 文件\n            do_coredump((long)signr, signr, regs);\n        }\n        ...\n    }\n    ...\n}\n\n\n2. 生成 coredump 文件\n\n当 coredump 相关信号被处理时，调用内核就会调用 do_coredump 函数来生成 coredump 文件，该函数核心代码如下，首先判断 ulimit 的资源限制情况，如果可用则创建 coredump 文件，最后将当前进程的寄存器、内存管理等相关信息写入到该文件中。\n\nint do_coredump(long signr, int exit_code, struct pt_regs *regs)\n{\n    char corename[CORENAME_MAX_SIZE + 1];\n    struct mm_struct *mm = current->mm;\n    struct linux_binfmt *binfmt;\n    struct inode *inode;\n    struct file *file;\n    int retval = 0;\n    int fsuid = current->fsuid;\n    int flag = 0;\n    int ispipe = 0;\n\n    binfmt = current->binfmt; // 当前进程所使用的可执行文件格式（如ELF格式）\n\n    ...\n    // 1. 判断当前进程可生成的 coredump 文件大小是否受到资源限制\n    if (current->signal->rlim[RLIMIT_CORE].rlim_cur < binfmt->min_coredump)\n        goto fail_unlock;\n\n    ...\n    // 2. 生成 coredump 文件名\n    ispipe = format_corename(corename, core_pattern, signr);\n\n    ...\n    // 3. 创建 coredump 文件\n    file = filp_open(corename, O_CREAT|2|O_NOFOLLOW|O_LARGEFILE|flag, 0600);\n\n    ...\n    // 4. 把进程的内存信息写入到 coredump 文件中\n    retval = binfmt->core_dump(signr, regs, file);\n\nfail_unlock:\n    ...\n    return retval;\n}\n\n\n\n# 参考资料\n\n一文读懂 | coredump文件是如何生成的-腾讯云开发者社区-腾讯云\n\ncore dump 路径定义以及监控\n\nLinux下gdb调试生成core文件并调试core文件-阿里云开发者社区\n\nLinux进程描述符task_struct结构体详解\n\ngdb调试coredump（使用篇）',normalizedContent:'在计算机系统中运行程序时，问题经常发生，而且通常很难找到根源。幸运的是，有一种叫做 coredump 的文件可以帮助我们找到问题的源头。本文将解释什么是 coredump，它是如何工作的，以及如何利用它来定位问题。\n\n\n# 01 什么是 coredump\n\n----------------------------------------\n\ncore dump（核心转储）是指在程序运行过程中发生错误或异常时，操作系统将程序的内存内容保存到磁盘上的一种文件。这个文件包含了程序崩溃时的内存状态，包括变量的值、函数调用栈、寄存器状态等信息。通过分析 coredump 文件，可以了解程序崩溃的原因，以便进行调试和修复。\n\n\n# 1.1 ulimit 命令\n\n要生成 core dump 文件，通常需要在操作系统中设置相应的配置。在 linux 和 unix 系统中，可以使用 ulimit 命令设置 core dump 文件的大小限制，并使用 gcore 或 kill -sigquit 命令生成 core dump 文件。\n\nulimit 是 unix 和 linux 系统中的内置命令，用于控制用户级别的系统资源限制。这些资源包括文件大小、进程数、核心文件大小、堆栈大小等等。以下是一些使用 ulimit 的基础知识。\n\n使用 ulimit -a 可以列出所有的限制，每一行都对应一个资源类型和其对应的限制。 以下是一些比较常用的 ulimit 选项：\n\n * ulimit -u : 查看用户可以用的最大进程数。\n * ulimit -n : 文件描述符的最大个数，即一个进程可以同时打开的最大文件数。\n * ulimit -d : 一个进程可以使用的最大数据段大小，单位为kb。\n * ulimit -s : 最大堆栈大小，单位为kb。\n * ulimit -c : 生成coredump文件的最大大小，单位为kb。\n * ulimit -v : 进程虚拟内存的最大值，单位kb。\n\n我们可以在命令后添加具体的数值来设置对应的资源限制，例如：\n\n * ulimit -n 1024 : 设置最大可以打开的文件描述符数为1024。\n * ulimit -c unlimited : 设置coredump的大小为无限。\n\n需要注意的是，ulimit 命令设置的资源限制是以 shell 环境为单位的，而不是全局性的。也就是说，在一个 shell 环境中设置的资源限制，并不会影响到其他的 shell 环境。同时，这些限制只对当前 shell 环境以及它派生出来的子进程生效，对已经存在的其他进程没有影响。\n\n总的来说，ulimit 命令是一个很有用的工具，它可以帮助我们控制进程对系统资源的使用，从而防止一些程序错误导致系统资源的耗尽。 3\n\n\n# 1.2 coredump 实例\n\n1. ulimit 查看资源限制\n\n一般情况下如果 coredump 文件没有生成，很大可能是由于受到资源限制，使用 ulimit命令查看和设置资源限制\n\nulimit -c\t\t\t\t\t\t # 查看是否开启 core，0 表示关闭 \nulimit -c [filesize] # 设置 core 文件大小\nulimit -c unlimited  # 设置 core 文件大小为无限\n\n\n2. 设置 core 文件路径\n\n在 linux 系统中，core dump 文件的路径是由 /proc/sys/kernel/core_pattern 定义的，如果这个文件不存在，或者内容为空，那么 core dump 文件就会生成在当前目录下\n\n也可以通过修改 /proc/sys/kernel/core_pattern 指定 core 文件生成的路径和文件名\n\n# 查看当前 core 文件路径\ncat /proc/sys/kernel/core_pattern \n\n# 指定 core 文件路径\nsudo echo "yourpath/core.%e.%p.%h.%t" > /proc/sys/kernel/core_pattern\nsudo sysctl -w kernel.core_pattern=yourpath/core.%e.%p.%h.%t  # # 也可以使用 sysctl 修改 kernel.core_pattern 来指定 core 文件路径\n\n\n其中 core 文件名称定义中，可以使用占位符保留一些有用信息\n\n%p: pid\n%u: uid\n%g: gid\n%s: signal number\n%t: unix time of dump\n%h: hostname\n%e: executable filename\n\n\n3. 空指针 core 示例\n\n下面这个例子中试图通过一个 null 指针来访问内存，这是非法的，因为 null 指针并没有指向任何有效的内存位置，因而在运行时，操作系统将识别这个非法操作，并生成一个 coredump 文件。\n\n#include <stdio.h>\n\nint main() {\n    int *ptr = null;\n    printf("%d", *ptr);\n    return 0;\n}\n\n\n编译运行这段程序如下，可以看到触发了 core dumped\n\n需要注意的是编译的时候记得加上 -g 参数保留调试信息，否则使用 gdb 调试时会找不到函数名或者变量名\n\n$ gcc -g main.c -o main\n$ ./main\n[1]    277 segmentation fault (core dumped)  ./main\n\n\n4. 使用 gdb 调试 core 文件\n\n找到 core 文件，然后使用命令 gdb [exec file] [core file] 调试 core 文件\n\n$ cd your-core-path\n$ ls\ncore.main\n$ gdb ~/main ./core.main\n\n\ngdb 运行后会停止在发生异常的代码处，并且将发生异常的代码打印出来，如下图中指出了异常位于 mian.c 的第 5 行代码 *ptr 是一个空指针\n\n\n# 02 coredump 是怎么发生的\n\n----------------------------------------\n\n\n# 2.1 程序运行错误导致 coredump\n\n程序执行非法操作时，例如解引用空指针，除数为零，或者访问越界的内存，操作系统就会生成一个 coredump 文件并终止程序运行。以下是一些常见导致 core dump 发生的原因：\n\n * 空指针引用：当程序试图访问一个空指针时，操作系统会捕获这个错误并生成 core dump 文件\n * 内存越界：当程序试图访问超出其分配内存范围的位置时，可能会导致内存越界错误，从而触发 core dump\n * 栈溢出：当程序的函数调用栈超过其允许的最大深度时，可能会发生栈溢出错误，导致 core dump 发生\n * 除零错误：当程序试图除以零时，会触发除零错误，操作系统可能会生成 core dump 文件\n * 非法指令：当程序执行了无效或非法的机器指令时，操作系统通常会生成 core dump 文件\n * 内存分配错误：当程序遇到内存分配错误，如申请内存失败或释放已释放的内存时，可能会触发 core dump\n\n这些程序执行非法操作时，操作系统会向指定进程发送特定信号（signal）终止程序运行并生成 coredump，一些常见信号有：\n\n * sigsegv (信号值 11)：当一个进程由于无效的内存访问，如解引用空指针，或访问受保护的内存区域时，系统会向它发送此信号。这是生成coredump最常见的原因\n * sigabrt (信号值 6)：当进程自身检测到一个无法恢复的问题，并选择主动终止时，它会发送这个信号给自己。例如，c库函数abort()就会发送这个信号\n * sigill (信号值 4)：当cpu检测到进程试图执行一条无效或未定义的指令时，系统会发送此信号。一个可能的原因是代码的内存被错误地当作数据修改\n * sigfpe (信号值 8)：在数学运算错误时发送，比如除以零或浮点溢出\n * sigbus (信号值 7)：用于处理错误的内存访问，但这个信号在不同的系统和架构下含义可能会有所不同。在某些系统中，它用于处理对齐（alignment）问题\n * sigquit (信号值 3)：用户通过控制台（通常是按ctrl+\\）向进程发送此信号，它不仅会停止进程的运行，还会生成coredump\n\nsignal    value   action   comment\nsigsegv   11      core     invalid memory reference\nsigabrt   6       core     abort signal from abort\nsigill    4       core     illegal instruction\nsigfpe    8       core     floating point exception\nsigbus    7       core     bus error (bad memory access)\nsigquit   3       core     quit from keyboard\n\n\n# 2.2 coredump 文件生成原理\n\n> 本节参考如有侵权，请告知：https://cloud.tencent.com/developer/article/1860631\n\ncoredump 文件的产生过程如下图所示：\n\nlinux 内核实现中使用一个复杂的任务结构（task_struct）结构体来代表系统中的每个进程或线程，这个结构体被定义在 include/linux/sched.h 文件中，其中也包含了记录信号处理相关的属性，如用于存放待处理信号的 pending 信号队列和阻塞信号 blocked 等。\n\n当一个信号被发送到进程时，它首先被添加到该进程的 pending 信号队列中。而内核在进程切换的上下文切换中，在运行被调用进程时会先检查这个 pending 信号队列。如果有待处理的信号，内核会在恢复进程运行前，调用信号的处理函数。这个过程大多数发生在 do_signal 函数中，这个函数在每次中断返回，系统调用返回，或者任何可能会改变进程状态的操作后执行。\n\n如果一个信号是致命的（如 sigsegv, sigabrt），并且进程并没有注册处理函数来处理它，那么内核会根据这个信号的默认行为来操作，比如可能会终止进程，或者产生 coredump 文件等。 通过上述分析，coredump 文件生成的过程可以总结为：程序运行产生 core 相关的信号 signal；do_signal 函数处理信号；如果默认行为是 core 则调用 do_coredump 函数生成 core 文件。下面结合源码进一步分析该过程\n\n1. 信号处理过程\n\n在进程切换的上下文切换时，检查信号队列 pending 是否有待处理信号，有则调用 do_singal 函数处理，该函数中使用 get_signal_to_deliver 函数从进程的信号队列 pending 中获取一个信号，然后根据信号的类型来进行不同的操作。\n\nget_signal_to_deliver 函数中处理 coredump 相关信号的代码实现如下，首先使用 dequeue_signal 函数获取信号，然后使用 sig_kernel_coredump 函数判断该信号是否为 coredump 相关信号，如果是则执行 core 相关动作\n\nint get_signal_to_deliver(siginfo_t *info, struct k_sigaction *return_ka,\n                          struct pt_regs *regs, void *cookie)\n{\n    sigset_t *mask = &current->blocked;\n    int signr = 0;\n\n    ...\n    for (;;) {\n        ...\n        // 1. 从进程信号队列中获取一个信号\n        signr = dequeue_signal(current, mask, info); \n\n        ...\n        // 2. 判断是否会生成 coredump 文件的信号\n        if (sig_kernel_coredump(signr)) {\n            // 3. 调用 do_coredump() 函数生成 coredump 文件\n            do_coredump((long)signr, signr, regs);\n        }\n        ...\n    }\n    ...\n}\n\n\n2. 生成 coredump 文件\n\n当 coredump 相关信号被处理时，调用内核就会调用 do_coredump 函数来生成 coredump 文件，该函数核心代码如下，首先判断 ulimit 的资源限制情况，如果可用则创建 coredump 文件，最后将当前进程的寄存器、内存管理等相关信息写入到该文件中。\n\nint do_coredump(long signr, int exit_code, struct pt_regs *regs)\n{\n    char corename[corename_max_size + 1];\n    struct mm_struct *mm = current->mm;\n    struct linux_binfmt *binfmt;\n    struct inode *inode;\n    struct file *file;\n    int retval = 0;\n    int fsuid = current->fsuid;\n    int flag = 0;\n    int ispipe = 0;\n\n    binfmt = current->binfmt; // 当前进程所使用的可执行文件格式（如elf格式）\n\n    ...\n    // 1. 判断当前进程可生成的 coredump 文件大小是否受到资源限制\n    if (current->signal->rlim[rlimit_core].rlim_cur < binfmt->min_coredump)\n        goto fail_unlock;\n\n    ...\n    // 2. 生成 coredump 文件名\n    ispipe = format_corename(corename, core_pattern, signr);\n\n    ...\n    // 3. 创建 coredump 文件\n    file = filp_open(corename, o_creat|2|o_nofollow|o_largefile|flag, 0600);\n\n    ...\n    // 4. 把进程的内存信息写入到 coredump 文件中\n    retval = binfmt->core_dump(signr, regs, file);\n\nfail_unlock:\n    ...\n    return retval;\n}\n\n\n\n# 参考资料\n\n一文读懂 | coredump文件是如何生成的-腾讯云开发者社区-腾讯云\n\ncore dump 路径定义以及监控\n\nlinux下gdb调试生成core文件并调试core文件-阿里云开发者社区\n\nlinux进程描述符task_struct结构体详解\n\ngdb调试coredump（使用篇）',charsets:{cjk:!0},lastUpdated:"2023/11/19, 12:55:48",lastUpdatedTimestamp:1700369748e3},{title:"GDB基础调试",frontmatter:{title:"GDB基础调试",date:"2023-05-27T10:32:04.000Z",permalink:"/pages/f4281d/"},regularPath:"/04.Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/04.GDB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/01.GDB%E5%9F%BA%E7%A1%80%E8%B0%83%E8%AF%95.html",relativePath:"04.Linux操作系统编程/04.GDB学习笔记/01.GDB基础调试.md",key:"v-b1312a2c",path:"/pages/f4281d/",headers:[{level:2,title:"1.1 基础使用",slug:"_1-1-基础使用",normalizedTitle:"1.1 基础使用",charIndex:267},{level:2,title:"1.2 常用命令",slug:"_1-2-常用命令",normalizedTitle:"1.2 常用命令",charIndex:1206},{level:2,title:"1.3 GDB 基础调试实例",slug:"_1-3-gdb-基础调试实例",normalizedTitle:"1.3 gdb 基础调试实例",charIndex:3870},{level:2,title:"2.1 多进程调试中常用的 GDB 命令",slug:"_2-1-多进程调试中常用的-gdb-命令",normalizedTitle:"2.1 多进程调试中常用的 gdb 命令",charIndex:8676},{level:2,title:"2.2 GDB 多进程调试实例",slug:"_2-2-gdb-多进程调试实例",normalizedTitle:"2.2 gdb 多进程调试实例",charIndex:10315},{level:3,title:"2.2.1 调试父进程",slug:"_2-2-1-调试父进程",normalizedTitle:"2.2.1 调试父进程",charIndex:11845},{level:3,title:"2.2.2 调试第一个子进程",slug:"_2-2-2-调试第一个子进程",normalizedTitle:"2.2.2 调试第一个子进程",charIndex:14281},{level:3,title:"2.2.3 调试第二个子进程",slug:"_2-2-3-调试第二个子进程",normalizedTitle:"2.2.3 调试第二个子进程",charIndex:17223}],headersStr:"1.1 基础使用 1.2 常用命令 1.3 GDB 基础调试实例 2.1 多进程调试中常用的 GDB 命令 2.2 GDB 多进程调试实例 2.2.1 调试父进程 2.2.2 调试第一个子进程 2.2.3 调试第二个子进程",content:'# 01 GDB 基础调试\n\n> reference:\n> \n> 学习使用 GDB 调试代码 | Linux 中国 - 知乎 (zhihu.com)\n> \n> GDB使用详解 - 知乎 (zhihu.com)\n> \n> GDB Documentation\n> \n> 使用 GDB 调试多进程程序 - 简书\n\nGDB 全称“GNU symbolic debugger”是 Linux 下常用的程序调试器，当下的 GDB 支持调试多种编程语言编写的程序，包括 C、C++、Go、Objective-C、OpenCL、Ada 等。\n\n\n# 1.1 基础使用\n\n 1. 安装工具\n\n# 安装 gcc\nsudo yum install gcc\n# 安装 g++\nsudo yum install gcc-c++ \n# 安装 gdb\nsudo yum install gdb\n\n\n 2. 编译程序\n\ngcc -g basic.c -o basic\n\n\n使用GDB调试程序，编译程序的过程中需要注意以下两点：\n\n 1. 要使用GDB调试某个程序，该程序编译时需要加上编译选项 -g，否则编译生成的程序是不包含调试信息的；\n 2. GCC编译器支持 -O 和 -g 一起参与编译，关闭编译器的程序优化选项。GCC编译过程对进行优化的程度分为5个等级：-O/O0, -O1, -O2, -O3, -Os，调试时一般选择默认选项 -O 不做任何优化。\n\n> 调试信息：reference: GDB调试信息与调试原理 - 知乎 (zhihu.com)\n> \n> 如果编译命令中不加 -g 选项，在编译后的程序中不会保留调试符号信息。\n> \n> 加不加该选项在启用 GDB 调试时存在明显区别\n> \n> gdb basic\n> \n> \n> （1）不加 -g 选项，尾行打印内容为\n> \n> Reading symbols from basic...(No debugging symbols found in basic)\n> \n> \n> （2）加 -g 选项，尾行打印内容为\n> \n> Reading symbols from basic...\n> \n> \n> 可以看到，不加 -g 选项会直接提示程序不包含调试信息 No debugging symbols found in basic\n\n 3. 启动 GDB 调试\n\nGDB调试主要有三种方式：\n\n * 直接调试目标程序：gdb ./basic\n\n * 附加进程id：gdb attach pid\n\n * 调试core文件：gdb filename corename\n\n 4. 退出 GDB 调试\n\n * 可以用命令：q（quit的缩写）或者 Ctr + d 退出 GDB。\n\n * 如果GDB attach某个进程，退出GDB之前要用命令 detach 解除附加进程。\n\n\n# 1.2 常用命令\n\n> 本节内容转自：GDB使用详解 - 知乎 (zhihu.com)\n\n命令名称          命令缩写        命令说明\nrun           r           运行一个待调试的程序\ncontinue      c           让暂停的程序继续运行\nnext          n           运行到下一行\nstep          s           单步执行，遇到函数会进入\nuntil         u           运行到指定行停下来\nfinish        fi          结束当前调用函数，回到上一层调用函数处\nreturn        return      结束当前调用函数并返回指定值，到上一层函数调用处\njump          j           将当前程序执行流跳转到指定行或地址\nprint         p           打印变量或寄存器值\nbacktrace     bt          查看当前线程的调用堆栈\nframe         f           切换到当前调用线程的指定堆栈\nthread        thread      切换到指定线程\nbreak         b           添加断点\ntbreak        tb          添加临时断点\ndelete        d           删除断点\nenable        enable      启用某个断点\ndisable       disable     禁用某个断点\nwatch         watch       监视某一个变量或内存地址的值是否发生变化\nlist          l           显示源码\ninfo          i           查看断点 / 线程等信息\nptype         ptype       查看变量类型\ndisassemble   dis         查看汇编代码\nset args      set args    设置程序启动命令行参数\nshow args     show args   查看设置的命令行参数\n\n一般调试中最为常用的命令，gdb 语法糖直接回车重复执行上一条命令。\n\n命令名称    命令缩写   命令说明\nbreak   b      添加断点\nrun     r      运行一个待调试的程序\nnext    n      运行到下一行（步过）\nstep    s      单步执行，遇到函数会进入（步入）\nprint   p      打印变量或寄存器值\nlist    l      显示当前正在执行代码位置附近的代码\n\n 1. break 打断点\n    \n    >  * break FunctionName，在函数的入口处添加一个断点；\n    >  * break LineNo，在当前文件行号为LineNo处添加断点；\n    >  * break FileName:LineNo，在FileName文件行号为LineNo处添加一个断点；\n    >  * break FileName:FunctionName，在FileName文件的FunctionName函数的入口处添加断点；\n    >  * break -/+offset，在当前程序暂停位置的前/后 offset 行处下断点；\n    >  * break ... if cond，下条件断点；\n\n 2. run 运行程序\n    \n    > 启用GDB调试只是附加了一个调试文件，并没有启动这个程序，需要输入run命令（简写为r）启动这个程序\n\n 3. next/step 步过/步入\n    \n    >  * next 是 单步步过（step over），即遇到函数直接跳过，不进入函数内部。\n    > \n    >  * step 是 单步步入（step into），即遇到函数会进入函数内部。\n\n 4. print 查看变量值\n    \n    >  * print param，用于在调试过程中查看变量的值；\n    >  * print param=value，用于在调试过程中修改变量的值；\n    >  * print a+b+c，可以进行一定的表达式计算，这里是计算a、b、c三个变量之和；\n    >  * print func()，输出func函数执行的结果，常见的用途是打印系统函数执行失败原因：print strerror(errno)；\n    >  * *print this，在c++对象中，可以输出当前对象的各成员变量的值；\n    >  * print arrname@arrlen，输出数组 arrname\n\n 5. list 显示源码上下文\n    \n    >  * list，输出上一次list命令显示的代码后面的代码，如果是第一次执行list命令，则会显示当前正在执行代码位置附近的代码；\n    > \n    >  * list -，带一个减号，显示上一次list命令显示的代码前面的代码；\n    > \n    >  * list LineNo，显示当前代码文件第 LineNo 行附近的代码；\n    > \n    >  * list FileName:LineNo，显示 FileName 文件第 LineNo 行附近的代码；\n    > \n    >  * list FunctionName，显示当前文件的 FunctionName 函数附近的代码；\n    > \n    >  * list FileName:FunctionName，显示 FileName 文件的 FunctionName 函数附件的代码；\n    > \n    >  * list from,to，其中from和to是具体的代码位置，显示这之间的代码；\n    > \n    > list命令默认只会输出 10 行源代码，也可以使用如下命令修改：\n    > \n    >  * show listsize，查看 list 命令显示的代码行数；\n    >  * set listsize count，设置 list 命令显示的代码行数为 count;\n\n\n# 1.3 GDB 基础调试实例\n\n下面结合一个例子熟悉常用的 gdb 调试命令，例子如下：\n\n代码定义了一个静态整型变量param，并初始化为1。\n\n然后定义了两个分别名为func1和func2的函数，它接收两个参数 var和val，并试图在 将 var的值修改为val。但是func1中形参是值传递，函数外部无法实现参数值的修改；func2中形参是引用传递，能够完成参数值修改。\n\n最后定义了主函数main，调用func函数，将i的值改为1，并将param加上i的值。\n\n#include<stdio.h>\n\nstatic int param = 1;\n\nvoid func1(int var, int val){\n    var = val;\n    printf("function func1 has been called!");\n}\n\nvoid func2(int *var, int val){\n    *var = val;\n    printf("function func2 has been called!");\n}\n\nint main(){\n\n    int i = 0;\n    func1(i, 1);\n    func2(&i, 1);\n    param += i;\n    printf("function main has been called!");\n\n    return 0;\n}\n\n\n首先编译该程序并启用 GDB 调试\n\n$ gcc -g basic.c -o basic\n$ gdb basic \nGNU gdb (Ubuntu 12.1-0ubuntu1~22.04) 12.1\nCopyright (C) 2022 Free Software Foundation, Inc.\nLicense GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>\nThis is free software: you are free to change and redistribute it.\nThere is NO WARRANTY, to the extent permitted by law.\nType "show copying" and "show warranty" for details.\nThis GDB was configured as "x86_64-linux-gnu".\nType "show configuration" for configuration details.\nFor bug reporting instructions, please see:\n<https://www.gnu.org/software/gdb/bugs/>.\nFind the GDB manual and other documentation resources online at:\n    <http://www.gnu.org/software/gdb/documentation/>.\n\nFor help, type "help".\nType "apropos word" to search for commands related to "word"...\nReading symbols from basic...\n\n\n使用 b 命令将断点打在 main 函数入口，并使用 r 命令运行程序\n\n(gdb) b main\nBreakpoint 1 at 0x11d7: file basic.c, line 15.\n(gdb) r\nStarting program: /home/randy/study/dev-tool/gdb/basic \n[Thread debugging using libthread_db enabled]\nUsing host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".\n\nBreakpoint 1, main () at basic.c:15\n15      int main(){\n\n\n使用 n 命令执行下一行语句，遇到函数直接跳过不进入；使用 s 命令步入函数 func1(i,1);，并使用 l 命令查看当前语句在源码中的上下文。\n\n(gdb) n\n17          int i = 0;\n(gdb) \n18          func1(i, 1);\n(gdb) s\nfunc1 (var=0, val=1) at basic.c:6\n6           var = val;\n(gdb) l\n1       #include<stdio.h>\n2\n3       static int param = 1;\n4\n5       void func1(int var, int val){\n6           var = val;\n7           printf("function func1 has been called!");\n8       }\n9\n10      void func2(int *var, int val){\n\n\n使用 p 命令查看 func1(var, val) 中 var 在修改前后的值，并查看在 func1 函数执行完成之后，传入的实参 i 的值未完成修改，仍为 0；\n\n(gdb) p var\n$1 = 0\n(gdb) n\n7           printf("function func1 has been called!");\n(gdb) p var\n$2 = 1\n(gdb) n\n8       }\n(gdb) \nmain () at basic.c:19\n19          func2(&i, 1);\n(gdb) p i\n$3 = 0\n\n\n使用 n 命令步过可以完成 i 值修改的函数 func2，并查看修改之后的值为 1\n\n(gdb) \nmain () at basic.c:19\n19          func2(&i, 1);\n(gdb) p i\n$3 = 0\n(gdb) n\n20          param += i;\n(gdb) p i\n$4 = 1\n(gdb) p param\n$5 = 1\n(gdb) n\n21          printf("function main has been called!");\n(gdb) p param\n$6 = 2\n(gdb) n\n23          return 0;\n(gdb) n\n24      }\n\n\n上述完整 gdb 调试过程如下：\n\n$ gdb gcc -g basic.c -o basic   \n$ gdb gdb basic \nGNU gdb (Ubuntu 12.1-0ubuntu1~22.04) 12.1\nCopyright (C) 2022 Free Software Foundation, Inc.\nLicense GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>\nThis is free software: you are free to change and redistribute it.\nThere is NO WARRANTY, to the extent permitted by law.\nType "show copying" and "show warranty" for details.\nThis GDB was configured as "x86_64-linux-gnu".\nType "show configuration" for configuration details.\nFor bug reporting instructions, please see:\n<https://www.gnu.org/software/gdb/bugs/>.\nFind the GDB manual and other documentation resources online at:\n--Type <RET> for more, q to quit, c to continue without paging--\n    <http://www.gnu.org/software/gdb/documentation/>.\n\nFor help, type "help".\nType "apropos word" to search for commands related to "word"...\nReading symbols from basic...\n(gdb) b main\nBreakpoint 1 at 0x11d7: file basic.c, line 15.\n(gdb) r\nStarting program: /home/randy/study/dev-tool/gdb/basic \n[Thread debugging using libthread_db enabled]\nUsing host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".\n\nBreakpoint 1, main () at basic.c:15\n15      int main(){\n(gdb) n\n17          int i = 0;\n(gdb) \n18          func1(i, 1);\n(gdb) s\nfunc1 (var=0, val=1) at basic.c:6\n6           var = val;\n(gdb) l\n1       #include<stdio.h>\n2\n3       static int param = 1;\n4\n5       void func1(int var, int val){\n6           var = val;\n7           printf("function func1 has been called!");\n8       }\n9\n10      void func2(int *var, int val){\n(gdb) p var\n$1 = 0\n(gdb) n\n7           printf("function func1 has been called!");\n(gdb) p var\n$2 = 1\n(gdb) n\n8       }\n(gdb) \nmain () at basic.c:19\n19          func2(&i, 1);\n(gdb) p i\n$3 = 0\n(gdb) n\n20          param += i;\n(gdb) p i\n$4 = 1\n(gdb) p param\n$5 = 1\n(gdb) n\n21          printf("function main has been called!");\n(gdb) p param\n$6 = 2\n(gdb) n\n23          return 0;\n(gdb) n\n24      }\n(gdb) n\n\n\n\n# 02 GDB 调试多进程程序\n\n\n# 2.1 多进程调试中常用的 GDB 命令\n\n命令名称                   命令缩写   命令说明\nset follow-fork-mode          设置需要跟踪的子进程\nset detach-on-fork            设置在程序运行时是否将调试器与进程分离\nattach                        附加到正在运行的进程进行调试\ndetach                        从正在调试的进程中分离gdb调试器\ninferior                      切换到另一个进程上下文进行调试\ncontinue               c      继续执行程序，直到下一个断点或程序结束\nbacktrace              bt     显示函数调用栈\nframe                  f      切换到指定堆栈\nset args                      设置程序启动命令行参数\nshow args                     查看设置的命令行参数\n\n 1. set follow-fork-mode [parent/child] 指定需要跟踪的子进程\n    \n    > set follow-fork-mode命令必须在程序开始执行前设置才能生效。如果在程序启动后再设置该命令，则不会影响当前正在进行的调试会话。该命令 set follow-fork-mode MODE 可以指定以下三种模式：\n    > \n    >  * parent：只跟踪父进程，fork 之后继续调试父进程，子进程不受影响\n    >  * child：只跟踪子进程，fork之后调试子进程，父进程不受影响\n    >  * ask：每次 fork 时询问用户选择\n\n 2. set detach-on-fork [on/off]是否将调试器与进程分离\n    \n    >  * on， 调试器将与新进程分离，以便在进程创建新进程时能够安全地停止和调试新进程，原进程会继续执行，直到调试器与新进程分离为止\n    > \n    >  * off，调试器将与新进程紧密关联，一直跟随新进程的执行，原进程不会等待新进程完成复制执行环境后才会重新启动\n\n 3. attach/detach 附加/分离指定进程\n    \n    >  * attach [PID]， 让 gdb 附加到已经在运行的进程上进行调试\n    > \n    >  * detach [PID]，从正在调试的进程中分离gdb调试器\n\n 4. inferior 切换到不同的进程上下文进行调试\n    \n    > inferior [PID | PNAME]，其中PID为进程编号，PNAME为进程名称。\n\n 5. continue 终端程序后继续执行\n    \n    > 当GDB触发断点或者使用 Ctrl + C 命令中断下来后，想让程序继续运行，只要输入 continue（简写为c）命令即可\n\n 6. bt/f 显示/切换函数调用栈\n    \n    >  * backtrace，也可简写为 bt，用于查看当前调用堆栈\n    >  * frame 堆栈编号，也可简写为 f 堆栈编号，用于切换到其他堆栈处\n\n 7. set/show args 设置/查看命令行参数\n    \n    >  * set args args1，设置单个启动参数 args1；\n    >  * set args "-p" "password"，如果单个参数之间有空格，可以使用引号将参数包裹起来；\n    >  * set args args1 args2 args3，设置多个启动参数，参数之间用空格隔开；\n    >  * set args，不带参数，则清除之前设置的参数；\n\n\n# 2.2 GDB 多进程调试实例\n\n下面结合一个例子介绍 gdb 调试多进程程序，例子如下：\n\n程序首先创建了一个管道，然后通过fork()函数创建了两个子进程。\n\n在第一个子进程中，它向管道的写端写入了一条消息，然后退出；在第二个子进程中，它从管道的读端读取了这条消息，并将其打印出来，然后退出。\n\n父进程在创建完子进程后，关闭了管道的读端和写端，并分别等待两个子进程结束。\n\n当两个子进程都结束时，父进程才会继续执行，并打印一条消息表示所有子进程都已完成。\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <string.h>\n#include <sys/wait.h>\n\nint main() {\n    int pipefd[2];  // 管道描述符数组\n    pid_t pid1, pid2;  // 子进程ID变量\n\n    if (pipe(pipefd) == -1) {  // 创建管道\n        perror("pipe");\n        exit(EXIT_FAILURE);\n    }\n\n    pid1 = fork();  // 创建第一个子进程\n    if (pid1 == -1) {\n        perror("fork");\n        exit(EXIT_FAILURE);\n    }\n\n    if (pid1 == 0) {  // 在第一个子进程中\n        close(pipefd[0]);  // 关闭读端\n        char msg[] = "Hello, I\'m child process 1!";\n        write(pipefd[1], msg, strlen(msg));  // 向写端写入消息\n        close(pipefd[1]);  // 关闭写端\n        exit(EXIT_SUCCESS);\n    } \n\n    pid2 = fork();  // 创建第二个子进程\n    if (pid2 == -1) {\n        perror("fork");\n        exit(EXIT_FAILURE);\n    }\n\n    if (pid2 == 0) {  // 在第二个子进程中\n        close(pipefd[1]);  // 关闭写端\n        char buf[1024];\n        read(pipefd[0], buf, sizeof(buf));  // 从读端读取消息\n        printf("This is child process 2. Received message from child process 1: %s\\n", buf);\n        close(pipefd[0]);  // 关闭读端\n        exit(EXIT_SUCCESS);\n    }\n\n    // 父进程中\n    close(pipefd[0]);  // 关闭读端\n    close(pipefd[1]);  // 关闭写端\n    waitpid(pid1, NULL, 0);  // 等待第一个子进程结束\n    waitpid(pid2, NULL, 0);  // 等待第二个子进程结束\n    printf("All child processes have completed.\\n");\n\n    return 0;\n}\n\n\n\n# 2.2.1 调试父进程\n\n首先编译该程序并启用 GDB 调试\n\n$ gdb gcc -g multi_process.c -o multi_process   \n$ gdb gdb multi_process \nGNU gdb (Ubuntu 12.1-0ubuntu1~22.04) 12.1\nCopyright (C) 2022 Free Software Foundation, Inc.\nLicense GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>\nThis is free software: you are free to change and redistribute it.\nThere is NO WARRANTY, to the extent permitted by law.\nType "show copying" and "show warranty" for details.\nThis GDB was configured as "x86_64-linux-gnu".\nType "show configuration" for configuration details.\nFor bug reporting instructions, please see:\n<https://www.gnu.org/software/gdb/bugs/>.\nFind the GDB manual and other documentation resources online at:\n    <http://www.gnu.org/software/gdb/documentation/>.\n\nFor help, type "help".\nType "apropos word" to search for commands related to "word"...\nReading symbols from multi_process...\n\n\nset follow-fork-mode parent 设置仅跟踪父进程（也可以直接跳过这个步骤，默认 parent）；使用 b 命令将断点打在 main 函数入口；并使用 r 命令运行程序。\n\n(gdb) set follow-fork-mode parent\n(gdb) b main\nBreakpoint 1 at 0x4007f8: file multi_process.c, line 11.\n(gdb) r\nStarting program: /home/randy/study/dev-tool/gdb/multi_process \n[Thread debugging using libthread_db enabled]\nUsing host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".\n\nBreakpoint 1, main () at multi_process.c:7\n7       int main() {\n\n\n\n使用 n 命令单步执行，查看程序执行情况，可以看到第一个子进程在被 fork 成功之后就从 gdb 调试中分离并继续执行了 [Detaching after fork from child process 20228]\n\n(gdb) n\n16          pid1 = fork();  // 创建第一个子进程\n(gdb) p pid1\n$1 = 0\n(gdb) n\n[Detaching after fork from child process 20228]\n17          if (pid1 == -1) {\n(gdb) \n22          if (pid1 == 0) {  // 在第一个子进程中\n\n\n同样的继续使用 n 命令单步执行，可以看到第二个子进程在被 fork 成功之后也从 gdb 调试中分离 [Detaching after fork from child process 20415]\n\n(gdb) \n30          pid2 = fork();  // 创建第二个子进程\n(gdb) p pid2\n$2 = 0\n(gdb) n\n[Detaching after fork from child process 20415]\n# 第二个子进程执行完成读取第一个子进程发送的消息并打印如下输出\nThis is child process 2. Received message from child process 1: Hello, I\'m child process 1!\n31          if (pid2 == -1) {\n(gdb) \n36          if (pid2 == 0) {  // 在第二个子进程中\n(gdb) \n46          close(pipefd[0]);  // 关闭读端\n(gdb) \n47          close(pipefd[1]);  // 关闭写端\n(gdb) \n48          waitpid(pid1, NULL, 0);  // 等待第一个子进程结束\n(gdb) \n49          waitpid(pid2, NULL, 0);  // 等待第二个子进程结束\n(gdb) \n50          printf("All child processes have completed.\\n");\n(gdb) \nAll child processes have completed.\n52          return 0;\n\n\n\n# 2.2.2 调试第一个子进程\n\n首先编译该程序并启用 GDB 调试\n\n$ gdb gcc -g multi_process.c -o multi_process   \n$ gdb gdb multi_process \nGNU gdb (Ubuntu 12.1-0ubuntu1~22.04) 12.1\nCopyright (C) 2022 Free Software Foundation, Inc.\nLicense GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>\nThis is free software: you are free to change and redistribute it.\nThere is NO WARRANTY, to the extent permitted by law.\nType "show copying" and "show warranty" for details.\nThis GDB was configured as "x86_64-linux-gnu".\nType "show configuration" for configuration details.\nFor bug reporting instructions, please see:\n<https://www.gnu.org/software/gdb/bugs/>.\nFind the GDB manual and other documentation resources online at:\n    <http://www.gnu.org/software/gdb/documentation/>.\n\nFor help, type "help".\nType "apropos word" to search for commands related to "word"...\nReading symbols from multi_process...\n\n\nset follow-fork-mode child 设置跟踪子进程，使用 b 命令将断点打在 main 函数入口，并使用 r 命令运行程序\n\n(gdb) set follow-fork-mode child\n(gdb) b main\nBreakpoint 1 at 0x12b8: file multi_process.c, line 7.\n(gdb) r\nStarting program: /home/randy/study/dev-tool/gdb/multi_process \n[Thread debugging using libthread_db enabled]\nUsing host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".\n\nBreakpoint 1, main () at multi_process.c:7\n7       int main() {\n\n\nn 单步执行程序，直到第一个子进程 pid1=0\n\n(gdb) n\n11          if (pipe(pipefd) == -1) {  // 创建管道\n(gdb) \n16          pid1 = fork();  // 创建第一个子进程\n(gdb) p pid1\n$1 = 0\n(gdb) n\n[Attaching after Thread 0x7ffff7d8c740 (LWP 5001) fork to child process 5166] # 表示gdb正在附加到一个已经fork出子进程的父进程中\n[New inferior 2 (process 5166)] # 表示gdb创建了一个新的被调试进程，并将其编号设置为2，该进程的PID为5166\n[Detaching after fork from parent process 5001] # 表示gdb从父进程中分离出子进程，将其作为独立的被调试进程进行调试\n[Inferior 1 (process 5001) detached] # 表示gdb已经从原始的父进程中分离出来，成为一个独立的进程（或线程）控制器。由于该进程的编号为1，因此显示为Inferior 1\n[Thread debugging using libthread_db enabled] # 表示gdb使用libthread_db库来进行线程调试\nUsing host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".\n[Switching to Thread 0x7ffff7d8c740 (LWP 5166)] # 表示gdb正在切换到子进程的线程上进行调试\nmain () at multi_process.c:17\n17          if (pid1 == -1) {\n\n\n在子进程中 使用 n 命令单步执行并观察变量值，由于 set follow-fork-mode child 只跟踪子进程，在上一步中 [Inferior 1 (process 5001) detached] 表示 gdb 已经将父进程分离并继续执行，所以在下面的内容中第一个子进程写完消息之后，第二个子进程就收到了消息并在打印后退出了。\n\n(gdb) n\n22          if (pid1 == 0) {  // 在第一个子进程中\n(gdb) \n23              close(pipefd[0]);  // 关闭读端\n(gdb) \n24              char msg[] = "Hello, I\'m child process 1!";\n(gdb) p msg\n$1 = "`\\317\\377\\367\\377\\177\\000\\000\\330J\\374\\367\\377\\177\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\060\\334\\377\\377"\n(gdb) n\n25              write(pipefd[1], msg, strlen(msg));  // 向写端写入消息\n(gdb) \nThis is child process 2. Received message from child process 1: Hello, I\'m child process 1!\n26              close(pipefd[1]);  // 关闭写端\n(gdb) \n27              exit(EXIT_SUCCESS);\n(gdb) \n[Inferior 2 (process 6971) exited normally]\nAll child processes have completed.\n\n\n\n# 2.2.3 调试第二个子进程\n\n首先编译该程序并启用 GDB 调试\n\n$ gdb gcc -g multi_process.c -o multi_process   \n$ gdb gdb multi_process \nGNU gdb (Ubuntu 12.1-0ubuntu1~22.04) 12.1\nCopyright (C) 2022 Free Software Foundation, Inc.\nLicense GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>\nThis is free software: you are free to change and redistribute it.\nThere is NO WARRANTY, to the extent permitted by law.\nType "show copying" and "show warranty" for details.\nThis GDB was configured as "x86_64-linux-gnu".\nType "show configuration" for configuration details.\nFor bug reporting instructions, please see:\n<https://www.gnu.org/software/gdb/bugs/>.\nFind the GDB manual and other documentation resources online at:\n    <http://www.gnu.org/software/gdb/documentation/>.\n\nFor help, type "help".\nType "apropos word" to search for commands related to "word"...\nReading symbols from multi_process...\n\n\n先设置跟踪父进程 set follow-fork-mode parent 来跳过第一个子进程的 fork 操作；使用 b 命令将断点打在创建第二个子进程的 fork 函数之前；并使用 r 命令运行程序。\n\n(gdb) set follow-fork-mode parent\n(gdb) b multi_process.c:22\nBreakpoint 1 at 0x40083f: file multi_process.c, line 22.\n(gdb) r\nStarting program: /home/randy/study/dev-tool/gdb/multi_process \n[Detaching after fork from child process 25249] # 分离第一个子进程\n\nBreakpoint 1, main () at multi_process.c:22\n22          if (pid1 == 0) {  // 在第一个子进程中\n\n\n在继续执行程序前 set follow-fork-mode child 设置 gdb 调试跟踪子进程，然后再使用 n 命令单步执行 fork 创建第二个子进程，可以看到第二个子进程在被 fork 成功之后，gdb 调试就分离的父进程，并切换到第二个子进程中。\n\n(gdb) set follow-fork-mode child\n(gdb) n\n30          pid2 = fork();  // 创建第二个子进程\n(gdb) n\n[Attaching after process 25358 fork to child process 25358]\n[New inferior 2 (process 25358)]\n[Detaching after fork from parent process 25245]\n[Inferior 1 (process 25245) detached] # 已经分离父进程\n[Switching to process 25358] # 切换到第二个子进程\n31          if (pid2 == -1) {\n\n\n进入第二个子进程后，就可以使用 n 命令单步执行程序，使用 p 命令查看变量值。\n\n(gdb) n\n36          if (pid2 == 0) {  // 在第二个子进程中\n(gdb) p pid2\n$1 = 0\n(gdb) n\n37              close(pipefd[1]);  // 关闭写端\n(gdb) n\n39              read(pipefd[0], buf, sizeof(buf));  // 从读端读取消息\n(gdb) n\n40              printf("This is child process 2. Received message from child process 1: %s\\n", buf);\n(gdb) p buf\n$2 = "Hello, I\'m child process 1!", \'\\000\' <repeats 477 times>...\n(gdb) n\nThis is child process 2. Received message from child process 1: Hello, I\'m child process 1!\n41              close(pipefd[0]);  // 关闭读端\n(gdb) n\n42              exit(EXIT_SUCCESS);\n(gdb) \n[Inferior 2 (process 25358) exited normally]\nAll child processes have completed.\n',normalizedContent:'# 01 gdb 基础调试\n\n> reference:\n> \n> 学习使用 gdb 调试代码 | linux 中国 - 知乎 (zhihu.com)\n> \n> gdb使用详解 - 知乎 (zhihu.com)\n> \n> gdb documentation\n> \n> 使用 gdb 调试多进程程序 - 简书\n\ngdb 全称“gnu symbolic debugger”是 linux 下常用的程序调试器，当下的 gdb 支持调试多种编程语言编写的程序，包括 c、c++、go、objective-c、opencl、ada 等。\n\n\n# 1.1 基础使用\n\n 1. 安装工具\n\n# 安装 gcc\nsudo yum install gcc\n# 安装 g++\nsudo yum install gcc-c++ \n# 安装 gdb\nsudo yum install gdb\n\n\n 2. 编译程序\n\ngcc -g basic.c -o basic\n\n\n使用gdb调试程序，编译程序的过程中需要注意以下两点：\n\n 1. 要使用gdb调试某个程序，该程序编译时需要加上编译选项 -g，否则编译生成的程序是不包含调试信息的；\n 2. gcc编译器支持 -o 和 -g 一起参与编译，关闭编译器的程序优化选项。gcc编译过程对进行优化的程度分为5个等级：-o/o0, -o1, -o2, -o3, -os，调试时一般选择默认选项 -o 不做任何优化。\n\n> 调试信息：reference: gdb调试信息与调试原理 - 知乎 (zhihu.com)\n> \n> 如果编译命令中不加 -g 选项，在编译后的程序中不会保留调试符号信息。\n> \n> 加不加该选项在启用 gdb 调试时存在明显区别\n> \n> gdb basic\n> \n> \n> （1）不加 -g 选项，尾行打印内容为\n> \n> reading symbols from basic...(no debugging symbols found in basic)\n> \n> \n> （2）加 -g 选项，尾行打印内容为\n> \n> reading symbols from basic...\n> \n> \n> 可以看到，不加 -g 选项会直接提示程序不包含调试信息 no debugging symbols found in basic\n\n 3. 启动 gdb 调试\n\ngdb调试主要有三种方式：\n\n * 直接调试目标程序：gdb ./basic\n\n * 附加进程id：gdb attach pid\n\n * 调试core文件：gdb filename corename\n\n 4. 退出 gdb 调试\n\n * 可以用命令：q（quit的缩写）或者 ctr + d 退出 gdb。\n\n * 如果gdb attach某个进程，退出gdb之前要用命令 detach 解除附加进程。\n\n\n# 1.2 常用命令\n\n> 本节内容转自：gdb使用详解 - 知乎 (zhihu.com)\n\n命令名称          命令缩写        命令说明\nrun           r           运行一个待调试的程序\ncontinue      c           让暂停的程序继续运行\nnext          n           运行到下一行\nstep          s           单步执行，遇到函数会进入\nuntil         u           运行到指定行停下来\nfinish        fi          结束当前调用函数，回到上一层调用函数处\nreturn        return      结束当前调用函数并返回指定值，到上一层函数调用处\njump          j           将当前程序执行流跳转到指定行或地址\nprint         p           打印变量或寄存器值\nbacktrace     bt          查看当前线程的调用堆栈\nframe         f           切换到当前调用线程的指定堆栈\nthread        thread      切换到指定线程\nbreak         b           添加断点\ntbreak        tb          添加临时断点\ndelete        d           删除断点\nenable        enable      启用某个断点\ndisable       disable     禁用某个断点\nwatch         watch       监视某一个变量或内存地址的值是否发生变化\nlist          l           显示源码\ninfo          i           查看断点 / 线程等信息\nptype         ptype       查看变量类型\ndisassemble   dis         查看汇编代码\nset args      set args    设置程序启动命令行参数\nshow args     show args   查看设置的命令行参数\n\n一般调试中最为常用的命令，gdb 语法糖直接回车重复执行上一条命令。\n\n命令名称    命令缩写   命令说明\nbreak   b      添加断点\nrun     r      运行一个待调试的程序\nnext    n      运行到下一行（步过）\nstep    s      单步执行，遇到函数会进入（步入）\nprint   p      打印变量或寄存器值\nlist    l      显示当前正在执行代码位置附近的代码\n\n 1. break 打断点\n    \n    >  * break functionname，在函数的入口处添加一个断点；\n    >  * break lineno，在当前文件行号为lineno处添加断点；\n    >  * break filename:lineno，在filename文件行号为lineno处添加一个断点；\n    >  * break filename:functionname，在filename文件的functionname函数的入口处添加断点；\n    >  * break -/+offset，在当前程序暂停位置的前/后 offset 行处下断点；\n    >  * break ... if cond，下条件断点；\n\n 2. run 运行程序\n    \n    > 启用gdb调试只是附加了一个调试文件，并没有启动这个程序，需要输入run命令（简写为r）启动这个程序\n\n 3. next/step 步过/步入\n    \n    >  * next 是 单步步过（step over），即遇到函数直接跳过，不进入函数内部。\n    > \n    >  * step 是 单步步入（step into），即遇到函数会进入函数内部。\n\n 4. print 查看变量值\n    \n    >  * print param，用于在调试过程中查看变量的值；\n    >  * print param=value，用于在调试过程中修改变量的值；\n    >  * print a+b+c，可以进行一定的表达式计算，这里是计算a、b、c三个变量之和；\n    >  * print func()，输出func函数执行的结果，常见的用途是打印系统函数执行失败原因：print strerror(errno)；\n    >  * *print this，在c++对象中，可以输出当前对象的各成员变量的值；\n    >  * print arrname@arrlen，输出数组 arrname\n\n 5. list 显示源码上下文\n    \n    >  * list，输出上一次list命令显示的代码后面的代码，如果是第一次执行list命令，则会显示当前正在执行代码位置附近的代码；\n    > \n    >  * list -，带一个减号，显示上一次list命令显示的代码前面的代码；\n    > \n    >  * list lineno，显示当前代码文件第 lineno 行附近的代码；\n    > \n    >  * list filename:lineno，显示 filename 文件第 lineno 行附近的代码；\n    > \n    >  * list functionname，显示当前文件的 functionname 函数附近的代码；\n    > \n    >  * list filename:functionname，显示 filename 文件的 functionname 函数附件的代码；\n    > \n    >  * list from,to，其中from和to是具体的代码位置，显示这之间的代码；\n    > \n    > list命令默认只会输出 10 行源代码，也可以使用如下命令修改：\n    > \n    >  * show listsize，查看 list 命令显示的代码行数；\n    >  * set listsize count，设置 list 命令显示的代码行数为 count;\n\n\n# 1.3 gdb 基础调试实例\n\n下面结合一个例子熟悉常用的 gdb 调试命令，例子如下：\n\n代码定义了一个静态整型变量param，并初始化为1。\n\n然后定义了两个分别名为func1和func2的函数，它接收两个参数 var和val，并试图在 将 var的值修改为val。但是func1中形参是值传递，函数外部无法实现参数值的修改；func2中形参是引用传递，能够完成参数值修改。\n\n最后定义了主函数main，调用func函数，将i的值改为1，并将param加上i的值。\n\n#include<stdio.h>\n\nstatic int param = 1;\n\nvoid func1(int var, int val){\n    var = val;\n    printf("function func1 has been called!");\n}\n\nvoid func2(int *var, int val){\n    *var = val;\n    printf("function func2 has been called!");\n}\n\nint main(){\n\n    int i = 0;\n    func1(i, 1);\n    func2(&i, 1);\n    param += i;\n    printf("function main has been called!");\n\n    return 0;\n}\n\n\n首先编译该程序并启用 gdb 调试\n\n$ gcc -g basic.c -o basic\n$ gdb basic \ngnu gdb (ubuntu 12.1-0ubuntu1~22.04) 12.1\ncopyright (c) 2022 free software foundation, inc.\nlicense gplv3+: gnu gpl version 3 or later <http://gnu.org/licenses/gpl.html>\nthis is free software: you are free to change and redistribute it.\nthere is no warranty, to the extent permitted by law.\ntype "show copying" and "show warranty" for details.\nthis gdb was configured as "x86_64-linux-gnu".\ntype "show configuration" for configuration details.\nfor bug reporting instructions, please see:\n<https://www.gnu.org/software/gdb/bugs/>.\nfind the gdb manual and other documentation resources online at:\n    <http://www.gnu.org/software/gdb/documentation/>.\n\nfor help, type "help".\ntype "apropos word" to search for commands related to "word"...\nreading symbols from basic...\n\n\n使用 b 命令将断点打在 main 函数入口，并使用 r 命令运行程序\n\n(gdb) b main\nbreakpoint 1 at 0x11d7: file basic.c, line 15.\n(gdb) r\nstarting program: /home/randy/study/dev-tool/gdb/basic \n[thread debugging using libthread_db enabled]\nusing host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".\n\nbreakpoint 1, main () at basic.c:15\n15      int main(){\n\n\n使用 n 命令执行下一行语句，遇到函数直接跳过不进入；使用 s 命令步入函数 func1(i,1);，并使用 l 命令查看当前语句在源码中的上下文。\n\n(gdb) n\n17          int i = 0;\n(gdb) \n18          func1(i, 1);\n(gdb) s\nfunc1 (var=0, val=1) at basic.c:6\n6           var = val;\n(gdb) l\n1       #include<stdio.h>\n2\n3       static int param = 1;\n4\n5       void func1(int var, int val){\n6           var = val;\n7           printf("function func1 has been called!");\n8       }\n9\n10      void func2(int *var, int val){\n\n\n使用 p 命令查看 func1(var, val) 中 var 在修改前后的值，并查看在 func1 函数执行完成之后，传入的实参 i 的值未完成修改，仍为 0；\n\n(gdb) p var\n$1 = 0\n(gdb) n\n7           printf("function func1 has been called!");\n(gdb) p var\n$2 = 1\n(gdb) n\n8       }\n(gdb) \nmain () at basic.c:19\n19          func2(&i, 1);\n(gdb) p i\n$3 = 0\n\n\n使用 n 命令步过可以完成 i 值修改的函数 func2，并查看修改之后的值为 1\n\n(gdb) \nmain () at basic.c:19\n19          func2(&i, 1);\n(gdb) p i\n$3 = 0\n(gdb) n\n20          param += i;\n(gdb) p i\n$4 = 1\n(gdb) p param\n$5 = 1\n(gdb) n\n21          printf("function main has been called!");\n(gdb) p param\n$6 = 2\n(gdb) n\n23          return 0;\n(gdb) n\n24      }\n\n\n上述完整 gdb 调试过程如下：\n\n$ gdb gcc -g basic.c -o basic   \n$ gdb gdb basic \ngnu gdb (ubuntu 12.1-0ubuntu1~22.04) 12.1\ncopyright (c) 2022 free software foundation, inc.\nlicense gplv3+: gnu gpl version 3 or later <http://gnu.org/licenses/gpl.html>\nthis is free software: you are free to change and redistribute it.\nthere is no warranty, to the extent permitted by law.\ntype "show copying" and "show warranty" for details.\nthis gdb was configured as "x86_64-linux-gnu".\ntype "show configuration" for configuration details.\nfor bug reporting instructions, please see:\n<https://www.gnu.org/software/gdb/bugs/>.\nfind the gdb manual and other documentation resources online at:\n--type <ret> for more, q to quit, c to continue without paging--\n    <http://www.gnu.org/software/gdb/documentation/>.\n\nfor help, type "help".\ntype "apropos word" to search for commands related to "word"...\nreading symbols from basic...\n(gdb) b main\nbreakpoint 1 at 0x11d7: file basic.c, line 15.\n(gdb) r\nstarting program: /home/randy/study/dev-tool/gdb/basic \n[thread debugging using libthread_db enabled]\nusing host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".\n\nbreakpoint 1, main () at basic.c:15\n15      int main(){\n(gdb) n\n17          int i = 0;\n(gdb) \n18          func1(i, 1);\n(gdb) s\nfunc1 (var=0, val=1) at basic.c:6\n6           var = val;\n(gdb) l\n1       #include<stdio.h>\n2\n3       static int param = 1;\n4\n5       void func1(int var, int val){\n6           var = val;\n7           printf("function func1 has been called!");\n8       }\n9\n10      void func2(int *var, int val){\n(gdb) p var\n$1 = 0\n(gdb) n\n7           printf("function func1 has been called!");\n(gdb) p var\n$2 = 1\n(gdb) n\n8       }\n(gdb) \nmain () at basic.c:19\n19          func2(&i, 1);\n(gdb) p i\n$3 = 0\n(gdb) n\n20          param += i;\n(gdb) p i\n$4 = 1\n(gdb) p param\n$5 = 1\n(gdb) n\n21          printf("function main has been called!");\n(gdb) p param\n$6 = 2\n(gdb) n\n23          return 0;\n(gdb) n\n24      }\n(gdb) n\n\n\n\n# 02 gdb 调试多进程程序\n\n\n# 2.1 多进程调试中常用的 gdb 命令\n\n命令名称                   命令缩写   命令说明\nset follow-fork-mode          设置需要跟踪的子进程\nset detach-on-fork            设置在程序运行时是否将调试器与进程分离\nattach                        附加到正在运行的进程进行调试\ndetach                        从正在调试的进程中分离gdb调试器\ninferior                      切换到另一个进程上下文进行调试\ncontinue               c      继续执行程序，直到下一个断点或程序结束\nbacktrace              bt     显示函数调用栈\nframe                  f      切换到指定堆栈\nset args                      设置程序启动命令行参数\nshow args                     查看设置的命令行参数\n\n 1. set follow-fork-mode [parent/child] 指定需要跟踪的子进程\n    \n    > set follow-fork-mode命令必须在程序开始执行前设置才能生效。如果在程序启动后再设置该命令，则不会影响当前正在进行的调试会话。该命令 set follow-fork-mode mode 可以指定以下三种模式：\n    > \n    >  * parent：只跟踪父进程，fork 之后继续调试父进程，子进程不受影响\n    >  * child：只跟踪子进程，fork之后调试子进程，父进程不受影响\n    >  * ask：每次 fork 时询问用户选择\n\n 2. set detach-on-fork [on/off]是否将调试器与进程分离\n    \n    >  * on， 调试器将与新进程分离，以便在进程创建新进程时能够安全地停止和调试新进程，原进程会继续执行，直到调试器与新进程分离为止\n    > \n    >  * off，调试器将与新进程紧密关联，一直跟随新进程的执行，原进程不会等待新进程完成复制执行环境后才会重新启动\n\n 3. attach/detach 附加/分离指定进程\n    \n    >  * attach [pid]， 让 gdb 附加到已经在运行的进程上进行调试\n    > \n    >  * detach [pid]，从正在调试的进程中分离gdb调试器\n\n 4. inferior 切换到不同的进程上下文进行调试\n    \n    > inferior [pid | pname]，其中pid为进程编号，pname为进程名称。\n\n 5. continue 终端程序后继续执行\n    \n    > 当gdb触发断点或者使用 ctrl + c 命令中断下来后，想让程序继续运行，只要输入 continue（简写为c）命令即可\n\n 6. bt/f 显示/切换函数调用栈\n    \n    >  * backtrace，也可简写为 bt，用于查看当前调用堆栈\n    >  * frame 堆栈编号，也可简写为 f 堆栈编号，用于切换到其他堆栈处\n\n 7. set/show args 设置/查看命令行参数\n    \n    >  * set args args1，设置单个启动参数 args1；\n    >  * set args "-p" "password"，如果单个参数之间有空格，可以使用引号将参数包裹起来；\n    >  * set args args1 args2 args3，设置多个启动参数，参数之间用空格隔开；\n    >  * set args，不带参数，则清除之前设置的参数；\n\n\n# 2.2 gdb 多进程调试实例\n\n下面结合一个例子介绍 gdb 调试多进程程序，例子如下：\n\n程序首先创建了一个管道，然后通过fork()函数创建了两个子进程。\n\n在第一个子进程中，它向管道的写端写入了一条消息，然后退出；在第二个子进程中，它从管道的读端读取了这条消息，并将其打印出来，然后退出。\n\n父进程在创建完子进程后，关闭了管道的读端和写端，并分别等待两个子进程结束。\n\n当两个子进程都结束时，父进程才会继续执行，并打印一条消息表示所有子进程都已完成。\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <string.h>\n#include <sys/wait.h>\n\nint main() {\n    int pipefd[2];  // 管道描述符数组\n    pid_t pid1, pid2;  // 子进程id变量\n\n    if (pipe(pipefd) == -1) {  // 创建管道\n        perror("pipe");\n        exit(exit_failure);\n    }\n\n    pid1 = fork();  // 创建第一个子进程\n    if (pid1 == -1) {\n        perror("fork");\n        exit(exit_failure);\n    }\n\n    if (pid1 == 0) {  // 在第一个子进程中\n        close(pipefd[0]);  // 关闭读端\n        char msg[] = "hello, i\'m child process 1!";\n        write(pipefd[1], msg, strlen(msg));  // 向写端写入消息\n        close(pipefd[1]);  // 关闭写端\n        exit(exit_success);\n    } \n\n    pid2 = fork();  // 创建第二个子进程\n    if (pid2 == -1) {\n        perror("fork");\n        exit(exit_failure);\n    }\n\n    if (pid2 == 0) {  // 在第二个子进程中\n        close(pipefd[1]);  // 关闭写端\n        char buf[1024];\n        read(pipefd[0], buf, sizeof(buf));  // 从读端读取消息\n        printf("this is child process 2. received message from child process 1: %s\\n", buf);\n        close(pipefd[0]);  // 关闭读端\n        exit(exit_success);\n    }\n\n    // 父进程中\n    close(pipefd[0]);  // 关闭读端\n    close(pipefd[1]);  // 关闭写端\n    waitpid(pid1, null, 0);  // 等待第一个子进程结束\n    waitpid(pid2, null, 0);  // 等待第二个子进程结束\n    printf("all child processes have completed.\\n");\n\n    return 0;\n}\n\n\n\n# 2.2.1 调试父进程\n\n首先编译该程序并启用 gdb 调试\n\n$ gdb gcc -g multi_process.c -o multi_process   \n$ gdb gdb multi_process \ngnu gdb (ubuntu 12.1-0ubuntu1~22.04) 12.1\ncopyright (c) 2022 free software foundation, inc.\nlicense gplv3+: gnu gpl version 3 or later <http://gnu.org/licenses/gpl.html>\nthis is free software: you are free to change and redistribute it.\nthere is no warranty, to the extent permitted by law.\ntype "show copying" and "show warranty" for details.\nthis gdb was configured as "x86_64-linux-gnu".\ntype "show configuration" for configuration details.\nfor bug reporting instructions, please see:\n<https://www.gnu.org/software/gdb/bugs/>.\nfind the gdb manual and other documentation resources online at:\n    <http://www.gnu.org/software/gdb/documentation/>.\n\nfor help, type "help".\ntype "apropos word" to search for commands related to "word"...\nreading symbols from multi_process...\n\n\nset follow-fork-mode parent 设置仅跟踪父进程（也可以直接跳过这个步骤，默认 parent）；使用 b 命令将断点打在 main 函数入口；并使用 r 命令运行程序。\n\n(gdb) set follow-fork-mode parent\n(gdb) b main\nbreakpoint 1 at 0x4007f8: file multi_process.c, line 11.\n(gdb) r\nstarting program: /home/randy/study/dev-tool/gdb/multi_process \n[thread debugging using libthread_db enabled]\nusing host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".\n\nbreakpoint 1, main () at multi_process.c:7\n7       int main() {\n\n\n\n使用 n 命令单步执行，查看程序执行情况，可以看到第一个子进程在被 fork 成功之后就从 gdb 调试中分离并继续执行了 [detaching after fork from child process 20228]\n\n(gdb) n\n16          pid1 = fork();  // 创建第一个子进程\n(gdb) p pid1\n$1 = 0\n(gdb) n\n[detaching after fork from child process 20228]\n17          if (pid1 == -1) {\n(gdb) \n22          if (pid1 == 0) {  // 在第一个子进程中\n\n\n同样的继续使用 n 命令单步执行，可以看到第二个子进程在被 fork 成功之后也从 gdb 调试中分离 [detaching after fork from child process 20415]\n\n(gdb) \n30          pid2 = fork();  // 创建第二个子进程\n(gdb) p pid2\n$2 = 0\n(gdb) n\n[detaching after fork from child process 20415]\n# 第二个子进程执行完成读取第一个子进程发送的消息并打印如下输出\nthis is child process 2. received message from child process 1: hello, i\'m child process 1!\n31          if (pid2 == -1) {\n(gdb) \n36          if (pid2 == 0) {  // 在第二个子进程中\n(gdb) \n46          close(pipefd[0]);  // 关闭读端\n(gdb) \n47          close(pipefd[1]);  // 关闭写端\n(gdb) \n48          waitpid(pid1, null, 0);  // 等待第一个子进程结束\n(gdb) \n49          waitpid(pid2, null, 0);  // 等待第二个子进程结束\n(gdb) \n50          printf("all child processes have completed.\\n");\n(gdb) \nall child processes have completed.\n52          return 0;\n\n\n\n# 2.2.2 调试第一个子进程\n\n首先编译该程序并启用 gdb 调试\n\n$ gdb gcc -g multi_process.c -o multi_process   \n$ gdb gdb multi_process \ngnu gdb (ubuntu 12.1-0ubuntu1~22.04) 12.1\ncopyright (c) 2022 free software foundation, inc.\nlicense gplv3+: gnu gpl version 3 or later <http://gnu.org/licenses/gpl.html>\nthis is free software: you are free to change and redistribute it.\nthere is no warranty, to the extent permitted by law.\ntype "show copying" and "show warranty" for details.\nthis gdb was configured as "x86_64-linux-gnu".\ntype "show configuration" for configuration details.\nfor bug reporting instructions, please see:\n<https://www.gnu.org/software/gdb/bugs/>.\nfind the gdb manual and other documentation resources online at:\n    <http://www.gnu.org/software/gdb/documentation/>.\n\nfor help, type "help".\ntype "apropos word" to search for commands related to "word"...\nreading symbols from multi_process...\n\n\nset follow-fork-mode child 设置跟踪子进程，使用 b 命令将断点打在 main 函数入口，并使用 r 命令运行程序\n\n(gdb) set follow-fork-mode child\n(gdb) b main\nbreakpoint 1 at 0x12b8: file multi_process.c, line 7.\n(gdb) r\nstarting program: /home/randy/study/dev-tool/gdb/multi_process \n[thread debugging using libthread_db enabled]\nusing host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".\n\nbreakpoint 1, main () at multi_process.c:7\n7       int main() {\n\n\nn 单步执行程序，直到第一个子进程 pid1=0\n\n(gdb) n\n11          if (pipe(pipefd) == -1) {  // 创建管道\n(gdb) \n16          pid1 = fork();  // 创建第一个子进程\n(gdb) p pid1\n$1 = 0\n(gdb) n\n[attaching after thread 0x7ffff7d8c740 (lwp 5001) fork to child process 5166] # 表示gdb正在附加到一个已经fork出子进程的父进程中\n[new inferior 2 (process 5166)] # 表示gdb创建了一个新的被调试进程，并将其编号设置为2，该进程的pid为5166\n[detaching after fork from parent process 5001] # 表示gdb从父进程中分离出子进程，将其作为独立的被调试进程进行调试\n[inferior 1 (process 5001) detached] # 表示gdb已经从原始的父进程中分离出来，成为一个独立的进程（或线程）控制器。由于该进程的编号为1，因此显示为inferior 1\n[thread debugging using libthread_db enabled] # 表示gdb使用libthread_db库来进行线程调试\nusing host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".\n[switching to thread 0x7ffff7d8c740 (lwp 5166)] # 表示gdb正在切换到子进程的线程上进行调试\nmain () at multi_process.c:17\n17          if (pid1 == -1) {\n\n\n在子进程中 使用 n 命令单步执行并观察变量值，由于 set follow-fork-mode child 只跟踪子进程，在上一步中 [inferior 1 (process 5001) detached] 表示 gdb 已经将父进程分离并继续执行，所以在下面的内容中第一个子进程写完消息之后，第二个子进程就收到了消息并在打印后退出了。\n\n(gdb) n\n22          if (pid1 == 0) {  // 在第一个子进程中\n(gdb) \n23              close(pipefd[0]);  // 关闭读端\n(gdb) \n24              char msg[] = "hello, i\'m child process 1!";\n(gdb) p msg\n$1 = "`\\317\\377\\367\\377\\177\\000\\000\\330j\\374\\367\\377\\177\\000\\000\\000\\000\\000\\000\\000\\000\\000\\000\\060\\334\\377\\377"\n(gdb) n\n25              write(pipefd[1], msg, strlen(msg));  // 向写端写入消息\n(gdb) \nthis is child process 2. received message from child process 1: hello, i\'m child process 1!\n26              close(pipefd[1]);  // 关闭写端\n(gdb) \n27              exit(exit_success);\n(gdb) \n[inferior 2 (process 6971) exited normally]\nall child processes have completed.\n\n\n\n# 2.2.3 调试第二个子进程\n\n首先编译该程序并启用 gdb 调试\n\n$ gdb gcc -g multi_process.c -o multi_process   \n$ gdb gdb multi_process \ngnu gdb (ubuntu 12.1-0ubuntu1~22.04) 12.1\ncopyright (c) 2022 free software foundation, inc.\nlicense gplv3+: gnu gpl version 3 or later <http://gnu.org/licenses/gpl.html>\nthis is free software: you are free to change and redistribute it.\nthere is no warranty, to the extent permitted by law.\ntype "show copying" and "show warranty" for details.\nthis gdb was configured as "x86_64-linux-gnu".\ntype "show configuration" for configuration details.\nfor bug reporting instructions, please see:\n<https://www.gnu.org/software/gdb/bugs/>.\nfind the gdb manual and other documentation resources online at:\n    <http://www.gnu.org/software/gdb/documentation/>.\n\nfor help, type "help".\ntype "apropos word" to search for commands related to "word"...\nreading symbols from multi_process...\n\n\n先设置跟踪父进程 set follow-fork-mode parent 来跳过第一个子进程的 fork 操作；使用 b 命令将断点打在创建第二个子进程的 fork 函数之前；并使用 r 命令运行程序。\n\n(gdb) set follow-fork-mode parent\n(gdb) b multi_process.c:22\nbreakpoint 1 at 0x40083f: file multi_process.c, line 22.\n(gdb) r\nstarting program: /home/randy/study/dev-tool/gdb/multi_process \n[detaching after fork from child process 25249] # 分离第一个子进程\n\nbreakpoint 1, main () at multi_process.c:22\n22          if (pid1 == 0) {  // 在第一个子进程中\n\n\n在继续执行程序前 set follow-fork-mode child 设置 gdb 调试跟踪子进程，然后再使用 n 命令单步执行 fork 创建第二个子进程，可以看到第二个子进程在被 fork 成功之后，gdb 调试就分离的父进程，并切换到第二个子进程中。\n\n(gdb) set follow-fork-mode child\n(gdb) n\n30          pid2 = fork();  // 创建第二个子进程\n(gdb) n\n[attaching after process 25358 fork to child process 25358]\n[new inferior 2 (process 25358)]\n[detaching after fork from parent process 25245]\n[inferior 1 (process 25245) detached] # 已经分离父进程\n[switching to process 25358] # 切换到第二个子进程\n31          if (pid2 == -1) {\n\n\n进入第二个子进程后，就可以使用 n 命令单步执行程序，使用 p 命令查看变量值。\n\n(gdb) n\n36          if (pid2 == 0) {  // 在第二个子进程中\n(gdb) p pid2\n$1 = 0\n(gdb) n\n37              close(pipefd[1]);  // 关闭写端\n(gdb) n\n39              read(pipefd[0], buf, sizeof(buf));  // 从读端读取消息\n(gdb) n\n40              printf("this is child process 2. received message from child process 1: %s\\n", buf);\n(gdb) p buf\n$2 = "hello, i\'m child process 1!", \'\\000\' <repeats 477 times>...\n(gdb) n\nthis is child process 2. received message from child process 1: hello, i\'m child process 1!\n41              close(pipefd[0]);  // 关闭读端\n(gdb) n\n42              exit(exit_success);\n(gdb) \n[inferior 2 (process 25358) exited normally]\nall child processes have completed.\n',charsets:{cjk:!0},lastUpdated:"2023/11/19, 12:55:48",lastUpdatedTimestamp:1700369748e3},{title:"目录",frontmatter:{title:"目录",date:"2023-04-30T15:12:24.000Z",permalink:"/pages/028d7e/"},regularPath:"/04.Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/03.Shell%20%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/00.%E7%9B%AE%E5%BD%95.html",relativePath:"04.Linux操作系统编程/03.Shell 脚本编程/00.目录.md",key:"v-3106070c",path:"/pages/028d7e/",headers:[{level:3,title:"📖 Shell脚本攻略",slug:"shell脚本攻略",normalizedTitle:"📖 shell脚本攻略",charIndex:2},{level:3,title:"🔎 [参考资料]()",slug:"参考资料",normalizedTitle:'🔎 <a href="">参考资料</a>',charIndex:null},{level:3,title:"🔖 源码目录",slug:"源码目录",normalizedTitle:"🔖 源码目录",charIndex:72}],headersStr:"📖 Shell脚本攻略 🔎 [参考资料]() 🔖 源码目录",content:"# 📖 Shell脚本攻略\n\n * 有待整理，相关命令实验代码，请查看源码目录\n\n\n# 🔎 参考资料\n\n * Shell 脚本攻略\n\n\n# 🔖 源码目录",normalizedContent:"# 📖 shell脚本攻略\n\n * 有待整理，相关命令实验代码，请查看源码目录\n\n\n# 🔎 参考资料\n\n * shell 脚本攻略\n\n\n# 🔖 源码目录",charsets:{cjk:!0},lastUpdated:"2023/11/19, 12:55:48",lastUpdatedTimestamp:1700369748e3},{title:"04数字字符串求和问题",frontmatter:{title:"04数字字符串求和问题",date:"2023-03-24T18:39:49.000Z",permalink:"/pages/65cf94/"},regularPath:"/03.LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/05.%E5%85%B6%E4%BB%96%E5%86%85%E5%AE%B9/01.%E6%95%B0%E5%AD%A6%E9%97%AE%E9%A2%98/04.%E6%95%B0%E5%AD%97%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%B1%82%E5%92%8C%E9%97%AE%E9%A2%98.html",relativePath:"03.LeetCode刷题笔记/05.其他内容/01.数学问题/04.数字字符串求和问题.md",key:"v-5f16ac72",path:"/pages/65cf94/",headers:[{level:2,title:"04 数字字符串求和问题",slug:"_04-数字字符串求和问题",normalizedTitle:"04 数字字符串求和问题",charIndex:2},{level:4,title:"415 字符串相加",slug:"_415-字符串相加",normalizedTitle:"415 字符串相加",charIndex:18},{level:4,title:"67 二进制求和",slug:"_67-二进制求和",normalizedTitle:"67 二进制求和",charIndex:1035}],headersStr:"04 数字字符串求和问题 415 字符串相加 67 二进制求和",content:"# 04 数字字符串求和问题\n\n# 415 字符串相加\n\n给定两个由数字组成的字符串，求它们相加的结果。\n\n输入是两个字符串，输出是一个整数，表示输入的数字和。\n\n> 输入：num1 = \"11\", num2 = \"123\"\n> 输出：\"134\"\n\n解析：\n\n因为相加运算是从后往前进行的，所以可以先翻转字符串也可以从字符串尾部开始，再逐位计算。这种类型的题考察的是细节，如进位、位数差等等。\n\n从字符串尾部开始计算和，如果扫描超出其中一个字符串长度则用0值代替，如果两个字符串计算完毕要检查是否还存在进位。字符串的数值计算通过与字符'0'比较得到。\n\nclass Solution {\npublic:\n    string addStrings(string num1, string num2) {\n        int tail1 = num1.length()-1, tail2 = num2.length()-1;\n        string ans = \"\";\n        int addbit = 0;\n        while(tail1>=0 || tail2>=0 || addbit!=0){\n            int x = 0, y = 0;\n            if(tail1 >= 0){\n                x = num1[tail1--] - '0';\n            }\n            if(tail2 >=0 ){\n                y = num2[tail2--] - '0';\n            }\n            int add = x + y + addbit;\n            // 记录当前位计算结果\n            ans.push_back(add % 10 + '0');\n            // 记录进位情况\n            if(add < 10){\n                addbit = 0;\n            }else{\n                addbit = 1;\n            }\n        }\n        reverse(ans.begin(),ans.end());\n        return ans;\n    }\n};\n\n\n# 67 二进制求和\n\n给你两个二进制字符串，返回它们的和（用二进制表示）\n\n输入是两个字符串，输出是一个字符串，表示输入的二进制数字和。\n\n> 输入: a = \"1010\", b = \"1011\"\n> 输出: \"10101\"\n\n解析：\n\n本题和字符串相加类似，从尾部开始逐位运算，要注意进位和两个字符串位数差的情况。\n\nclass Solution {\npublic:\n    string addBinary(string a, string b) {\n        int taila = a.length()-1, tailb = b.length()-1;\n        string ans;\n        int addbit = 0;\n        while(taila>=0 || tailb>=0 || addbit){\n            int x = 0, y = 0;\n            if(taila >= 0){\n                x = a[taila--] - '0';\n            }\n            if(tailb >= 0){\n                y = b[tailb--] - '0';\n            }\n            int add = x + y + addbit;\n            char c = add % 2 + '0';\n            ans = c + ans;\n            if(add < 2){\n                addbit = 0;\n            }else{\n                addbit = 1;\n            }\n        }\n        return ans;\n    }\n};\n",normalizedContent:"# 04 数字字符串求和问题\n\n# 415 字符串相加\n\n给定两个由数字组成的字符串，求它们相加的结果。\n\n输入是两个字符串，输出是一个整数，表示输入的数字和。\n\n> 输入：num1 = \"11\", num2 = \"123\"\n> 输出：\"134\"\n\n解析：\n\n因为相加运算是从后往前进行的，所以可以先翻转字符串也可以从字符串尾部开始，再逐位计算。这种类型的题考察的是细节，如进位、位数差等等。\n\n从字符串尾部开始计算和，如果扫描超出其中一个字符串长度则用0值代替，如果两个字符串计算完毕要检查是否还存在进位。字符串的数值计算通过与字符'0'比较得到。\n\nclass solution {\npublic:\n    string addstrings(string num1, string num2) {\n        int tail1 = num1.length()-1, tail2 = num2.length()-1;\n        string ans = \"\";\n        int addbit = 0;\n        while(tail1>=0 || tail2>=0 || addbit!=0){\n            int x = 0, y = 0;\n            if(tail1 >= 0){\n                x = num1[tail1--] - '0';\n            }\n            if(tail2 >=0 ){\n                y = num2[tail2--] - '0';\n            }\n            int add = x + y + addbit;\n            // 记录当前位计算结果\n            ans.push_back(add % 10 + '0');\n            // 记录进位情况\n            if(add < 10){\n                addbit = 0;\n            }else{\n                addbit = 1;\n            }\n        }\n        reverse(ans.begin(),ans.end());\n        return ans;\n    }\n};\n\n\n# 67 二进制求和\n\n给你两个二进制字符串，返回它们的和（用二进制表示）\n\n输入是两个字符串，输出是一个字符串，表示输入的二进制数字和。\n\n> 输入: a = \"1010\", b = \"1011\"\n> 输出: \"10101\"\n\n解析：\n\n本题和字符串相加类似，从尾部开始逐位运算，要注意进位和两个字符串位数差的情况。\n\nclass solution {\npublic:\n    string addbinary(string a, string b) {\n        int taila = a.length()-1, tailb = b.length()-1;\n        string ans;\n        int addbit = 0;\n        while(taila>=0 || tailb>=0 || addbit){\n            int x = 0, y = 0;\n            if(taila >= 0){\n                x = a[taila--] - '0';\n            }\n            if(tailb >= 0){\n                y = b[tailb--] - '0';\n            }\n            int add = x + y + addbit;\n            char c = add % 2 + '0';\n            ans = c + ans;\n            if(add < 2){\n                addbit = 0;\n            }else{\n                addbit = 1;\n            }\n        }\n        return ans;\n    }\n};\n",charsets:{cjk:!0},lastUpdated:"2023/11/19, 12:55:48",lastUpdatedTimestamp:1700369748e3},{title:"常用Git命令清单",frontmatter:{title:"常用Git命令清单",date:"2020-11-18T17:43:57.000Z",permalink:"/pages/8292d8/",categories:["《Git》学习笔记"],tags:["Git"],author:{name:"王清欢",link:"https://github.com/wang-haihua"}},regularPath:"/05.Git%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.Git%20%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/01.%E5%B8%B8%E7%94%A8Git%E5%91%BD%E4%BB%A4%E6%B8%85%E5%8D%95.html",relativePath:"05.Git 学习笔记/10.Git 常用技巧/01.常用Git命令清单.md",key:"v-3999f758",path:"/pages/8292d8/",headers:[{level:2,title:"一、新建代码库",slug:"一、新建代码库",normalizedTitle:"一、新建代码库",charIndex:187},{level:2,title:"二、配置",slug:"二、配置",normalizedTitle:"二、配置",charIndex:316},{level:2,title:"三、增加/删除文件",slug:"三、增加-删除文件",normalizedTitle:"三、增加/删除文件",charIndex:567},{level:2,title:"四、代码提交",slug:"四、代码提交",normalizedTitle:"四、代码提交",charIndex:911},{level:2,title:"五、分支",slug:"五、分支",normalizedTitle:"五、分支",charIndex:1265},{level:2,title:"六、标签",slug:"六、标签",normalizedTitle:"六、标签",charIndex:1939},{level:2,title:"七、查看信息",slug:"七、查看信息",normalizedTitle:"七、查看信息",charIndex:2285},{level:2,title:"八、远程同步",slug:"八、远程同步",normalizedTitle:"八、远程同步",charIndex:3221},{level:2,title:"九、撤销",slug:"九、撤销",normalizedTitle:"九、撤销",charIndex:3581},{level:2,title:"十、常用操作组合",slug:"十、常用操作组合",normalizedTitle:"十、常用操作组合",charIndex:4147},{level:3,title:"1. 修改本地分支名和远程分支名",slug:"_1-修改本地分支名和远程分支名",normalizedTitle:"1. 修改本地分支名和远程分支名",charIndex:4160}],headersStr:"一、新建代码库 二、配置 三、增加/删除文件 四、代码提交 五、分支 六、标签 七、查看信息 八、远程同步 九、撤销 十、常用操作组合 1. 修改本地分支名和远程分支名",content:'# 常用Git命令清单\n\n一般来说，日常使用只要记住下图6个命令，就可以了。但是熟练使用，恐怕要记住60～100个命令。\n\n\n\n下面是我整理的常用 Git 命令清单。几个专用名词的译名如下。\n\n>  * Workspace：工作区\n>  * Index / Stage：暂存区\n>  * Repository：仓库区（或本地仓库）\n>  * Remote：远程仓库\n\n\n# 一、新建代码库\n\n# 在当前目录新建一个Git代码库\n$ git init\n\n# 新建一个目录，将其初始化为Git代码库\n$ git init [project-name]\n\n# 下载一个项目和它的整个代码历史\n$ git clone [url]\n\n\n\n# 二、配置\n\nGit的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。\n\n# 显示当前的Git配置\n$ git config --list\n\n# 编辑Git配置文件\n$ git config -e [--global]\n\n# 设置提交代码时的用户信息\n$ git config [--global] user.name "[name]"\n$ git config [--global] user.email "[email address]"\n\n\n\n# 三、增加/删除文件\n\n# 添加指定文件到暂存区\n$ git add [file1] [file2] ...\n\n# 添加指定目录到暂存区，包括子目录\n$ git add [dir]\n\n# 添加当前目录的所有文件到暂存区\n$ git add .\n\n# 添加每个变化前，都会要求确认\n# 对于同一个文件的多处变化，可以实现分次提交\n$ git add -p\n\n# 删除工作区文件，并且将这次删除放入暂存区\n$ git rm [file1] [file2] ...\n\n# 停止追踪指定文件，但该文件会保留在工作区\n$ git rm --cached [file]\n\n# 改名文件，并且将这个改名放入暂存区\n$ git mv [file-original] [file-renamed]\n\n\n\n# 四、代码提交\n\n# 提交暂存区到仓库区\n$ git commit -m [message]\n\n# 提交暂存区的指定文件到仓库区\n$ git commit [file1] [file2] ... -m [message]\n\n# 提交工作区自上次commit之后的变化，直接到仓库区\n$ git commit -a\n\n# 提交时显示所有diff信息\n$ git commit -v\n\n# 使用一次新的commit，替代上一次提交\n# 如果代码没有任何新变化，则用来改写上一次commit的提交信息\n$ git commit --amend -m [message]\n\n# 重做上一次commit，并包括指定文件的新变化\n$ git commit --amend [file1] [file2] ...\n\n\n\n# 五、分支\n\n# 列出所有本地分支\n$ git branch\n\n# 列出所有远程分支\n$ git branch -r\n\n# 列出所有本地分支和远程分支\n$ git branch -a\n\n# 新建一个分支，但依然停留在当前分支\n$ git branch [branch-name]\n\n# 新建一个分支，并切换到该分支\n$ git checkout -b [branch]\n\n# 新建一个分支，指向指定commit\n$ git branch [branch] [commit]\n\n# 新建一个分支，与指定的远程分支建立追踪关系\n$ git branch --track [branch] [remote-branch]\n\n# 切换到指定分支，并更新工作区\n$ git checkout [branch-name]\n\n# 切换到上一个分支\n$ git checkout -\n\n# 建立追踪关系，在现有分支与指定的远程分支之间\n$ git branch --set-upstream [branch] [remote-branch]\n\n# 合并指定分支到当前分支\n$ git merge [branch]\n\n# 选择一个commit，合并进当前分支\n$ git cherry-pick [commit]\n\n# 删除分支\n$ git branch -d [branch-name]\n\n# 删除远程分支\n$ git push origin --delete [branch-name]\n$ git branch -dr [remote/branch]\n\n\n\n# 六、标签\n\n# 列出所有tag\n$ git tag\n\n# 新建一个tag在当前commit\n$ git tag [tag]\n\n# 新建一个tag在指定commit\n$ git tag [tag] [commit]\n\n# 删除本地tag\n$ git tag -d [tag]\n\n# 删除远程tag\n$ git push origin :refs/tags/[tagName]\n\n# 查看tag信息\n$ git show [tag]\n\n# 提交指定tag\n$ git push [remote] [tag]\n\n# 提交所有tag\n$ git push [remote] --tags\n\n# 新建一个分支，指向某个tag\n$ git checkout -b [branch] [tag]\n\n\n\n# 七、查看信息\n\n# 显示有变更的文件\n$ git status\n\n# 显示当前分支的版本历史\n$ git log\n\n# 显示commit历史，以及每次commit发生变更的文件\n$ git log --stat\n\n# 搜索提交历史，根据关键词\n$ git log -S [keyword]\n\n# 显示某个commit之后的所有变动，每个commit占据一行\n$ git log [tag] HEAD --pretty=format:%s\n\n# 显示某个commit之后的所有变动，其"提交说明"必须符合搜索条件\n$ git log [tag] HEAD --grep feature\n\n# 显示某个文件的版本历史，包括文件改名\n$ git log --follow [file]\n$ git whatchanged [file]\n\n# 显示指定文件相关的每一次diff\n$ git log -p [file]\n\n# 显示过去5次提交\n$ git log -5 --pretty --oneline\n\n# 显示所有提交过的用户，按提交次数排序\n$ git shortlog -sn\n\n# 显示指定文件是什么人在什么时间修改过\n$ git blame [file]\n\n# 显示暂存区和工作区的差异\n$ git diff\n\n# 显示暂存区和上一个commit的差异\n$ git diff --cached [file]\n\n# 显示工作区与当前分支最新commit之间的差异\n$ git diff HEAD\n\n# 显示两次提交之间的差异\n$ git diff [first-branch]...[second-branch]\n\n# 显示今天你写了多少行代码\n$ git diff --shortstat "@{0 day ago}"\n\n# 显示某次提交的元数据和内容变化\n$ git show [commit]\n\n# 显示某次提交发生变化的文件\n$ git show --name-only [commit]\n\n# 显示某次提交时，某个文件的内容\n$ git show [commit]:[filename]\n\n# 显示当前分支的最近几次提交\n$ git reflog\n\n\n\n# 八、远程同步\n\n# 下载远程仓库的所有变动\n$ git fetch [remote]\n\n# 显示所有远程仓库\n$ git remote -v\n\n# 显示某个远程仓库的信息\n$ git remote show [remote]\n\n# 增加一个新的远程仓库，并命名\n$ git remote add [shortname] [url]\n\n# 取回远程仓库的变化，并与本地分支合并\n$ git pull [remote] [branch]\n\n# 上传本地指定分支到远程仓库\n$ git push [remote] [branch]\n\n# 强行推送当前分支到远程仓库，即使有冲突\n$ git push [remote] --force\n\n# 推送所有分支到远程仓库\n$ git push [remote] --all\n\n\n\n# 九、撤销\n\n# 恢复暂存区的指定文件到工作区\n$ git checkout [file]\n\n# 恢复某个commit的指定文件到暂存区和工作区\n$ git checkout [commit] [file]\n\n# 恢复暂存区的所有文件到工作区\n$ git checkout .\n\n# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变\n$ git reset [file]\n\n# 重置暂存区与工作区，与上一次commit保持一致\n$ git reset --hard\n\n# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变\n$ git reset [commit]\n\n# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致\n$ git reset --hard [commit]\n\n# 重置当前HEAD为指定commit，但保持暂存区和工作区不变\n$ git reset --keep [commit]\n\n# 新建一个commit，用来撤销指定commit\n# 后者的所有变化都将被前者抵消，并且应用到当前分支\n$ git revert [commit]\n\n# 暂时将未提交的变化移除，稍后再移入\n$ git stash\n$ git stash pop\n\n\n\n# 十、常用操作组合\n\n\n# 1. 修改本地分支名和远程分支名\n\ngit branch -m old_branch new_branch # 重命名本地分支\ngit push origin :old_branch # 删除远程旧分支（分支名前有冒号）\ngit push --set-upstream origin new_branch # 推送新的分支，并设置本地分支跟踪新的远程分支\n\n\n相关文章：\n\n《如何撤销 Git 操作？》\n\n《git cherry-pick 教程》 复制某分支上的部分提交到另一个分支上（相对于可以选择指定提交的 rebase 操作）。\n\n> 命令清单来源：https://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html',normalizedContent:'# 常用git命令清单\n\n一般来说，日常使用只要记住下图6个命令，就可以了。但是熟练使用，恐怕要记住60～100个命令。\n\n\n\n下面是我整理的常用 git 命令清单。几个专用名词的译名如下。\n\n>  * workspace：工作区\n>  * index / stage：暂存区\n>  * repository：仓库区（或本地仓库）\n>  * remote：远程仓库\n\n\n# 一、新建代码库\n\n# 在当前目录新建一个git代码库\n$ git init\n\n# 新建一个目录，将其初始化为git代码库\n$ git init [project-name]\n\n# 下载一个项目和它的整个代码历史\n$ git clone [url]\n\n\n\n# 二、配置\n\ngit的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。\n\n# 显示当前的git配置\n$ git config --list\n\n# 编辑git配置文件\n$ git config -e [--global]\n\n# 设置提交代码时的用户信息\n$ git config [--global] user.name "[name]"\n$ git config [--global] user.email "[email address]"\n\n\n\n# 三、增加/删除文件\n\n# 添加指定文件到暂存区\n$ git add [file1] [file2] ...\n\n# 添加指定目录到暂存区，包括子目录\n$ git add [dir]\n\n# 添加当前目录的所有文件到暂存区\n$ git add .\n\n# 添加每个变化前，都会要求确认\n# 对于同一个文件的多处变化，可以实现分次提交\n$ git add -p\n\n# 删除工作区文件，并且将这次删除放入暂存区\n$ git rm [file1] [file2] ...\n\n# 停止追踪指定文件，但该文件会保留在工作区\n$ git rm --cached [file]\n\n# 改名文件，并且将这个改名放入暂存区\n$ git mv [file-original] [file-renamed]\n\n\n\n# 四、代码提交\n\n# 提交暂存区到仓库区\n$ git commit -m [message]\n\n# 提交暂存区的指定文件到仓库区\n$ git commit [file1] [file2] ... -m [message]\n\n# 提交工作区自上次commit之后的变化，直接到仓库区\n$ git commit -a\n\n# 提交时显示所有diff信息\n$ git commit -v\n\n# 使用一次新的commit，替代上一次提交\n# 如果代码没有任何新变化，则用来改写上一次commit的提交信息\n$ git commit --amend -m [message]\n\n# 重做上一次commit，并包括指定文件的新变化\n$ git commit --amend [file1] [file2] ...\n\n\n\n# 五、分支\n\n# 列出所有本地分支\n$ git branch\n\n# 列出所有远程分支\n$ git branch -r\n\n# 列出所有本地分支和远程分支\n$ git branch -a\n\n# 新建一个分支，但依然停留在当前分支\n$ git branch [branch-name]\n\n# 新建一个分支，并切换到该分支\n$ git checkout -b [branch]\n\n# 新建一个分支，指向指定commit\n$ git branch [branch] [commit]\n\n# 新建一个分支，与指定的远程分支建立追踪关系\n$ git branch --track [branch] [remote-branch]\n\n# 切换到指定分支，并更新工作区\n$ git checkout [branch-name]\n\n# 切换到上一个分支\n$ git checkout -\n\n# 建立追踪关系，在现有分支与指定的远程分支之间\n$ git branch --set-upstream [branch] [remote-branch]\n\n# 合并指定分支到当前分支\n$ git merge [branch]\n\n# 选择一个commit，合并进当前分支\n$ git cherry-pick [commit]\n\n# 删除分支\n$ git branch -d [branch-name]\n\n# 删除远程分支\n$ git push origin --delete [branch-name]\n$ git branch -dr [remote/branch]\n\n\n\n# 六、标签\n\n# 列出所有tag\n$ git tag\n\n# 新建一个tag在当前commit\n$ git tag [tag]\n\n# 新建一个tag在指定commit\n$ git tag [tag] [commit]\n\n# 删除本地tag\n$ git tag -d [tag]\n\n# 删除远程tag\n$ git push origin :refs/tags/[tagname]\n\n# 查看tag信息\n$ git show [tag]\n\n# 提交指定tag\n$ git push [remote] [tag]\n\n# 提交所有tag\n$ git push [remote] --tags\n\n# 新建一个分支，指向某个tag\n$ git checkout -b [branch] [tag]\n\n\n\n# 七、查看信息\n\n# 显示有变更的文件\n$ git status\n\n# 显示当前分支的版本历史\n$ git log\n\n# 显示commit历史，以及每次commit发生变更的文件\n$ git log --stat\n\n# 搜索提交历史，根据关键词\n$ git log -s [keyword]\n\n# 显示某个commit之后的所有变动，每个commit占据一行\n$ git log [tag] head --pretty=format:%s\n\n# 显示某个commit之后的所有变动，其"提交说明"必须符合搜索条件\n$ git log [tag] head --grep feature\n\n# 显示某个文件的版本历史，包括文件改名\n$ git log --follow [file]\n$ git whatchanged [file]\n\n# 显示指定文件相关的每一次diff\n$ git log -p [file]\n\n# 显示过去5次提交\n$ git log -5 --pretty --oneline\n\n# 显示所有提交过的用户，按提交次数排序\n$ git shortlog -sn\n\n# 显示指定文件是什么人在什么时间修改过\n$ git blame [file]\n\n# 显示暂存区和工作区的差异\n$ git diff\n\n# 显示暂存区和上一个commit的差异\n$ git diff --cached [file]\n\n# 显示工作区与当前分支最新commit之间的差异\n$ git diff head\n\n# 显示两次提交之间的差异\n$ git diff [first-branch]...[second-branch]\n\n# 显示今天你写了多少行代码\n$ git diff --shortstat "@{0 day ago}"\n\n# 显示某次提交的元数据和内容变化\n$ git show [commit]\n\n# 显示某次提交发生变化的文件\n$ git show --name-only [commit]\n\n# 显示某次提交时，某个文件的内容\n$ git show [commit]:[filename]\n\n# 显示当前分支的最近几次提交\n$ git reflog\n\n\n\n# 八、远程同步\n\n# 下载远程仓库的所有变动\n$ git fetch [remote]\n\n# 显示所有远程仓库\n$ git remote -v\n\n# 显示某个远程仓库的信息\n$ git remote show [remote]\n\n# 增加一个新的远程仓库，并命名\n$ git remote add [shortname] [url]\n\n# 取回远程仓库的变化，并与本地分支合并\n$ git pull [remote] [branch]\n\n# 上传本地指定分支到远程仓库\n$ git push [remote] [branch]\n\n# 强行推送当前分支到远程仓库，即使有冲突\n$ git push [remote] --force\n\n# 推送所有分支到远程仓库\n$ git push [remote] --all\n\n\n\n# 九、撤销\n\n# 恢复暂存区的指定文件到工作区\n$ git checkout [file]\n\n# 恢复某个commit的指定文件到暂存区和工作区\n$ git checkout [commit] [file]\n\n# 恢复暂存区的所有文件到工作区\n$ git checkout .\n\n# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变\n$ git reset [file]\n\n# 重置暂存区与工作区，与上一次commit保持一致\n$ git reset --hard\n\n# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变\n$ git reset [commit]\n\n# 重置当前分支的head为指定commit，同时重置暂存区和工作区，与指定commit一致\n$ git reset --hard [commit]\n\n# 重置当前head为指定commit，但保持暂存区和工作区不变\n$ git reset --keep [commit]\n\n# 新建一个commit，用来撤销指定commit\n# 后者的所有变化都将被前者抵消，并且应用到当前分支\n$ git revert [commit]\n\n# 暂时将未提交的变化移除，稍后再移入\n$ git stash\n$ git stash pop\n\n\n\n# 十、常用操作组合\n\n\n# 1. 修改本地分支名和远程分支名\n\ngit branch -m old_branch new_branch # 重命名本地分支\ngit push origin :old_branch # 删除远程旧分支（分支名前有冒号）\ngit push --set-upstream origin new_branch # 推送新的分支，并设置本地分支跟踪新的远程分支\n\n\n相关文章：\n\n《如何撤销 git 操作？》\n\n《git cherry-pick 教程》 复制某分支上的部分提交到另一个分支上（相对于可以选择指定提交的 rebase 操作）。\n\n> 命令清单来源：https://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html',charsets:{cjk:!0},lastUpdated:"2023/11/19, 12:55:48",lastUpdatedTimestamp:1700369748e3},{title:"Git使用手册",frontmatter:{title:"Git使用手册",date:"2019-12-25T14:27:01.000Z",permalink:"/pages/9a7ee40fc232253e",categories:["技术","技术文档"],tags:[null],author:{name:"王清欢",link:"https://github.com/wang-haihua"}},regularPath:"/05.Git%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.Git%20%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/02.Git%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C.html",relativePath:"05.Git 学习笔记/10.Git 常用技巧/02.Git使用手册.md",key:"v-43552b36",path:"/pages/9a7ee40fc232253e/",headers:[{level:2,title:"安装",slug:"安装",normalizedTitle:"安装",charIndex:14},{level:2,title:"创建版本库（仓库）",slug:"创建版本库-仓库",normalizedTitle:"创建版本库（仓库）",charIndex:290},{level:2,title:"添加文件到仓库",slug:"添加文件到仓库",normalizedTitle:"添加文件到仓库",charIndex:446},{level:4,title:"提交描述规范",slug:"提交描述规范",normalizedTitle:"提交描述规范",charIndex:743},{level:2,title:"版本管理",slug:"版本管理",normalizedTitle:"版本管理",charIndex:767},{level:4,title:"提交修改",slug:"提交修改",normalizedTitle:"提交修改",charIndex:866},{level:4,title:"查看版本记录",slug:"查看版本记录",normalizedTitle:"查看版本记录",charIndex:1029},{level:4,title:"回退版本",slug:"回退版本",normalizedTitle:"回退版本",charIndex:1122},{level:4,title:"撤销修改",slug:"撤销修改",normalizedTitle:"撤销修改",charIndex:1467},{level:4,title:"删除文件",slug:"删除文件",normalizedTitle:"删除文件",charIndex:1541},{level:2,title:"远程仓库",slug:"远程仓库",normalizedTitle:"远程仓库",charIndex:1616},{level:4,title:"SSH验证",slug:"ssh验证",normalizedTitle:"ssh验证",charIndex:1624},{level:4,title:"关联远程仓库",slug:"关联远程仓库",normalizedTitle:"关联远程仓库",charIndex:1635},{level:4,title:"查看远程仓库",slug:"查看远程仓库",normalizedTitle:"查看远程仓库",charIndex:2637},{level:4,title:"删除远程仓库",slug:"删除远程仓库",normalizedTitle:"删除远程仓库",charIndex:2672},{level:4,title:"从远程库克隆项目",slug:"从远程库克隆项目",normalizedTitle:"从远程库克隆项目",charIndex:2713},{level:5,title:"克隆指定分支",slug:"克隆指定分支",normalizedTitle:"克隆指定分支",charIndex:2755},{level:2,title:"分支管理",slug:"分支管理",normalizedTitle:"分支管理",charIndex:2803},{level:4,title:"创建分支",slug:"创建分支",normalizedTitle:"创建分支",charIndex:2811},{level:4,title:"查看分支",slug:"查看分支",normalizedTitle:"查看分支",charIndex:2850},{level:4,title:"切换分支",slug:"切换分支",normalizedTitle:"切换分支",charIndex:2903},{level:4,title:"合并分支",slug:"合并分支",normalizedTitle:"合并分支",charIndex:2939},{level:4,title:"删除分支",slug:"删除分支",normalizedTitle:"删除分支",charIndex:3076},{level:4,title:"修改分支名",slug:"修改分支名",normalizedTitle:"修改分支名",charIndex:3113},{level:2,title:"帮助命令",slug:"帮助命令",normalizedTitle:"帮助命令",charIndex:3161},{level:2,title:"参考文档",slug:"参考文档",normalizedTitle:"参考文档",charIndex:6585}],excerpt:'<h1 id="git使用手册"><a class="header-anchor" href="#git使用手册">#</a> Git使用手册</h1>\n<h2 id="安装"><a class="header-anchor" href="#安装">#</a> 安装</h2>\n<p>官网下载：<a href="https://git-scm.com/downloads" target="_blank" rel="noopener noreferrer">https://git-scm.com/downloads<OutboundLink/></a> 下载完成后使用默认进行安装。</p>\n<p>安装完成后，在开始菜单里找到 <code>Git</code> -&gt; <code>Git Bash</code>，蹦出一个类似命令行窗口的东西，就说明Git安装成功！\n还需要最后一步设置，在命令行输入：</p>\n\x3c!--beforebegin--\x3e<div class="language-bash extra-class">\x3c!--afterbegin--\x3e<pre v-pre class="language-bash"><code><span class="token function">git</span> config <span class="token parameter variable">--global</span> user.name <span class="token string">"Your Name"</span>\n<span class="token function">git</span> config <span class="token parameter variable">--global</span> user.email <span class="token string">"email@example.com"</span>\n</code></pre>\n\x3c!--beforeend--\x3e</div>\x3c!--afterend--\x3e<p>因为Git是分布式版本控制系统，所以，每个机器都必须自报家门：你的名字和Email地址。</p>\n',headersStr:"安装 创建版本库（仓库） 添加文件到仓库 提交描述规范 版本管理 提交修改 查看版本记录 回退版本 撤销修改 删除文件 远程仓库 SSH验证 关联远程仓库 查看远程仓库 删除远程仓库 从远程库克隆项目 克隆指定分支 分支管理 创建分支 查看分支 切换分支 合并分支 删除分支 修改分支名 帮助命令 参考文档",content:"# Git使用手册\n\n\n# 安装\n\n官网下载：https://git-scm.com/downloads 下载完成后使用默认进行安装。\n\n安装完成后，在开始菜单里找到 Git -> Git Bash，蹦出一个类似命令行窗口的东西，就说明Git安装成功！ 还需要最后一步设置，在命令行输入：\n\ngit config --global user.name \"Your Name\"\ngit config --global user.email \"email@example.com\"\n\n\n因为Git是分布式版本控制系统，所以，每个机器都必须自报家门：你的名字和Email地址。\n\n\n# 创建版本库（仓库）\n\n# 创建仓库\nmkdir <仓库name> \n\n# 进入仓库\ncd <仓库name>\n\n# 此命令用于显示当前目录\npwd\n\n# 把当前目录初始化成Git仓库\ngit init\n\n\n> 也不一定必须在空目录下创建Git仓库，选择一个已经有东西的目录直接git init也是可以的。\n\n\n# 添加文件到仓库\n\n在仓库目录下放入文件，如新建一个test.txt文件，然后使用git add test.txt命令告诉Git，把文件添加到缓存区，然后使用git commit -m \"提交描述\"告诉Git，把文件提交到仓库。\n\n# 添加指定文件或文件夹到缓存区，文件需添加后缀\ngit add <文件或文件夹name>                   # 单个文件\ngit add <文件或文件夹name> <文件或文件夹name>  # 多个文件\n\n# 或 全部文件同时添加到缓存区\ngit add .\n\n# 把文件从缓存区提交至仓库\ngit commit -m \"提交描述\"\n\n\n# 提交描述规范\n\n在提交代码时输入清晰的说明有利于版本管理，建议搭配如下关键字编写提交描述\n\n# 新建(add)\n# 删除(rm)\n# 更新(update)\n# 改动(change)\n# 实现\n# 发布\n# 修复\n...\n\n\n\n# 版本管理\n\n# 提交修改\n\n如修改test.txt的内容后，运行git status命令看看被修改的文件，然后再使用git add test.txt、 git commit -m \"修改描述\"把修改后的文件提交到仓库，提交后可再次使用git status查看当前状态。\n\n# 显示 新增/删除/被改动等 的文件\ngit status\n\n\n# 查看版本记录\n\n# 查看版本记录\ngit log   # 显示版本号、提交时间等信息\n\n\n> 也可使用可视化工具查看Git版本历史： 在仓库目录右键 > Git BUI Here\n\n# 回退版本\n\n首先，Git必须知道当前版本是哪个版本，在Git中，用HEAD表示当前版本，也就是最新的提交1094adb...（注意我的提交ID和你的肯定不一样），上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100。\n\n# 回退到上一个版本\n$ git reset --hard HEAD^\n\n\n此时查看git log记录发现，原来最新的版本已经没有了，想回到原来最新的版本怎么办？这就需要知道最新的版本的版本号\n\n# 跳转到指定版本\ngit reset --hard <版本号前几位>\n\n\n但是不知道版本号怎么办？Git提供了一个命令git reflog用来记录你的每一次命令\n\ngit reflog\n\n\n# 撤销修改\n\nhttps://www.liaoxuefeng.com/wiki/896043488029600/897889638509536\n\n# 删除文件\n\nhttps://www.liaoxuefeng.com/wiki/896043488029600/900002180232448\n\n\n# 远程仓库\n\n# SSH验证\n\n使本机能关联远程仓库，首次需要SSH验证\n\n * 第1步：创建SSH Key。在用户主（C:\\Users\\dell）目录下，看看有没有.ssh目录， 如果有，再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件，如果已经有了，可直接跳到下一步。 如果没有，打开Shell（Windows下打开Git Bash），创建SSH Key：\n\n# 创建SSH Key\nssh-keygen -t rsa -C \"邮件地址\"\n\n\n * 第2步：登陆GitHub，右上角头像 > settings > SSH and GPG keys >Add SSH Key，在key的文本框里粘贴id_rsa.pub文件的内容\n\n# 关联远程仓库\n\nSSH验证完成后，在github创建仓库，创建仓库时记得取消 Initialize this repository with a README的勾选，然后在本地命令：\n\n# 关联远程仓库，仓库名一般使用origin\ngit remote add <仓库名> <远程仓库地址>\n\n# 示例\ngit remote add origin git@github.com:xugaoyi/test.git\n\n\n下一步，就可以把本地库的所有内容推送到远程库上\n\n# 把文件推送到远程仓库\ngit push -u <仓库名> <分支名>\n\n# 示例\ngit push -u origin master\n\n\n由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。\n\n> 前提是目录已经git init初始化成仓库，并且git status状态是没有改动的，如果有改动则先git add .添加至缓存区，git commit -m '提交描述'提交至仓库，然后执行上面命令。\n> \n> 如创建仓库时勾选了 Initialize this repository with a README 则需先拉取README.md文件到本地仓库git pull\n> \n> 可关联多个远程仓库，注意给不同的远程仓库取不一样的名称，提交是分别按名称提交到不一样的远程仓库。\n\n# 简化的推送命令\ngit push\n\n\n# 查看远程仓库\n\n# 查看远程仓库\ngit remote -v\n\n\n# 删除远程仓库\n\n# 删除远程仓库\ngit remote rm <仓库名>\n\n\n# 从远程库克隆项目\n\n# 从远程库克隆项目\ngit clone <仓库地址>\n\n\n# 克隆指定分支\n\n# 克隆指定分支\ngit clone -b <分支名> <仓库地址>\n\n\n\n# 分支管理\n\n# 创建分支\n\n# 创建分支\ngit checkout -b <分支名>\n\n\n# 查看分支\n\n# 查看分支\ngit branch\n\n\n查看分支时，在分支前带 * 号的表示当前的分支\n\n# 切换分支\n\n# 切换分支\ngit checkout <分支名>\n\n\n# 合并分支\n\n# 合并本地的分支\ngit merge <分支名>\n\n# 合并远程的分支\ngit merge <远程仓库名>/<分支名>\n\n\n注意，是将指定分支合并到当前分支，并非当前分支合并到指定分支。\n\n一般情况下是把当前分支切换到主分支，然后把子分支合并到主分支。\n\n# 删除分支\n\n# 删除分支\ngit branch -d <分支名>\n\n\n# 修改分支名\n\n# 修改分支名\ngit branch -m <原分支名> <新分支名>\n\n\n\n# 帮助命令\n\n如对命令不清楚时，可使用git help命令显示出git命令介绍。\n\n# 帮助命令\ngit help\n\n\n$ git help\nusage: git [--version] [--help] [-C <path>] [-c <name>=<value>]\n           [--exec-path[=<path>]] [--html-path] [--man-path] [--info-path]\n           [-p | --paginate | -P | --no-pager] [--no-replace-objects] [--bare]\n           [--git-dir=<path>] [--work-tree=<path>] [--namespace=<name>]\n           <command> [<args>]\n\nThese are common Git commands used in various situations:\n\nstart a working area (see also: git help tutorial)\n   clone      Clone a repository into a new directory\n   init       Create an empty Git repository or reinitialize an existing one\n\nwork on the current change (see also: git help everyday)\n   add        Add file contents to the index\n   mv         Move or rename a file, a directory, or a symlink\n   reset      Reset current HEAD to the specified state\n   rm         Remove files from the working tree and from the index\n\nexamine the history and state (see also: git help revisions)\n   bisect     Use binary search to find the commit that introduced a bug\n   grep       Print lines matching a pattern\n   log        Show commit logs\n   show       Show various types of objects\n   status     Show the working tree status\n\ngrow, mark and tweak your common history\n   branch     List, create, or delete branches\n   checkout   Switch branches or restore working tree files\n   commit     Record changes to the repository\n   diff       Show changes between commits, commit and working tree, etc\n   merge      Join two or more development histories together\n   rebase     Reapply commits on top of another base tip\n   tag        Create, list, delete or verify a tag object signed with GPG\n\ncollaborate (see also: git help workflows)\n   fetch      Download objects and refs from another repository\n   pull       Fetch from and integrate with another repository or a local branch\n   push       Update remote refs along with associated objects\n\n'git help -a' and 'git help -g' list available subcommands and some\nconcept guides. See 'git help <command>' or 'git help <concept>'\nto read about a specific subcommand or concept.\n\n\n翻译工具翻译中文\n\n$ git help\n使用：git [--version] [--help] [-C <path>] [-c <name>=<value>]\n           [--exec-path[=<path>]] [--html-path] [--man-path] [--info-path]\n           [-p | --paginate | -P | --no-pager] [--no-replace-objects] [--bare]\n           [--git-dir=<path>] [--work-tree=<path>] [--namespace=<name>]\n           <command> [<args>]\n\n这些是在各种情况下使用的通用Git命令：\n\nstart a working area (参见命令: git help tutorial)\n   clone      将存储库克隆到新目录中\n   init       创建一个空的Git存储库或重新初始化一个现有的存储库\n\nwork on the current change (参见命令: git help everyday)\n   add        将文件内容添加到索引中\n   mv         移动或重命名文件、目录或符号链接\n   reset      将当前磁头重置为指定状态\n   rm         从工作树和索引中删除文件\n\nexamine the history and state (参见命令: git help revisions)\n   bisect     使用二分查找查找引入错误的提交\n   grep       打印与模式匹配的行\n   log        显示提交日志\n   show       显示各种类型的对象\n   status     显示工作树状态\n\ngrow, mark and tweak your common history\n   branch     列出、创建或删除分支\n   checkout   切换分支或还原工作树文件\n   commit     记录对存储库的更改\n   diff       显示提交、提交和工作树等之间的更改\n   merge      将两个或多个开发历史连接在一起\n   rebase     在另一个基本提示之上重新应用提交\n   tag        创建、列表、删除或验证用GPG签名的标记对象\n\ncollaborate (参见命令: git help workflows)\n   fetch      从另一个存储库下载对象和引用\n   pull       从另一个存储库或本地分支获取并与之集成\n   push       更新远程引用和相关对象\n\n'git help -a' 和 'git help -g' 列出可用的子命令和一些概念指导。\n命令'git help <command>' 或 'git help <concept>' 查看特定子命令或概念.\n\n\n\n# 参考文档\n\nhttps://www.liaoxuefeng.com/wiki/896043488029600",normalizedContent:"# git使用手册\n\n\n# 安装\n\n官网下载：https://git-scm.com/downloads 下载完成后使用默认进行安装。\n\n安装完成后，在开始菜单里找到 git -> git bash，蹦出一个类似命令行窗口的东西，就说明git安装成功！ 还需要最后一步设置，在命令行输入：\n\ngit config --global user.name \"your name\"\ngit config --global user.email \"email@example.com\"\n\n\n因为git是分布式版本控制系统，所以，每个机器都必须自报家门：你的名字和email地址。\n\n\n# 创建版本库（仓库）\n\n# 创建仓库\nmkdir <仓库name> \n\n# 进入仓库\ncd <仓库name>\n\n# 此命令用于显示当前目录\npwd\n\n# 把当前目录初始化成git仓库\ngit init\n\n\n> 也不一定必须在空目录下创建git仓库，选择一个已经有东西的目录直接git init也是可以的。\n\n\n# 添加文件到仓库\n\n在仓库目录下放入文件，如新建一个test.txt文件，然后使用git add test.txt命令告诉git，把文件添加到缓存区，然后使用git commit -m \"提交描述\"告诉git，把文件提交到仓库。\n\n# 添加指定文件或文件夹到缓存区，文件需添加后缀\ngit add <文件或文件夹name>                   # 单个文件\ngit add <文件或文件夹name> <文件或文件夹name>  # 多个文件\n\n# 或 全部文件同时添加到缓存区\ngit add .\n\n# 把文件从缓存区提交至仓库\ngit commit -m \"提交描述\"\n\n\n# 提交描述规范\n\n在提交代码时输入清晰的说明有利于版本管理，建议搭配如下关键字编写提交描述\n\n# 新建(add)\n# 删除(rm)\n# 更新(update)\n# 改动(change)\n# 实现\n# 发布\n# 修复\n...\n\n\n\n# 版本管理\n\n# 提交修改\n\n如修改test.txt的内容后，运行git status命令看看被修改的文件，然后再使用git add test.txt、 git commit -m \"修改描述\"把修改后的文件提交到仓库，提交后可再次使用git status查看当前状态。\n\n# 显示 新增/删除/被改动等 的文件\ngit status\n\n\n# 查看版本记录\n\n# 查看版本记录\ngit log   # 显示版本号、提交时间等信息\n\n\n> 也可使用可视化工具查看git版本历史： 在仓库目录右键 > git bui here\n\n# 回退版本\n\n首先，git必须知道当前版本是哪个版本，在git中，用head表示当前版本，也就是最新的提交1094adb...（注意我的提交id和你的肯定不一样），上一个版本就是head^，上上一个版本就是head^^，当然往上100个版本写100个^比较容易数不过来，所以写成head~100。\n\n# 回退到上一个版本\n$ git reset --hard head^\n\n\n此时查看git log记录发现，原来最新的版本已经没有了，想回到原来最新的版本怎么办？这就需要知道最新的版本的版本号\n\n# 跳转到指定版本\ngit reset --hard <版本号前几位>\n\n\n但是不知道版本号怎么办？git提供了一个命令git reflog用来记录你的每一次命令\n\ngit reflog\n\n\n# 撤销修改\n\nhttps://www.liaoxuefeng.com/wiki/896043488029600/897889638509536\n\n# 删除文件\n\nhttps://www.liaoxuefeng.com/wiki/896043488029600/900002180232448\n\n\n# 远程仓库\n\n# ssh验证\n\n使本机能关联远程仓库，首次需要ssh验证\n\n * 第1步：创建ssh key。在用户主（c:\\users\\dell）目录下，看看有没有.ssh目录， 如果有，再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件，如果已经有了，可直接跳到下一步。 如果没有，打开shell（windows下打开git bash），创建ssh key：\n\n# 创建ssh key\nssh-keygen -t rsa -c \"邮件地址\"\n\n\n * 第2步：登陆github，右上角头像 > settings > ssh and gpg keys >add ssh key，在key的文本框里粘贴id_rsa.pub文件的内容\n\n# 关联远程仓库\n\nssh验证完成后，在github创建仓库，创建仓库时记得取消 initialize this repository with a readme的勾选，然后在本地命令：\n\n# 关联远程仓库，仓库名一般使用origin\ngit remote add <仓库名> <远程仓库地址>\n\n# 示例\ngit remote add origin git@github.com:xugaoyi/test.git\n\n\n下一步，就可以把本地库的所有内容推送到远程库上\n\n# 把文件推送到远程仓库\ngit push -u <仓库名> <分支名>\n\n# 示例\ngit push -u origin master\n\n\n由于远程库是空的，我们第一次推送master分支时，加上了-u参数，git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。\n\n> 前提是目录已经git init初始化成仓库，并且git status状态是没有改动的，如果有改动则先git add .添加至缓存区，git commit -m '提交描述'提交至仓库，然后执行上面命令。\n> \n> 如创建仓库时勾选了 initialize this repository with a readme 则需先拉取readme.md文件到本地仓库git pull\n> \n> 可关联多个远程仓库，注意给不同的远程仓库取不一样的名称，提交是分别按名称提交到不一样的远程仓库。\n\n# 简化的推送命令\ngit push\n\n\n# 查看远程仓库\n\n# 查看远程仓库\ngit remote -v\n\n\n# 删除远程仓库\n\n# 删除远程仓库\ngit remote rm <仓库名>\n\n\n# 从远程库克隆项目\n\n# 从远程库克隆项目\ngit clone <仓库地址>\n\n\n# 克隆指定分支\n\n# 克隆指定分支\ngit clone -b <分支名> <仓库地址>\n\n\n\n# 分支管理\n\n# 创建分支\n\n# 创建分支\ngit checkout -b <分支名>\n\n\n# 查看分支\n\n# 查看分支\ngit branch\n\n\n查看分支时，在分支前带 * 号的表示当前的分支\n\n# 切换分支\n\n# 切换分支\ngit checkout <分支名>\n\n\n# 合并分支\n\n# 合并本地的分支\ngit merge <分支名>\n\n# 合并远程的分支\ngit merge <远程仓库名>/<分支名>\n\n\n注意，是将指定分支合并到当前分支，并非当前分支合并到指定分支。\n\n一般情况下是把当前分支切换到主分支，然后把子分支合并到主分支。\n\n# 删除分支\n\n# 删除分支\ngit branch -d <分支名>\n\n\n# 修改分支名\n\n# 修改分支名\ngit branch -m <原分支名> <新分支名>\n\n\n\n# 帮助命令\n\n如对命令不清楚时，可使用git help命令显示出git命令介绍。\n\n# 帮助命令\ngit help\n\n\n$ git help\nusage: git [--version] [--help] [-c <path>] [-c <name>=<value>]\n           [--exec-path[=<path>]] [--html-path] [--man-path] [--info-path]\n           [-p | --paginate | -p | --no-pager] [--no-replace-objects] [--bare]\n           [--git-dir=<path>] [--work-tree=<path>] [--namespace=<name>]\n           <command> [<args>]\n\nthese are common git commands used in various situations:\n\nstart a working area (see also: git help tutorial)\n   clone      clone a repository into a new directory\n   init       create an empty git repository or reinitialize an existing one\n\nwork on the current change (see also: git help everyday)\n   add        add file contents to the index\n   mv         move or rename a file, a directory, or a symlink\n   reset      reset current head to the specified state\n   rm         remove files from the working tree and from the index\n\nexamine the history and state (see also: git help revisions)\n   bisect     use binary search to find the commit that introduced a bug\n   grep       print lines matching a pattern\n   log        show commit logs\n   show       show various types of objects\n   status     show the working tree status\n\ngrow, mark and tweak your common history\n   branch     list, create, or delete branches\n   checkout   switch branches or restore working tree files\n   commit     record changes to the repository\n   diff       show changes between commits, commit and working tree, etc\n   merge      join two or more development histories together\n   rebase     reapply commits on top of another base tip\n   tag        create, list, delete or verify a tag object signed with gpg\n\ncollaborate (see also: git help workflows)\n   fetch      download objects and refs from another repository\n   pull       fetch from and integrate with another repository or a local branch\n   push       update remote refs along with associated objects\n\n'git help -a' and 'git help -g' list available subcommands and some\nconcept guides. see 'git help <command>' or 'git help <concept>'\nto read about a specific subcommand or concept.\n\n\n翻译工具翻译中文\n\n$ git help\n使用：git [--version] [--help] [-c <path>] [-c <name>=<value>]\n           [--exec-path[=<path>]] [--html-path] [--man-path] [--info-path]\n           [-p | --paginate | -p | --no-pager] [--no-replace-objects] [--bare]\n           [--git-dir=<path>] [--work-tree=<path>] [--namespace=<name>]\n           <command> [<args>]\n\n这些是在各种情况下使用的通用git命令：\n\nstart a working area (参见命令: git help tutorial)\n   clone      将存储库克隆到新目录中\n   init       创建一个空的git存储库或重新初始化一个现有的存储库\n\nwork on the current change (参见命令: git help everyday)\n   add        将文件内容添加到索引中\n   mv         移动或重命名文件、目录或符号链接\n   reset      将当前磁头重置为指定状态\n   rm         从工作树和索引中删除文件\n\nexamine the history and state (参见命令: git help revisions)\n   bisect     使用二分查找查找引入错误的提交\n   grep       打印与模式匹配的行\n   log        显示提交日志\n   show       显示各种类型的对象\n   status     显示工作树状态\n\ngrow, mark and tweak your common history\n   branch     列出、创建或删除分支\n   checkout   切换分支或还原工作树文件\n   commit     记录对存储库的更改\n   diff       显示提交、提交和工作树等之间的更改\n   merge      将两个或多个开发历史连接在一起\n   rebase     在另一个基本提示之上重新应用提交\n   tag        创建、列表、删除或验证用gpg签名的标记对象\n\ncollaborate (参见命令: git help workflows)\n   fetch      从另一个存储库下载对象和引用\n   pull       从另一个存储库或本地分支获取并与之集成\n   push       更新远程引用和相关对象\n\n'git help -a' 和 'git help -g' 列出可用的子命令和一些概念指导。\n命令'git help <command>' 或 'git help <concept>' 查看特定子命令或概念.\n\n\n\n# 参考文档\n\nhttps://www.liaoxuefeng.com/wiki/896043488029600",charsets:{cjk:!0},lastUpdated:"2023/11/19, 12:55:48",lastUpdatedTimestamp:1700369748e3},{title:"Git命令思维导图",frontmatter:{title:"Git命令思维导图",date:"2020-11-18T17:46:22.000Z",permalink:"/pages/4cbc21/",categories:["《Git》学习笔记"],tags:["Git"],author:{name:"王清欢",link:"https://github.com/wang-haihua"}},regularPath:"/05.Git%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.Git%20%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/04.Git%E5%91%BD%E4%BB%A4%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE.html",relativePath:"05.Git 学习笔记/10.Git 常用技巧/04.Git命令思维导图.md",key:"v-12d068a5",path:"/pages/4cbc21/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/11/19, 12:55:48",lastUpdatedTimestamp:1700369748e3},{title:"Git修改分支名",frontmatter:{title:"Git修改分支名",date:"2022-08-11T10:51:18.000Z",permalink:"/pages/922650/",categories:["技术","技术文档"],tags:[null],author:{name:"王清欢",link:"https://github.com/wang-haihua"}},regularPath:"/05.Git%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.Git%20%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/05.Git%E4%BF%AE%E6%94%B9%E5%88%86%E6%94%AF%E5%90%8D.html",relativePath:"05.Git 学习笔记/10.Git 常用技巧/05.Git修改分支名.md",key:"v-26aabec5",path:"/pages/922650/",headers:[{level:2,title:"同时修改本地分支名和对应的远程分支名",slug:"同时修改本地分支名和对应的远程分支名",normalizedTitle:"同时修改本地分支名和对应的远程分支名",charIndex:2}],headersStr:"同时修改本地分支名和对应的远程分支名",content:"# 同时修改本地分支名和对应的远程分支名\n\n修改前要确保本地分支的代码是最新的，并且修改后不会影响到同事的代码。\n\n 1. 修改本地分支名\n\ngit branch -m oldBranchName newBranchName\n\n\n 2. 删除远程分支\n\ngit push origin :oldBranchName\n# 或者 git push origin --delete oldBranchName\n\n\n 3. 改名后的本地分支推送到远程\n\ngit push --set-upstream origin newBranchName\n",normalizedContent:"# 同时修改本地分支名和对应的远程分支名\n\n修改前要确保本地分支的代码是最新的，并且修改后不会影响到同事的代码。\n\n 1. 修改本地分支名\n\ngit branch -m oldbranchname newbranchname\n\n\n 2. 删除远程分支\n\ngit push origin :oldbranchname\n# 或者 git push origin --delete oldbranchname\n\n\n 3. 改名后的本地分支推送到远程\n\ngit push --set-upstream origin newbranchname\n",charsets:{cjk:!0},lastUpdated:"2023/11/19, 12:55:48",lastUpdatedTimestamp:1700369748e3},{title:"Markdown使用教程",frontmatter:{title:"Markdown使用教程",date:"2019-12-25T14:27:01.000Z",permalink:"/pages/ad247c4332211551",categories:["技术","技术文档"],tags:[null],author:{name:"王清欢",link:"https://github.com/wang-haihua"}},regularPath:"/05.Git%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.Git%20%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/06.Markdown%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B.html",relativePath:"05.Git 学习笔记/10.Git 常用技巧/06.Markdown使用教程.md",key:"v-7b47030e",path:"/pages/ad247c4332211551/",headers:[{level:2,title:"一、Markdown",slug:"一、markdown",normalizedTitle:"一、markdown",charIndex:19},{level:3,title:"简介",slug:"简介",normalizedTitle:"简介",charIndex:34},{level:3,title:"应用",slug:"应用",normalizedTitle:"应用",charIndex:87},{level:3,title:"编辑器",slug:"编辑器",normalizedTitle:"编辑器",charIndex:152},{level:2,title:"二、徽章",slug:"二、徽章",normalizedTitle:"二、徽章",charIndex:194},{level:4,title:"什么是徽章",slug:"什么是徽章",normalizedTitle:"什么是徽章",charIndex:202},{level:4,title:"徽章的使用",slug:"徽章的使用",normalizedTitle:"徽章的使用",charIndex:318},{level:2,title:"三、设置目录",slug:"三、设置目录",normalizedTitle:"三、设置目录",charIndex:567},{level:2,title:"四、标题",slug:"四、标题",normalizedTitle:"四、标题",charIndex:1181},{level:2,title:"二级标题",slug:"二级标题",normalizedTitle:"二级标题",charIndex:1199},{level:3,title:"三级标题",slug:"三级标题",normalizedTitle:"三级标题",charIndex:1211},{level:4,title:"四级标题",slug:"四级标题",normalizedTitle:"四级标题",charIndex:1225},{level:5,title:"五级标题",slug:"五级标题",normalizedTitle:"五级标题",charIndex:1241},{level:6,title:"六级标题",slug:"六级标题",normalizedTitle:"六级标题",charIndex:1259},{level:2,title:"五、文本",slug:"五、文本",normalizedTitle:"五、文本",charIndex:1269},{level:3,title:"段落",slug:"段落",normalizedTitle:"段落",charIndex:1281},{level:3,title:"字体",slug:"字体",normalizedTitle:"字体",charIndex:1291},{level:3,title:"删除线",slug:"删除线",normalizedTitle:"删除线",charIndex:1301},{level:3,title:"下划线",slug:"下划线",normalizedTitle:"下划线",charIndex:1312},{level:3,title:"文字高亮",slug:"文字高亮",normalizedTitle:"文字高亮",charIndex:1323},{level:3,title:"分隔线",slug:"分隔线",normalizedTitle:"分隔线",charIndex:1335},{level:3,title:"脚注",slug:"脚注",normalizedTitle:"脚注",charIndex:1346},{level:2,title:"六、列表",slug:"六、列表",normalizedTitle:"六、列表",charIndex:1354},{level:3,title:"无序列表",slug:"无序列表",normalizedTitle:"无序列表",charIndex:1366},{level:3,title:"有序列表",slug:"有序列表",normalizedTitle:"有序列表",charIndex:1378},{level:3,title:"折叠列表",slug:"折叠列表",normalizedTitle:"折叠列表",charIndex:1390},{level:3,title:"带复选框列表",slug:"带复选框列表",normalizedTitle:"带复选框列表",charIndex:1402},{level:3,title:"列表嵌套",slug:"列表嵌套",normalizedTitle:"列表嵌套",charIndex:1416},{level:2,title:"七、区块引用",slug:"七、区块引用",normalizedTitle:"七、区块引用",charIndex:1426},{level:4,title:"区块嵌套",slug:"区块嵌套",normalizedTitle:"区块嵌套",charIndex:1440},{level:4,title:"区块中使用列表",slug:"区块中使用列表",normalizedTitle:"区块中使用列表",charIndex:1452},{level:4,title:"列表中使用区块",slug:"列表中使用区块",normalizedTitle:"列表中使用区块",charIndex:1467},{level:2,title:"八、代码",slug:"八、代码",normalizedTitle:"八、代码",charIndex:1480},{level:3,title:"代码区块",slug:"代码区块",normalizedTitle:"代码区块",charIndex:1492},{level:2,title:"九、链接",slug:"九、链接",normalizedTitle:"九、链接",charIndex:1502},{level:3,title:"变量链接",slug:"变量链接",normalizedTitle:"变量链接",charIndex:1514},{level:3,title:"Github仓库中使用内部链接",slug:"github仓库中使用内部链接",normalizedTitle:"github仓库中使用内部链接",charIndex:4680},{level:3,title:"锚点链接",slug:"锚点链接",normalizedTitle:"锚点链接",charIndex:1547},{level:2,title:"十、图片",slug:"十、图片",normalizedTitle:"十、图片",charIndex:1557},{level:3,title:"图片宽高",slug:"图片宽高",normalizedTitle:"图片宽高",charIndex:1569},{level:3,title:"相对路径以及Github中使用图片",slug:"相对路径以及github中使用图片",normalizedTitle:"相对路径以及github中使用图片",charIndex:1581},{level:2,title:"十一、表格",slug:"十一、表格",normalizedTitle:"十一、表格",charIndex:1604},{level:2,title:"十二、Emoji表情包",slug:"十二、emoji表情包",normalizedTitle:"十二、emoji表情包",charIndex:1615},{level:2,title:"十三、其他技巧",slug:"十三、其他技巧",normalizedTitle:"十三、其他技巧",charIndex:1632},{level:3,title:"支持的 HTML 元素",slug:"支持的-html-元素",normalizedTitle:"支持的 html 元素",charIndex:1647},{level:3,title:"转义",slug:"转义",normalizedTitle:"转义",charIndex:1666},{level:3,title:"数学公式",slug:"数学公式",normalizedTitle:"数学公式",charIndex:1676},{level:3,title:"图表",slug:"图表",normalizedTitle:"图表",charIndex:1688},{level:3,title:"流程图",slug:"流程图",normalizedTitle:"流程图",charIndex:1698},{level:3,title:"时序图",slug:"时序图",normalizedTitle:"时序图",charIndex:1709},{level:3,title:"甘特图",slug:"甘特图",normalizedTitle:"甘特图",charIndex:1720}],excerpt:'<h1 id="markdown使用教程"><a class="header-anchor" href="#markdown使用教程">#</a> Markdown使用教程</h1>\n<h2 id="一、markdown"><a class="header-anchor" href="#一、markdown">#</a> 一、Markdown</h2>\n<h3 id="简介"><a class="header-anchor" href="#简介">#</a> 简介</h3>\n<p><img src="https://raw.githubusercontent.com/xugaoyi/image_store/master/blog/md_logo.png" alt="logo"></p>\n<p><code>Markdown</code> 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。</p>\n',headersStr:"一、Markdown 简介 应用 编辑器 二、徽章 什么是徽章 徽章的使用 三、设置目录 四、标题 二级标题 三级标题 四级标题 五级标题 六级标题 五、文本 段落 字体 删除线 下划线 文字高亮 分隔线 脚注 六、列表 无序列表 有序列表 折叠列表 带复选框列表 列表嵌套 七、区块引用 区块嵌套 区块中使用列表 列表中使用区块 八、代码 代码区块 九、链接 变量链接 Github仓库中使用内部链接 锚点链接 十、图片 图片宽高 相对路径以及Github中使用图片 十一、表格 十二、Emoji表情包 十三、其他技巧 支持的 HTML 元素 转义 数学公式 图表 流程图 时序图 甘特图",content:"# Markdown使用教程\n\n\n# 一、Markdown\n\n\n# 简介\n\n\n\nMarkdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。\n\n\n# 应用\n\n当前许多网站都广泛使用 Markdown 来撰写帮助文档或是用于论坛上发表消息。例如：GitHub、简书、知乎等\n\n\n# 编辑器\n\n推荐使用Typora，官网：https://typora.io/\n\n\n# 二、徽章\n\n# 什么是徽章\n\n徽章是一种小巧精美的小图标，一般配有相关文字进行辅助说明，可对数据进行监控，链接跳转等，富有表现力。\n\n常见于github项目主页，但其不仅出现于 github 项目主页，凡是能够表现图片的地方都可以出现徽章。\n\n# 徽章的使用\n\n * 在markdown中使用\n\n格式:\n[![图片文字说明](图片源地址)](超链接地址)  # 即超链接内部嵌套图片\n\n语法：\n[![github](https://img.shields.io/badge/github-xugaoyi-brightgreen.svg)](https://github.com/xugaoyi)\n\n\n\n\n徽章生成网站：https://shields.io/\n\n本文档主要介绍markdown，不对徽章做过多介绍，详细介绍请 戳我 了解。\n\n\n# 三、设置目录\n\n设置之后会根据分级标题来自动生成目录。\n\n[TOC]\n\n\n> 注：github暂未支持。\n\n[TOC]\n\n在github生成TOC的方法：https://github.com/ekalinin/github-markdown-toc\n\nwindows系统需要基于golang实现的工具：https://github.com/ekalinin/github-markdown-toc.go\n\n> 如果你有GO语言的编译环境，可以尝试自己编译，如果没有，可以直接下载编译好的二进制文件。\n> \n> 如windows系统64位 下载：gh-md-toc.windows.amd64.tgz （386 是32位，amd64是64位）\n> \n> 下载解压后，发现没有后缀名无法识别，实际上这是个exe文件，所以只需要暴力地在后面加上.exe就可以开始愉快使用了。\n> \n> 使用方法：\n> \n>  1. 首先将.md文档复制到gh-md-toc.exe的根目录下\n>  2. 在该目录下打开系统命令行，输入命令：gh-md-toc.exe README.MD 生成目录\n>  3. 把生成的目录复制到.md文件即可。\n\n这是gh-md-toc生成的目录：\n\n * 一、Markdown\n   * 简介\n   * 应用\n   * 编辑器\n * 二、徽章\n   * 什么是徽章\n   * 徽章的使用\n * 三、设置目录\n * 四、标题\n * 一级标题\n   * 二级标题\n     * 三级标题\n       * 四级标题\n         * 五级标题\n           * 六级标题\n   * 五、文本\n     * 段落\n     * 字体\n     * 删除线\n     * 下划线\n     * 文字高亮\n     * 分隔线\n     * 脚注\n   * 六、列表\n     * 无序列表\n     * 有序列表\n     * 折叠列表\n     * 带复选框列表\n     * 列表嵌套\n   * 七、区块引用\n     * 区块嵌套\n     * 区块中使用列表\n     * 列表中使用区块\n   * 八、代码\n     * 代码区块\n   * 九、链接\n     * 变量链接\n     * Github中使用内部链接\n     * 锚点链接\n   * 十、图片\n     * 图片宽高\n     * 相对路径以及Github中使用图片\n   * 十一、表格\n   * 十二、Emoji表情包\n   * 十三、其他技巧\n     * 支持的 HTML 元素\n     * 转义\n     * 数学公式\n     * 图表\n     * 流程图\n     * 时序图\n     * 甘特图\n\n\n# 四、标题\n\n# 一级标题\n## 二级标题\n### 三级标题\n#### 四级标题\n##### 五级标题\n###### 六级标题\n\n\n\n# 一级标题\n\n\n# 二级标题\n\n\n# 三级标题\n\n# 四级标题\n\n# 五级标题\n\n# 六级标题\n\n\n# 五、文本\n\n\n# 段落\n\nMarkdown 段落没有特殊的格式，直接编写文字，需要段落缩进时使用2个Tab\n\n\n# 字体\n\n*斜体文本*\n或 _斜体文本_\n**粗体文本**\n或  __粗体文本__\n***粗斜体文本***\n或 ___粗斜体文本___\n\n\n斜体文本\n\n斜体文本\n\n粗体文本\n\n粗体文本\n\n粗斜体文本\n\n粗斜体文本\n\n\n# 删除线\n\n如果段落上的文字要添加删除线，只需要在文字的两端加上两个波浪线 ~~ 即可，实例如下：\n\n~~BAIDU.COM~~\n\n\nBAIDU.COM\n\n\n# 下划线\n\n下划线可以通过 HTML 的<u> 标签来实现：\n\n<u>带下划线的文本</u>\n\n\n带下划线的文本\n\n\n# 文字高亮\n\n文字高亮能使行内部分文字高亮，使用一对反引号。\n\n`html` `css` `javascript`\n\n\nhtml css javascript\n\n\n# 分隔线\n\n你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线：\n\n***\n\n*****\n\n- - -\n\n----------\n\n\n----------------------------------------\n\n\n# 脚注\n\n脚注是对文本的补充说明。\n\n[^变量]\n在文档结尾或其他位置給变量赋值：\n[^变量]: 注明框内显示的内容\n\n鼠标移到这里> [^哈喽]\n[^哈喽]: 注明框内显示的内容\n\n\n> 注：在部分线上预览未支持\n\n鼠标移到这里> ^哈喽\n\n\n# 六、列表\n\n\n# 无序列表\n\n使用星号*、加号+或是减号-作为列表标记：\n\n* 第一项\n* 第二项\n\n+ 第一项\n+ 第二项\n\n- 第一项\n- 第二项\n\n\n * 第一项\n * 第二项\n\n\n# 有序列表\n\n使用数字并加上. 号来表示\n\n1. 第一项\n2. 第二项\n\n\n 1. 第一项\n 2. 第二项\n\n\n# 折叠列表\n\n<details>\n<summary>点我打开关闭折叠</summary>\n 折叠内容\n <ul>\n     <li>1</li>\n     <li>2</li>\n     <li>3</li>\n </ul>\n</details>\n\n\n> 注意：<details> 标签内写markdown代码无效，可写html代码，如ul>li、table等\n\n点我打开关闭折叠 折叠内容\n * 1\n * 2\n * 3\n\n包含table的折叠\n\n分类        例词\n人称代词-主格   I我，you你，he他，she她，they他们， we我们\n人称代词-宾格   me我， you你， him他， her她， them他们， us我们\n物主代词      my我的， his他的， your你的（your你们的）， their他们的， hers她的\n指示代词      this这， that那， these这些， those 那些\n反身代词      myself我自己， himself他自己， themselves他们自己，\n          yourself你(们)自己，herself她自己\n疑问代词      who谁， what什么， which哪个\n不定代词      some一些， many许多， both两个、两个都， any许多\n关系代词      which……的物， who……的人， that……的人或物， who谁， that引导定语从句\n相互代词      each other 互相， one another互相\n连接代词      who,whom,whose,what,which,whatever,whichever,whoever,whomever\n替代词       one（单数），ones（复数）\n\n\n# 带复选框列表\n\n* [x] 第一项\n* [ ] 第二项\n* [ ] 第三项\n\n\n> 注：在部分线上预览未支持\n\n * [x] 第一项\n\n * [ ] 第二项\n\n * [ ] 第三项\n\n\n# 列表嵌套\n\n1. 第一项：\n    - 第一项嵌套的第一个元素\n    - 第一项嵌套的第二个元素\n2. 第二项：\n    - 第二项嵌套的第一个元素\n       - 第三层嵌套\n\n\n 1. 第一项\n    * 嵌套1\n    * 嵌套2\n 2. 第二项\n    * 嵌套1\n      * 嵌套2\n\n\n# 七、区块引用\n\n区块引用是在段落开头使用 >符号 ，然后后面紧跟一个空格符号：\n\n> 区块引用\n\n\n> 区块引用\n> \n> Typora中回车键自动延伸区块\n\n# 区块嵌套\n\n> 第一层\n> > 第二层\n> > > 第三层\n\n\n> 第一层\n> \n> > 第二层\n> > \n> > > 第三层\n\n# 区块中使用列表\n\n> 区块中使用列表\n> 1. 第一项\n> 2. 第二项\n> * 111\n> * 222\n\n\n> 区块中使用列表\n> \n>  1. 第一项\n>  2. 第二项\n>     * 111\n>     * 222\n\n# 列表中使用区块\n\n* 第一项\n    > 区块\n* 第二项\n\n\n * 第一项\n   \n   > 区块\n   > \n   > 区块\n\n * 第二项\n\n\n# 八、代码\n\n如果是段落上的一个代码片段可以用反引号把它包起来（`），示例：\n\n`alert()`\n\n\nalert()\n\n\n# 代码区块\n\n用三个反引号 ``` 包裹一段代码，并指定一种语言（也可以不指定），指定代码语言后会有代码的颜色高亮\n\n本代码区块为示例说明：\n\n​```javascript\nfunction test() {\n\talert('test')\n}\n​```\n\n\n效果：\n\nfunction test() {\n\talert('test')\n}\n\n\n\n# 九、链接\n\n格式：\n\n[链接名称](链接地址)\n\n[链接名称](链接地址,可选的alt)\n\n或\n\n<链接地址>\n\n\n示例：\n\n[百度](http://www.baidu.com,'百度')\n\n\n百度\n\n直接显示链接地址：\n\n<http://www.baidu.com>\n\n\nhttp://www.baidu.com\n\n\n# 变量链接\n\n链接可以用变量来代替，文档末尾或其他位置附带变量地址：\n\n这个链接用 1 作为网址变量 [Google][1]\n这个链接用 baidu 作为网址变量 [Baidu][baidu]\n\n然后在文档的结尾或其他位置给变量赋值（网址）\n  [1]: http://www.google.com/\n  [baidu]: http://www.baidu.com/\n\n\n这个链接用 1 作为网址变量 Google\n\n这个链接用 baidu 作为网址变量 Baidu\n\n\n# Github仓库中使用内部链接\n\n可使用相对路径（前提是有该路径下的文件）\n[test](test.md)\n\n\ntest\n\n\n# 锚点链接\n\n本文件中每一个标题都是一个锚点，和HTML的锚点（#）类似\n\n[Markdown](#Markdown)\n\n\n> 注： github对含有标点符号的标题进行锚点时会忽略掉标点符号， 本页中，如果这样写则无法跳转：[链接](#九、链接) 正确写法：[链接](#九链接)\n\nMarkdown\n\n链接\n\n流程图\n\n\n# 十、图片\n\n和链接的区别是前面多一个感叹号!\n\n![图片名](图片链接)\n\n\n当然，你也可以像链接那样对图片地址使用变量:\n\n这里链接用 img 作为图片地址变量\n然后在文档的结尾或其他位置给变量赋值（图片地址）\n![RUNOOB][img]\n[img]: https://raw.githubusercontent.com/xugaoyi/image_store/master/blog/md_logo.png\n\n\n\n\n\n# 图片宽高\n\n如下想设置图片宽高，可以使用 <img> 标签。\n\n<img src=\"https://raw.githubusercontent.com/xugaoyi/image_store/master/blog/md_logo.png\" width=\"50px\" height=\"30px\">\n\n\n\n# 相对路径以及Github中使用图片\n\n不管是在本地还是在github同一个仓库中，如果图片存在，可以使用相对路径。\n\n相对路径图片：\n\n![头像图片](./md-img/test.jpg)\n\n\ngithub上如果引用其他github仓库中的图片则要注意地址格式：仓库地址/raw/分支名/图片路径 或 https://raw.githubusercontent.com/用户名/仓库名/分支名/图片路径\n\n![其他仓库的图片1](https://github.com/xugaoyi/vue-music/raw/master/src/common/image/default.png)\n或\n![其他仓库的图片2](https://raw.githubusercontent.com/xugaoyi/image_store/master/blog/md_logo.png)\n\n\n\n\n\n\n\n\n# 十一、表格\n\n制作表格使用 |来分隔不同的单元格，使用-来分隔表头和其他行。\n\n|  表头   | 表头  |\n|  ----  | ----  |\n| 单元格  | 单元格 |\n| 单元格  | 单元格 |\n\n\n表头    表头\n单元格   单元格\n单元格   单元格\n\n对齐方式\n\n * -: 设置内容和标题栏居右对齐\n * :- 设置内容和标题栏居左对齐\n * :-: 设置内容和标题栏居中对齐\n\n| 左对齐 | 右对齐 | 居中对齐 |\n| :-----| ----: | :----: |\n| 单元格 | 单元格 | 单元格 |\n| 单元格 | 单元格 | 单元格 |\n\n\n左对齐   右对齐   居中对齐\n单元格   单元格   单元格\n单元格   单元格   单元格\n\n\n# 十二、Emoji表情包\n\nEmoji表情英文名的前后加冒号，Typore上先输入冒号再输入首字母有表情提示\n\n:smirk:\n\n\n💋 😸🙈🐴 😏😊😃😄 ☀️\n\n更多表情名称请查看：表情包清单\n\n\n# 十三、其他技巧\n\n\n# 支持的 HTML 元素\n\n不在 Markdown 语法涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。\n\n目前支持的 HTML 元素有：<kbd> <b> <i> <em> <sup> <sub> <br>等等 ，如：\n\n使用 <kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>Del</kbd> 重启电脑\n\n\n使用 Ctrl+Alt+Del 重启电脑\n\n我是使用b标签的加粗字体\n\n\n# 转义\n\nMarkdown 使用了很多特殊符号来表示特定的意义，如果需要显示特定的符号则需要使用反斜杠转义字符：\n\n**未转义星号显示加粗**\n\\*\\* 转义显示星号 \\*\\*\n\n\n未转义星号显示加粗 ** 转义显示星号 **\n\nMarkdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号：\n\n\\   反斜线\n`   反引号\n*   星号\n_   下划线\n{}  花括号\n[]  方括号\n()  小括号\n#   井字号\n+   加号\n-   减号\n.   英文句点\n!   感叹号\n\n\n----------------------------------------\n\n*** 以下部分在Github或其他在线预览中暂未支持 ***\n\n----------------------------------------\n\n\n# 数学公式\n\n当你需要在编辑器中插入数学公式时，可以使用两个美元符 $$ 包裹 TeX 或 LaTeX 格式的数学公式来实现。提交后，问答和文章页会根据需要加载 Mathjax 对数学公式进行渲染。如：\n\n$$\n\\mathbf{V}_1 \\times \\mathbf{V}_2 =  \\begin{vmatrix}\n\\mathbf{i} & \\mathbf{j} & \\mathbf{k} \\\\\n\\frac{\\partial X}{\\partial u} &  \\frac{\\partial Y}{\\partial u} & 0 \\\\\n\\frac{\\partial X}{\\partial v} &  \\frac{\\partial Y}{\\partial v} & 0 \\\\\n\\end{vmatrix}\n$$tep1}{\\style{visibility:hidden}{(x+1)(x+1)}}\n$$\n\n\n$$ \\mathbf{V}_1 \\times \\mathbf{V}_2 = \\begin{vmatrix} \\mathbf{i} & \\mathbf{j} & \\mathbf{k} \\ \\frac{\\partial X}{\\partial u} & \\frac{\\partial Y}{\\partial u} & 0 \\ \\frac{\\partial X}{\\partial v} & \\frac{\\partial Y}{\\partial v} & 0 \\ \\end{vmatrix} $$\n\n\n# 图表\n\n​```chart\n,Budget,Income,Expenses,Debt\nJune,5000,8000,4000,6000\nJuly,3000,1000,4000,3000\nAug,5000,7000,6000,3000\nSep,7000,2000,3000,1000\nOct,6000,5000,4000,2000\nNov,4000,3000,5000,\n\ntype: pie\ntitle: Monthly Revenue\nx.title: Amount\ny.title: Month\ny.suffix: $\n​```\n​```mermaid\nsequenceDiagram\nA->>B: 是否已收到消息？\nB--\x3e>A: 已收到消息\n​```\n\n\n> 注：在Typora中未支持\n\n\n# 流程图\n\n语法：\n​```mermaid\ngraph TD\nA[模块A] --\x3e|A1| B(模块B)\nB --\x3e C{判断条件C}\nC --\x3e|条件C1| D[模块D]\nC --\x3e|条件C2| E[模块E]\nC --\x3e|条件C3| F[模块F]\n​```\n\n\n流程图相关文章：\n\nhttps://www.jianshu.com/p/b421cc723da5\n\nhttp://www.imooc.com/article/292708\n\n\n# 时序图\n\n​```mermaid\nsequenceDiagram\nA->>B: 是否已收到消息？\nB--\x3e>A: 已收到消息\n​```\n\n\n\n# 甘特图\n\n​```mermaid\ngantt\ntitle 甘特图\ndateFormat  YYYY-MM-DD\nsection 项目A\n任务1           :a1, 2018-06-06, 30d\n任务2     :after a1  , 20d\nsection 项目B\n任务3      :2018-06-12  , 12d\n任务4      : 24d\n​```\n\n\n回到顶部",normalizedContent:"# markdown使用教程\n\n\n# 一、markdown\n\n\n# 简介\n\n\n\nmarkdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。\n\n\n# 应用\n\n当前许多网站都广泛使用 markdown 来撰写帮助文档或是用于论坛上发表消息。例如：github、简书、知乎等\n\n\n# 编辑器\n\n推荐使用typora，官网：https://typora.io/\n\n\n# 二、徽章\n\n# 什么是徽章\n\n徽章是一种小巧精美的小图标，一般配有相关文字进行辅助说明，可对数据进行监控，链接跳转等，富有表现力。\n\n常见于github项目主页，但其不仅出现于 github 项目主页，凡是能够表现图片的地方都可以出现徽章。\n\n# 徽章的使用\n\n * 在markdown中使用\n\n格式:\n[![图片文字说明](图片源地址)](超链接地址)  # 即超链接内部嵌套图片\n\n语法：\n[![github](https://img.shields.io/badge/github-xugaoyi-brightgreen.svg)](https://github.com/xugaoyi)\n\n\n\n\n徽章生成网站：https://shields.io/\n\n本文档主要介绍markdown，不对徽章做过多介绍，详细介绍请 戳我 了解。\n\n\n# 三、设置目录\n\n设置之后会根据分级标题来自动生成目录。\n\n[toc]\n\n\n> 注：github暂未支持。\n\n[toc]\n\n在github生成toc的方法：https://github.com/ekalinin/github-markdown-toc\n\nwindows系统需要基于golang实现的工具：https://github.com/ekalinin/github-markdown-toc.go\n\n> 如果你有go语言的编译环境，可以尝试自己编译，如果没有，可以直接下载编译好的二进制文件。\n> \n> 如windows系统64位 下载：gh-md-toc.windows.amd64.tgz （386 是32位，amd64是64位）\n> \n> 下载解压后，发现没有后缀名无法识别，实际上这是个exe文件，所以只需要暴力地在后面加上.exe就可以开始愉快使用了。\n> \n> 使用方法：\n> \n>  1. 首先将.md文档复制到gh-md-toc.exe的根目录下\n>  2. 在该目录下打开系统命令行，输入命令：gh-md-toc.exe readme.md 生成目录\n>  3. 把生成的目录复制到.md文件即可。\n\n这是gh-md-toc生成的目录：\n\n * 一、markdown\n   * 简介\n   * 应用\n   * 编辑器\n * 二、徽章\n   * 什么是徽章\n   * 徽章的使用\n * 三、设置目录\n * 四、标题\n * 一级标题\n   * 二级标题\n     * 三级标题\n       * 四级标题\n         * 五级标题\n           * 六级标题\n   * 五、文本\n     * 段落\n     * 字体\n     * 删除线\n     * 下划线\n     * 文字高亮\n     * 分隔线\n     * 脚注\n   * 六、列表\n     * 无序列表\n     * 有序列表\n     * 折叠列表\n     * 带复选框列表\n     * 列表嵌套\n   * 七、区块引用\n     * 区块嵌套\n     * 区块中使用列表\n     * 列表中使用区块\n   * 八、代码\n     * 代码区块\n   * 九、链接\n     * 变量链接\n     * github中使用内部链接\n     * 锚点链接\n   * 十、图片\n     * 图片宽高\n     * 相对路径以及github中使用图片\n   * 十一、表格\n   * 十二、emoji表情包\n   * 十三、其他技巧\n     * 支持的 html 元素\n     * 转义\n     * 数学公式\n     * 图表\n     * 流程图\n     * 时序图\n     * 甘特图\n\n\n# 四、标题\n\n# 一级标题\n## 二级标题\n### 三级标题\n#### 四级标题\n##### 五级标题\n###### 六级标题\n\n\n\n# 一级标题\n\n\n# 二级标题\n\n\n# 三级标题\n\n# 四级标题\n\n# 五级标题\n\n# 六级标题\n\n\n# 五、文本\n\n\n# 段落\n\nmarkdown 段落没有特殊的格式，直接编写文字，需要段落缩进时使用2个tab\n\n\n# 字体\n\n*斜体文本*\n或 _斜体文本_\n**粗体文本**\n或  __粗体文本__\n***粗斜体文本***\n或 ___粗斜体文本___\n\n\n斜体文本\n\n斜体文本\n\n粗体文本\n\n粗体文本\n\n粗斜体文本\n\n粗斜体文本\n\n\n# 删除线\n\n如果段落上的文字要添加删除线，只需要在文字的两端加上两个波浪线 ~~ 即可，实例如下：\n\n~~baidu.com~~\n\n\nbaidu.com\n\n\n# 下划线\n\n下划线可以通过 html 的<u> 标签来实现：\n\n<u>带下划线的文本</u>\n\n\n带下划线的文本\n\n\n# 文字高亮\n\n文字高亮能使行内部分文字高亮，使用一对反引号。\n\n`html` `css` `javascript`\n\n\nhtml css javascript\n\n\n# 分隔线\n\n你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线：\n\n***\n\n*****\n\n- - -\n\n----------\n\n\n----------------------------------------\n\n\n# 脚注\n\n脚注是对文本的补充说明。\n\n[^变量]\n在文档结尾或其他位置給变量赋值：\n[^变量]: 注明框内显示的内容\n\n鼠标移到这里> [^哈喽]\n[^哈喽]: 注明框内显示的内容\n\n\n> 注：在部分线上预览未支持\n\n鼠标移到这里> ^哈喽\n\n\n# 六、列表\n\n\n# 无序列表\n\n使用星号*、加号+或是减号-作为列表标记：\n\n* 第一项\n* 第二项\n\n+ 第一项\n+ 第二项\n\n- 第一项\n- 第二项\n\n\n * 第一项\n * 第二项\n\n\n# 有序列表\n\n使用数字并加上. 号来表示\n\n1. 第一项\n2. 第二项\n\n\n 1. 第一项\n 2. 第二项\n\n\n# 折叠列表\n\n<details>\n<summary>点我打开关闭折叠</summary>\n 折叠内容\n <ul>\n     <li>1</li>\n     <li>2</li>\n     <li>3</li>\n </ul>\n</details>\n\n\n> 注意：<details> 标签内写markdown代码无效，可写html代码，如ul>li、table等\n\n点我打开关闭折叠 折叠内容\n * 1\n * 2\n * 3\n\n包含table的折叠\n\n分类        例词\n人称代词-主格   i我，you你，he他，she她，they他们， we我们\n人称代词-宾格   me我， you你， him他， her她， them他们， us我们\n物主代词      my我的， his他的， your你的（your你们的）， their他们的， hers她的\n指示代词      this这， that那， these这些， those 那些\n反身代词      myself我自己， himself他自己， themselves他们自己，\n          yourself你(们)自己，herself她自己\n疑问代词      who谁， what什么， which哪个\n不定代词      some一些， many许多， both两个、两个都， any许多\n关系代词      which……的物， who……的人， that……的人或物， who谁， that引导定语从句\n相互代词      each other 互相， one another互相\n连接代词      who,whom,whose,what,which,whatever,whichever,whoever,whomever\n替代词       one（单数），ones（复数）\n\n\n# 带复选框列表\n\n* [x] 第一项\n* [ ] 第二项\n* [ ] 第三项\n\n\n> 注：在部分线上预览未支持\n\n * [x] 第一项\n\n * [ ] 第二项\n\n * [ ] 第三项\n\n\n# 列表嵌套\n\n1. 第一项：\n    - 第一项嵌套的第一个元素\n    - 第一项嵌套的第二个元素\n2. 第二项：\n    - 第二项嵌套的第一个元素\n       - 第三层嵌套\n\n\n 1. 第一项\n    * 嵌套1\n    * 嵌套2\n 2. 第二项\n    * 嵌套1\n      * 嵌套2\n\n\n# 七、区块引用\n\n区块引用是在段落开头使用 >符号 ，然后后面紧跟一个空格符号：\n\n> 区块引用\n\n\n> 区块引用\n> \n> typora中回车键自动延伸区块\n\n# 区块嵌套\n\n> 第一层\n> > 第二层\n> > > 第三层\n\n\n> 第一层\n> \n> > 第二层\n> > \n> > > 第三层\n\n# 区块中使用列表\n\n> 区块中使用列表\n> 1. 第一项\n> 2. 第二项\n> * 111\n> * 222\n\n\n> 区块中使用列表\n> \n>  1. 第一项\n>  2. 第二项\n>     * 111\n>     * 222\n\n# 列表中使用区块\n\n* 第一项\n    > 区块\n* 第二项\n\n\n * 第一项\n   \n   > 区块\n   > \n   > 区块\n\n * 第二项\n\n\n# 八、代码\n\n如果是段落上的一个代码片段可以用反引号把它包起来（`），示例：\n\n`alert()`\n\n\nalert()\n\n\n# 代码区块\n\n用三个反引号 ``` 包裹一段代码，并指定一种语言（也可以不指定），指定代码语言后会有代码的颜色高亮\n\n本代码区块为示例说明：\n\n​```javascript\nfunction test() {\n\talert('test')\n}\n​```\n\n\n效果：\n\nfunction test() {\n\talert('test')\n}\n\n\n\n# 九、链接\n\n格式：\n\n[链接名称](链接地址)\n\n[链接名称](链接地址,可选的alt)\n\n或\n\n<链接地址>\n\n\n示例：\n\n[百度](http://www.baidu.com,'百度')\n\n\n百度\n\n直接显示链接地址：\n\n<http://www.baidu.com>\n\n\nhttp://www.baidu.com\n\n\n# 变量链接\n\n链接可以用变量来代替，文档末尾或其他位置附带变量地址：\n\n这个链接用 1 作为网址变量 [google][1]\n这个链接用 baidu 作为网址变量 [baidu][baidu]\n\n然后在文档的结尾或其他位置给变量赋值（网址）\n  [1]: http://www.google.com/\n  [baidu]: http://www.baidu.com/\n\n\n这个链接用 1 作为网址变量 google\n\n这个链接用 baidu 作为网址变量 baidu\n\n\n# github仓库中使用内部链接\n\n可使用相对路径（前提是有该路径下的文件）\n[test](test.md)\n\n\ntest\n\n\n# 锚点链接\n\n本文件中每一个标题都是一个锚点，和html的锚点（#）类似\n\n[markdown](#markdown)\n\n\n> 注： github对含有标点符号的标题进行锚点时会忽略掉标点符号， 本页中，如果这样写则无法跳转：[链接](#九、链接) 正确写法：[链接](#九链接)\n\nmarkdown\n\n链接\n\n流程图\n\n\n# 十、图片\n\n和链接的区别是前面多一个感叹号!\n\n![图片名](图片链接)\n\n\n当然，你也可以像链接那样对图片地址使用变量:\n\n这里链接用 img 作为图片地址变量\n然后在文档的结尾或其他位置给变量赋值（图片地址）\n![runoob][img]\n[img]: https://raw.githubusercontent.com/xugaoyi/image_store/master/blog/md_logo.png\n\n\n\n\n\n# 图片宽高\n\n如下想设置图片宽高，可以使用 <img> 标签。\n\n<img src=\"https://raw.githubusercontent.com/xugaoyi/image_store/master/blog/md_logo.png\" width=\"50px\" height=\"30px\">\n\n\n\n# 相对路径以及github中使用图片\n\n不管是在本地还是在github同一个仓库中，如果图片存在，可以使用相对路径。\n\n相对路径图片：\n\n![头像图片](./md-img/test.jpg)\n\n\ngithub上如果引用其他github仓库中的图片则要注意地址格式：仓库地址/raw/分支名/图片路径 或 https://raw.githubusercontent.com/用户名/仓库名/分支名/图片路径\n\n![其他仓库的图片1](https://github.com/xugaoyi/vue-music/raw/master/src/common/image/default.png)\n或\n![其他仓库的图片2](https://raw.githubusercontent.com/xugaoyi/image_store/master/blog/md_logo.png)\n\n\n\n\n\n\n\n\n# 十一、表格\n\n制作表格使用 |来分隔不同的单元格，使用-来分隔表头和其他行。\n\n|  表头   | 表头  |\n|  ----  | ----  |\n| 单元格  | 单元格 |\n| 单元格  | 单元格 |\n\n\n表头    表头\n单元格   单元格\n单元格   单元格\n\n对齐方式\n\n * -: 设置内容和标题栏居右对齐\n * :- 设置内容和标题栏居左对齐\n * :-: 设置内容和标题栏居中对齐\n\n| 左对齐 | 右对齐 | 居中对齐 |\n| :-----| ----: | :----: |\n| 单元格 | 单元格 | 单元格 |\n| 单元格 | 单元格 | 单元格 |\n\n\n左对齐   右对齐   居中对齐\n单元格   单元格   单元格\n单元格   单元格   单元格\n\n\n# 十二、emoji表情包\n\nemoji表情英文名的前后加冒号，typore上先输入冒号再输入首字母有表情提示\n\n:smirk:\n\n\n💋 😸🙈🐴 😏😊😃😄 ☀️\n\n更多表情名称请查看：表情包清单\n\n\n# 十三、其他技巧\n\n\n# 支持的 html 元素\n\n不在 markdown 语法涵盖范围之内的标签，都可以直接在文档里面用 html 撰写。\n\n目前支持的 html 元素有：<kbd> <b> <i> <em> <sup> <sub> <br>等等 ，如：\n\n使用 <kbd>ctrl</kbd>+<kbd>alt</kbd>+<kbd>del</kbd> 重启电脑\n\n\n使用 ctrl+alt+del 重启电脑\n\n我是使用b标签的加粗字体\n\n\n# 转义\n\nmarkdown 使用了很多特殊符号来表示特定的意义，如果需要显示特定的符号则需要使用反斜杠转义字符：\n\n**未转义星号显示加粗**\n\\*\\* 转义显示星号 \\*\\*\n\n\n未转义星号显示加粗 ** 转义显示星号 **\n\nmarkdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号：\n\n\\   反斜线\n`   反引号\n*   星号\n_   下划线\n{}  花括号\n[]  方括号\n()  小括号\n#   井字号\n+   加号\n-   减号\n.   英文句点\n!   感叹号\n\n\n----------------------------------------\n\n*** 以下部分在github或其他在线预览中暂未支持 ***\n\n----------------------------------------\n\n\n# 数学公式\n\n当你需要在编辑器中插入数学公式时，可以使用两个美元符 $$ 包裹 tex 或 latex 格式的数学公式来实现。提交后，问答和文章页会根据需要加载 mathjax 对数学公式进行渲染。如：\n\n$$\n\\mathbf{v}_1 \\times \\mathbf{v}_2 =  \\begin{vmatrix}\n\\mathbf{i} & \\mathbf{j} & \\mathbf{k} \\\\\n\\frac{\\partial x}{\\partial u} &  \\frac{\\partial y}{\\partial u} & 0 \\\\\n\\frac{\\partial x}{\\partial v} &  \\frac{\\partial y}{\\partial v} & 0 \\\\\n\\end{vmatrix}\n$$tep1}{\\style{visibility:hidden}{(x+1)(x+1)}}\n$$\n\n\n$$ \\mathbf{v}_1 \\times \\mathbf{v}_2 = \\begin{vmatrix} \\mathbf{i} & \\mathbf{j} & \\mathbf{k} \\ \\frac{\\partial x}{\\partial u} & \\frac{\\partial y}{\\partial u} & 0 \\ \\frac{\\partial x}{\\partial v} & \\frac{\\partial y}{\\partial v} & 0 \\ \\end{vmatrix} $$\n\n\n# 图表\n\n​```chart\n,budget,income,expenses,debt\njune,5000,8000,4000,6000\njuly,3000,1000,4000,3000\naug,5000,7000,6000,3000\nsep,7000,2000,3000,1000\noct,6000,5000,4000,2000\nnov,4000,3000,5000,\n\ntype: pie\ntitle: monthly revenue\nx.title: amount\ny.title: month\ny.suffix: $\n​```\n​```mermaid\nsequencediagram\na->>b: 是否已收到消息？\nb--\x3e>a: 已收到消息\n​```\n\n\n> 注：在typora中未支持\n\n\n# 流程图\n\n语法：\n​```mermaid\ngraph td\na[模块a] --\x3e|a1| b(模块b)\nb --\x3e c{判断条件c}\nc --\x3e|条件c1| d[模块d]\nc --\x3e|条件c2| e[模块e]\nc --\x3e|条件c3| f[模块f]\n​```\n\n\n流程图相关文章：\n\nhttps://www.jianshu.com/p/b421cc723da5\n\nhttp://www.imooc.com/article/292708\n\n\n# 时序图\n\n​```mermaid\nsequencediagram\na->>b: 是否已收到消息？\nb--\x3e>a: 已收到消息\n​```\n\n\n\n# 甘特图\n\n​```mermaid\ngantt\ntitle 甘特图\ndateformat  yyyy-mm-dd\nsection 项目a\n任务1           :a1, 2018-06-06, 30d\n任务2     :after a1  , 20d\nsection 项目b\n任务3      :2018-06-12  , 12d\n任务4      : 24d\n​```\n\n\n回到顶部",charsets:{cjk:!0},lastUpdated:"2023/11/19, 12:55:48",lastUpdatedTimestamp:1700369748e3},{title:"Git提交规范",frontmatter:{title:"Git提交规范",date:"2023-07-06T21:02:44.000Z",permalink:"/pages/172ab2/"},regularPath:"/05.Git%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.Git%20%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/07.Git%E6%8F%90%E4%BA%A4%E8%A7%84%E8%8C%83.html",relativePath:"05.Git 学习笔记/10.Git 常用技巧/07.Git提交规范.md",key:"v-7cae4d1f",path:"/pages/172ab2/",headers:[{level:2,title:"git commit 提交规范",slug:"git-commit-提交规范",normalizedTitle:"git commit 提交规范",charIndex:2}],headersStr:"git commit 提交规范",content:"# git commit 提交规范\n\ncommit message 格式\n\n<type>(<scope>): <subject>\n\n\n包括三个字段：type（必需）、scope（可选）和 subject（必需）。\n\n（1）type : 用于说明 commit 的类别，只允许使用下面标识：\n\n>  * feat：新功能（feature）\n>  * fix：修补bug\n>  * style： 不影响代码含义的更改 (例如空格、格式化、少了分号)\n>  * perf：优化相关，比如提升性能、体验\n>  * docs：文档（documentation）\n>  * refactor：重构（即不是新增功能，也不是修改bug的代码变动）\n>  * test：增加测试\n>  * chore：构建过程或辅助工具的变动\n\n（2）scope : 用于说明 commit 影响的范围，比如数据层、控制层、视图层等等，视项目不同而不同\n\n（3）subject : commit 目的的简短描述，不超过50个字符\n\n> 以动词开头，使用第一人称现在时，比如change，而不是changed或changes 第一个字母小写 结尾不加句号（.）",normalizedContent:"# git commit 提交规范\n\ncommit message 格式\n\n<type>(<scope>): <subject>\n\n\n包括三个字段：type（必需）、scope（可选）和 subject（必需）。\n\n（1）type : 用于说明 commit 的类别，只允许使用下面标识：\n\n>  * feat：新功能（feature）\n>  * fix：修补bug\n>  * style： 不影响代码含义的更改 (例如空格、格式化、少了分号)\n>  * perf：优化相关，比如提升性能、体验\n>  * docs：文档（documentation）\n>  * refactor：重构（即不是新增功能，也不是修改bug的代码变动）\n>  * test：增加测试\n>  * chore：构建过程或辅助工具的变动\n\n（2）scope : 用于说明 commit 影响的范围，比如数据层、控制层、视图层等等，视项目不同而不同\n\n（3）subject : commit 目的的简短描述，不超过50个字符\n\n> 以动词开头，使用第一人称现在时，比如change，而不是changed或changes 第一个字母小写 结尾不加句号（.）",charsets:{cjk:!0},lastUpdated:"2023/11/19, 12:55:48",lastUpdatedTimestamp:1700369748e3},{title:"Git合并多个提交",frontmatter:{title:"Git合并多个提交",date:"2023-07-07T20:28:15.000Z",permalink:"/pages/1d2468/"},regularPath:"/05.Git%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.Git%20%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/08.Git%E5%90%88%E5%B9%B6%E5%A4%9A%E4%B8%AA%E6%8F%90%E4%BA%A4.html",relativePath:"05.Git 学习笔记/10.Git 常用技巧/08.Git合并多个提交.md",key:"v-698342a0",path:"/pages/1d2468/",headers:[{level:2,title:"使用场景",slug:"使用场景",normalizedTitle:"使用场景",charIndex:2},{level:2,title:"git rebase",slug:"git-rebase",normalizedTitle:"git rebase",charIndex:67},{level:2,title:"合并步骤",slug:"合并步骤",normalizedTitle:"合并步骤",charIndex:1154},{level:3,title:"1. 查看 log",slug:"_1-查看-log",normalizedTitle:"1. 查看 log",charIndex:1161},{level:3,title:"2. 交互页面编辑合并版本",slug:"_2-交互页面编辑合并版本",normalizedTitle:"2. 交互页面编辑合并版本",charIndex:1710},{level:3,title:"3. 查看合并后的 log",slug:"_3-查看合并后的-log",normalizedTitle:"3. 查看合并后的 log",charIndex:3335},{level:3,title:"4. 推送远程",slug:"_4-推送远程",normalizedTitle:"4. 推送远程",charIndex:1283},{level:2,title:"GitLens",slug:"gitlens",normalizedTitle:"gitlens",charIndex:4031}],headersStr:"使用场景 git rebase 合并步骤 1. 查看 log 2. 交互页面编辑合并版本 3. 查看合并后的 log 4. 推送远程 GitLens",content:'# 使用场景\n\n开发过程中，本地通常会有无数次 commit ，可以合并“相同功能”的多个 commit，以保持历史的简洁。\n\n\n# git rebase\n\n命令使用\n\ngit rebase --help\n\n# 从HEAD版本开始往过去数3个版本\n$ git rebase -i HEAD~3\n\n# 合并指定版本号（不包含此版本）\n$ git rebase -i [commitid]\n\n\n说明：\n\n>  * -i（--interactive）：弹出交互式的界面进行编辑合并\n>  * [commitid]：要合并多个版本之前的版本号，注意：[commitid] 本身不参与合并\n\n例如，如下例子中你想合并前 5 个 commit, 那么命令指定的 commitid 为 1d795e6，即 git rebase -i 1d795e6\n\n$ git log --oneline\n291e427 update website\n8c8f3f4 update website\n1693a6f update clear-logs.sh version\n3759b84 update clear-logs.sh\nfc36a2a add links\n1d795e6 fix && update clear-logs.sh 0.0.2\n9536dab add dingtalk script\n3a51aaa fix shellcheck problem\n2db6ad3 add clear logs scripts\ne57b0e6 fix && add batch del\n17cb931 fix && add batch del\ncf7e875 add redis script\nfe4bbcb Initial commit\n\n\n使用该命令之后会进入一个交互式的界面进行编辑合并，该页面中的第一列表示指令：\n\n>  * p, pick = use commit\n>  * r, reword = use commit, but edit the commit message\n>  * e, edit = use commit, but stop for amending\n>  * s, squash = use commit, but meld into previous commit\n>  * f, fixup = like "squash", but discard this commit\'s log message\n>  * x, exec = run command (the rest of the line) using shell\n>  * d, drop = remove commit\n\n\n# 合并步骤\n\n 1. 查看 log 记录，使用 git rebase -i [commitid] 选择要合并的 commit\n 2. 编辑要合并的版本信息，保存提交，多条合并会出现多次（可能会出现冲突）\n 3. 修改注释信息后，保存提交，多条合并会出现多次\n 4. 推送远程仓库或合并到主干分支、\n\n\n# 1. 查看 log\n\n$ git log --oneline\n291e427 update website\n8c8f3f4 update website\n1693a6f update clear-logs.sh version\n3759b84 update clear-logs.sh\nfc36a2a add links\n1d795e6 fix && update clear-logs.sh 0.0.2\n9536dab add dingtalk script\n3a51aaa fix shellcheck problem\n2db6ad3 add clear logs scripts\ne57b0e6 fix && add batch del\n17cb931 fix && add batch del\ncf7e875 add redis script\nfe4bbcb Initial commit\n\n\n\n# 2. 交互页面编辑合并版本\n\n例如，执行 git rebase -i [commitid] 命令之后会跳出如下内容，注意显示的内容是倒序的最老的提交在最上面，最新的在最下面\n\n# 指定要合并版本号，cf7e875 不参与合并，进入 vi 编辑器\n$ git rebase -i cf7e875 \npick 17cb931 fix && add batch del\npick e57b0e6 fix && add batch del\npick 2db6ad3 add clear logs scripts\npick 3a51aaa fix shellcheck problem\npick 9536dab add dingtalk script\npick 1d795e6 fix && update clear-logs.sh 0.0.2\npick fc36a2a add links\npick 3759b84 update clear-logs.sh\npick 1693a6f update clear-logs.sh version\npick 8c8f3f4 update website\n\n# Rebase cf7e875..291e427 onto cf7e875 (10 commands)\n#\n# Commands:\n# p, pick = use commit\n# r, reword = use commit, but edit the commit message\n# e, edit = use commit, but stop for amending\n# s, squash = use commit, but meld into previous commit\n# f, fixup = like "squash", but discard this commit\'s log message\n# x, exec = run command (the rest of the line) using shell\n# d, drop = remove commit\n#\n# These lines can be re-ordered; they are executed from top to bottom.\n#\n# If you remove a line here THAT COMMIT WILL BE LOST.\n#\n# However, if you remove everything, the rebase will be aborted.\n#\n# Note that empty commits are commented out\n\n\n根据需求修改第一列的指令，对版本进行合并\n\npick 17cb931 fix && add batch del\nf e57b0e6 fix && add batch del # 把 e57b0e6 合并到 17cb931，且不保留注释\npick 2db6ad3 add clear logs scripts\npick 3a51aaa fix shellcheck problem\npick 9536dab add dingtalk script\npick 1d795e6 fix && update clear-logs.sh 0.0.2\npick fc36a2a add linkss\npick 3759b84 update clear-logs.sh\ns 1693a6f update clear-logs.sh version\ns 8c8f3f4 update website # 把 8c8f3f4 和 1693a6f 合并到 3759b84\n\n\n修改完成之后，:wq 保持退出。保存退出后，又弹出一个新的框，让我们更改commit信息，编辑完后退出就好了。\n\n\n# 3. 查看合并后的 log\n\n4c2316c update clear-logs.sh\n73f082e add links\n56adcf2 fix && update clear-logs.sh 0.0.2\nebf3786 add dingtalk script\n6e81ea7 fix shellcheck problem\n64ca58f add clear logs scripts\n9327def fix && add batch del\ncf7e875 add redis script\nfe4bbcb Initial commit\n\n\n\n# 4. 推送远程\n\n首先，git pull 拉取与远程仓库同步，养成先pull最新代码再修改的好习惯；在修改本地代码前，先使用git pull拉取远程最新代码，然后再进行修改（推荐--rebase）\n\ngit pull 远程仓库名 远程分支名 --rebase\n\n\n然后，git push 推送，合并后 commitid 发生了变化，git 不允许 push 改变提交历史的操作，可以新增或者减少 commit 但不能改变原来的commit 历史，因此会报冲突。\n\n在确认代码无误的情况下，直接使用 --force 强制推送\n\ngit push 远程仓库名 远程分支名 --force\n\n\n在 git rebase 过程中，可能会存在冲突，此时就需要解决冲突。\n\n# 查看冲突\n$ git status\n\n# 解决冲突之后，本地提交\n$ git add .\n\n# rebase 继续\n$ git rebase --continue\n\n\n\n# GitLens\n\n如果你的 VSCode 安装了 GitLens 插件，这一切都可以变得很简单\n\n如下图所示：\n\n * 首先点击侧边栏的版本控制按钮，\n * 然后，打开 Commits 栏，在该栏目中可以选择 Undo Commit 撤销提交\n * 接着，在本地暂存区 Stage 中就可以看到撤销的提交；选择需要合并冲突或者要修改的文件点击 Unstage，这些文件就会从暂存区撤回到工作区 Changes，这样就可以进行修改了；\n * 最后，修改完成之后，将不同的 Commit 修改合并成一个 Commit 提交\n\n----------------------------------------\n\nreference:\n\n>  * https://cloud.tencent.com/developer/article/1690638\n>  * https://zhuanlan.zhihu.com/p/139321091',normalizedContent:'# 使用场景\n\n开发过程中，本地通常会有无数次 commit ，可以合并“相同功能”的多个 commit，以保持历史的简洁。\n\n\n# git rebase\n\n命令使用\n\ngit rebase --help\n\n# 从head版本开始往过去数3个版本\n$ git rebase -i head~3\n\n# 合并指定版本号（不包含此版本）\n$ git rebase -i [commitid]\n\n\n说明：\n\n>  * -i（--interactive）：弹出交互式的界面进行编辑合并\n>  * [commitid]：要合并多个版本之前的版本号，注意：[commitid] 本身不参与合并\n\n例如，如下例子中你想合并前 5 个 commit, 那么命令指定的 commitid 为 1d795e6，即 git rebase -i 1d795e6\n\n$ git log --oneline\n291e427 update website\n8c8f3f4 update website\n1693a6f update clear-logs.sh version\n3759b84 update clear-logs.sh\nfc36a2a add links\n1d795e6 fix && update clear-logs.sh 0.0.2\n9536dab add dingtalk script\n3a51aaa fix shellcheck problem\n2db6ad3 add clear logs scripts\ne57b0e6 fix && add batch del\n17cb931 fix && add batch del\ncf7e875 add redis script\nfe4bbcb initial commit\n\n\n使用该命令之后会进入一个交互式的界面进行编辑合并，该页面中的第一列表示指令：\n\n>  * p, pick = use commit\n>  * r, reword = use commit, but edit the commit message\n>  * e, edit = use commit, but stop for amending\n>  * s, squash = use commit, but meld into previous commit\n>  * f, fixup = like "squash", but discard this commit\'s log message\n>  * x, exec = run command (the rest of the line) using shell\n>  * d, drop = remove commit\n\n\n# 合并步骤\n\n 1. 查看 log 记录，使用 git rebase -i [commitid] 选择要合并的 commit\n 2. 编辑要合并的版本信息，保存提交，多条合并会出现多次（可能会出现冲突）\n 3. 修改注释信息后，保存提交，多条合并会出现多次\n 4. 推送远程仓库或合并到主干分支、\n\n\n# 1. 查看 log\n\n$ git log --oneline\n291e427 update website\n8c8f3f4 update website\n1693a6f update clear-logs.sh version\n3759b84 update clear-logs.sh\nfc36a2a add links\n1d795e6 fix && update clear-logs.sh 0.0.2\n9536dab add dingtalk script\n3a51aaa fix shellcheck problem\n2db6ad3 add clear logs scripts\ne57b0e6 fix && add batch del\n17cb931 fix && add batch del\ncf7e875 add redis script\nfe4bbcb initial commit\n\n\n\n# 2. 交互页面编辑合并版本\n\n例如，执行 git rebase -i [commitid] 命令之后会跳出如下内容，注意显示的内容是倒序的最老的提交在最上面，最新的在最下面\n\n# 指定要合并版本号，cf7e875 不参与合并，进入 vi 编辑器\n$ git rebase -i cf7e875 \npick 17cb931 fix && add batch del\npick e57b0e6 fix && add batch del\npick 2db6ad3 add clear logs scripts\npick 3a51aaa fix shellcheck problem\npick 9536dab add dingtalk script\npick 1d795e6 fix && update clear-logs.sh 0.0.2\npick fc36a2a add links\npick 3759b84 update clear-logs.sh\npick 1693a6f update clear-logs.sh version\npick 8c8f3f4 update website\n\n# rebase cf7e875..291e427 onto cf7e875 (10 commands)\n#\n# commands:\n# p, pick = use commit\n# r, reword = use commit, but edit the commit message\n# e, edit = use commit, but stop for amending\n# s, squash = use commit, but meld into previous commit\n# f, fixup = like "squash", but discard this commit\'s log message\n# x, exec = run command (the rest of the line) using shell\n# d, drop = remove commit\n#\n# these lines can be re-ordered; they are executed from top to bottom.\n#\n# if you remove a line here that commit will be lost.\n#\n# however, if you remove everything, the rebase will be aborted.\n#\n# note that empty commits are commented out\n\n\n根据需求修改第一列的指令，对版本进行合并\n\npick 17cb931 fix && add batch del\nf e57b0e6 fix && add batch del # 把 e57b0e6 合并到 17cb931，且不保留注释\npick 2db6ad3 add clear logs scripts\npick 3a51aaa fix shellcheck problem\npick 9536dab add dingtalk script\npick 1d795e6 fix && update clear-logs.sh 0.0.2\npick fc36a2a add linkss\npick 3759b84 update clear-logs.sh\ns 1693a6f update clear-logs.sh version\ns 8c8f3f4 update website # 把 8c8f3f4 和 1693a6f 合并到 3759b84\n\n\n修改完成之后，:wq 保持退出。保存退出后，又弹出一个新的框，让我们更改commit信息，编辑完后退出就好了。\n\n\n# 3. 查看合并后的 log\n\n4c2316c update clear-logs.sh\n73f082e add links\n56adcf2 fix && update clear-logs.sh 0.0.2\nebf3786 add dingtalk script\n6e81ea7 fix shellcheck problem\n64ca58f add clear logs scripts\n9327def fix && add batch del\ncf7e875 add redis script\nfe4bbcb initial commit\n\n\n\n# 4. 推送远程\n\n首先，git pull 拉取与远程仓库同步，养成先pull最新代码再修改的好习惯；在修改本地代码前，先使用git pull拉取远程最新代码，然后再进行修改（推荐--rebase）\n\ngit pull 远程仓库名 远程分支名 --rebase\n\n\n然后，git push 推送，合并后 commitid 发生了变化，git 不允许 push 改变提交历史的操作，可以新增或者减少 commit 但不能改变原来的commit 历史，因此会报冲突。\n\n在确认代码无误的情况下，直接使用 --force 强制推送\n\ngit push 远程仓库名 远程分支名 --force\n\n\n在 git rebase 过程中，可能会存在冲突，此时就需要解决冲突。\n\n# 查看冲突\n$ git status\n\n# 解决冲突之后，本地提交\n$ git add .\n\n# rebase 继续\n$ git rebase --continue\n\n\n\n# gitlens\n\n如果你的 vscode 安装了 gitlens 插件，这一切都可以变得很简单\n\n如下图所示：\n\n * 首先点击侧边栏的版本控制按钮，\n * 然后，打开 commits 栏，在该栏目中可以选择 undo commit 撤销提交\n * 接着，在本地暂存区 stage 中就可以看到撤销的提交；选择需要合并冲突或者要修改的文件点击 unstage，这些文件就会从暂存区撤回到工作区 changes，这样就可以进行修改了；\n * 最后，修改完成之后，将不同的 commit 修改合并成一个 commit 提交\n\n----------------------------------------\n\nreference:\n\n>  * https://cloud.tencent.com/developer/article/1690638\n>  * https://zhuanlan.zhihu.com/p/139321091',charsets:{cjk:!0},lastUpdated:"2023/11/19, 12:55:48",lastUpdatedTimestamp:1700369748e3},{title:"GitHub高级搜索技巧",frontmatter:{title:"GitHub高级搜索技巧",date:"2019-12-25T14:27:01.000Z",permalink:"/pages/4c778760be26d8b3",categories:["技术","GitHub技巧"],tags:[null],author:{name:"王清欢",link:"https://github.com/wang-haihua"}},regularPath:"/05.Git%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20.GitHub%20%E9%AB%98%E7%BA%A7%E6%8A%80%E5%B7%A7/11.GitHub%E9%AB%98%E7%BA%A7%E6%90%9C%E7%B4%A2%E6%8A%80%E5%B7%A7.html",relativePath:"05.Git 学习笔记/20.GitHub 高级技巧/11.GitHub高级搜索技巧.md",key:"v-2ce72fc6",path:"/pages/4c778760be26d8b3/",excerpt:'<h1 id="github高级搜索技巧"><a class="header-anchor" href="#github高级搜索技巧">#</a> GitHub高级搜索技巧</h1>\n<p><code>in:name &lt;关键字&gt;</code>\n仓库名称带关键字查询</p>\n<p><code>in:description &lt;关键字&gt;</code>\n仓库描述带关键字查询</p>\n<p><code>in:readme &lt;关键字&gt;</code>\nREADME文件带关键字查询</p>\n',headersStr:null,content:'# GitHub高级搜索技巧\n\nin:name <关键字> 仓库名称带关键字查询\n\nin:description <关键字> 仓库描述带关键字查询\n\nin:readme <关键字> README文件带关键字查询\n\nstars(fork): >(=) <数字> <关键字> star或fork数大于(或等于)指定数字的带关键字查询\n\nstars(fork): 10..20 <关键词> star或fork数在10到20之间的带关键字查询\n\nsize:>=5000 <关键词> 限定仓库大于等于5000K的带关键字查询\n\npushed(created):>2019-11-15 <关键字> 更新 或 创建 日期在2019年11月16日之后的带关键字查询\n\nlicense:apache-2.0 <关键字> LICENSE为apache-2.0的带关键字查询\n\nlanguage:java <关键词> 仓库语言为Java的带关键字查询\n\nuser:<用户名> 查询某个用户的项目\n\norg:<组织名> 查询某个组织的项目\n\n*以上查询条件可组合使用，空格隔开\n\n# 示例1：搜索仓库名包含javascript，并且stars数大于1000的项目\nin:name javascript stars:>1000\n\n# 示例2：搜索描述中包含"小程序"，并且fork大于100，并且最近更新时间在2019-11-15之后的，并且使用开发语言为vue的项目\nin:description 小程序 fork:>100 pushed:>2019-11-15 language:vue\n\n\n*或使用高级搜索页搜索：\n\nhttps://github.com/search/advanced',normalizedContent:'# github高级搜索技巧\n\nin:name <关键字> 仓库名称带关键字查询\n\nin:description <关键字> 仓库描述带关键字查询\n\nin:readme <关键字> readme文件带关键字查询\n\nstars(fork): >(=) <数字> <关键字> star或fork数大于(或等于)指定数字的带关键字查询\n\nstars(fork): 10..20 <关键词> star或fork数在10到20之间的带关键字查询\n\nsize:>=5000 <关键词> 限定仓库大于等于5000k的带关键字查询\n\npushed(created):>2019-11-15 <关键字> 更新 或 创建 日期在2019年11月16日之后的带关键字查询\n\nlicense:apache-2.0 <关键字> license为apache-2.0的带关键字查询\n\nlanguage:java <关键词> 仓库语言为java的带关键字查询\n\nuser:<用户名> 查询某个用户的项目\n\norg:<组织名> 查询某个组织的项目\n\n*以上查询条件可组合使用，空格隔开\n\n# 示例1：搜索仓库名包含javascript，并且stars数大于1000的项目\nin:name javascript stars:>1000\n\n# 示例2：搜索描述中包含"小程序"，并且fork大于100，并且最近更新时间在2019-11-15之后的，并且使用开发语言为vue的项目\nin:description 小程序 fork:>100 pushed:>2019-11-15 language:vue\n\n\n*或使用高级搜索页搜索：\n\nhttps://github.com/search/advanced',charsets:{cjk:!0},lastUpdated:"2023/11/19, 12:55:48",lastUpdatedTimestamp:1700369748e3},{title:"GitHub Actions 实现自动部署静态博客",frontmatter:{title:"GitHub Actions 实现自动部署静态博客",date:"2019-12-27T11:44:41.000Z",permalink:"/pages/6b9d359ec5aa5019",categories:["技术","GitHub技巧"],tags:[null],author:{name:"王清欢",link:"https://github.com/wang-haihua"}},regularPath:"/05.Git%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20.GitHub%20%E9%AB%98%E7%BA%A7%E6%8A%80%E5%B7%A7/12.GitHub%20Actions%20%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2.html",relativePath:"05.Git 学习笔记/20.GitHub 高级技巧/12.GitHub Actions 实现自动部署静态博客.md",key:"v-26153a30",path:"/pages/6b9d359ec5aa5019/",headers:[{level:2,title:"前言",slug:"前言",normalizedTitle:"前言",charIndex:32},{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:17},{level:2,title:"相关文章",slug:"相关文章",normalizedTitle:"相关文章",charIndex:3270}],excerpt:'<h1 id="github-actions-实现自动部署静态博客"><a class="header-anchor" href="#github-actions-实现自动部署静态博客">#</a> GitHub Actions 实现自动部署静态博客</h1>\n<h2 id="前言"><a class="header-anchor" href="#前言">#</a> 前言</h2>\n<p>我使用vuepress搭建了一个静态博客，挂在了Github pages和<a href="https://dev.tencent.com/" target="_blank" rel="noopener noreferrer">Coding pages<OutboundLink/></a>上面。</p>\n<p>coding pages在国内的访问速度比github pages要快很多，而且还可以被百度收录。</p>\n',headersStr:"前言 实现 相关文章",content:'# GitHub Actions 实现自动部署静态博客\n\n\n# 前言\n\n我使用vuepress搭建了一个静态博客，挂在了Github pages和Coding pages上面。\n\ncoding pages在国内的访问速度比github pages要快很多，而且还可以被百度收录。\n\n一开始的部署方式是使用sh部署脚本把代码提交到这两个平台的仓库分支，虽然已经很方便了，但是我还想把博客未打包的源码提交到Github主分支上。这就需要我操作两次命令，我就想能不能只需要一次操作就可以同时把源码、部署代码一次性提交到两个平台呢？\n\n\n# 实现\n\n在了解GitHub Actions最近（2019.12）刚正式发布了之后，尝试使用它发现能够满足我的需求。GitHub Actions 入门教程\n\n首先，需要获取token，后面会用到。获取方法：github获取token官方文档、coding获取token官方文档。\n\n然后，将这两个token同时储存到github仓库的Settings/Secrets里面。变量名可以随便取，但是注意要和后面的ci.yml文件内的变量名一致，这里取的是ACCESS_TOKEN和CODING_TOKEN。\n\n\n\nGitHub Actions 的配置文件叫做 workflow 文件，存放在代码仓库的.github/workflows目录。\n\nworkflow 文件采用 YAML 格式，文件名可以任意取，但是后缀名统一为.yml，比如ci.yml。一个库可以有多个 workflow 文件。GitHub 只要发现.github/workflows目录里面有.yml文件，就会自动运行该文件。\n\n我的ci.yml文件：\n\nname: CI\n\n# 在master分支发生push事件时触发。\non:\n  push:\n    branches:\n      - master\njobs: # 工作流\n  build:\n    runs-on: ubuntu-latest #运行在虚拟机环境ubuntu-latest\n\n    strategy:\n      matrix:\n        node-version: [10.x]\n\n    steps:\n      - name: Checkout # 步骤1\n        uses: actions/checkout@v1 # 使用的动作。格式：userName/repoName。作用：检出仓库，获取源码。 官方actions库：https://github.com/actions\n      - name: Use Node.js ${{ matrix.node-version }} # 步骤2\n        uses: actions/setup-node@v1 # 作用：安装nodejs\n        with:\n          node-version: ${{ matrix.node-version }} # 版本\n      - name: run deploy.sh # 步骤3 （同时部署到github和coding）\n        env: # 设置环境变量\n          GITHUB_TOKEN: ${{ secrets.ACCESS_TOKEN }} # toKen私密变量\n          CODING_TOKEN: ${{ secrets.CODING_TOKEN }} # 腾讯云开发者平台（coding）私密token\n        run: npm install && npm run deploy # 执行的命令\n        # package.json 中添加 "deploy": "bash deploy.sh"\n\n\n这个配置文件会在我push提交代码到主分支时触发工作，运行环境是ubuntu-latest，工作步骤：\n\n * 一，获取仓库源码\n\n * 二，安装nodejs，打包项目有用到nodejs\n\n * 三，把token设置到环境变量，安装项目依赖，并运行deploy.sh文件，\n\n> ACCESS_TOKE 和 CODING_TOKEN 都是保存在github仓库的Settings/Secrets位置的私密变量，仓库代码中可以通过<secrets.变量名>来获取，保证了token的私密性。\n\n再来看看将要被运行的deploy.sh部署代码：\n\n#!/usr/bin/env sh\n# 确保脚本抛出遇到的错误\nset -e\nnpm run build # 生成静态文件\ncd docs/.vuepress/dist # 进入生成的文件夹\n\n# deploy to github\necho \'blog.xugaoyi.com\' > CNAME\nif [ -z "$GITHUB_TOKEN" ]; then\n  msg=\'deploy\'\n  githubUrl=git@github.com:xugaoyi/blog.git\nelse\n  msg=\'来自github action的自动部署\'\n  githubUrl=https://xugaoyi:${GITHUB_TOKEN}@github.com/xugaoyi/blog.git\n  git config --global user.name "xugaoyi"\n  git config --global user.email "894072666@qq.com"\nfi\ngit init\ngit add -A\ngit commit -m "${msg}"\ngit push -f $githubUrl master:gh-pages # 推送到github\n\n# deploy to coding\necho \'www.xugaoyi.com\\nxugaoyi.com\' > CNAME  # 自定义域名\nif [ -z "$CODING_TOKEN" ]; then  # -z 字符串 长度为0则为true；$CODING_TOKEN来自于github仓库`Settings/Secrets`设置的私密环境变量\n  codingUrl=git@git.dev.tencent.com:xugaoyi/xugaoyi.git\nelse\n  codingUrl=https://xugaoyi:${CODING_TOKEN}@git.dev.tencent.com/xugaoyi/xugaoyi.git\nfi\ngit add -A\ngit commit -m "${msg}"\ngit push -f $codingUrl master # 推送到coding\n\ncd -\nrm -rf docs/.vuepress/dist\n\n\n这个文件使用Shell命令写的，它会先运行打包命令，进入打包好的文件，创建一个自定义域名的CNAME文件（如果你没有自定义域名可去掉这个命令），判断是否有token环境变量，如果没有说明是在本地自己的电脑上运行的部署，使用ssh代码仓库地址，如果有token环境变量，说明是GitHub Actions自动触发的部署，此时使用的是可以通过toKen来获取代码提交权限的提交地址。最后通过git命令提交到各自的仓库，完成部署。\n\n> 提示：\n> \n>  * Shell 可以获取到环境变量。\n> \n>  * 我想给两个平台上部署的博客不一样的自定义域名，因此做了分开创建CNAME文件，分开提交。\n\n至此，我前面提到的需求就实现啦，只需要把源码push到github仓库这一个步骤，后面的博客打包、部署到github和coding等工作都由GitHub Actions来自动完成。\n\n如下你想查看部署日志，你可以到github仓库的Actions这一项查看。\n\n\n\n\n# 相关文章\n\n《GitHub Actions 定时运行代码：每天定时百度链接推送》',normalizedContent:'# github actions 实现自动部署静态博客\n\n\n# 前言\n\n我使用vuepress搭建了一个静态博客，挂在了github pages和coding pages上面。\n\ncoding pages在国内的访问速度比github pages要快很多，而且还可以被百度收录。\n\n一开始的部署方式是使用sh部署脚本把代码提交到这两个平台的仓库分支，虽然已经很方便了，但是我还想把博客未打包的源码提交到github主分支上。这就需要我操作两次命令，我就想能不能只需要一次操作就可以同时把源码、部署代码一次性提交到两个平台呢？\n\n\n# 实现\n\n在了解github actions最近（2019.12）刚正式发布了之后，尝试使用它发现能够满足我的需求。github actions 入门教程\n\n首先，需要获取token，后面会用到。获取方法：github获取token官方文档、coding获取token官方文档。\n\n然后，将这两个token同时储存到github仓库的settings/secrets里面。变量名可以随便取，但是注意要和后面的ci.yml文件内的变量名一致，这里取的是access_token和coding_token。\n\n\n\ngithub actions 的配置文件叫做 workflow 文件，存放在代码仓库的.github/workflows目录。\n\nworkflow 文件采用 yaml 格式，文件名可以任意取，但是后缀名统一为.yml，比如ci.yml。一个库可以有多个 workflow 文件。github 只要发现.github/workflows目录里面有.yml文件，就会自动运行该文件。\n\n我的ci.yml文件：\n\nname: ci\n\n# 在master分支发生push事件时触发。\non:\n  push:\n    branches:\n      - master\njobs: # 工作流\n  build:\n    runs-on: ubuntu-latest #运行在虚拟机环境ubuntu-latest\n\n    strategy:\n      matrix:\n        node-version: [10.x]\n\n    steps:\n      - name: checkout # 步骤1\n        uses: actions/checkout@v1 # 使用的动作。格式：username/reponame。作用：检出仓库，获取源码。 官方actions库：https://github.com/actions\n      - name: use node.js ${{ matrix.node-version }} # 步骤2\n        uses: actions/setup-node@v1 # 作用：安装nodejs\n        with:\n          node-version: ${{ matrix.node-version }} # 版本\n      - name: run deploy.sh # 步骤3 （同时部署到github和coding）\n        env: # 设置环境变量\n          github_token: ${{ secrets.access_token }} # token私密变量\n          coding_token: ${{ secrets.coding_token }} # 腾讯云开发者平台（coding）私密token\n        run: npm install && npm run deploy # 执行的命令\n        # package.json 中添加 "deploy": "bash deploy.sh"\n\n\n这个配置文件会在我push提交代码到主分支时触发工作，运行环境是ubuntu-latest，工作步骤：\n\n * 一，获取仓库源码\n\n * 二，安装nodejs，打包项目有用到nodejs\n\n * 三，把token设置到环境变量，安装项目依赖，并运行deploy.sh文件，\n\n> access_toke 和 coding_token 都是保存在github仓库的settings/secrets位置的私密变量，仓库代码中可以通过<secrets.变量名>来获取，保证了token的私密性。\n\n再来看看将要被运行的deploy.sh部署代码：\n\n#!/usr/bin/env sh\n# 确保脚本抛出遇到的错误\nset -e\nnpm run build # 生成静态文件\ncd docs/.vuepress/dist # 进入生成的文件夹\n\n# deploy to github\necho \'blog.xugaoyi.com\' > cname\nif [ -z "$github_token" ]; then\n  msg=\'deploy\'\n  githuburl=git@github.com:xugaoyi/blog.git\nelse\n  msg=\'来自github action的自动部署\'\n  githuburl=https://xugaoyi:${github_token}@github.com/xugaoyi/blog.git\n  git config --global user.name "xugaoyi"\n  git config --global user.email "894072666@qq.com"\nfi\ngit init\ngit add -a\ngit commit -m "${msg}"\ngit push -f $githuburl master:gh-pages # 推送到github\n\n# deploy to coding\necho \'www.xugaoyi.com\\nxugaoyi.com\' > cname  # 自定义域名\nif [ -z "$coding_token" ]; then  # -z 字符串 长度为0则为true；$coding_token来自于github仓库`settings/secrets`设置的私密环境变量\n  codingurl=git@git.dev.tencent.com:xugaoyi/xugaoyi.git\nelse\n  codingurl=https://xugaoyi:${coding_token}@git.dev.tencent.com/xugaoyi/xugaoyi.git\nfi\ngit add -a\ngit commit -m "${msg}"\ngit push -f $codingurl master # 推送到coding\n\ncd -\nrm -rf docs/.vuepress/dist\n\n\n这个文件使用shell命令写的，它会先运行打包命令，进入打包好的文件，创建一个自定义域名的cname文件（如果你没有自定义域名可去掉这个命令），判断是否有token环境变量，如果没有说明是在本地自己的电脑上运行的部署，使用ssh代码仓库地址，如果有token环境变量，说明是github actions自动触发的部署，此时使用的是可以通过token来获取代码提交权限的提交地址。最后通过git命令提交到各自的仓库，完成部署。\n\n> 提示：\n> \n>  * shell 可以获取到环境变量。\n> \n>  * 我想给两个平台上部署的博客不一样的自定义域名，因此做了分开创建cname文件，分开提交。\n\n至此，我前面提到的需求就实现啦，只需要把源码push到github仓库这一个步骤，后面的博客打包、部署到github和coding等工作都由github actions来自动完成。\n\n如下你想查看部署日志，你可以到github仓库的actions这一项查看。\n\n\n\n\n# 相关文章\n\n《github actions 定时运行代码：每天定时百度链接推送》',charsets:{cjk:!0},lastUpdated:"2023/11/19, 12:55:48",lastUpdatedTimestamp:1700369748e3},{title:"GitHub Actions 定时运行代码：每天定时百度链接推送",frontmatter:{title:"GitHub Actions 定时运行代码：每天定时百度链接推送",date:"2019-12-30T21:23:00.000Z",permalink:"/pages/f44d2f9ad04ab8d3",categories:["技术","GitHub技巧"],tags:["github","博客"],author:{name:"王清欢",link:"https://github.com/wang-haihua"}},regularPath:"/05.Git%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20.GitHub%20%E9%AB%98%E7%BA%A7%E6%8A%80%E5%B7%A7/13.GitHub%20Actions%20%E5%AE%9A%E6%97%B6%E8%BF%90%E8%A1%8C%E4%BB%A3%E7%A0%81%EF%BC%9A%E6%AF%8F%E5%A4%A9%E5%AE%9A%E6%97%B6%E7%99%BE%E5%BA%A6%E9%93%BE%E6%8E%A5%E6%8E%A8%E9%80%81.html",relativePath:"05.Git 学习笔记/20.GitHub 高级技巧/13.GitHub Actions 定时运行代码：每天定时百度链接推送.md",key:"v-4236935a",path:"/pages/f44d2f9ad04ab8d3/",headers:[{level:2,title:"百度主动链接推送",slug:"百度主动链接推送",normalizedTitle:"百度主动链接推送",charIndex:246},{level:2,title:"自动生成urls.txt",slug:"自动生成urls-txt",normalizedTitle:"自动生成urls.txt",charIndex:599},{level:2,title:"GitHub Actions 定时运行代码",slug:"github-actions-定时运行代码",normalizedTitle:"github actions 定时运行代码",charIndex:2},{level:3,title:"配置 GitHub Actions",slug:"配置-github-actions",normalizedTitle:"配置 github actions",charIndex:1970},{level:3,title:"baiduPush命令在package.json配置",slug:"baidupush命令在package-json配置",normalizedTitle:"baidupush命令在package.json配置",charIndex:2688},{level:3,title:"baiduPush.sh执行百度推送命令",slug:"baidupush-sh执行百度推送命令",normalizedTitle:"baidupush.sh执行百度推送命令",charIndex:3029},{level:2,title:"相关文章",slug:"相关文章",normalizedTitle:"相关文章",charIndex:3495}],excerpt:'<h1 id="github-actions-定时运行代码-每天定时百度链接推送"><a class="header-anchor" href="#github-actions-定时运行代码-每天定时百度链接推送">#</a> GitHub Actions 定时运行代码：每天定时百度链接推送</h1>\n<p>博客上线已经有些日子了，却发现百度迟迟没有收录我的博客页面，在百度推送工具当中除了有自动推送的代码嵌入网站之外，还有一个实时的主动推送更高效。</p>\n<p>最近刚好了解到GitHub Actions的定时运行代码功能，可以用它来每天自动运行命令生成所有博客链接并进行一次性推送给百度。</p>\n<p>GitHub Actions 是一个 CI/CD（持续集成/持续部署）工具，但也可用作代码运行环境。<strong>功能非常强大，能够玩出许多花样。</strong></p>\n',headersStr:"百度主动链接推送 自动生成urls.txt GitHub Actions 定时运行代码 配置 GitHub Actions baiduPush命令在package.json配置 baiduPush.sh执行百度推送命令 相关文章",content:"# GitHub Actions 定时运行代码：每天定时百度链接推送\n\n博客上线已经有些日子了，却发现百度迟迟没有收录我的博客页面，在百度推送工具当中除了有自动推送的代码嵌入网站之外，还有一个实时的主动推送更高效。\n\n最近刚好了解到GitHub Actions的定时运行代码功能，可以用它来每天自动运行命令生成所有博客链接并进行一次性推送给百度。\n\nGitHub Actions 是一个 CI/CD（持续集成/持续部署）工具，但也可用作代码运行环境。功能非常强大，能够玩出许多花样。\n\n\n# 百度主动链接推送\n\n链接主动推送在百度站长中有介绍，如图。\n\n\n\n具体使用方法就是创建一个文件urls.txt，文件内每行一条链接的格式写入提交的多个链接，如图。\n\n\n\n运行命令\n\ncurl -H 'Content-Type:text/plain' --data-binary @urls.txt \"http://data.zz.baidu.com/urls?site=xugaoyi.com&token=T5PEAzhG*****\"\n\n\n上面命令的地址和参数由百度站长提供。运行完命令会返回推送结果，不出意外的话就会把urls.txt内的所有链接一次性推送给百度。\n\n这个方法虽然比嵌入网站头部的自动推送更高效，但是也有它的麻烦之处，就是得自己填入链接到urls.txt文件，然后手动运行命令。\n\n\n# 自动生成urls.txt\n\n没关系，技术的本质就是让人\"偷懒\"的。于是，我写了一个nodejs工具，用于把所有的博客页面链接生成到urls.txt\n\n// baiduPush.js\n\n/**\n * 生成百度链接推送文件\n */\nconst fs = require('fs');\nconst path = require('path');\nconst logger = require('tracer').colorConsole();\nconst matter = require('gray-matter'); // FrontMatter解析器 https://github.com/jonschlinkert/gray-matter\nconst readFileList = require('./modules/readFileList');\nconst urlsRoot = path.join(__dirname, '..', 'urls.txt'); // 百度链接推送文件\nconst DOMAIN = process.argv.splice(2)[0]; // 获取命令行传入的参数\n\nif (!DOMAIN) {\n  logger.error('请在运行此文件时指定一个你要进行百度推送的域名参数，例：node utils/baiduPush.js https://xugaoyi.com')\n  return\n}\n\nmain();\nfunction main() {\n  fs.writeFileSync(urlsRoot, DOMAIN)\n  const files = readFileList(); // 读取所有md文件数据\n\n  files.forEach( file => {\n    const { data } = matter(fs.readFileSync(file.filePath, 'utf8'));\n\n    if (data.permalink) {\n      const link = `\\r\\n${DOMAIN}${data.permalink}/`;\n      console.log(link)\n      fs.appendFileSync(urlsRoot, link);\n    }\n  })\n}\n\n\n上面代码仅是针对我个人的博客生成链接到urls.txt文件。更多代码在 这里。\n\n运行如下命令就可以生产一个包含博客所有链接的urls.txt文件：\n\nnode utils/baiduPush.js https://xugaoyi.com\n\n\n哈哈，第一个麻烦解决了😏，接下来是解决第二个需要手动运行推送命令的问题。\n\n> 如果你没办法自动生成，你也可以自己手动创建一个urls.txt文件，放到github仓库。\n\n\n# GitHub Actions 定时运行代码\n\n今天的主角GitHub Actions 要登场了。（相关：GitHub Actions 入门教程、GitHub Actions 实现自动部署静态博客）\n\nGitHub Actions 是一个 CI/CD（持续集成/持续部署）工具，但也可用作代码运行环境。功能非常强大，能够玩出许多花样。\n\n\n# 配置 GitHub Actions\n\n触发 GitHub Actions 需要在项目仓库新建一个.github/workflows子目录，里面是 YAML 格式配置文件，文件名可以随便取。GitHub 只要发现配置文件，就会运行 Actions。\n\n配置文件的第一部分是触发条件。\n\n## baiduPush.yml\nname: 'baiduPush'\n\non:\n  push:\n  schedule:\n    - cron: '0 23 * * *'\n\n\n上面代码中，name字段是配置文件的描述，on字段是触发条件。我们指定两种情况下触发，第一种是代码 Push 进仓库，第二种是定时任务，每天在国际标准时间23点（北京时间+8，即早上7点）运行。\n\n> 定时设置看这里\n\n接着，就是运行流程。\n\njobs:\n  bot:\n    runs-on: ubuntu-latest # 运行环境为最新版的Ubuntu\n    steps:\n      - name: 'Checkout codes' # 步骤一，获取仓库代码\n        uses: actions/checkout@v1\n      - name: 'Run baiduPush.sh' # 步骤二，执行sh命令文件\n        run: npm install && npm run baiduPush # 运行命令。（注意，运行目录是仓库根目录）\n\n\n上面代码中，指定运行环境是最新的ubuntu，流程的第一步是从代码仓库获取代码，第二步运行两个命令，先安装项目依赖，再运行写在package.json的baiduPush命令。完整代码看 这里\n\n\n# baiduPush命令在package.json配置\n\n// package.json\n\"scripts\": {\n\t\"baiduPush\": \"node utils/baiduPush.js https://xugaoyi.com && bash baiduPush.sh\"\n}\n\n\n上面脚本中在node utils/baiduPush.js的后面加入你的域名参数。运行此命令生成urls.txt文件，然后执行baiduPush.sh文件。\n\n注意，在使用window系统时，请使用git bash命令窗运行上面的脚本。\n\n> baiduPush命令之所以没有放在baiduPush.yml的 run 里面是因为我想在本地也可以执行npm run baiduPush命令。\n\n\n# baiduPush.sh执行百度推送命令\n\nbaiduPush.sh文件：\n\n#!/usr/bin/env sh\n\nset -e\n\n# 百度链接推送\ncurl -H 'Content-Type:text/plain' --data-binary @urls.txt \"http://data.zz.baidu.com/urls?site=https://xugaoyi.com&token=T5PEAzhGa*****\"\n\nrm -rf urls.txt # 灭迹\n\n\n上面代码中，把urls.txt文件中的所有链接一次性推送。\n\n> baiduPush.sh内的命令之所以没有写在package.json是因为我觉得命令太长了，不方便阅读。\n\n写好配置，推送到仓库，就会在每天的早上7点钟，自动运行命令生成一个包含博客所有页面链接的urls.txt文件，并把所有链接一次性推送到百度。麻麻再也不用担心我的网站不被收录~~😘 😘 😘\n\n在这个基础上可以扩展，使用GitHub Actions满足你自己的各种定时需求。\n\n\n# 相关文章\n\n《 GitHub Actions 实现自动部署静态博客》\n\n《解决百度无法收录搭建在GitHub上的静态博客的问题》",normalizedContent:"# github actions 定时运行代码：每天定时百度链接推送\n\n博客上线已经有些日子了，却发现百度迟迟没有收录我的博客页面，在百度推送工具当中除了有自动推送的代码嵌入网站之外，还有一个实时的主动推送更高效。\n\n最近刚好了解到github actions的定时运行代码功能，可以用它来每天自动运行命令生成所有博客链接并进行一次性推送给百度。\n\ngithub actions 是一个 ci/cd（持续集成/持续部署）工具，但也可用作代码运行环境。功能非常强大，能够玩出许多花样。\n\n\n# 百度主动链接推送\n\n链接主动推送在百度站长中有介绍，如图。\n\n\n\n具体使用方法就是创建一个文件urls.txt，文件内每行一条链接的格式写入提交的多个链接，如图。\n\n\n\n运行命令\n\ncurl -h 'content-type:text/plain' --data-binary @urls.txt \"http://data.zz.baidu.com/urls?site=xugaoyi.com&token=t5peazhg*****\"\n\n\n上面命令的地址和参数由百度站长提供。运行完命令会返回推送结果，不出意外的话就会把urls.txt内的所有链接一次性推送给百度。\n\n这个方法虽然比嵌入网站头部的自动推送更高效，但是也有它的麻烦之处，就是得自己填入链接到urls.txt文件，然后手动运行命令。\n\n\n# 自动生成urls.txt\n\n没关系，技术的本质就是让人\"偷懒\"的。于是，我写了一个nodejs工具，用于把所有的博客页面链接生成到urls.txt\n\n// baidupush.js\n\n/**\n * 生成百度链接推送文件\n */\nconst fs = require('fs');\nconst path = require('path');\nconst logger = require('tracer').colorconsole();\nconst matter = require('gray-matter'); // frontmatter解析器 https://github.com/jonschlinkert/gray-matter\nconst readfilelist = require('./modules/readfilelist');\nconst urlsroot = path.join(__dirname, '..', 'urls.txt'); // 百度链接推送文件\nconst domain = process.argv.splice(2)[0]; // 获取命令行传入的参数\n\nif (!domain) {\n  logger.error('请在运行此文件时指定一个你要进行百度推送的域名参数，例：node utils/baidupush.js https://xugaoyi.com')\n  return\n}\n\nmain();\nfunction main() {\n  fs.writefilesync(urlsroot, domain)\n  const files = readfilelist(); // 读取所有md文件数据\n\n  files.foreach( file => {\n    const { data } = matter(fs.readfilesync(file.filepath, 'utf8'));\n\n    if (data.permalink) {\n      const link = `\\r\\n${domain}${data.permalink}/`;\n      console.log(link)\n      fs.appendfilesync(urlsroot, link);\n    }\n  })\n}\n\n\n上面代码仅是针对我个人的博客生成链接到urls.txt文件。更多代码在 这里。\n\n运行如下命令就可以生产一个包含博客所有链接的urls.txt文件：\n\nnode utils/baidupush.js https://xugaoyi.com\n\n\n哈哈，第一个麻烦解决了😏，接下来是解决第二个需要手动运行推送命令的问题。\n\n> 如果你没办法自动生成，你也可以自己手动创建一个urls.txt文件，放到github仓库。\n\n\n# github actions 定时运行代码\n\n今天的主角github actions 要登场了。（相关：github actions 入门教程、github actions 实现自动部署静态博客）\n\ngithub actions 是一个 ci/cd（持续集成/持续部署）工具，但也可用作代码运行环境。功能非常强大，能够玩出许多花样。\n\n\n# 配置 github actions\n\n触发 github actions 需要在项目仓库新建一个.github/workflows子目录，里面是 yaml 格式配置文件，文件名可以随便取。github 只要发现配置文件，就会运行 actions。\n\n配置文件的第一部分是触发条件。\n\n## baidupush.yml\nname: 'baidupush'\n\non:\n  push:\n  schedule:\n    - cron: '0 23 * * *'\n\n\n上面代码中，name字段是配置文件的描述，on字段是触发条件。我们指定两种情况下触发，第一种是代码 push 进仓库，第二种是定时任务，每天在国际标准时间23点（北京时间+8，即早上7点）运行。\n\n> 定时设置看这里\n\n接着，就是运行流程。\n\njobs:\n  bot:\n    runs-on: ubuntu-latest # 运行环境为最新版的ubuntu\n    steps:\n      - name: 'checkout codes' # 步骤一，获取仓库代码\n        uses: actions/checkout@v1\n      - name: 'run baidupush.sh' # 步骤二，执行sh命令文件\n        run: npm install && npm run baidupush # 运行命令。（注意，运行目录是仓库根目录）\n\n\n上面代码中，指定运行环境是最新的ubuntu，流程的第一步是从代码仓库获取代码，第二步运行两个命令，先安装项目依赖，再运行写在package.json的baidupush命令。完整代码看 这里\n\n\n# baidupush命令在package.json配置\n\n// package.json\n\"scripts\": {\n\t\"baidupush\": \"node utils/baidupush.js https://xugaoyi.com && bash baidupush.sh\"\n}\n\n\n上面脚本中在node utils/baidupush.js的后面加入你的域名参数。运行此命令生成urls.txt文件，然后执行baidupush.sh文件。\n\n注意，在使用window系统时，请使用git bash命令窗运行上面的脚本。\n\n> baidupush命令之所以没有放在baidupush.yml的 run 里面是因为我想在本地也可以执行npm run baidupush命令。\n\n\n# baidupush.sh执行百度推送命令\n\nbaidupush.sh文件：\n\n#!/usr/bin/env sh\n\nset -e\n\n# 百度链接推送\ncurl -h 'content-type:text/plain' --data-binary @urls.txt \"http://data.zz.baidu.com/urls?site=https://xugaoyi.com&token=t5peazhga*****\"\n\nrm -rf urls.txt # 灭迹\n\n\n上面代码中，把urls.txt文件中的所有链接一次性推送。\n\n> baidupush.sh内的命令之所以没有写在package.json是因为我觉得命令太长了，不方便阅读。\n\n写好配置，推送到仓库，就会在每天的早上7点钟，自动运行命令生成一个包含博客所有页面链接的urls.txt文件，并把所有链接一次性推送到百度。麻麻再也不用担心我的网站不被收录~~😘 😘 😘\n\n在这个基础上可以扩展，使用github actions满足你自己的各种定时需求。\n\n\n# 相关文章\n\n《 github actions 实现自动部署静态博客》\n\n《解决百度无法收录搭建在github上的静态博客的问题》",charsets:{cjk:!0},lastUpdated:"2023/11/19, 12:55:48",lastUpdatedTimestamp:1700369748e3},{title:"Git变基合并",frontmatter:{title:"Git变基合并",date:"2020-11-18T17:43:57.000Z",permalink:"/pages/c10281/",categories:["《Git》学习笔记"],tags:["Git"],author:{name:"王清欢",link:"https://github.com/wang-haihua"}},regularPath:"/05.Git%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.Git%20%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/03.Git%E5%8F%98%E5%9F%BA%E5%90%88%E5%B9%B6.html",relativePath:"05.Git 学习笔记/10.Git 常用技巧/03.Git变基合并.md",key:"v-fe412f70",path:"/pages/c10281/",headers:[{level:2,title:"说明",slug:"说明",normalizedTitle:"说明",charIndex:17},{level:3,title:"变基要遵守的准则",slug:"变基要遵守的准则",normalizedTitle:"变基要遵守的准则",charIndex:673},{level:3,title:"变基的实质",slug:"变基的实质",normalizedTitle:"变基的实质",charIndex:742},{level:2,title:"后悔药",slug:"后悔药",normalizedTitle:"后悔药",charIndex:531},{level:2,title:"开发期间的rebase操作",slug:"开发期间的rebase操作",normalizedTitle:"开发期间的rebase操作",charIndex:1761},{level:3,title:"背景",slug:"背景",normalizedTitle:"背景",charIndex:1779},{level:3,title:"操作步骤",slug:"操作步骤",normalizedTitle:"操作步骤",charIndex:2004},{level:2,title:"git cherry-pick",slug:"git-cherry-pick",normalizedTitle:"git cherry-pick",charIndex:2325},{level:3,title:"基本应用",slug:"基本应用",normalizedTitle:"基本应用",charIndex:2397},{level:3,title:"转移多个提交",slug:"转移多个提交",normalizedTitle:"转移多个提交",charIndex:2576}],headersStr:"说明 变基要遵守的准则 变基的实质 后悔药 开发期间的rebase操作 背景 操作步骤 git cherry-pick 基本应用 转移多个提交",content:"# rebase分支合并\n\n\n# 说明\n\n以下 v2 是某个需求的开发分支， dev是总的开发分支，v2 是基于dev分支签出的。\n\n当完成v2的开发后，需要把代码合并到dev，我们可以使用rebase进行合并：\n\n# 首先将 v2 push到远程仓库\ngit add .\ngit commit -m 'xxx'\ngit push origin v2\n\n# 切换到 dev 拉取最新代码\ngit checkout dev\ngit pull origin dev\n\n# 切换到 v2\ngit checkout v2\ngit rebase dev # 将 v2 的所有[commit] 变基到(应用到) dev\n\n# 切换到 dev\ngit checkout dev\ngit merge v2  # 将 dev分支 快进合并 （此时 (HEAD -> dev, v2) [commit] 两个分支指向同一个提交）\n\n# 查看 原v2的[commit]记录 是否在dev分支的最前面（变基成功会把v2的提交记录应用到dev分支的最前面）\ngit log\n\n\t# 如果到这一步发现有问题，尝试使用 git --abort中止变基，如果还是有问题的可以在dev分支上使用《后悔药》操作， 再到v2分支上使用《后悔药》操作，即可使两个分支都回退到 rebase变基 之前的状态\n\n# 试运行项目是否有问题\nyarn start\n\ngit status # 查看状态是否有问题\ngit push origin dev # 推送到远程仓库的 dev\n\n\n\n\n# 变基要遵守的准则\n\n几个人同时在一个分支上进行开发和提交时，开发中途请不要私自执行变基，只有在大家都完成工作之后才可以执行变基。\n\n\n# 变基的实质\n\n变基操作的实质是丢弃一些现有的提交，然后相应地新建一些内容一样但实际上不同的提交。 因此，变基操作过后的分支将不要再使用。\n\n\n# 后悔药\n\n# 查看HEAD指针变动记录\ngit reflog\n# 记录示例(当前分支是v2):\n07c398f (HEAD -> v2, master) HEAD@{0}: checkout: moving from master to v2\n07c398f (HEAD -> v2, master) HEAD@{1}: rebase (finish): returning to refs/heads/master\n07c398f (HEAD -> v2, master) HEAD@{2}: rebase (start): checkout v2\n15a97d8 HEAD@{3}: reset: moving to 15a97d8\n07c398f (HEAD -> v2, master) HEAD@{4}: merge v2: Fast-forward\n15a97d8 HEAD@{5}: checkout: moving from v2 to master\n07c398f (HEAD -> v2, master) HEAD@{6}: rebase (finish): returning to refs/heads/v2\n07c398f (HEAD -> v2, master) HEAD@{7}: rebase (pick): C\n15a97d8 HEAD@{8}: rebase (start): checkout master # 首次rebase\nd278ecd HEAD@{9}: checkout: moving from master to v2 # rebase前的状态\n15a97d8 HEAD@{10}: commit: D\n\n# 可见，示例中最初的 rebase 操作是 HEAD@{8}，想回退到变基前的状态需让指针指向 HEAD@{9}\ngit reset --hard d278ecd  # 重置当前分支的HEAD为指定[commit]，同时重置暂存区和工作区，与指定[commit]一致\n\n# 此时打印 log 查看是否回到之前的状态\ngit log\n\n\n注意：此操作只能回退当前的分支，如其他分支也要回退，需要切换到该分支并执行上面操作。\n\n\n# 开发期间的rebase操作\n\n\n# 背景\n\n有两个分支：\n\ndev\n*v2\n\n\nv2 是基于dev切出来的。\n\n提交记录如下：\n\n\t\tdev\na - b - c\n\t\tv2\n\n\n开发期间，两个分支同时有新的commit ：\n\n\t\t\t\tdev\na - b - c - d - e\n\t\t\\ - f - g\n\t\t\t\tv2\n\n\n当前你正在v2进行开发，dev也同时进行开发，并有重大的改变，你需要把dev的提交同步到v2。\n\n需求： 把dev中新的提交同步到v2，且不能影响dev分支。\n\n\n# 操作步骤\n\n 1. 基于最新的 dev 切一个新的分支 dev-copy\n    \n    > dev-copy 和 dev 两者的 commit ID 一致。\n\n 2. 在dev-copy中执行rebase，将 dev-copy 的提交变基到 v2\n    \n    git rebase v2 # 将 dev-copy 的提交[commit] 变基到(应用到) v2\n    \n\n 3. 删除原v2分支，将dev-copy分支名改为v2\n    \n    # 当前在 dev-copy 分支\n    git branch -d v2 # 删除分支\n    git branch -m dev-copy v2 # 重命名\n    \n\n\n# git cherry-pick\n\n来源：《git cherry-pick 教程》\n\n用于将单个或几个[commit]复制到另一个分支。\n\n\n# 基本应用\n\ngit cherry-pick <commitHash> # 将commitHash应用于当前分支\n\n\n上面命令就会将指定的提交commitHash，应用于当前分支。这会在当前分支产生一个新的提交，当然它们的哈希值会不一样。\n\ngit cherry-pick命令的参数，不一定是提交的哈希值，分支名也是可以的，表示转移该分支的最新提交。\n\n\n# 转移多个提交\n\nCherry pick 支持一次转移多个提交。\n\ngit cherry-pick <HashA> <HashB> # A和B提交\n\n\n上面的命令将 A 和 B 两个提交应用到当前分支。这会在当前分支生成两个对应的新提交。\n\n如果想要转移一系列的连续提交，可以使用下面的简便语法。\n\ngit cherry-pick A..B # A到B提交，不包含A\n\n\n上面的命令可以转移从 A 到 B 的所有提交。它们必须按照正确的顺序放置：提交 A 必须早于提交 B，否则命令将失败，但不会报错。\n\n注意，使用上面的命令，提交 A 将不会包含在 Cherry pick 中。如果要包含提交 A，可以使用下面的语法。\n\ngit cherry-pick A^..B # A到B提交，包含A\n",normalizedContent:"# rebase分支合并\n\n\n# 说明\n\n以下 v2 是某个需求的开发分支， dev是总的开发分支，v2 是基于dev分支签出的。\n\n当完成v2的开发后，需要把代码合并到dev，我们可以使用rebase进行合并：\n\n# 首先将 v2 push到远程仓库\ngit add .\ngit commit -m 'xxx'\ngit push origin v2\n\n# 切换到 dev 拉取最新代码\ngit checkout dev\ngit pull origin dev\n\n# 切换到 v2\ngit checkout v2\ngit rebase dev # 将 v2 的所有[commit] 变基到(应用到) dev\n\n# 切换到 dev\ngit checkout dev\ngit merge v2  # 将 dev分支 快进合并 （此时 (head -> dev, v2) [commit] 两个分支指向同一个提交）\n\n# 查看 原v2的[commit]记录 是否在dev分支的最前面（变基成功会把v2的提交记录应用到dev分支的最前面）\ngit log\n\n\t# 如果到这一步发现有问题，尝试使用 git --abort中止变基，如果还是有问题的可以在dev分支上使用《后悔药》操作， 再到v2分支上使用《后悔药》操作，即可使两个分支都回退到 rebase变基 之前的状态\n\n# 试运行项目是否有问题\nyarn start\n\ngit status # 查看状态是否有问题\ngit push origin dev # 推送到远程仓库的 dev\n\n\n\n\n# 变基要遵守的准则\n\n几个人同时在一个分支上进行开发和提交时，开发中途请不要私自执行变基，只有在大家都完成工作之后才可以执行变基。\n\n\n# 变基的实质\n\n变基操作的实质是丢弃一些现有的提交，然后相应地新建一些内容一样但实际上不同的提交。 因此，变基操作过后的分支将不要再使用。\n\n\n# 后悔药\n\n# 查看head指针变动记录\ngit reflog\n# 记录示例(当前分支是v2):\n07c398f (head -> v2, master) head@{0}: checkout: moving from master to v2\n07c398f (head -> v2, master) head@{1}: rebase (finish): returning to refs/heads/master\n07c398f (head -> v2, master) head@{2}: rebase (start): checkout v2\n15a97d8 head@{3}: reset: moving to 15a97d8\n07c398f (head -> v2, master) head@{4}: merge v2: fast-forward\n15a97d8 head@{5}: checkout: moving from v2 to master\n07c398f (head -> v2, master) head@{6}: rebase (finish): returning to refs/heads/v2\n07c398f (head -> v2, master) head@{7}: rebase (pick): c\n15a97d8 head@{8}: rebase (start): checkout master # 首次rebase\nd278ecd head@{9}: checkout: moving from master to v2 # rebase前的状态\n15a97d8 head@{10}: commit: d\n\n# 可见，示例中最初的 rebase 操作是 head@{8}，想回退到变基前的状态需让指针指向 head@{9}\ngit reset --hard d278ecd  # 重置当前分支的head为指定[commit]，同时重置暂存区和工作区，与指定[commit]一致\n\n# 此时打印 log 查看是否回到之前的状态\ngit log\n\n\n注意：此操作只能回退当前的分支，如其他分支也要回退，需要切换到该分支并执行上面操作。\n\n\n# 开发期间的rebase操作\n\n\n# 背景\n\n有两个分支：\n\ndev\n*v2\n\n\nv2 是基于dev切出来的。\n\n提交记录如下：\n\n\t\tdev\na - b - c\n\t\tv2\n\n\n开发期间，两个分支同时有新的commit ：\n\n\t\t\t\tdev\na - b - c - d - e\n\t\t\\ - f - g\n\t\t\t\tv2\n\n\n当前你正在v2进行开发，dev也同时进行开发，并有重大的改变，你需要把dev的提交同步到v2。\n\n需求： 把dev中新的提交同步到v2，且不能影响dev分支。\n\n\n# 操作步骤\n\n 1. 基于最新的 dev 切一个新的分支 dev-copy\n    \n    > dev-copy 和 dev 两者的 commit id 一致。\n\n 2. 在dev-copy中执行rebase，将 dev-copy 的提交变基到 v2\n    \n    git rebase v2 # 将 dev-copy 的提交[commit] 变基到(应用到) v2\n    \n\n 3. 删除原v2分支，将dev-copy分支名改为v2\n    \n    # 当前在 dev-copy 分支\n    git branch -d v2 # 删除分支\n    git branch -m dev-copy v2 # 重命名\n    \n\n\n# git cherry-pick\n\n来源：《git cherry-pick 教程》\n\n用于将单个或几个[commit]复制到另一个分支。\n\n\n# 基本应用\n\ngit cherry-pick <commithash> # 将commithash应用于当前分支\n\n\n上面命令就会将指定的提交commithash，应用于当前分支。这会在当前分支产生一个新的提交，当然它们的哈希值会不一样。\n\ngit cherry-pick命令的参数，不一定是提交的哈希值，分支名也是可以的，表示转移该分支的最新提交。\n\n\n# 转移多个提交\n\ncherry pick 支持一次转移多个提交。\n\ngit cherry-pick <hasha> <hashb> # a和b提交\n\n\n上面的命令将 a 和 b 两个提交应用到当前分支。这会在当前分支生成两个对应的新提交。\n\n如果想要转移一系列的连续提交，可以使用下面的简便语法。\n\ngit cherry-pick a..b # a到b提交，不包含a\n\n\n上面的命令可以转移从 a 到 b 的所有提交。它们必须按照正确的顺序放置：提交 a 必须早于提交 b，否则命令将失败，但不会报错。\n\n注意，使用上面的命令，提交 a 将不会包含在 cherry pick 中。如果要包含提交 a，可以使用下面的语法。\n\ngit cherry-pick a^..b # a到b提交，包含a\n",charsets:{cjk:!0},lastUpdated:"2023/11/19, 12:55:48",lastUpdatedTimestamp:1700369748e3},{title:"GitHub加速下载项目的方法",frontmatter:{title:"GitHub加速下载项目的方法",date:"2020-03-09T10:28:09.000Z",permalink:"/pages/95331c6a9613faf8",categories:["技术","GitHub技巧"],tags:[null],author:{name:"王清欢",link:"https://github.com/wang-haihua"}},regularPath:"/05.Git%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20.GitHub%20%E9%AB%98%E7%BA%A7%E6%8A%80%E5%B7%A7/14.GitHub%E5%8A%A0%E9%80%9F%E4%B8%8B%E8%BD%BD%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%96%B9%E6%B3%95.html",relativePath:"05.Git 学习笔记/20.GitHub 高级技巧/14.GitHub加速下载项目的方法.md",key:"v-7b4b4b8e",path:"/pages/95331c6a9613faf8/",headers:[{level:2,title:"利用码云来转接做下载加速",slug:"利用码云来转接做下载加速",normalizedTitle:"利用码云来转接做下载加速",charIndex:109}],excerpt:'<h1 id="github加速下载项目的方法"><a class="header-anchor" href="#github加速下载项目的方法">#</a> GitHub加速下载项目的方法</h1>\n<p>国内在github上克隆项目总是异常的慢，据我多次克隆观察，下载速度最快就20k/s左右，特别是在克隆比较大的项目时简直慢得无法忍受！下面介绍一种加载克隆项目的方法。</p>\n',headersStr:"利用码云来转接做下载加速",content:'# GitHub加速下载项目的方法\n\n国内在github上克隆项目总是异常的慢，据我多次克隆观察，下载速度最快就20k/s左右，特别是在克隆比较大的项目时简直慢得无法忍受！下面介绍一种加载克隆项目的方法。\n\n\n\n\n# 利用码云来转接做下载加速\n\n 1. 首先你得有一个 码云 的账号\n\n 2. 登录码云之后在页面右上角的加号选择从GitHub/GitLab导入项目\n    \n    \n\n 3. 选择从URL导入，粘贴从GitHub复制来的仓库地址，然后导入，这个导入过程一般是很快的。\n    \n    \n\n 4. 从码云克隆刚导入的这个项目，克隆速度会快很多，网速好的能达到几兆每秒（具体速度就看你的网速了，吐槽一下我家网速，总在关键时刻显示"视频加载中"....）\n    \n    \n\n 5. 另外要注意的一点，克隆下来的项目关联的是码云的仓库，如果你需要关联github仓库需要更改远程仓库。\n    \n    git remote -v # 查看关联的远程仓库\n    git remote rm <仓库名> # 删除远程仓库\n    git remote add <仓库名> <远程仓库地址> # 关联远程仓库，仓库名一般使用origin\n    \n\n这个方法适合用于克隆比较大的项目，如果克隆小项目，20k/s的速度好像还能将就~~',normalizedContent:'# github加速下载项目的方法\n\n国内在github上克隆项目总是异常的慢，据我多次克隆观察，下载速度最快就20k/s左右，特别是在克隆比较大的项目时简直慢得无法忍受！下面介绍一种加载克隆项目的方法。\n\n\n\n\n# 利用码云来转接做下载加速\n\n 1. 首先你得有一个 码云 的账号\n\n 2. 登录码云之后在页面右上角的加号选择从github/gitlab导入项目\n    \n    \n\n 3. 选择从url导入，粘贴从github复制来的仓库地址，然后导入，这个导入过程一般是很快的。\n    \n    \n\n 4. 从码云克隆刚导入的这个项目，克隆速度会快很多，网速好的能达到几兆每秒（具体速度就看你的网速了，吐槽一下我家网速，总在关键时刻显示"视频加载中"....）\n    \n    \n\n 5. 另外要注意的一点，克隆下来的项目关联的是码云的仓库，如果你需要关联github仓库需要更改远程仓库。\n    \n    git remote -v # 查看关联的远程仓库\n    git remote rm <仓库名> # 删除远程仓库\n    git remote add <仓库名> <远程仓库地址> # 关联远程仓库，仓库名一般使用origin\n    \n\n这个方法适合用于克隆比较大的项目，如果克隆小项目，20k/s的速度好像还能将就~~',charsets:{cjk:!0},lastUpdated:"2023/11/19, 12:55:48",lastUpdatedTimestamp:1700369748e3},{title:"GitHub提交MR分支合并请求",frontmatter:{title:"GitHub提交MR分支合并请求",date:"2023-07-07T22:05:51.000Z",permalink:"/pages/fcb482/"},regularPath:"/05.Git%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20.GitHub%20%E9%AB%98%E7%BA%A7%E6%8A%80%E5%B7%A7/15.GitHub%E6%8F%90%E4%BA%A4MR%E5%88%86%E6%94%AF%E5%90%88%E5%B9%B6%E8%AF%B7%E6%B1%82.html",relativePath:"05.Git 学习笔记/20.GitHub 高级技巧/15.GitHub提交MR分支合并请求.md",key:"v-efad95c8",path:"/pages/fcb482/",headers:[{level:2,title:"MR 介绍",slug:"mr-介绍",normalizedTitle:"mr 介绍",charIndex:2},{level:2,title:"提交 MR 流程",slug:"提交-mr-流程",normalizedTitle:"提交 mr 流程",charIndex:347},{level:3,title:"1. 创建新分支",slug:"_1-创建新分支",normalizedTitle:"1. 创建新分支",charIndex:360},{level:3,title:"2. 开发后提交",slug:"_2-开发后提交",normalizedTitle:"2. 开发后提交",charIndex:484},{level:3,title:"3. 创建 MR",slug:"_3-创建-mr",normalizedTitle:"3. 创建 mr",charIndex:661},{level:3,title:"4. 合并后清理分支",slug:"_4-合并后清理分支",normalizedTitle:"4. 合并后清理分支",charIndex:889}],headersStr:"MR 介绍 提交 MR 流程 1. 创建新分支 2. 开发后提交 3. 创建 MR 4. 合并后清理分支",content:'# MR 介绍\n\n分支合并请求 Merge Request（MR），也可叫 Pull Request（PR）\n\nMR(或者PR)就是指将你开发的代码的内容以一种请求合并的方式来合并到它想去的分支上，这个请求的接收人(Reviewer)一般是项目、团队的负责人或者其他成员。\n\n一般来讲，开发团队都对Code Review（代码复审/审查/检视）的重视程度比较高。因为Code Review的确实能够提升代码的质量以及减少BUG的产生率。\n\nMerge Request在Code review中就是重要的一环。如果使用MR来发起合并请求，那么在代码审查时就完全可以以你本次请求的合并内容为单元进行代码审查，如果审查通过那么就成功合并。审查交由Reviewer进行，他可以是请求的接收人。\n\n\n# 提交 MR 流程\n\n\n# 1. 创建新分支\n\n每次新增功能，要基于 master（或其他基础分支） 分支创建新分支\n\n任何新建或修改操作之前，养成先 pull 再操作的好习惯\n\ngit pull\ngit checkout -b [new-branch-name]\n\n\n\n# 2. 开发后提交\n\n在新分支上进行修改操作，开发完成之后进行提交\n\ngit add .\ngit commit -m "your commit messages"\n\n\n最后，将代码推送到远程的仓库上，如下命令不仅完成关联并推送内容到远程仓库的分支，还可以在没有远程分支时创建该分支\n\ngit push -u origin your-branch\n\n\n\n# 3. 创建 MR\n\n在远程仓库的页面找到创建 MR 的按钮，不同仓库不太一样，Github 和 Gitee 中称为 Pull Request，GitLab 中则是 Merge Request。\n\n不论叫什么，流程大致是一样的，点击创建 MR，然后选择你提交的分支 Source branch 和要合并到的目标分支 Target branch\n\n选择委托人 Assignee，审查人 Reviewer，标签和里程碑，完成之后审查人就会收到你的 MR\n\n\n# 4. 合并后清理分支\n\n合并完成之后，需要删除本地分支和远程分支\n\n删除本地分支\n\ngit checkout master           \ngit pull\ngit branch -d your-branch\n\n\n删除远程分支\n\ngit push origin --delete your-branch\n\n\n----------------------------------------\n\nreference:\n\n * https://segmentfault.com/a/1190000040941132\n * https://blog.csdn.net/Alaska_State/article/details/121837486',normalizedContent:'# mr 介绍\n\n分支合并请求 merge request（mr），也可叫 pull request（pr）\n\nmr(或者pr)就是指将你开发的代码的内容以一种请求合并的方式来合并到它想去的分支上，这个请求的接收人(reviewer)一般是项目、团队的负责人或者其他成员。\n\n一般来讲，开发团队都对code review（代码复审/审查/检视）的重视程度比较高。因为code review的确实能够提升代码的质量以及减少bug的产生率。\n\nmerge request在code review中就是重要的一环。如果使用mr来发起合并请求，那么在代码审查时就完全可以以你本次请求的合并内容为单元进行代码审查，如果审查通过那么就成功合并。审查交由reviewer进行，他可以是请求的接收人。\n\n\n# 提交 mr 流程\n\n\n# 1. 创建新分支\n\n每次新增功能，要基于 master（或其他基础分支） 分支创建新分支\n\n任何新建或修改操作之前，养成先 pull 再操作的好习惯\n\ngit pull\ngit checkout -b [new-branch-name]\n\n\n\n# 2. 开发后提交\n\n在新分支上进行修改操作，开发完成之后进行提交\n\ngit add .\ngit commit -m "your commit messages"\n\n\n最后，将代码推送到远程的仓库上，如下命令不仅完成关联并推送内容到远程仓库的分支，还可以在没有远程分支时创建该分支\n\ngit push -u origin your-branch\n\n\n\n# 3. 创建 mr\n\n在远程仓库的页面找到创建 mr 的按钮，不同仓库不太一样，github 和 gitee 中称为 pull request，gitlab 中则是 merge request。\n\n不论叫什么，流程大致是一样的，点击创建 mr，然后选择你提交的分支 source branch 和要合并到的目标分支 target branch\n\n选择委托人 assignee，审查人 reviewer，标签和里程碑，完成之后审查人就会收到你的 mr\n\n\n# 4. 合并后清理分支\n\n合并完成之后，需要删除本地分支和远程分支\n\n删除本地分支\n\ngit checkout master           \ngit pull\ngit branch -d your-branch\n\n\n删除远程分支\n\ngit push origin --delete your-branch\n\n\n----------------------------------------\n\nreference:\n\n * https://segmentfault.com/a/1190000040941132\n * https://blog.csdn.net/alaska_state/article/details/121837486',charsets:{cjk:!0},lastUpdated:"2023/11/19, 12:55:48",lastUpdatedTimestamp:1700369748e3},{title:"Git基础与命令",frontmatter:{title:"Git基础与命令",date:"2020-11-18T17:43:57.000Z",permalink:"/pages/635088/",categories:["《Git》学习笔记"],tags:["Git"],author:{name:"王清欢",link:"https://github.com/wang-haihua"}},regularPath:"/05.Git%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/30.Git%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%AC%94%E8%AE%B0/10.Git%E5%9F%BA%E7%A1%80%E4%B8%8E%E5%91%BD%E4%BB%A4.html",relativePath:"05.Git 学习笔记/30.Git 官方文档笔记/10.Git基础与命令.md",key:"v-f5673184",path:"/pages/635088/",headers:[{level:2,title:"Git基础",slug:"git基础",normalizedTitle:"git基础",charIndex:2},{level:3,title:"全局配置",slug:"全局配置",normalizedTitle:"全局配置",charIndex:93},{level:3,title:"检查配置信息",slug:"检查配置信息",normalizedTitle:"检查配置信息",charIndex:196},{level:3,title:"获取帮助",slug:"获取帮助",normalizedTitle:"获取帮助",charIndex:227},{level:3,title:"初始化仓库",slug:"初始化仓库",normalizedTitle:"初始化仓库",charIndex:368},{level:3,title:"克隆远程仓库",slug:"克隆远程仓库",normalizedTitle:"克隆远程仓库",charIndex:438},{level:3,title:"检查文件状态",slug:"检查文件状态",normalizedTitle:"检查文件状态",charIndex:575},{level:3,title:"加入暂存区 (跟踪文件)",slug:"加入暂存区-跟踪文件",normalizedTitle:"加入暂存区 (跟踪文件)",charIndex:879},{level:3,title:"忽略文件",slug:"忽略文件",normalizedTitle:"忽略文件",charIndex:1042},{level:3,title:"查看修改的具体内容",slug:"查看修改的具体内容",normalizedTitle:"查看修改的具体内容",charIndex:1978},{level:3,title:"提交更新",slug:"提交更新",normalizedTitle:"提交更新",charIndex:2128},{level:3,title:"跳过使用暂存区域",slug:"跳过使用暂存区域",normalizedTitle:"跳过使用暂存区域",charIndex:2263},{level:2,title:"Git 基础 - 查看提交历史",slug:"git-基础-查看提交历史",normalizedTitle:"git 基础 - 查看提交历史",charIndex:2359},{level:2,title:"Git 基础 - 撤消操作",slug:"git-基础-撤消操作",normalizedTitle:"git 基础 - 撤消操作",charIndex:3817},{level:2,title:"Git 基础 - 远程仓库的使用",slug:"git-基础-远程仓库的使用",normalizedTitle:"git 基础 - 远程仓库的使用",charIndex:4015},{level:3,title:"查看远程仓库",slug:"查看远程仓库",normalizedTitle:"查看远程仓库",charIndex:4036},{level:3,title:"添加远程仓库",slug:"添加远程仓库",normalizedTitle:"添加远程仓库",charIndex:4104},{level:3,title:"从远程仓库中抓取与拉取",slug:"从远程仓库中抓取与拉取",normalizedTitle:"从远程仓库中抓取与拉取",charIndex:4147},{level:3,title:"推送到远程仓库",slug:"推送到远程仓库",normalizedTitle:"推送到远程仓库",charIndex:1029},{level:3,title:"查看某个远程仓库",slug:"查看某个远程仓库",normalizedTitle:"查看某个远程仓库",charIndex:4590},{level:3,title:"远程仓库的重命名与移除",slug:"远程仓库的重命名与移除",normalizedTitle:"远程仓库的重命名与移除",charIndex:4712},{level:2,title:"Git 基础 - 打标签",slug:"git-基础-打标签",normalizedTitle:"git 基础 - 打标签",charIndex:4804},{level:3,title:"列出标签",slug:"列出标签",normalizedTitle:"列出标签",charIndex:4821},{level:3,title:"创建标签",slug:"创建标签",normalizedTitle:"创建标签",charIndex:4913},{level:3,title:"附注标签",slug:"附注标签",normalizedTitle:"附注标签",charIndex:4948},{level:3,title:"轻量标签",slug:"轻量标签",normalizedTitle:"轻量标签",charIndex:4930},{level:3,title:"后期打标签",slug:"后期打标签",normalizedTitle:"后期打标签",charIndex:5620},{level:3,title:"共享标签",slug:"共享标签",normalizedTitle:"共享标签",charIndex:6007},{level:3,title:"删除标签",slug:"删除标签",normalizedTitle:"删除标签",charIndex:6234},{level:3,title:"检出标签",slug:"检出标签",normalizedTitle:"检出标签",charIndex:6703},{level:2,title:"Git 命令别名",slug:"git-命令别名",normalizedTitle:"git 命令别名",charIndex:7774}],headersStr:"Git基础 全局配置 检查配置信息 获取帮助 初始化仓库 克隆远程仓库 检查文件状态 加入暂存区 (跟踪文件) 忽略文件 查看修改的具体内容 提交更新 跳过使用暂存区域 Git 基础 - 查看提交历史 Git 基础 - 撤消操作 Git 基础 - 远程仓库的使用 查看远程仓库 添加远程仓库 从远程仓库中抓取与拉取 推送到远程仓库 查看某个远程仓库 远程仓库的重命名与移除 Git 基础 - 打标签 列出标签 创建标签 附注标签 轻量标签 后期打标签 共享标签 删除标签 检出标签 Git 命令别名",content:"# Git基础与命令\n\n官方文档（中文）：https://git-scm.com/book/zh/v2\n\n> 本文档是根据官方文档来编写的，以官方文档为准。\n\n\n# Git基础\n\n\n# 全局配置\n\ngit config --global user.name 'your name'\ngit config --global user.email 'xxx@xx.com'\n\n\n自报家门\n\n\n# 检查配置信息\n\ngit config --list\n\n\n\n# 获取帮助\n\n# 获取全局帮助手册\ngit help\n\n# 获取特定命令的详细版帮助手册 (两个命令是等价的)\ngit help <某个命令>\ngit <某个命令> --help # 两个横杠\n\n# 获取特定命令的简明版帮助手册\ngit <某个命令> -h  # 一个横杠\n\n\n\n# 初始化仓库\n\n# 本地目录初始化仓库\ngit init\n\n\n如果你是从远程仓库clone的项目，则该项目是已经初始化好的git仓库\n\n\n# 克隆远程仓库\n\n# 克隆\ngit clone <url>\n\n# 克隆同时修改目录名\ngit clone <url> <name>\n\n\n初次克隆某个仓库的时候，工作目录中的所有文件都属于已跟踪文件，并处于未修改状态，因为 Git 刚刚检出了它们， 而你尚未编辑过它们\n\n\n# 检查文件状态\n\n# 查看详细状态说明\ngit status\n\n# 查看简明状态说明\ngit status -s  # -s 或 --short\n M README # 已修改，但未暂存 （M的位置靠右，红色）\nMM Rakefile # 已修改，暂存后又作了修改（有暂存和未暂存）\nA  lib/git.rb # 新添加到暂存区，未提交\nM  lib/simplegit.rb # 已修改，已暂存 （M的位置靠左，绿色）\n?? LICENSE.txt # 新添加，未跟踪\n\n\n * git目录中的文件状态包含：是否跟踪、是否修改、是否已存入暂存区\n\n * 参数的一个横杠表示缩写，两个横杠表示全称。\n\n\n# 加入暂存区 (跟踪文件)\n\n# 文件加入暂存区（跟踪指定文件)\ngit add <files>\n\n\ngit add 命令使用文件或目录的路径作为参数；如果参数是目录的路径，该命令将递归地跟踪该目录下的所有文件。\n\nadd 命令是将文件加入到暂存区，commit 命令的提交到本地仓库，push 命令是推送到远程仓库。\n\n\n# 忽略文件\n\n添加一个名为 .gitignore 的文件，列出要忽略的文件的模式\n\n*.[oa]  # 忽略以 .o 或 .a 结尾的文件（一般这类文件是编译过程出现）\n*~      # 忽略以 ~ 结尾的文件（一般是文本编辑软件保存的副本）\n\n\n文件 .gitignore 的格式规范如下：\n\n * 所有空行或者以 # 开头的行都会被 Git 忽略（注释符号）。\n\n * 可以使用标准的 glob 模式匹配，它会递归地应用在整个工作区中。\n   \n   > glob 模式是指 shell 所使用的简化了的正则表达式\n\n * 匹配模式可以以（/）开头防止递归。\n\n * 匹配模式可以以（/）结尾指定目录。\n\n * 要忽略指定模式以外的文件或目录，可以在模式前加上叹号（!）取反。\n\n----------------------------------------\n\n * 星号（*）匹配零个或多个任意字符\n * [abc] 匹配任何一个列在方括号中的字符 （这个例子要么匹配一个 a，要么匹配一个 b，要么匹配一个 c）\n * 问号（?）只匹配一个任意字符\n * [0-9] 表示匹配所有 0 到 9 的数字。在方括号中使用短划线分隔两个字符， 表示所有在这两个字符范围内的都可以匹配\n * 使用两个星号（**）表示匹配任意中间目录，比如 a/**/z 可以匹配 a/z 、 a/b/z 或 a/b/c/z 等。\n\n# 忽略所有的 .a 文件\n*.a\n\n# 但跟踪所有的 lib.a，即便你在前面忽略了 .a 文件\n!lib.a\n\n# 只忽略当前目录下的 TODO 文件，而不忽略 subdir/TODO\n/TODO\n\n# 忽略任何目录下名为 build 的文件夹\nbuild/\n\n# 忽略 doc/notes.txt，但不忽略 doc/server/arch.txt\ndoc/*.txt\n\n# 忽略 doc/ 目录及其所有子目录下的 .pdf 文件\ndoc/**/*.pdf\n\n\nGitHub 有一个十分详细的针对数十种项目及语言的 .gitignore 文件列表， 你可以在 https://github.com/github/gitignore 找到它。\n\n\n# 查看修改的具体内容\n\ngit diff # 比较修改之后还没有暂存起来的变化内容。\n\ngit diff --staged # 查看已暂存的将要添加到下次提交里的内容\n\n\ngit status 只能查看文件变动的状态，并不能查看具体修改了哪些内容。使用git diff可以看到具体变动的内容。\n\n\n# 提交更新\n\ngit commit # 未带参数的会打开默认文本编辑器让你输入提交说明\n\ngit commit -m '提交说明' # 带-m参数直接输入提交说明\n\n\n使用git commit提交更新，在此之前，务必确认所有变动已经被git add添加到暂存区。\n\n\n# 跳过使用暂存区域\n\ngit commit -a -m '提交说明'\n\n\n添加-a选项可以跳过git add 步骤，把已经跟踪过的文件一并提交。\n\n注意：这个操作无法提交未跟踪的文件。\n\n\n# Git 基础 - 查看提交历史\n\ngit log\n\n\n不传入任何参数的默认情况下，git log 会按时间先后顺序列出所有的提交，最近的更新排在最上面。\n\n此命令打印的数据中有一项是一长串的 SHA-1 校验码。\n\n带入-p或--patch查看提交的具体差异：\n\ngit log -p -2 # -p显示差异  -2显示最近的提交次数\n\n\n--stat 显示每次提交的差异统计\n\ngit log --stat\n\n\n--pretty 这个选项可以使用不同于默认格式的方式展示提交历史\n\n这个选项有一些内建的子选项供你使用。 比如 oneline 会将每个提交放在一行显示，在浏览大量的提交时非常有用。 另外还有 short，full 和 fuller 选项，它们展示信息的格式基本一致，但是详尽程度不一：\n\n$ git log --pretty=oneline\nca82a6dff817ec66f44342007202690a93763949 changed the version number\n085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7 removed unnecessary test\na11bef06a3f659402fe7563abf99ad00de2209e6 first commit\n\n\n最有意思的是 format ，可以定制记录的显示格式。 这样的输出对后期提取分析格外有用——因为你知道输出的格式不会随着 Git 的更新而发生改变：\n\n$ git log --pretty=format:\"%h - %an, %ar : %s\"\nca82a6d - Scott Chacon, 6 years ago : changed the version number\n085bb3b - Scott Chacon, 6 years ago : removed unnecessary test\na11bef0 - Scott Chacon, 6 years ago : first commit\n\n\ngit log --pretty=format 常用的选项 列出了 format 接受的常用格式占位符的写法及其代表的意义。\n\n当 oneline 或 format 与另一个 log 选项 --graph 结合使用时尤其有用。 这个选项添加了一些 ASCII 字符串来形象地展示你的分支、合并历史：\n\n$ git log --pretty=format:\"%h %s\" --graph\n* 2d3acf9 ignore errors from SIGCHLD on trap\n*  5e3ee11 Merge branch 'master' of git://github.com/dustin/grit\n|\\\n| * 420eac9 Added a method for getting the current branch.\n* | 30e367c timeout code and tests\n* | 5a09431 add timeout protection to grit\n* | e1193f8 support for heads with slashes in them\n|/\n* d6016bc require time for xmlschema\n*  11d191e Merge branch 'defunkt' into local\n\n\n\n# Git 基础 - 撤消操作\n\n你提交后发现忘记了暂存某些需要的修改，可以像下面这样操作：\n\n$ git commit -m 'initial commit'\n$ git add forgotten_file\n$ git commit --amend # 重新提交，且只有一次提交记录\n\n\n最终你只会有一个提交——第二次提交将代替第一次提交的结果。\n\n更多撤销操作请了解 reset命令。\n\n\n# Git 基础 - 远程仓库的使用\n\n\n# 查看远程仓库\n\ngit remote # 仅显示远程仓库的名称\ngit remote -v # 显示远程仓库的名称 + 地址\n\n\n\n# 添加远程仓库\n\n git remote add <远程仓库名> <url>\n\n\n\n# 从远程仓库中抓取与拉取\n\n就如刚才所见，从远程仓库中获得数据，可以执行：\n\ngit fetch <remote>\n\n\n这个命令会访问远程仓库，从中拉取所有你还没有的数据。 执行完成后，你将会拥有那个远程仓库中所有分支的引用，可以随时合并或查看。\n\n注意： git fetch 命令只会将数据下载到你的本地仓库——它并不会自动合并或修改你当前的工作。 当准备好时你必须手动将其合并入你的工作。\n\ngit pull\n\n\n用 git pull 命令来自动抓取后合并该远程分支到当前分支。 这或许是个更加简单舒服的工作流程。默认情况下，git clone 命令会自动设置本地 master 分支跟踪克隆的远程仓库的 master 分支（或其它名字的默认分支）。 运行 git pull 通常会从最初克隆的服务器上抓取数据并自动尝试合并到当前所在的分支。\n\n\n# 推送到远程仓库\n\ngit push <remote> <branch> # git push origin master\n\n\n\n# 查看某个远程仓库\n\n git remote show <remote> # git remote show origin\n\n\n查看远程仓库的详细信息。这个命令列出了当你在特定的分支上执行 git push 会自动地推送到哪一个远程分支\n\n\n# 远程仓库的重命名与移除\n\ngit remote rename <原名> <新名> # 重命名\ngit remote remove paul <remote># 移除远程仓库\n\n\n\n# Git 基础 - 打标签\n\n\n# 列出标签\n\ngit tag # 完整标签列表\ngit tag -l \"v2.0*\" # 只显示包含 v2.0 的标签。 注意加星号(*)\n\n\n-l 或 --list 都可以。\n\n\n# 创建标签\n\nGit 支持两种标签：轻量标签（lightweight）与附注标签（annotated）。\n\n轻量标签很像一个不会改变的分支——它只是某个特定提交的引用。\n\n而附注标签是存储在 Git 数据库中的一个完整对象， 它们是可以被校验的，其中包含打标签者的名字、电子邮件地址、日期时间， 此外还有一个标签信息，并且可以使用 GNU Privacy Guard （GPG）签名并验证。 通常会建议创建附注标签，这样你可以拥有以上所有信息。但是如果你只是想用一个临时的标签， 或者因为某些原因不想要保存这些信息，那么也可以用轻量标签。\n\n\n# 附注标签\n\ngit tag -a v1.4 -m \"my version 1.4\" # -a表示add， -m 表示附件信息\n\n\n通过使用 git show 命令可以看到标签信息和与之对应的提交信息：\n\ngit show v1.4\n\n\n\n# 轻量标签\n\n轻量标签本质上是将提交校验和存储到一个文件中——没有保存任何其他信息。 创建轻量标签，不需要使用 -a、-s 或 -m 选项，只需要提供标签名字：\n\ngit tag v1.4-lw # 不需要添加选项\n\n\n这时，如果在标签上运行 git show，你不会看到额外的标签信息。 命令只会显示出提交信息：\n\n$ git show v1.4-lw\ncommit ca82a6dff817ec66f44342007202690a93763949\nAuthor: Scott Chacon <schacon@gee-mail.com>\nDate:   Mon Mar 17 21:52:11 2008 -0700\n\n\n\n# 后期打标签\n\n你也可以对过去的提交打标签。 假设提交历史是这样的：\n\n$ git log --pretty=oneline\n166ae0c4d3f420721acbb115cc33848dfcc2121a started write support\n9fceb02d0ae598e95dc970b74767f19372d61af8 updated rakefile\n8a5cbc430f1a9c3d00faaeffd07798508422908a updated readme\n\n\n现在，假设在 v1.2 时你忘记给项目打标签，也就是在 “updated rakefile” 提交。 你可以在之后补上标签。 要在那个提交上打标签，你需要在命令的末尾指定提交的校验和（或部分校验和）：\n\n$ git tag -a v1.2 9fceb02 # 打的标签属于附注标签\n\n\n\n# 共享标签\n\ngit push 命令并不会传送标签到远程仓库服务器上。 在创建完标签后你必须显式地推送标签到共享服务器上。 这个过程就像共享远程分支一样——你可以运行 git push origin <tagname>。\n\ngit push origin v1.5 # 显式地推送标签到远程仓库\ngit push origin --tags # 一次性推送所有不在远程仓库上的标签\n\n\n现在，当其他人从仓库中克隆或拉取，他们也能得到你的那些标签。\n\n\n# 删除标签\n\n要删除掉你本地仓库上的标签，可以使用命令 git tag -d <tagname>。 例如，可以使用以下命令删除一个轻量标签：\n\n$ git tag -d v1.4-lw\nDeleted tag 'v1.4-lw' (was e7d5add)\n\n\n注意上述命令并不会从任何远程仓库中移除这个标签，你必须用 git push <remote> :refs/tags/<tagname> 来更新你的远程仓库：\n\n第一种变体是 git push <remote> :refs/tags/<tagname> ：\n\n$ git push origin :refs/tags/v1.4-lw\nTo /git@github.com:schacon/simplegit.git\n - [deleted]         v1.4-lw\n\n\n上面这种操作的含义是，将冒号前面的空值推送到远程标签名，从而高效地删除它。\n\n第二种更直观的删除远程标签的方式是：\n\n$ git push origin --delete <tagname>\n\n\n\n# 检出标签\n\n如果你想查看某个标签所指向的文件版本，可以使用 git checkout 命令， 虽然这会使你的仓库处于“分离头指针（detached HEAD）”的状态——这个状态有些不好的副作用：\n\n$ git checkout 2.0.0\nNote: checking out '2.0.0'.\n\nYou are in 'detached HEAD' state. You can look around, make experimental\nchanges and commit them, and you can discard any commits you make in this\nstate without impacting any branches by performing another checkout.\n\nIf you want to create a new branch to retain commits you create, you may\ndo so (now or later) by using -b with the checkout command again. Example:\n\n  git checkout -b <new-branch>\n\nHEAD is now at 99ada87... Merge pull request #89 from schacon/appendix-final\n\n$ git checkout 2.0-beta-0.1\nPrevious HEAD position was 99ada87... Merge pull request #89 from schacon/appendix-final\nHEAD is now at df3f601... add atlas.json and cover image\n\n\n在“分离头指针”状态下，如果你做了某些更改然后提交它们，标签不会发生变化， 但你的新提交将不属于任何分支，并且将无法访问，除非通过确切的提交哈希才能访问。 因此，如果你需要进行更改，比如你要修复旧版本中的错误，那么通常需要创建一个新分支：\n\n$ git checkout -b version2 v2.0.0\nSwitched to a new branch 'version2'\n\n\n如果在这之后又进行了一次提交，version2 分支就会因为这个改动向前移动， 此时它就会和 v2.0.0 标签稍微有些不同，这时就要当心了。\n\n\n# Git 命令别名\n\nGit 并不会在你输入部分命令时自动推断出你想要的命令。 如果不想每次都输入完整的 Git 命令，可以通过 git config 文件来轻松地为每一个命令设置一个别名。 这里有一些例子你可以试试：\n\n$ git config --global alias.co checkout\n$ git config --global alias.br branch\n$ git config --global alias.ci commit\n$ git config --global alias.st status\n\n\n这意味着，当要输入 git commit 时，只需要输入 git ci。\n\n在创建你认为应该存在的命令时这个技术会很有用。 例如，为了解决取消暂存文件的易用性问题，可以向 Git 中添加你自己的取消暂存别名：\n\n$ git config --global alias.unstage 'reset HEAD --'\n\n\n这会使下面的两个命令等价：\n\n$ git unstage fileA\n$ git reset HEAD -- fileA\n\n\n这样看起来更清楚一些。 通常也会添加一个 last 命令，像这样：\n\n$ git config --global alias.last 'log -1 HEAD'\n\n\n这样，可以轻松地看到最后一次提交：\n\n$ git last\ncommit 66938dae3329c7aebe598c2246a8e6af90d04646\nAuthor: Josh Goebel <dreamer3@example.com>\nDate:   Tue Aug 26 19:48:51 2008 +0800\n\n    test for current head\n\n    Signed-off-by: Scott Chacon <schacon@example.com>\n\n\n可以看出，Git 只是简单地将别名替换为对应的命令。 然而，你可能想要执行外部命令，而不是一个 Git 子命令。 如果是那样的话，可以在命令前面加入 ! 符号。 如果你自己要写一些与 Git 仓库协作的工具的话，那会很有用。 我们现在演示将 git visual 定义为 gitk 的别名：\n\n$ git config --global alias.visual '!gitk'\n",normalizedContent:"# git基础与命令\n\n官方文档（中文）：https://git-scm.com/book/zh/v2\n\n> 本文档是根据官方文档来编写的，以官方文档为准。\n\n\n# git基础\n\n\n# 全局配置\n\ngit config --global user.name 'your name'\ngit config --global user.email 'xxx@xx.com'\n\n\n自报家门\n\n\n# 检查配置信息\n\ngit config --list\n\n\n\n# 获取帮助\n\n# 获取全局帮助手册\ngit help\n\n# 获取特定命令的详细版帮助手册 (两个命令是等价的)\ngit help <某个命令>\ngit <某个命令> --help # 两个横杠\n\n# 获取特定命令的简明版帮助手册\ngit <某个命令> -h  # 一个横杠\n\n\n\n# 初始化仓库\n\n# 本地目录初始化仓库\ngit init\n\n\n如果你是从远程仓库clone的项目，则该项目是已经初始化好的git仓库\n\n\n# 克隆远程仓库\n\n# 克隆\ngit clone <url>\n\n# 克隆同时修改目录名\ngit clone <url> <name>\n\n\n初次克隆某个仓库的时候，工作目录中的所有文件都属于已跟踪文件，并处于未修改状态，因为 git 刚刚检出了它们， 而你尚未编辑过它们\n\n\n# 检查文件状态\n\n# 查看详细状态说明\ngit status\n\n# 查看简明状态说明\ngit status -s  # -s 或 --short\n m readme # 已修改，但未暂存 （m的位置靠右，红色）\nmm rakefile # 已修改，暂存后又作了修改（有暂存和未暂存）\na  lib/git.rb # 新添加到暂存区，未提交\nm  lib/simplegit.rb # 已修改，已暂存 （m的位置靠左，绿色）\n?? license.txt # 新添加，未跟踪\n\n\n * git目录中的文件状态包含：是否跟踪、是否修改、是否已存入暂存区\n\n * 参数的一个横杠表示缩写，两个横杠表示全称。\n\n\n# 加入暂存区 (跟踪文件)\n\n# 文件加入暂存区（跟踪指定文件)\ngit add <files>\n\n\ngit add 命令使用文件或目录的路径作为参数；如果参数是目录的路径，该命令将递归地跟踪该目录下的所有文件。\n\nadd 命令是将文件加入到暂存区，commit 命令的提交到本地仓库，push 命令是推送到远程仓库。\n\n\n# 忽略文件\n\n添加一个名为 .gitignore 的文件，列出要忽略的文件的模式\n\n*.[oa]  # 忽略以 .o 或 .a 结尾的文件（一般这类文件是编译过程出现）\n*~      # 忽略以 ~ 结尾的文件（一般是文本编辑软件保存的副本）\n\n\n文件 .gitignore 的格式规范如下：\n\n * 所有空行或者以 # 开头的行都会被 git 忽略（注释符号）。\n\n * 可以使用标准的 glob 模式匹配，它会递归地应用在整个工作区中。\n   \n   > glob 模式是指 shell 所使用的简化了的正则表达式\n\n * 匹配模式可以以（/）开头防止递归。\n\n * 匹配模式可以以（/）结尾指定目录。\n\n * 要忽略指定模式以外的文件或目录，可以在模式前加上叹号（!）取反。\n\n----------------------------------------\n\n * 星号（*）匹配零个或多个任意字符\n * [abc] 匹配任何一个列在方括号中的字符 （这个例子要么匹配一个 a，要么匹配一个 b，要么匹配一个 c）\n * 问号（?）只匹配一个任意字符\n * [0-9] 表示匹配所有 0 到 9 的数字。在方括号中使用短划线分隔两个字符， 表示所有在这两个字符范围内的都可以匹配\n * 使用两个星号（**）表示匹配任意中间目录，比如 a/**/z 可以匹配 a/z 、 a/b/z 或 a/b/c/z 等。\n\n# 忽略所有的 .a 文件\n*.a\n\n# 但跟踪所有的 lib.a，即便你在前面忽略了 .a 文件\n!lib.a\n\n# 只忽略当前目录下的 todo 文件，而不忽略 subdir/todo\n/todo\n\n# 忽略任何目录下名为 build 的文件夹\nbuild/\n\n# 忽略 doc/notes.txt，但不忽略 doc/server/arch.txt\ndoc/*.txt\n\n# 忽略 doc/ 目录及其所有子目录下的 .pdf 文件\ndoc/**/*.pdf\n\n\ngithub 有一个十分详细的针对数十种项目及语言的 .gitignore 文件列表， 你可以在 https://github.com/github/gitignore 找到它。\n\n\n# 查看修改的具体内容\n\ngit diff # 比较修改之后还没有暂存起来的变化内容。\n\ngit diff --staged # 查看已暂存的将要添加到下次提交里的内容\n\n\ngit status 只能查看文件变动的状态，并不能查看具体修改了哪些内容。使用git diff可以看到具体变动的内容。\n\n\n# 提交更新\n\ngit commit # 未带参数的会打开默认文本编辑器让你输入提交说明\n\ngit commit -m '提交说明' # 带-m参数直接输入提交说明\n\n\n使用git commit提交更新，在此之前，务必确认所有变动已经被git add添加到暂存区。\n\n\n# 跳过使用暂存区域\n\ngit commit -a -m '提交说明'\n\n\n添加-a选项可以跳过git add 步骤，把已经跟踪过的文件一并提交。\n\n注意：这个操作无法提交未跟踪的文件。\n\n\n# git 基础 - 查看提交历史\n\ngit log\n\n\n不传入任何参数的默认情况下，git log 会按时间先后顺序列出所有的提交，最近的更新排在最上面。\n\n此命令打印的数据中有一项是一长串的 sha-1 校验码。\n\n带入-p或--patch查看提交的具体差异：\n\ngit log -p -2 # -p显示差异  -2显示最近的提交次数\n\n\n--stat 显示每次提交的差异统计\n\ngit log --stat\n\n\n--pretty 这个选项可以使用不同于默认格式的方式展示提交历史\n\n这个选项有一些内建的子选项供你使用。 比如 oneline 会将每个提交放在一行显示，在浏览大量的提交时非常有用。 另外还有 short，full 和 fuller 选项，它们展示信息的格式基本一致，但是详尽程度不一：\n\n$ git log --pretty=oneline\nca82a6dff817ec66f44342007202690a93763949 changed the version number\n085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7 removed unnecessary test\na11bef06a3f659402fe7563abf99ad00de2209e6 first commit\n\n\n最有意思的是 format ，可以定制记录的显示格式。 这样的输出对后期提取分析格外有用——因为你知道输出的格式不会随着 git 的更新而发生改变：\n\n$ git log --pretty=format:\"%h - %an, %ar : %s\"\nca82a6d - scott chacon, 6 years ago : changed the version number\n085bb3b - scott chacon, 6 years ago : removed unnecessary test\na11bef0 - scott chacon, 6 years ago : first commit\n\n\ngit log --pretty=format 常用的选项 列出了 format 接受的常用格式占位符的写法及其代表的意义。\n\n当 oneline 或 format 与另一个 log 选项 --graph 结合使用时尤其有用。 这个选项添加了一些 ascii 字符串来形象地展示你的分支、合并历史：\n\n$ git log --pretty=format:\"%h %s\" --graph\n* 2d3acf9 ignore errors from sigchld on trap\n*  5e3ee11 merge branch 'master' of git://github.com/dustin/grit\n|\\\n| * 420eac9 added a method for getting the current branch.\n* | 30e367c timeout code and tests\n* | 5a09431 add timeout protection to grit\n* | e1193f8 support for heads with slashes in them\n|/\n* d6016bc require time for xmlschema\n*  11d191e merge branch 'defunkt' into local\n\n\n\n# git 基础 - 撤消操作\n\n你提交后发现忘记了暂存某些需要的修改，可以像下面这样操作：\n\n$ git commit -m 'initial commit'\n$ git add forgotten_file\n$ git commit --amend # 重新提交，且只有一次提交记录\n\n\n最终你只会有一个提交——第二次提交将代替第一次提交的结果。\n\n更多撤销操作请了解 reset命令。\n\n\n# git 基础 - 远程仓库的使用\n\n\n# 查看远程仓库\n\ngit remote # 仅显示远程仓库的名称\ngit remote -v # 显示远程仓库的名称 + 地址\n\n\n\n# 添加远程仓库\n\n git remote add <远程仓库名> <url>\n\n\n\n# 从远程仓库中抓取与拉取\n\n就如刚才所见，从远程仓库中获得数据，可以执行：\n\ngit fetch <remote>\n\n\n这个命令会访问远程仓库，从中拉取所有你还没有的数据。 执行完成后，你将会拥有那个远程仓库中所有分支的引用，可以随时合并或查看。\n\n注意： git fetch 命令只会将数据下载到你的本地仓库——它并不会自动合并或修改你当前的工作。 当准备好时你必须手动将其合并入你的工作。\n\ngit pull\n\n\n用 git pull 命令来自动抓取后合并该远程分支到当前分支。 这或许是个更加简单舒服的工作流程。默认情况下，git clone 命令会自动设置本地 master 分支跟踪克隆的远程仓库的 master 分支（或其它名字的默认分支）。 运行 git pull 通常会从最初克隆的服务器上抓取数据并自动尝试合并到当前所在的分支。\n\n\n# 推送到远程仓库\n\ngit push <remote> <branch> # git push origin master\n\n\n\n# 查看某个远程仓库\n\n git remote show <remote> # git remote show origin\n\n\n查看远程仓库的详细信息。这个命令列出了当你在特定的分支上执行 git push 会自动地推送到哪一个远程分支\n\n\n# 远程仓库的重命名与移除\n\ngit remote rename <原名> <新名> # 重命名\ngit remote remove paul <remote># 移除远程仓库\n\n\n\n# git 基础 - 打标签\n\n\n# 列出标签\n\ngit tag # 完整标签列表\ngit tag -l \"v2.0*\" # 只显示包含 v2.0 的标签。 注意加星号(*)\n\n\n-l 或 --list 都可以。\n\n\n# 创建标签\n\ngit 支持两种标签：轻量标签（lightweight）与附注标签（annotated）。\n\n轻量标签很像一个不会改变的分支——它只是某个特定提交的引用。\n\n而附注标签是存储在 git 数据库中的一个完整对象， 它们是可以被校验的，其中包含打标签者的名字、电子邮件地址、日期时间， 此外还有一个标签信息，并且可以使用 gnu privacy guard （gpg）签名并验证。 通常会建议创建附注标签，这样你可以拥有以上所有信息。但是如果你只是想用一个临时的标签， 或者因为某些原因不想要保存这些信息，那么也可以用轻量标签。\n\n\n# 附注标签\n\ngit tag -a v1.4 -m \"my version 1.4\" # -a表示add， -m 表示附件信息\n\n\n通过使用 git show 命令可以看到标签信息和与之对应的提交信息：\n\ngit show v1.4\n\n\n\n# 轻量标签\n\n轻量标签本质上是将提交校验和存储到一个文件中——没有保存任何其他信息。 创建轻量标签，不需要使用 -a、-s 或 -m 选项，只需要提供标签名字：\n\ngit tag v1.4-lw # 不需要添加选项\n\n\n这时，如果在标签上运行 git show，你不会看到额外的标签信息。 命令只会显示出提交信息：\n\n$ git show v1.4-lw\ncommit ca82a6dff817ec66f44342007202690a93763949\nauthor: scott chacon <schacon@gee-mail.com>\ndate:   mon mar 17 21:52:11 2008 -0700\n\n\n\n# 后期打标签\n\n你也可以对过去的提交打标签。 假设提交历史是这样的：\n\n$ git log --pretty=oneline\n166ae0c4d3f420721acbb115cc33848dfcc2121a started write support\n9fceb02d0ae598e95dc970b74767f19372d61af8 updated rakefile\n8a5cbc430f1a9c3d00faaeffd07798508422908a updated readme\n\n\n现在，假设在 v1.2 时你忘记给项目打标签，也就是在 “updated rakefile” 提交。 你可以在之后补上标签。 要在那个提交上打标签，你需要在命令的末尾指定提交的校验和（或部分校验和）：\n\n$ git tag -a v1.2 9fceb02 # 打的标签属于附注标签\n\n\n\n# 共享标签\n\ngit push 命令并不会传送标签到远程仓库服务器上。 在创建完标签后你必须显式地推送标签到共享服务器上。 这个过程就像共享远程分支一样——你可以运行 git push origin <tagname>。\n\ngit push origin v1.5 # 显式地推送标签到远程仓库\ngit push origin --tags # 一次性推送所有不在远程仓库上的标签\n\n\n现在，当其他人从仓库中克隆或拉取，他们也能得到你的那些标签。\n\n\n# 删除标签\n\n要删除掉你本地仓库上的标签，可以使用命令 git tag -d <tagname>。 例如，可以使用以下命令删除一个轻量标签：\n\n$ git tag -d v1.4-lw\ndeleted tag 'v1.4-lw' (was e7d5add)\n\n\n注意上述命令并不会从任何远程仓库中移除这个标签，你必须用 git push <remote> :refs/tags/<tagname> 来更新你的远程仓库：\n\n第一种变体是 git push <remote> :refs/tags/<tagname> ：\n\n$ git push origin :refs/tags/v1.4-lw\nto /git@github.com:schacon/simplegit.git\n - [deleted]         v1.4-lw\n\n\n上面这种操作的含义是，将冒号前面的空值推送到远程标签名，从而高效地删除它。\n\n第二种更直观的删除远程标签的方式是：\n\n$ git push origin --delete <tagname>\n\n\n\n# 检出标签\n\n如果你想查看某个标签所指向的文件版本，可以使用 git checkout 命令， 虽然这会使你的仓库处于“分离头指针（detached head）”的状态——这个状态有些不好的副作用：\n\n$ git checkout 2.0.0\nnote: checking out '2.0.0'.\n\nyou are in 'detached head' state. you can look around, make experimental\nchanges and commit them, and you can discard any commits you make in this\nstate without impacting any branches by performing another checkout.\n\nif you want to create a new branch to retain commits you create, you may\ndo so (now or later) by using -b with the checkout command again. example:\n\n  git checkout -b <new-branch>\n\nhead is now at 99ada87... merge pull request #89 from schacon/appendix-final\n\n$ git checkout 2.0-beta-0.1\nprevious head position was 99ada87... merge pull request #89 from schacon/appendix-final\nhead is now at df3f601... add atlas.json and cover image\n\n\n在“分离头指针”状态下，如果你做了某些更改然后提交它们，标签不会发生变化， 但你的新提交将不属于任何分支，并且将无法访问，除非通过确切的提交哈希才能访问。 因此，如果你需要进行更改，比如你要修复旧版本中的错误，那么通常需要创建一个新分支：\n\n$ git checkout -b version2 v2.0.0\nswitched to a new branch 'version2'\n\n\n如果在这之后又进行了一次提交，version2 分支就会因为这个改动向前移动， 此时它就会和 v2.0.0 标签稍微有些不同，这时就要当心了。\n\n\n# git 命令别名\n\ngit 并不会在你输入部分命令时自动推断出你想要的命令。 如果不想每次都输入完整的 git 命令，可以通过 git config 文件来轻松地为每一个命令设置一个别名。 这里有一些例子你可以试试：\n\n$ git config --global alias.co checkout\n$ git config --global alias.br branch\n$ git config --global alias.ci commit\n$ git config --global alias.st status\n\n\n这意味着，当要输入 git commit 时，只需要输入 git ci。\n\n在创建你认为应该存在的命令时这个技术会很有用。 例如，为了解决取消暂存文件的易用性问题，可以向 git 中添加你自己的取消暂存别名：\n\n$ git config --global alias.unstage 'reset head --'\n\n\n这会使下面的两个命令等价：\n\n$ git unstage filea\n$ git reset head -- filea\n\n\n这样看起来更清楚一些。 通常也会添加一个 last 命令，像这样：\n\n$ git config --global alias.last 'log -1 head'\n\n\n这样，可以轻松地看到最后一次提交：\n\n$ git last\ncommit 66938dae3329c7aebe598c2246a8e6af90d04646\nauthor: josh goebel <dreamer3@example.com>\ndate:   tue aug 26 19:48:51 2008 +0800\n\n    test for current head\n\n    signed-off-by: scott chacon <schacon@example.com>\n\n\n可以看出，git 只是简单地将别名替换为对应的命令。 然而，你可能想要执行外部命令，而不是一个 git 子命令。 如果是那样的话，可以在命令前面加入 ! 符号。 如果你自己要写一些与 git 仓库协作的工具的话，那会很有用。 我们现在演示将 git visual 定义为 gitk 的别名：\n\n$ git config --global alias.visual '!gitk'\n",charsets:{cjk:!0},lastUpdated:"2023/11/19, 12:55:48",lastUpdatedTimestamp:1700369748e3},{title:"Git工具-重置揭密",frontmatter:{title:"Git工具-重置揭密",date:"2020-11-18T17:43:57.000Z",permalink:"/pages/d9e9c6/",categories:["《Git》学习笔记"],tags:["Git"],author:{name:"王清欢",link:"https://github.com/wang-haihua"}},regularPath:"/05.Git%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/30.Git%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%AC%94%E8%AE%B0/110.Git%E5%B7%A5%E5%85%B7-%E9%87%8D%E7%BD%AE%E6%8F%AD%E5%AF%86.html",relativePath:"05.Git 学习笔记/30.Git 官方文档笔记/110.Git工具-重置揭密.md",key:"v-c67256e6",path:"/pages/d9e9c6/",headers:[{level:2,title:"三棵树",slug:"三棵树",normalizedTitle:"三棵树",charIndex:147},{level:3,title:"HEAD",slug:"head",normalizedTitle:"head",charIndex:348},{level:3,title:"索引",slug:"索引",normalizedTitle:"索引",charIndex:257},{level:3,title:"工作目录",slug:"工作目录",normalizedTitle:"工作目录",charIndex:1090},{level:2,title:"工作流程",slug:"工作流程",normalizedTitle:"工作流程",charIndex:1710},{level:2,title:"重置的作用",slug:"重置的作用",normalizedTitle:"重置的作用",charIndex:2519},{level:3,title:"第 1 步：移动 HEAD",slug:"第-1-步-移动-head",normalizedTitle:"第 1 步：移动 head",charIndex:2666},{level:3,title:"第 2 步：更新索引（--mixed）",slug:"第-2-步-更新索引-mixed",normalizedTitle:"第 2 步：更新索引（--mixed）",charIndex:3153},{level:3,title:"第 3 步：更新工作目录（--hard）",slug:"第-3-步-更新工作目录-hard",normalizedTitle:"第 3 步：更新工作目录（--hard）",charIndex:3453},{level:3,title:"回顾",slug:"回顾",normalizedTitle:"回顾",charIndex:3813},{level:2,title:"通过路径来重置",slug:"通过路径来重置",normalizedTitle:"通过路径来重置",charIndex:3948},{level:2,title:"压缩",slug:"压缩",normalizedTitle:"压缩",charIndex:4801},{level:2,title:"检出",slug:"检出",normalizedTitle:"检出",charIndex:1087},{level:3,title:"不带路径",slug:"不带路径",normalizedTitle:"不带路径",charIndex:5374},{level:3,title:"带路径",slug:"带路径",normalizedTitle:"带路径",charIndex:5375},{level:2,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:6294}],headersStr:"三棵树 HEAD 索引 工作目录 工作流程 重置的作用 第 1 步：移动 HEAD 第 2 步：更新索引（--mixed） 第 3 步：更新工作目录（--hard） 回顾 通过路径来重置 压缩 检出 不带路径 带路径 总结",content:"# Git 工具 - 重置揭密\n\n在继续了解更专业的工具前，我们先探讨一下 Git 的 reset 和 checkout 命令。 在初遇的 Git 命令中，这两个是最让人困惑的。 它们能做很多事情，所以看起来我们很难真正地理解并恰当地运用它们。 针对这一点，我们先来做一个简单的比喻。\n\n\n# 三棵树\n\n理解 reset 和 checkout 的最简方法，就是以 Git 的思维框架（将其作为内容管理器）来管理三棵不同的树。 “树” 在我们这里的实际意思是 “文件的集合”，而不是指特定的数据结构。 （在某些情况下索引看起来并不像一棵树，不过我们现在的目的是用简单的方式思考它。）\n\nGit 作为一个系统，是以它的一般操作来管理并操纵这三棵树的：\n\n树                   用途\nHEAD                上一次提交的快照，下一次提交的父结点\nIndex               预期的下一次提交的快照\nWorking Directory   沙盒\n\n\n# HEAD\n\nHEAD 是当前分支引用的指针，它总是指向该分支上的最后一次提交。 这表示 HEAD 将是下一次提交的父结点。 通常，理解 HEAD 的最简方式，就是将它看做 该分支上的最后一次提交 的快照。\n\n其实，查看快照的样子很容易。 下例就显示了 HEAD 快照实际的目录列表，以及其中每个文件的 SHA-1 校验和：\n\n$ git cat-file -p HEAD\ntree cfda3bf379e4f8dba8717dee55aab78aef7f4daf\nauthor Scott Chacon  1301511835 -0700\ncommitter Scott Chacon  1301511835 -0700\n\ninitial commit\n\n$ git ls-tree -r HEAD\n100644 blob a906cb2a4a904a152...   README\n100644 blob 8f94139338f9404f2...   Rakefile\n040000 tree 99f1a6d12cb4b6f19...   lib\n\n\nGit 的 cat-file 和 ls-tree 是底层命令，它们一般用于底层工作，在日常工作中并不使用。 不过它们能帮助我们了解到底发生了什么。\n\n\n# 索引\n\n索引是你的 预期的下一次提交。 我们也会将这个概念引用为 Git 的“暂存区”，这就是当你运行 git commit 时 Git 看起来的样子。\n\nGit 将上一次检出到工作目录中的所有文件填充到索引区，它们看起来就像最初被检出时的样子。 之后你会将其中一些文件替换为新版本，接着通过 git commit 将它们转换为树来用作新的提交。\n\n$ git ls-files -s\n100644 a906cb2a4a904a152e80877d4088654daad0c859 0\tREADME\n100644 8f94139338f9404f26296befa88755fc2598c289 0\tRakefile\n100644 47c6340d6459e05787f644c2447d2595f5d3a54b 0\tlib/simplegit.rb\n\n\n再说一次，我们在这里又用到了 git ls-files 这个幕后的命令，它会显示出索引当前的样子。\n\n确切来说，索引在技术上并非树结构，它其实是以扁平的清单实现的。不过对我们而言，把它当做树就够了。\n\n\n# 工作目录\n\n最后，你就有了自己的 工作目录（通常也叫 工作区）。 另外两棵树以一种高效但并不直观的方式，将它们的内容存储在 .git 文件夹中。 工作目录会将它们解包为实际的文件以便编辑。 你可以把工作目录当做 沙盒。在你将修改提交到暂存区并记录到历史之前，可以随意更改。\n\n$ tree\n.\n├── README\n├── Rakefile\n└── lib\n    └── simplegit.rb\n\n1 directory, 3 files\n\n\n\n# 工作流程\n\n经典的 Git 工作流程是通过操纵这三个区域来以更加连续的状态记录项目快照的。\n\n\n\n让我们来可视化这个过程：假设我们进入到一个新目录，其中有一个文件。 我们称其为该文件的 v1 版本，将它标记为蓝色。 现在运行 git init，这会创建一个 Git 仓库，其中的 HEAD 引用指向未创建的 master 分支。\n\n\n\n此时，只有工作目录有内容。\n\n现在我们想要提交这个文件，所以用 git add 来获取工作目录中的内容，并将其复制到索引中。\n\n\n\n接着运行 git commit，它会取得索引中的内容并将它保存为一个永久的快照， 然后创建一个指向该快照的提交对象，最后更新 master 来指向本次提交。\n\n\n\n此时如果我们运行 git status，会发现没有任何改动，因为现在三棵树完全相同。\n\n现在我们想要对文件进行修改然后提交它。 我们将会经历同样的过程；首先在工作目录中修改文件。 我们称其为该文件的 v2 版本，并将它标记为红色。\n\n\n\n如果现在运行 git status，我们会看到文件显示在 “Changes not staged for commit” 下面并被标记为红色，因为该条目在索引与工作目录之间存在不同。 接着我们运行 git add 来将它暂存到索引中。\n\n\n\n此时，由于索引和 HEAD 不同，若运行 git status 的话就会看到 “Changes to be committed” 下的该文件变为绿色 ——也就是说，现在预期的下一次提交与上一次提交不同。 最后，我们运行 git commit 来完成提交。\n\n\n\n现在运行 git status 会没有输出，因为三棵树又变得相同了。\n\n切换分支或克隆的过程也类似。 当检出一个分支时，它会修改 HEAD 指向新的分支引用，将 索引 填充为该次提交的快照， 然后将 索引 的内容复制到 工作目录 中。\n\n\n# 重置的作用\n\n在以下情景中观察 reset 命令会更有意义。\n\n为了演示这些例子，假设我们再次修改了 file.txt 文件并第三次提交它。 现在的历史看起来是这样的：\n\n\n\n让我们跟着 reset 看看它都做了什么。 它以一种简单可预见的方式直接操纵这三棵树。 它做了三个基本操作。\n\n\n# 第 1 步：移动 HEAD\n\nreset 做的第一件事是移动 HEAD 的指向。 这与改变 HEAD 自身不同（checkout 所做的）；reset 移动 HEAD 指向的分支。 这意味着如果 HEAD 设置为 master 分支（例如，你正在 master 分支上）， 运行 git reset 9e5e6a4 将会使 master 指向 9e5e6a4。\n\n\n\n无论你调用了何种形式的带有一个提交的 reset，它首先都会尝试这样做。 使用 reset --soft，它将仅仅停在那儿。\n\n现在看一眼上图，理解一下发生的事情：它本质上是撤销了上一次 git commit 命令。 当你在运行 git commit 时，Git 会创建一个新的提交，并移动 HEAD 所指向的分支来使其指向该提交。 当你将它 reset 回 HEAD~（HEAD 的父结点）时，其实就是把该分支移动回原来的位置，而不会改变索引和工作目录。 现在你可以更新索引并再次运行 git commit 来完成 git commit --amend 所要做的事情了（见 修改最后一次提交）。\n\n\n# 第 2 步：更新索引（--mixed）\n\n注意，如果你现在运行 git status 的话，就会看到新的 HEAD 和以绿色标出的它和索引之间的区别。\n\n接下来，reset 会用 HEAD 指向的当前快照的内容来更新索引。\n\n\n\n如果指定 --mixed 选项，reset 将会在这时停止。 这也是默认行为，所以如果没有指定任何选项（在本例中只是 git reset HEAD~），这就是命令将会停止的地方。\n\n现在再看一眼上图，理解一下发生的事情：它依然会撤销一上次 提交，但还会 取消暂存 所有的东西。 于是，我们回滚到了所有 git add 和 git commit 的命令执行之前。\n\n\n# 第 3 步：更新工作目录（--hard）\n\nreset 要做的的第三件事情就是让工作目录看起来像索引。 如果使用 --hard 选项，它将会继续这一步。\n\n\n\n现在让我们回想一下刚才发生的事情。 你撤销了最后的提交、git add 和 git commit 命令 以及 工作目录中的所有工作。\n\n必须注意，--hard 标记是 reset 命令唯一的危险用法，它也是 Git 会真正地销毁数据的仅有的几个操作之一。 其他任何形式的 reset 调用都可以轻松撤消，但是 --hard 选项不能，因为它强制覆盖了工作目录中的文件。 在这种特殊情况下，我们的 Git 数据库中的一个提交内还留有该文件的 v3 版本， 我们可以通过 reflog 来找回它。但是若该文件还未提交，Git 仍会覆盖它从而导致无法恢复。\n\n\n# 回顾\n\nreset 命令会以特定的顺序重写这三棵树，在你指定以下选项时停止：\n\n 1. 移动 HEAD 分支的指向 （若指定了 --soft，则到此停止）\n 2. 使索引看起来像 HEAD （若未指定 --hard，则到此停止）\n 3. 使工作目录看起来像索引\n\n\n# 通过路径来重置\n\n前面讲述了 reset 基本形式的行为，不过你还可以给它提供一个作用路径。 若指定了一个路径，reset 将会跳过第 1 步，并且将它的作用范围限定为指定的文件或文件集合。 这样做自然有它的道理，因为 HEAD 只是一个指针，你无法让它同时指向两个提交中各自的一部分。 不过索引和工作目录 可以部分更新，所以重置会继续进行第 2、3 步。\n\n现在，假如我们运行 git reset file.txt （这其实是 git reset --mixed HEAD file.txt 的简写形式，因为你既没有指定一个提交的 SHA-1 或分支，也没有指定 --soft 或 --hard），它会：\n\n 1. 移动 HEAD 分支的指向 （已跳过）\n 2. 让索引看起来像 HEAD （到此处停止）\n\n所以它本质上只是将 file.txt 从 HEAD 复制到索引中。\n\n\n\n它还有 取消暂存文件 的实际效果。 如果我们查看该命令的示意图，然后再想想 git add 所做的事，就会发现它们正好相反。\n\n\n\n这就是为什么 git status 命令的输出会建议运行此命令来取消暂存一个文件。 （查看 取消暂存的文件 来了解更多。）\n\n我们可以不让 Git 从 HEAD 拉取数据，而是通过具体指定一个提交来拉取该文件的对应版本。 我们只需运行类似于 git reset eb43bf file.txt 的命令即可。\n\n\n\n它其实做了同样的事情，也就是把工作目录中的文件恢复到 v1 版本，运行 git add 添加它， 然后再将它恢复到 v3 版本（只是不用真的过一遍这些步骤）。 如果我们现在运行 git commit，它就会记录一条“将该文件恢复到 v1 版本”的更改， 尽管我们并未在工作目录中真正地再次拥有它。\n\n还有一点同 git add 一样，就是 reset 命令也可以接受一个 --patch 选项来一块一块地取消暂存的内容。 这样你就可以根据选择来取消暂存或恢复内容了。\n\n\n# 压缩\n\n我们来看看如何利用这种新的功能来做一些有趣的事情——压缩提交。\n\n假设你的一系列提交信息中有 “oops.”“WIP” 和 “forgot this file”， 聪明的你就能使用 reset 来轻松快速地将它们压缩成单个提交，也显出你的聪明。 （压缩提交 展示了另一种方式，不过在本例中用 reset 更简单。）\n\n假设你有一个项目，第一次提交中有一个文件，第二次提交增加了一个新的文件并修改了第一个文件，第三次提交再次修改了第一个文件。 由于第二次提交是一个未完成的工作，因此你想要压缩它。\n\n\n\n那么可以运行 git reset --soft HEAD~2 来将 HEAD 分支移动到一个旧一点的提交上（即你想要保留的最近的提交）：\n\n\n\n然后只需再次运行 git commit：\n\n\n\n现在你可以查看可到达的历史，即将会推送的历史，现在看起来有个 v1 版 file-a.txt 的提交， 接着第二个提交将 file-a.txt 修改成了 v3 版并增加了 file-b.txt。 包含 v2 版本的文件已经不在历史中了。\n\n\n# 检出\n\n最后，你大概还想知道 checkout 和 reset 之间的区别。 和 reset 一样，checkout 也操纵三棵树，不过它有一点不同，这取决于你是否传给该命令一个文件路径。\n\n\n# 不带路径\n\n运行 git checkout [branch] 与运行 git reset --hard [branch] 非常相似，它会更新所有三棵树使其看起来像 [branch]，不过有两点重要的区别。\n\n首先不同于 reset --hard，checkout 对工作目录是安全的，它会通过检查来确保不会将已更改的文件弄丢。 其实它还更聪明一些。它会在工作目录中先试着简单合并一下，这样所有_还未修改过的_文件都会被更新。 而 reset --hard 则会不做检查就全面地替换所有东西。\n\n第二个重要的区别是 checkout 如何更新 HEAD。 reset 会移动 HEAD 分支的指向，而 checkout 只会移动 HEAD 自身来指向另一个分支。\n\n例如，假设我们有 master 和 develop 分支，它们分别指向不同的提交；我们现在在 develop 上（所以 HEAD 指向它）。 如果我们运行 git reset master，那么 develop 自身现在会和 master 指向同一个提交。 而如果我们运行 git checkout master 的话，develop 不会移动，HEAD 自身会移动。 现在 HEAD 将会指向 master。\n\n所以，虽然在这两种情况下我们都移动 HEAD 使其指向了提交 A，但_做法_是非常不同的。 reset 会移动 HEAD 分支的指向，而 checkout 则移动 HEAD 自身。\n\n\n\n\n# 带路径\n\n运行 checkout 的另一种方式就是指定一个文件路径，这会像 reset 一样不会移动 HEAD。 它就像 git reset [branch] file 那样用该次提交中的那个文件来更新索引，但是它也会覆盖工作目录中对应的文件。 它就像是 git reset --hard [branch] file（如果 reset 允许你这样运行的话）， 这样对工作目录并不安全，它也不会移动 HEAD。\n\n此外，同 git reset 和 git add 一样，checkout 也接受一个 --patch 选项，允许你根据选择一块一块地恢复文件内容。\n\n\n# 总结\n\n希望你现在熟悉并理解了 reset 命令，不过关于它和 checkout 之间的区别，你可能还是会有点困惑，毕竟不太可能记住不同调用的所有规则。\n\n下面的速查表列出了命令对树的影响。 “HEAD” 一列中的 “REF” 表示该命令移动了 HEAD 指向的分支引用，而 “HEAD” 则表示只移动了 HEAD 自身。 特别注意 WD Safe? 一列——如果它标记为 NO，那么运行该命令之前请考虑一下。\n\n                            HEAD   INDEX   WORKDIR   WD SAFE?\nCommit Level                                         \nreset --soft [commit]       REF    NO      NO        YES\nreset [commit]              REF    YES     NO        YES\nreset --hard [commit]       REF    YES     YES       NO\ncheckout <commit>           HEAD   YES     YES       YES\nFile Level                                           \nreset [commit] <paths>      NO     YES     NO        YES\ncheckout [commit] <paths>   NO     YES     YES       NO",normalizedContent:"# git 工具 - 重置揭密\n\n在继续了解更专业的工具前，我们先探讨一下 git 的 reset 和 checkout 命令。 在初遇的 git 命令中，这两个是最让人困惑的。 它们能做很多事情，所以看起来我们很难真正地理解并恰当地运用它们。 针对这一点，我们先来做一个简单的比喻。\n\n\n# 三棵树\n\n理解 reset 和 checkout 的最简方法，就是以 git 的思维框架（将其作为内容管理器）来管理三棵不同的树。 “树” 在我们这里的实际意思是 “文件的集合”，而不是指特定的数据结构。 （在某些情况下索引看起来并不像一棵树，不过我们现在的目的是用简单的方式思考它。）\n\ngit 作为一个系统，是以它的一般操作来管理并操纵这三棵树的：\n\n树                   用途\nhead                上一次提交的快照，下一次提交的父结点\nindex               预期的下一次提交的快照\nworking directory   沙盒\n\n\n# head\n\nhead 是当前分支引用的指针，它总是指向该分支上的最后一次提交。 这表示 head 将是下一次提交的父结点。 通常，理解 head 的最简方式，就是将它看做 该分支上的最后一次提交 的快照。\n\n其实，查看快照的样子很容易。 下例就显示了 head 快照实际的目录列表，以及其中每个文件的 sha-1 校验和：\n\n$ git cat-file -p head\ntree cfda3bf379e4f8dba8717dee55aab78aef7f4daf\nauthor scott chacon  1301511835 -0700\ncommitter scott chacon  1301511835 -0700\n\ninitial commit\n\n$ git ls-tree -r head\n100644 blob a906cb2a4a904a152...   readme\n100644 blob 8f94139338f9404f2...   rakefile\n040000 tree 99f1a6d12cb4b6f19...   lib\n\n\ngit 的 cat-file 和 ls-tree 是底层命令，它们一般用于底层工作，在日常工作中并不使用。 不过它们能帮助我们了解到底发生了什么。\n\n\n# 索引\n\n索引是你的 预期的下一次提交。 我们也会将这个概念引用为 git 的“暂存区”，这就是当你运行 git commit 时 git 看起来的样子。\n\ngit 将上一次检出到工作目录中的所有文件填充到索引区，它们看起来就像最初被检出时的样子。 之后你会将其中一些文件替换为新版本，接着通过 git commit 将它们转换为树来用作新的提交。\n\n$ git ls-files -s\n100644 a906cb2a4a904a152e80877d4088654daad0c859 0\treadme\n100644 8f94139338f9404f26296befa88755fc2598c289 0\trakefile\n100644 47c6340d6459e05787f644c2447d2595f5d3a54b 0\tlib/simplegit.rb\n\n\n再说一次，我们在这里又用到了 git ls-files 这个幕后的命令，它会显示出索引当前的样子。\n\n确切来说，索引在技术上并非树结构，它其实是以扁平的清单实现的。不过对我们而言，把它当做树就够了。\n\n\n# 工作目录\n\n最后，你就有了自己的 工作目录（通常也叫 工作区）。 另外两棵树以一种高效但并不直观的方式，将它们的内容存储在 .git 文件夹中。 工作目录会将它们解包为实际的文件以便编辑。 你可以把工作目录当做 沙盒。在你将修改提交到暂存区并记录到历史之前，可以随意更改。\n\n$ tree\n.\n├── readme\n├── rakefile\n└── lib\n    └── simplegit.rb\n\n1 directory, 3 files\n\n\n\n# 工作流程\n\n经典的 git 工作流程是通过操纵这三个区域来以更加连续的状态记录项目快照的。\n\n\n\n让我们来可视化这个过程：假设我们进入到一个新目录，其中有一个文件。 我们称其为该文件的 v1 版本，将它标记为蓝色。 现在运行 git init，这会创建一个 git 仓库，其中的 head 引用指向未创建的 master 分支。\n\n\n\n此时，只有工作目录有内容。\n\n现在我们想要提交这个文件，所以用 git add 来获取工作目录中的内容，并将其复制到索引中。\n\n\n\n接着运行 git commit，它会取得索引中的内容并将它保存为一个永久的快照， 然后创建一个指向该快照的提交对象，最后更新 master 来指向本次提交。\n\n\n\n此时如果我们运行 git status，会发现没有任何改动，因为现在三棵树完全相同。\n\n现在我们想要对文件进行修改然后提交它。 我们将会经历同样的过程；首先在工作目录中修改文件。 我们称其为该文件的 v2 版本，并将它标记为红色。\n\n\n\n如果现在运行 git status，我们会看到文件显示在 “changes not staged for commit” 下面并被标记为红色，因为该条目在索引与工作目录之间存在不同。 接着我们运行 git add 来将它暂存到索引中。\n\n\n\n此时，由于索引和 head 不同，若运行 git status 的话就会看到 “changes to be committed” 下的该文件变为绿色 ——也就是说，现在预期的下一次提交与上一次提交不同。 最后，我们运行 git commit 来完成提交。\n\n\n\n现在运行 git status 会没有输出，因为三棵树又变得相同了。\n\n切换分支或克隆的过程也类似。 当检出一个分支时，它会修改 head 指向新的分支引用，将 索引 填充为该次提交的快照， 然后将 索引 的内容复制到 工作目录 中。\n\n\n# 重置的作用\n\n在以下情景中观察 reset 命令会更有意义。\n\n为了演示这些例子，假设我们再次修改了 file.txt 文件并第三次提交它。 现在的历史看起来是这样的：\n\n\n\n让我们跟着 reset 看看它都做了什么。 它以一种简单可预见的方式直接操纵这三棵树。 它做了三个基本操作。\n\n\n# 第 1 步：移动 head\n\nreset 做的第一件事是移动 head 的指向。 这与改变 head 自身不同（checkout 所做的）；reset 移动 head 指向的分支。 这意味着如果 head 设置为 master 分支（例如，你正在 master 分支上）， 运行 git reset 9e5e6a4 将会使 master 指向 9e5e6a4。\n\n\n\n无论你调用了何种形式的带有一个提交的 reset，它首先都会尝试这样做。 使用 reset --soft，它将仅仅停在那儿。\n\n现在看一眼上图，理解一下发生的事情：它本质上是撤销了上一次 git commit 命令。 当你在运行 git commit 时，git 会创建一个新的提交，并移动 head 所指向的分支来使其指向该提交。 当你将它 reset 回 head~（head 的父结点）时，其实就是把该分支移动回原来的位置，而不会改变索引和工作目录。 现在你可以更新索引并再次运行 git commit 来完成 git commit --amend 所要做的事情了（见 修改最后一次提交）。\n\n\n# 第 2 步：更新索引（--mixed）\n\n注意，如果你现在运行 git status 的话，就会看到新的 head 和以绿色标出的它和索引之间的区别。\n\n接下来，reset 会用 head 指向的当前快照的内容来更新索引。\n\n\n\n如果指定 --mixed 选项，reset 将会在这时停止。 这也是默认行为，所以如果没有指定任何选项（在本例中只是 git reset head~），这就是命令将会停止的地方。\n\n现在再看一眼上图，理解一下发生的事情：它依然会撤销一上次 提交，但还会 取消暂存 所有的东西。 于是，我们回滚到了所有 git add 和 git commit 的命令执行之前。\n\n\n# 第 3 步：更新工作目录（--hard）\n\nreset 要做的的第三件事情就是让工作目录看起来像索引。 如果使用 --hard 选项，它将会继续这一步。\n\n\n\n现在让我们回想一下刚才发生的事情。 你撤销了最后的提交、git add 和 git commit 命令 以及 工作目录中的所有工作。\n\n必须注意，--hard 标记是 reset 命令唯一的危险用法，它也是 git 会真正地销毁数据的仅有的几个操作之一。 其他任何形式的 reset 调用都可以轻松撤消，但是 --hard 选项不能，因为它强制覆盖了工作目录中的文件。 在这种特殊情况下，我们的 git 数据库中的一个提交内还留有该文件的 v3 版本， 我们可以通过 reflog 来找回它。但是若该文件还未提交，git 仍会覆盖它从而导致无法恢复。\n\n\n# 回顾\n\nreset 命令会以特定的顺序重写这三棵树，在你指定以下选项时停止：\n\n 1. 移动 head 分支的指向 （若指定了 --soft，则到此停止）\n 2. 使索引看起来像 head （若未指定 --hard，则到此停止）\n 3. 使工作目录看起来像索引\n\n\n# 通过路径来重置\n\n前面讲述了 reset 基本形式的行为，不过你还可以给它提供一个作用路径。 若指定了一个路径，reset 将会跳过第 1 步，并且将它的作用范围限定为指定的文件或文件集合。 这样做自然有它的道理，因为 head 只是一个指针，你无法让它同时指向两个提交中各自的一部分。 不过索引和工作目录 可以部分更新，所以重置会继续进行第 2、3 步。\n\n现在，假如我们运行 git reset file.txt （这其实是 git reset --mixed head file.txt 的简写形式，因为你既没有指定一个提交的 sha-1 或分支，也没有指定 --soft 或 --hard），它会：\n\n 1. 移动 head 分支的指向 （已跳过）\n 2. 让索引看起来像 head （到此处停止）\n\n所以它本质上只是将 file.txt 从 head 复制到索引中。\n\n\n\n它还有 取消暂存文件 的实际效果。 如果我们查看该命令的示意图，然后再想想 git add 所做的事，就会发现它们正好相反。\n\n\n\n这就是为什么 git status 命令的输出会建议运行此命令来取消暂存一个文件。 （查看 取消暂存的文件 来了解更多。）\n\n我们可以不让 git 从 head 拉取数据，而是通过具体指定一个提交来拉取该文件的对应版本。 我们只需运行类似于 git reset eb43bf file.txt 的命令即可。\n\n\n\n它其实做了同样的事情，也就是把工作目录中的文件恢复到 v1 版本，运行 git add 添加它， 然后再将它恢复到 v3 版本（只是不用真的过一遍这些步骤）。 如果我们现在运行 git commit，它就会记录一条“将该文件恢复到 v1 版本”的更改， 尽管我们并未在工作目录中真正地再次拥有它。\n\n还有一点同 git add 一样，就是 reset 命令也可以接受一个 --patch 选项来一块一块地取消暂存的内容。 这样你就可以根据选择来取消暂存或恢复内容了。\n\n\n# 压缩\n\n我们来看看如何利用这种新的功能来做一些有趣的事情——压缩提交。\n\n假设你的一系列提交信息中有 “oops.”“wip” 和 “forgot this file”， 聪明的你就能使用 reset 来轻松快速地将它们压缩成单个提交，也显出你的聪明。 （压缩提交 展示了另一种方式，不过在本例中用 reset 更简单。）\n\n假设你有一个项目，第一次提交中有一个文件，第二次提交增加了一个新的文件并修改了第一个文件，第三次提交再次修改了第一个文件。 由于第二次提交是一个未完成的工作，因此你想要压缩它。\n\n\n\n那么可以运行 git reset --soft head~2 来将 head 分支移动到一个旧一点的提交上（即你想要保留的最近的提交）：\n\n\n\n然后只需再次运行 git commit：\n\n\n\n现在你可以查看可到达的历史，即将会推送的历史，现在看起来有个 v1 版 file-a.txt 的提交， 接着第二个提交将 file-a.txt 修改成了 v3 版并增加了 file-b.txt。 包含 v2 版本的文件已经不在历史中了。\n\n\n# 检出\n\n最后，你大概还想知道 checkout 和 reset 之间的区别。 和 reset 一样，checkout 也操纵三棵树，不过它有一点不同，这取决于你是否传给该命令一个文件路径。\n\n\n# 不带路径\n\n运行 git checkout [branch] 与运行 git reset --hard [branch] 非常相似，它会更新所有三棵树使其看起来像 [branch]，不过有两点重要的区别。\n\n首先不同于 reset --hard，checkout 对工作目录是安全的，它会通过检查来确保不会将已更改的文件弄丢。 其实它还更聪明一些。它会在工作目录中先试着简单合并一下，这样所有_还未修改过的_文件都会被更新。 而 reset --hard 则会不做检查就全面地替换所有东西。\n\n第二个重要的区别是 checkout 如何更新 head。 reset 会移动 head 分支的指向，而 checkout 只会移动 head 自身来指向另一个分支。\n\n例如，假设我们有 master 和 develop 分支，它们分别指向不同的提交；我们现在在 develop 上（所以 head 指向它）。 如果我们运行 git reset master，那么 develop 自身现在会和 master 指向同一个提交。 而如果我们运行 git checkout master 的话，develop 不会移动，head 自身会移动。 现在 head 将会指向 master。\n\n所以，虽然在这两种情况下我们都移动 head 使其指向了提交 a，但_做法_是非常不同的。 reset 会移动 head 分支的指向，而 checkout 则移动 head 自身。\n\n\n\n\n# 带路径\n\n运行 checkout 的另一种方式就是指定一个文件路径，这会像 reset 一样不会移动 head。 它就像 git reset [branch] file 那样用该次提交中的那个文件来更新索引，但是它也会覆盖工作目录中对应的文件。 它就像是 git reset --hard [branch] file（如果 reset 允许你这样运行的话）， 这样对工作目录并不安全，它也不会移动 head。\n\n此外，同 git reset 和 git add 一样，checkout 也接受一个 --patch 选项，允许你根据选择一块一块地恢复文件内容。\n\n\n# 总结\n\n希望你现在熟悉并理解了 reset 命令，不过关于它和 checkout 之间的区别，你可能还是会有点困惑，毕竟不太可能记住不同调用的所有规则。\n\n下面的速查表列出了命令对树的影响。 “head” 一列中的 “ref” 表示该命令移动了 head 指向的分支引用，而 “head” 则表示只移动了 head 自身。 特别注意 wd safe? 一列——如果它标记为 no，那么运行该命令之前请考虑一下。\n\n                            head   index   workdir   wd safe?\ncommit level                                         \nreset --soft [commit]       ref    no      no        yes\nreset [commit]              ref    yes     no        yes\nreset --hard [commit]       ref    yes     yes       no\ncheckout <commit>           head   yes     yes       yes\nfile level                                           \nreset [commit] <paths>      no     yes     no        yes\ncheckout [commit] <paths>   no     yes     yes       no",charsets:{cjk:!0},lastUpdated:"2023/11/19, 12:55:48",lastUpdatedTimestamp:1700369748e3},{title:"Git工具-重写历史",frontmatter:{title:"Git工具-重写历史",date:"2020-11-18T17:43:57.000Z",permalink:"/pages/1832fe/",categories:["《Git》学习笔记"],tags:["Git"],author:{name:"王清欢",link:"https://github.com/wang-haihua"}},regularPath:"/05.Git%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/30.Git%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%AC%94%E8%AE%B0/100.Git%E5%B7%A5%E5%85%B7-%E9%87%8D%E5%86%99%E5%8E%86%E5%8F%B2.html",relativePath:"05.Git 学习笔记/30.Git 官方文档笔记/100.Git工具-重写历史.md",key:"v-60adb5e5",path:"/pages/1832fe/",headers:[{level:2,title:"修改最后一次提交",slug:"修改最后一次提交",normalizedTitle:"修改最后一次提交",charIndex:453},{level:3,title:"修改提交信息",slug:"修改提交信息",normalizedTitle:"修改提交信息",charIndex:519},{level:3,title:"修改实际内容",slug:"修改实际内容",normalizedTitle:"修改实际内容",charIndex:696},{level:2,title:"修改多个提交信息",slug:"修改多个提交信息",normalizedTitle:"修改多个提交信息",charIndex:1109},{level:2,title:"重新排序提交",slug:"重新排序提交",normalizedTitle:"重新排序提交",charIndex:3900},{level:2,title:"压缩提交",slug:"压缩提交",normalizedTitle:"压缩提交",charIndex:4312},{level:2,title:"拆分提交",slug:"拆分提交",normalizedTitle:"拆分提交",charIndex:5971},{level:2,title:"核武器级选项：filter-branch",slug:"核武器级选项-filter-branch",normalizedTitle:"核武器级选项：filter-branch",charIndex:6963},{level:3,title:"从每一个提交中移除一个文件",slug:"从每一个提交中移除一个文件",normalizedTitle:"从每一个提交中移除一个文件",charIndex:7037},{level:3,title:"使一个子目录做为新的根目录",slug:"使一个子目录做为新的根目录",normalizedTitle:"使一个子目录做为新的根目录",charIndex:8069},{level:3,title:"全局修改邮箱地址",slug:"全局修改邮箱地址",normalizedTitle:"全局修改邮箱地址",charIndex:8387}],headersStr:"修改最后一次提交 修改提交信息 修改实际内容 修改多个提交信息 重新排序提交 压缩提交 拆分提交 核武器级选项：filter-branch 从每一个提交中移除一个文件 使一个子目录做为新的根目录 全局修改邮箱地址",content:"# Git 工具 - 重写历史\n\n许多时候，在使用 Git 时，你可能想要修订提交历史。 Git 很棒的一点是它允许你在最后时刻做决定。 你可以在将暂存区内容提交前决定哪些文件进入提交，可以通过 git stash 来决定不与某些内容工作， 也可以重写已经发生的提交就像它们以另一种方式发生的一样。 这可能涉及改变提交的顺序，改变提交中的信息或修改文件，将提交压缩或是拆分， 或完全地移除提交——在将你的工作成果与他人共享之前。\n\n在本节中，你可以学到如何完成这些工作，这样在与他人分享你的工作成果时你的提交历史将如你所愿地展示出来。\n\nNOTE   在满意之前不要推送你的工作GIT 的基本原则之一是，由于克隆中有很多工作是本地的，因此你可以 在本地 随便重写历史记录。\n       然而一旦推送了你的工作，那就完全是另一回事了，除非你有充分的理由进行更改，否则应该将推送的工作视为最终结果。\n       简而言之，在对它感到满意并准备与他人分享之前，应当避免推送你的工作。\n       \n\n\n# 修改最后一次提交\n\n修改你最近一次提交可能是所有修改历史提交的操作中最常见的一个。 对于你的最近一次提交，你往往想做两件事情：简单地修改提交信息， 或者通过添加、移除或修改文件来更改提交实际的内容。\n\n\n# 修改提交信息\n\n如果，你只是想修改最近一次提交的提交信息，那么很简单：\n\n$ git commit --amend\n\n\n上面这条命令会将最后一次的提交信息载入到编辑器中供你修改。 当保存并关闭编辑器后，编辑器会将更新后的提交信息写入新提交中，它会成为新的最后一次提交。\n\n\n# 修改实际内容\n\n另一方面，如果你想要修改最后一次提交的实际内容，那么流程很相似：首先作出你想要补上的修改， 暂存它们，然后用 git commit --amend 以新的改进后的提交来 替换 掉旧有的最后一次提交，\n\n使用这个技巧的时候需要小心，因为修正会改变提交的 SHA-1 校验和。 它类似于一个小的变基——如果已经推送了最后一次提交就不要修正它。\n\nTIP   修补后的提交可能需要修补提交信息当你在修补一次提交时，可以同时修改提交信息和提交内容。\n      如果你修补了提交的内容，那么几乎肯定要更新提交消息以反映修改后的内容。另一方面，如果你的修补是琐碎的（如修改了一个笔误或添加了一个忘记暂存的文件），\n      那么之前的提交信息不必修改，你只需作出更改，暂存它们，然后通过以下命令避免不必要的编辑器环节即可：$ GIT\n      COMMIT --AMEND --NO-EDIT\n      \n\n\n# 修改多个提交信息\n\n为了修改在提交历史中较远的提交，必须使用更复杂的工具。 Git 没有一个改变历史工具，但是可以使用变基工具来变基一系列提交，基于它们原来的 HEAD 而不是将其移动到另一个新的上面。 通过交互式变基工具，可以在任何想要修改的提交后停止，然后修改信息、添加文件或做任何想做的事情。 可以通过给 git rebase 增加 -i 选项来交互式地运行变基。 必须指定想要重写多久远的历史，这可以通过告诉命令将要变基到的提交来做到。\n\n例如，如果想要修改最近三次提交信息，或者那组提交中的任意一个提交信息， 将想要修改的最近一次提交的父提交作为参数传递给 git rebase -i 命令，即 HEAD~2^ 或 HEAD~3。 记住 ~3 可能比较容易，因为你正尝试修改最后三次提交；但是注意实际上指定了以前的四次提交，即想要修改提交的父提交：\n\n$ git rebase -i HEAD~3\n\n\n再次记住这是一个变基命令——在 HEAD~3..HEAD 范围内的每一个修改了提交信息的提交及其 所有后裔 都会被重写。 不要涉及任何已经推送到中央服务器的提交——这样做会产生一次变更的两个版本，因而使他人困惑。\n\n运行这个命令会在文本编辑器上给你一个提交的列表，看起来像下面这样：\n\npick f7f3f6d changed my name a bit\npick 310154e updated README formatting and added blame\npick a5f4a0d added cat-file\n\n# Rebase 710f0f8..a5f4a0d onto 710f0f8\n#\n# Commands:\n# p, pick <commit> = use commit\n# r, reword <commit> = use commit, but edit the commit message\n# e, edit <commit> = use commit, but stop for amending\n# s, squash <commit> = use commit, but meld into previous commit\n# f, fixup <commit> = like \"squash\", but discard this commit's log message\n# x, exec <command> = run command (the rest of the line) using shell\n# b, break = stop here (continue rebase later with 'git rebase --continue')\n# d, drop <commit> = remove commit\n# l, label <label> = label current HEAD with a name\n# t, reset <label> = reset HEAD to a label\n# m, merge [-C <commit> | -c <commit>] <label> [# <oneline>]\n# .       create a merge commit using the original merge commit's\n# .       message (or the oneline, if no original merge commit was\n# .       specified). Use -c <commit> to reword the commit message.\n#\n# These lines can be re-ordered; they are executed from top to bottom.\n#\n# If you remove a line here THAT COMMIT WILL BE LOST.\n#\n# However, if you remove everything, the rebase will be aborted.\n#\n# Note that empty commits are commented out\n\n\n需要重点注意的是相对于正常使用的 log 命令，这些提交显示的顺序是相反的。 运行一次 log 命令，会看到类似这样的东西：\n\n$ git log --pretty=format:\"%h %s\" HEAD~3..HEAD\na5f4a0d added cat-file\n310154e updated README formatting and added blame\nf7f3f6d changed my name a bit\n\n\n注意其中的反序显示。 交互式变基给你一个它将会运行的脚本。 它将会从你在命令行中指定的提交（HEAD~3）开始，从上到下的依次重演每一个提交引入的修改。 它将最旧的而不是最新的列在上面，因为那会是第一个将要重演的。\n\n你需要修改脚本来让它停留在你想修改的变更上。 要达到这个目的，你只要将你想修改的每一次提交前面的 ‘pick’ 改为 ‘edit’。 例如，只想修改第三次提交信息，可以像下面这样修改文件：\n\nedit f7f3f6d changed my name a bit\npick 310154e updated README formatting and added blame\npick a5f4a0d added cat-file\n\n\n当保存并退出编辑器时，Git 将你带回到列表中的最后一次提交，把你送回命令行并提示以下信息：\n\n$ git rebase -i HEAD~3\nStopped at f7f3f6d... changed my name a bit\nYou can amend the commit now, with\n\n       git commit --amend\n\nOnce you're satisfied with your changes, run\n\n       git rebase --continue\n\n\n这些指令准确地告诉你该做什么。 输入\n\n$ git commit --amend\n\n\n修改提交信息，然后退出编辑器。 然后，运行\n\n$ git rebase --continue\n\n\n这个命令将会自动地应用另外两个提交，然后就完成了。 如果需要将不止一处的 pick 改为 edit，需要在每一个修改为 edit 的提交上重复这些步骤。 每一次，Git 将会停止，让你修正提交，然后继续直到完成。\n\n\n# 重新排序提交\n\n也可以使用交互式变基来重新排序或完全移除提交。 如果想要移除 “added cat-file” 提交然后修改另外两个提交引入的顺序，可以将变基脚本从这样：\n\npick f7f3f6d changed my name a bit\npick 310154e updated README formatting and added blame\npick a5f4a0d added cat-file\n\n\n改为这样：\n\npick 310154e updated README formatting and added blame\npick f7f3f6d changed my name a bit\n\n\n当保存并退出编辑器时，Git 将你的分支带回这些提交的父提交，应用 310154e 然后应用 f7f3f6d，最后停止。 事实修改了那些提交的顺序并完全地移除了 “added cat-file” 提交。\n\n\n# 压缩提交\n\n通过交互式变基工具，也可以将一连串提交压缩成一个单独的提交。 在变基信息中脚本给出了有用的指令：\n\n#\n# Commands:\n# p, pick <commit> = use commit\n# r, reword <commit> = use commit, but edit the commit message\n# e, edit <commit> = use commit, but stop for amending\n# s, squash <commit> = use commit, but meld into previous commit\n# f, fixup <commit> = like \"squash\", but discard this commit's log message\n# x, exec <command> = run command (the rest of the line) using shell\n# b, break = stop here (continue rebase later with 'git rebase --continue')\n# d, drop <commit> = remove commit\n# l, label <label> = label current HEAD with a name\n# t, reset <label> = reset HEAD to a label\n# m, merge [-C <commit> | -c <commit>] <label> [# <oneline>]\n# .       create a merge commit using the original merge commit's\n# .       message (or the oneline, if no original merge commit was\n# .       specified). Use -c <commit> to reword the commit message.\n#\n# These lines can be re-ordered; they are executed from top to bottom.\n#\n# If you remove a line here THAT COMMIT WILL BE LOST.\n#\n# However, if you remove everything, the rebase will be aborted.\n#\n# Note that empty commits are commented out\n\n\n如果，指定 “squash” 而不是 “pick” 或 “edit”，Git 将应用两者的修改并合并提交信息在一起。 所以，如果想要这三次提交变为一个提交，可以这样修改脚本：\n\npick f7f3f6d changed my name a bit\nsquash 310154e updated README formatting and added blame\nsquash a5f4a0d added cat-file\n\n\n当保存并退出编辑器时，Git 应用所有的三次修改然后将你放到编辑器中来合并三次提交信息：\n\n# This is a combination of 3 commits.\n# The first commit's message is:\nchanged my name a bit\n\n# This is the 2nd commit message:\n\nupdated README formatting and added blame\n\n# This is the 3rd commit message:\n\nadded cat-file\n\n\n当你保存之后，你就拥有了一个包含前三次提交的全部变更的提交。\n\n\n# 拆分提交\n\n拆分一个提交会撤消这个提交，然后多次地部分地暂存与提交直到完成你所需次数的提交。 例如，假设想要拆分三次提交的中间那次提交。 想要将它拆分为两次提交：第一个 “updated README formatting”，第二个 “added blame” 来代替原来的 “updated README formatting and added blame”。 可以通过修改 rebase -i 的脚本来做到这点，将要拆分的提交的指令修改为 “edit”：\n\npick f7f3f6d changed my name a bit\nedit 310154e updated README formatting and added blame\npick a5f4a0d added cat-file\n\n\n然后，当脚本带你进入到命令行时，重置那个提交，拿到被重置的修改，从中创建几次提交。 当保存并退出编辑器时，Git 带你到列表中第一个提交的父提交，应用第一个提交（f7f3f6d）， 应用第二个提交（310154e），然后让你进入命令行。 那里，可以通过 git reset HEAD^ 做一次针对那个提交的混合重置，实际上将会撤消那次提交并将修改的文件取消暂存。 现在可以暂存并提交文件直到有几个提交，然后当完成时运行 git rebase --continue：\n\n$ git reset HEAD^\n$ git add README\n$ git commit -m 'updated README formatting'\n$ git add lib/simplegit.rb\n$ git commit -m 'added blame'\n$ git rebase --continue\n\n\nGit 在脚本中应用最后一次提交（a5f4a0d），历史记录看起来像这样：\n\n$ git log -4 --pretty=format:\"%h %s\"\n1c002dd added cat-file\n9b29157 added blame\n35cfb2b updated README formatting\nf3cc40e changed my name a bit\n\n\n再次强调，这些改动了所有在列表中的提交的 SHA-1 校验和，所以要确保列表中的提交还没有推送到共享仓库中。\n\n\n# 核武器级选项：filter-branch\n\n有另一个历史改写的选项，如果想要通过脚本的方式改写大量提交的话可以使用它——例如，全局修改你的邮箱地址或从每一个提交中移除一个文件。 这个命令是 filter-branch，它可以改写历史中大量的提交，除非你的项目还没有公开并且其他人没有基于要改写的工作的提交做的工作，否则你不应当使用它。 然而，它可以很有用。 你将会学习到几个常用的用途，这样就得到了它适合使用地方的想法。\n\nCAUTION   GIT FILTER-BRANCH 有很多陷阱，不再推荐使用它来重写历史。 请考虑使用\n          GIT-FILTER-REPO，它是一个 PYTHON 脚本，相比大多数使用 FILTER-BRANCH\n          的应用来说，它做得要更好。它的文档和源码可访问\n          HTTPS://GITHUB.COM/NEWREN/GIT-FILTER-REPO 获取。\n          \n\n\n# 从每一个提交中移除一个文件\n\n这经常发生。 有人粗心地通过 git add . 提交了一个巨大的二进制文件，你想要从所有地方删除。 可能偶然地提交了一个包括一个密码的文件，然而你想要开源项目。 filter-branch 是一个可能会用来擦洗整个提交历史的工具。 为了从整个提交历史中移除一个叫做 passwords.txt 的文件，可以使用 --tree-filter 选项给 filter-branch：\n\n$ git filter-branch --tree-filter 'rm -f passwords.txt' HEAD\nRewrite 6b9b3cf04e7c5686a9cb838c3f36a8cb6a0fc2bd (21/21)\nRef 'refs/heads/master' was rewritten\n\n\n--tree-filter 选项在检出项目的每一个提交后运行指定的命令然后重新提交结果。 在本例中，你从每一个快照中移除了一个叫作 passwords.txt 的文件，无论它是否存在。 如果想要移除所有偶然提交的编辑器备份文件，可以运行类似 git filter-branch --tree-filter 'rm -f *~' HEAD 的命令。\n\n最后将可以看到 Git 重写树与提交然后移动分支指针。 通常一个好的想法是在一个测试分支中做这件事，然后当你决定最终结果是真正想要的，可以硬重置 master 分支。 为了让 filter-branch 在所有分支上运行，可以给命令传递 --all 选项。\n\n\n# 使一个子目录做为新的根目录\n\n假设已经从另一个源代码控制系统中导入，并且有几个没意义的子目录（trunk、tags 等等）。 如果想要让 trunk 子目录作为每一个提交的新的项目根目录，filter-branch 也可以帮助你那么做：\n\n$ git filter-branch --subdirectory-filter trunk HEAD\nRewrite 856f0bf61e41a27326cdae8f09fe708d679f596f (12/12)\nRef 'refs/heads/master' was rewritten\n\n\n现在新项目根目录是 trunk 子目录了。 Git 会自动移除所有不影响子目录的提交。\n\n\n# 全局修改邮箱地址\n\n另一个常见的情形是在你开始工作时忘记运行 git config 来设置你的名字与邮箱地址， 或者你想要开源一个项目并且修改所有你的工作邮箱地址为你的个人邮箱地址。 任何情形下，你也可以通过 filter-branch 来一次性修改多个提交中的邮箱地址。 需要小心的是只修改你自己的邮箱地址，所以你使用 --commit-filter：\n\n$ git filter-branch --commit-filter '\n        if [ \"$GIT_AUTHOR_EMAIL\" = \"schacon@localhost\" ];\n        then\n                GIT_AUTHOR_NAME=\"Scott Chacon\";\n                GIT_AUTHOR_EMAIL=\"schacon@example.com\";\n                git commit-tree \"$@\";\n        else\n                git commit-tree \"$@\";\n        fi' HEAD\n\n\n这会遍历并重写每一个提交来包含你的新邮箱地址。 因为提交包含了它们父提交的 SHA-1 校验和，这个命令会修改你的历史中的每一个提交的 SHA-1 校验和， 而不仅仅只是那些匹配邮箱地址的提交。",normalizedContent:"# git 工具 - 重写历史\n\n许多时候，在使用 git 时，你可能想要修订提交历史。 git 很棒的一点是它允许你在最后时刻做决定。 你可以在将暂存区内容提交前决定哪些文件进入提交，可以通过 git stash 来决定不与某些内容工作， 也可以重写已经发生的提交就像它们以另一种方式发生的一样。 这可能涉及改变提交的顺序，改变提交中的信息或修改文件，将提交压缩或是拆分， 或完全地移除提交——在将你的工作成果与他人共享之前。\n\n在本节中，你可以学到如何完成这些工作，这样在与他人分享你的工作成果时你的提交历史将如你所愿地展示出来。\n\nnote   在满意之前不要推送你的工作git 的基本原则之一是，由于克隆中有很多工作是本地的，因此你可以 在本地 随便重写历史记录。\n       然而一旦推送了你的工作，那就完全是另一回事了，除非你有充分的理由进行更改，否则应该将推送的工作视为最终结果。\n       简而言之，在对它感到满意并准备与他人分享之前，应当避免推送你的工作。\n       \n\n\n# 修改最后一次提交\n\n修改你最近一次提交可能是所有修改历史提交的操作中最常见的一个。 对于你的最近一次提交，你往往想做两件事情：简单地修改提交信息， 或者通过添加、移除或修改文件来更改提交实际的内容。\n\n\n# 修改提交信息\n\n如果，你只是想修改最近一次提交的提交信息，那么很简单：\n\n$ git commit --amend\n\n\n上面这条命令会将最后一次的提交信息载入到编辑器中供你修改。 当保存并关闭编辑器后，编辑器会将更新后的提交信息写入新提交中，它会成为新的最后一次提交。\n\n\n# 修改实际内容\n\n另一方面，如果你想要修改最后一次提交的实际内容，那么流程很相似：首先作出你想要补上的修改， 暂存它们，然后用 git commit --amend 以新的改进后的提交来 替换 掉旧有的最后一次提交，\n\n使用这个技巧的时候需要小心，因为修正会改变提交的 sha-1 校验和。 它类似于一个小的变基——如果已经推送了最后一次提交就不要修正它。\n\ntip   修补后的提交可能需要修补提交信息当你在修补一次提交时，可以同时修改提交信息和提交内容。\n      如果你修补了提交的内容，那么几乎肯定要更新提交消息以反映修改后的内容。另一方面，如果你的修补是琐碎的（如修改了一个笔误或添加了一个忘记暂存的文件），\n      那么之前的提交信息不必修改，你只需作出更改，暂存它们，然后通过以下命令避免不必要的编辑器环节即可：$ git\n      commit --amend --no-edit\n      \n\n\n# 修改多个提交信息\n\n为了修改在提交历史中较远的提交，必须使用更复杂的工具。 git 没有一个改变历史工具，但是可以使用变基工具来变基一系列提交，基于它们原来的 head 而不是将其移动到另一个新的上面。 通过交互式变基工具，可以在任何想要修改的提交后停止，然后修改信息、添加文件或做任何想做的事情。 可以通过给 git rebase 增加 -i 选项来交互式地运行变基。 必须指定想要重写多久远的历史，这可以通过告诉命令将要变基到的提交来做到。\n\n例如，如果想要修改最近三次提交信息，或者那组提交中的任意一个提交信息， 将想要修改的最近一次提交的父提交作为参数传递给 git rebase -i 命令，即 head~2^ 或 head~3。 记住 ~3 可能比较容易，因为你正尝试修改最后三次提交；但是注意实际上指定了以前的四次提交，即想要修改提交的父提交：\n\n$ git rebase -i head~3\n\n\n再次记住这是一个变基命令——在 head~3..head 范围内的每一个修改了提交信息的提交及其 所有后裔 都会被重写。 不要涉及任何已经推送到中央服务器的提交——这样做会产生一次变更的两个版本，因而使他人困惑。\n\n运行这个命令会在文本编辑器上给你一个提交的列表，看起来像下面这样：\n\npick f7f3f6d changed my name a bit\npick 310154e updated readme formatting and added blame\npick a5f4a0d added cat-file\n\n# rebase 710f0f8..a5f4a0d onto 710f0f8\n#\n# commands:\n# p, pick <commit> = use commit\n# r, reword <commit> = use commit, but edit the commit message\n# e, edit <commit> = use commit, but stop for amending\n# s, squash <commit> = use commit, but meld into previous commit\n# f, fixup <commit> = like \"squash\", but discard this commit's log message\n# x, exec <command> = run command (the rest of the line) using shell\n# b, break = stop here (continue rebase later with 'git rebase --continue')\n# d, drop <commit> = remove commit\n# l, label <label> = label current head with a name\n# t, reset <label> = reset head to a label\n# m, merge [-c <commit> | -c <commit>] <label> [# <oneline>]\n# .       create a merge commit using the original merge commit's\n# .       message (or the oneline, if no original merge commit was\n# .       specified). use -c <commit> to reword the commit message.\n#\n# these lines can be re-ordered; they are executed from top to bottom.\n#\n# if you remove a line here that commit will be lost.\n#\n# however, if you remove everything, the rebase will be aborted.\n#\n# note that empty commits are commented out\n\n\n需要重点注意的是相对于正常使用的 log 命令，这些提交显示的顺序是相反的。 运行一次 log 命令，会看到类似这样的东西：\n\n$ git log --pretty=format:\"%h %s\" head~3..head\na5f4a0d added cat-file\n310154e updated readme formatting and added blame\nf7f3f6d changed my name a bit\n\n\n注意其中的反序显示。 交互式变基给你一个它将会运行的脚本。 它将会从你在命令行中指定的提交（head~3）开始，从上到下的依次重演每一个提交引入的修改。 它将最旧的而不是最新的列在上面，因为那会是第一个将要重演的。\n\n你需要修改脚本来让它停留在你想修改的变更上。 要达到这个目的，你只要将你想修改的每一次提交前面的 ‘pick’ 改为 ‘edit’。 例如，只想修改第三次提交信息，可以像下面这样修改文件：\n\nedit f7f3f6d changed my name a bit\npick 310154e updated readme formatting and added blame\npick a5f4a0d added cat-file\n\n\n当保存并退出编辑器时，git 将你带回到列表中的最后一次提交，把你送回命令行并提示以下信息：\n\n$ git rebase -i head~3\nstopped at f7f3f6d... changed my name a bit\nyou can amend the commit now, with\n\n       git commit --amend\n\nonce you're satisfied with your changes, run\n\n       git rebase --continue\n\n\n这些指令准确地告诉你该做什么。 输入\n\n$ git commit --amend\n\n\n修改提交信息，然后退出编辑器。 然后，运行\n\n$ git rebase --continue\n\n\n这个命令将会自动地应用另外两个提交，然后就完成了。 如果需要将不止一处的 pick 改为 edit，需要在每一个修改为 edit 的提交上重复这些步骤。 每一次，git 将会停止，让你修正提交，然后继续直到完成。\n\n\n# 重新排序提交\n\n也可以使用交互式变基来重新排序或完全移除提交。 如果想要移除 “added cat-file” 提交然后修改另外两个提交引入的顺序，可以将变基脚本从这样：\n\npick f7f3f6d changed my name a bit\npick 310154e updated readme formatting and added blame\npick a5f4a0d added cat-file\n\n\n改为这样：\n\npick 310154e updated readme formatting and added blame\npick f7f3f6d changed my name a bit\n\n\n当保存并退出编辑器时，git 将你的分支带回这些提交的父提交，应用 310154e 然后应用 f7f3f6d，最后停止。 事实修改了那些提交的顺序并完全地移除了 “added cat-file” 提交。\n\n\n# 压缩提交\n\n通过交互式变基工具，也可以将一连串提交压缩成一个单独的提交。 在变基信息中脚本给出了有用的指令：\n\n#\n# commands:\n# p, pick <commit> = use commit\n# r, reword <commit> = use commit, but edit the commit message\n# e, edit <commit> = use commit, but stop for amending\n# s, squash <commit> = use commit, but meld into previous commit\n# f, fixup <commit> = like \"squash\", but discard this commit's log message\n# x, exec <command> = run command (the rest of the line) using shell\n# b, break = stop here (continue rebase later with 'git rebase --continue')\n# d, drop <commit> = remove commit\n# l, label <label> = label current head with a name\n# t, reset <label> = reset head to a label\n# m, merge [-c <commit> | -c <commit>] <label> [# <oneline>]\n# .       create a merge commit using the original merge commit's\n# .       message (or the oneline, if no original merge commit was\n# .       specified). use -c <commit> to reword the commit message.\n#\n# these lines can be re-ordered; they are executed from top to bottom.\n#\n# if you remove a line here that commit will be lost.\n#\n# however, if you remove everything, the rebase will be aborted.\n#\n# note that empty commits are commented out\n\n\n如果，指定 “squash” 而不是 “pick” 或 “edit”，git 将应用两者的修改并合并提交信息在一起。 所以，如果想要这三次提交变为一个提交，可以这样修改脚本：\n\npick f7f3f6d changed my name a bit\nsquash 310154e updated readme formatting and added blame\nsquash a5f4a0d added cat-file\n\n\n当保存并退出编辑器时，git 应用所有的三次修改然后将你放到编辑器中来合并三次提交信息：\n\n# this is a combination of 3 commits.\n# the first commit's message is:\nchanged my name a bit\n\n# this is the 2nd commit message:\n\nupdated readme formatting and added blame\n\n# this is the 3rd commit message:\n\nadded cat-file\n\n\n当你保存之后，你就拥有了一个包含前三次提交的全部变更的提交。\n\n\n# 拆分提交\n\n拆分一个提交会撤消这个提交，然后多次地部分地暂存与提交直到完成你所需次数的提交。 例如，假设想要拆分三次提交的中间那次提交。 想要将它拆分为两次提交：第一个 “updated readme formatting”，第二个 “added blame” 来代替原来的 “updated readme formatting and added blame”。 可以通过修改 rebase -i 的脚本来做到这点，将要拆分的提交的指令修改为 “edit”：\n\npick f7f3f6d changed my name a bit\nedit 310154e updated readme formatting and added blame\npick a5f4a0d added cat-file\n\n\n然后，当脚本带你进入到命令行时，重置那个提交，拿到被重置的修改，从中创建几次提交。 当保存并退出编辑器时，git 带你到列表中第一个提交的父提交，应用第一个提交（f7f3f6d）， 应用第二个提交（310154e），然后让你进入命令行。 那里，可以通过 git reset head^ 做一次针对那个提交的混合重置，实际上将会撤消那次提交并将修改的文件取消暂存。 现在可以暂存并提交文件直到有几个提交，然后当完成时运行 git rebase --continue：\n\n$ git reset head^\n$ git add readme\n$ git commit -m 'updated readme formatting'\n$ git add lib/simplegit.rb\n$ git commit -m 'added blame'\n$ git rebase --continue\n\n\ngit 在脚本中应用最后一次提交（a5f4a0d），历史记录看起来像这样：\n\n$ git log -4 --pretty=format:\"%h %s\"\n1c002dd added cat-file\n9b29157 added blame\n35cfb2b updated readme formatting\nf3cc40e changed my name a bit\n\n\n再次强调，这些改动了所有在列表中的提交的 sha-1 校验和，所以要确保列表中的提交还没有推送到共享仓库中。\n\n\n# 核武器级选项：filter-branch\n\n有另一个历史改写的选项，如果想要通过脚本的方式改写大量提交的话可以使用它——例如，全局修改你的邮箱地址或从每一个提交中移除一个文件。 这个命令是 filter-branch，它可以改写历史中大量的提交，除非你的项目还没有公开并且其他人没有基于要改写的工作的提交做的工作，否则你不应当使用它。 然而，它可以很有用。 你将会学习到几个常用的用途，这样就得到了它适合使用地方的想法。\n\ncaution   git filter-branch 有很多陷阱，不再推荐使用它来重写历史。 请考虑使用\n          git-filter-repo，它是一个 python 脚本，相比大多数使用 filter-branch\n          的应用来说，它做得要更好。它的文档和源码可访问\n          https://github.com/newren/git-filter-repo 获取。\n          \n\n\n# 从每一个提交中移除一个文件\n\n这经常发生。 有人粗心地通过 git add . 提交了一个巨大的二进制文件，你想要从所有地方删除。 可能偶然地提交了一个包括一个密码的文件，然而你想要开源项目。 filter-branch 是一个可能会用来擦洗整个提交历史的工具。 为了从整个提交历史中移除一个叫做 passwords.txt 的文件，可以使用 --tree-filter 选项给 filter-branch：\n\n$ git filter-branch --tree-filter 'rm -f passwords.txt' head\nrewrite 6b9b3cf04e7c5686a9cb838c3f36a8cb6a0fc2bd (21/21)\nref 'refs/heads/master' was rewritten\n\n\n--tree-filter 选项在检出项目的每一个提交后运行指定的命令然后重新提交结果。 在本例中，你从每一个快照中移除了一个叫作 passwords.txt 的文件，无论它是否存在。 如果想要移除所有偶然提交的编辑器备份文件，可以运行类似 git filter-branch --tree-filter 'rm -f *~' head 的命令。\n\n最后将可以看到 git 重写树与提交然后移动分支指针。 通常一个好的想法是在一个测试分支中做这件事，然后当你决定最终结果是真正想要的，可以硬重置 master 分支。 为了让 filter-branch 在所有分支上运行，可以给命令传递 --all 选项。\n\n\n# 使一个子目录做为新的根目录\n\n假设已经从另一个源代码控制系统中导入，并且有几个没意义的子目录（trunk、tags 等等）。 如果想要让 trunk 子目录作为每一个提交的新的项目根目录，filter-branch 也可以帮助你那么做：\n\n$ git filter-branch --subdirectory-filter trunk head\nrewrite 856f0bf61e41a27326cdae8f09fe708d679f596f (12/12)\nref 'refs/heads/master' was rewritten\n\n\n现在新项目根目录是 trunk 子目录了。 git 会自动移除所有不影响子目录的提交。\n\n\n# 全局修改邮箱地址\n\n另一个常见的情形是在你开始工作时忘记运行 git config 来设置你的名字与邮箱地址， 或者你想要开源一个项目并且修改所有你的工作邮箱地址为你的个人邮箱地址。 任何情形下，你也可以通过 filter-branch 来一次性修改多个提交中的邮箱地址。 需要小心的是只修改你自己的邮箱地址，所以你使用 --commit-filter：\n\n$ git filter-branch --commit-filter '\n        if [ \"$git_author_email\" = \"schacon@localhost\" ];\n        then\n                git_author_name=\"scott chacon\";\n                git_author_email=\"schacon@example.com\";\n                git commit-tree \"$@\";\n        else\n                git commit-tree \"$@\";\n        fi' head\n\n\n这会遍历并重写每一个提交来包含你的新邮箱地址。 因为提交包含了它们父提交的 sha-1 校验和，这个命令会修改你的历史中的每一个提交的 sha-1 校验和， 而不仅仅只是那些匹配邮箱地址的提交。",charsets:{cjk:!0},lastUpdated:"2023/11/19, 12:55:48",lastUpdatedTimestamp:1700369748e3},{title:"Git分支-分支原理",frontmatter:{title:"Git分支-分支原理",date:"2020-11-18T17:43:57.000Z",permalink:"/pages/4bef1a/",categories:["《Git》学习笔记"],tags:["Git"],author:{name:"王清欢",link:"https://github.com/wang-haihua"}},regularPath:"/05.Git%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/30.Git%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%AC%94%E8%AE%B0/20.Git%E5%88%86%E6%94%AF-%E5%88%86%E6%94%AF%E5%8E%9F%E7%90%86.html",relativePath:"05.Git 学习笔记/30.Git 官方文档笔记/20.Git分支-分支原理.md",key:"v-0fec5a68",path:"/pages/4bef1a/",headers:[{level:3,title:"首次提交",slug:"首次提交",normalizedTitle:"首次提交",charIndex:130},{level:4,title:"小结：",slug:"小结",normalizedTitle:"小结：",charIndex:678},{level:3,title:"再次提交",slug:"再次提交",normalizedTitle:"再次提交",charIndex:817},{level:3,title:"Git 的分支",slug:"git-的分支",normalizedTitle:"git 的分支",charIndex:890},{level:3,title:"创建分支",slug:"创建分支",normalizedTitle:"创建分支",charIndex:1082},{level:3,title:"当前分支的指针",slug:"当前分支的指针",normalizedTitle:"当前分支的指针",charIndex:1242},{level:3,title:"查看当前所在分支",slug:"查看当前所在分支",normalizedTitle:"查看当前所在分支",charIndex:1422},{level:3,title:"分支切换",slug:"分支切换",normalizedTitle:"分支切换",charIndex:1751},{level:3,title:"创建分支同时切换",slug:"创建分支同时切换",normalizedTitle:"创建分支同时切换",charIndex:3167}],headersStr:"首次提交 小结： 再次提交 Git 的分支 创建分支 当前分支的指针 查看当前所在分支 分支切换 创建分支同时切换",content:"# Git分支-分支原理\n\nGit 处理分支的方式可谓是难以置信的轻量，创建新分支这一操作几乎能在瞬间完成，并且在不同分支之间的切换操作也是一样便捷。 与许多其它版本控制系统不同，Git 鼓励在工作流程中频繁地使用分支与合并，哪怕一天之内进行许多次。\n\n\n# 首次提交\n\n在进行提交操作时，Git 会保存一个提交对象（commit object）。\n\n假设现在有一个工作目录，里面包含了三个将要被暂存和提交的文件。 暂存操作会为每一个文件计算校验和（使用 SHA-1 哈希算法），然后会把当前版本的文件快照保存到 Git 仓库中 （Git 使用 blob 对象来保存它们），最终将校验和加入到暂存区域等待提交：\n\n$ git add README test.rb LICENSE\n$ git commit -m 'The initial commit of my project'\n\n\n当使用 git commit 进行提交操作时，Git 会先计算每一个子目录（本例中只有项目根目录）的校验和， 然后在 Git 仓库中这些校验和保存为树对象。随后，Git 便会创建一个提交对象， 它除了包含上面提到的那些信息外，还包含指向这个树对象（项目根目录）的指针。 如此一来，Git 就可以在需要的时候重现此次保存的快照。\n\n现在，Git 仓库中有五个对象：三个 blob 对象（保存着文件快照）、一个 树对象 （记录着目录结构和 blob 对象索引）以及一个 提交对象（包含着指向前述树对象的指针和所有提交信息）。\n\n\n\n图1. 首次提交对象及其树结构 ▲\n\n# 小结：\n\n 1. git add 加入暂存操作，会为每个文件创建计算校验和，以及每个文件对应的文件快照（blob对象）。\n\n 2. git commit 提交操作，计算子目录或跟目录的校验和 保存为树对象。随后，创建一个提交对象，包含着指向树对象的指针和所有提交信息。\n\n\n# 再次提交\n\n做些修改后再次提交，那么这次产生的提交对象会包含一个指向上次提交对象（父对象）的指针。\n\n\n\n图2. 提交对象及其父对象 ▲\n\n\n# Git 的分支\n\nGit 的分支，其实本质上仅仅是指向提交对象的可变指针。 Git 的默认分支名字是 master。 在多次提交操作之后，你其实已经有一个指向最后那个提交对象的 master 分支。 master 分支指针会在每次提交时自动向前移动。\n\n> Git 的 master 分支并不是一个特殊分支。 它就跟其它分支完全没有区别。\n\n\n\n图3. 分支及其提交历史 ▲\n\n\n# 创建分支\n\nGit 是怎么创建新分支的呢？ 很简单，它只是为你创建了一个可以移动的新的指针。 比如，创建一个 testing 分支， 你需要使用 git branch 命令：\n\n$ git branch testing\n\n\n这会在当前所在的提交对象上创建一个指针。\n\n\n\n图4. 两个指向相同提交历史的分支 ▲\n\n\n# 当前分支的指针\n\nGit 是怎么知道当前在哪一个分支上呢？ 很简单，它有一个名为 HEAD 的特殊指针，指向当前所在的本地分支（译注：将 HEAD 想象为当前分支的别名）。 在本例中，你仍然在 master 分支上。 因为 git branch 命令仅仅 创建 一个新分支，并不会自动切换到新分支中去。\n\n\n\n图5. HEAD 指向当前所在的分支 ▲\n\n\n# 查看当前所在分支\n\n你可以简单地使用 git log 命令查看各个分支当前所指的对象。 提供这一功能的参数是 --decorate。\n\n$ git log --oneline --decorate\nf30ab (HEAD -> master, testing) add feature # f30ab提交对象 (HEAD当前所在分支 -> master分支，testing 分支)\n34ac2 Fixed bug # 34ac2 提交对象\n98ca9 The initial commit of my project # 98ca9 提交对象\n\n\n正如你所见，当前 master 和 testing 分支均指向校验和以 f30ab 开头的提交对象。\n\n\n# 分支切换\n\n$ git checkout testing  # git checkout <分支名>\n\n\n这样 HEAD 就指向 testing 分支了。\n\n\n\n图6. HEAD 指向当前所在的分支 ▲\n\n那么，这样的实现方式会给我们带来什么好处呢？ 现在不妨再提交一次：\n\n$ vim test.rb\n$ git commit -a -m 'made a change'\n\n\n\n\n图7. HEAD 分支随着提交操作自动向前移动 ▲\n\n如图所示，你的 testing 分支向前移动了，但是 master 分支却没有，它仍然指向运行 git checkout 时所指的对象。 这就有意思了，现在我们切换回 master 分支看看：\n\n$ git checkout master\n\n\n\n\n图8. 检出时 HEAD 随之移动 ▲\n\n这条命令做了两件事。 一是使 HEAD 指回 master 分支，二是将工作目录恢复成 master 分支所指向的快照内容。 也就是说，你现在做修改的话，项目将始于一个较旧的版本。 本质上来讲，这就是忽略 testing 分支所做的修改，以便于向另一个方向进行开发。\n\n我们不妨再稍微做些修改并提交：\n\n$ vim test.rb\n$ git commit -a -m 'made other changes'\n\n\n现在，这个项目的提交历史已经产生了分叉（参见 项目分叉历史）。 因为刚才你创建了一个新分支，并切换过去进行了一些工作，随后又切换回 master 分支进行了另外一些工作。 上述两次改动针对的是不同分支：你可以在不同分支间不断地来回切换和工作，并在时机成熟时将它们合并起来。 而所有这些工作，你需要的命令只有 branch、checkout 和 commit。\n\n\n\n图9. 项目分叉历史 ▲\n\n你可以简单地使用 git log 命令查看分叉历史。 运行 git log --oneline --decorate --graph --all ，它会输出你的提交历史、各个分支的指向以及项目的分支分叉情况。\n\n$ git log --oneline --decorate --graph --all\n* c2b9e (HEAD, master) made other changes\n| * 87ab2 (testing) made a change\n|/\n* f30ab add feature\n* 34ac2 fixed bug\n* 98ca9 initial commit of my project\n\n\n由于 Git 的分支实质上仅是包含所指对象校验和（长度为 40 的 SHA-1 值字符串）的文件，所以它的创建和销毁都异常高效。 创建一个新分支就相当于往一个文件中写入 41 个字节（40 个字符和 1 个换行符），如此的简单能不快吗？\n\n这与过去大多数版本控制系统形成了鲜明的对比，它们在创建分支时，将所有的项目文件都复制一遍，并保存到一个特定的目录。 完成这样繁琐的过程通常需要好几秒钟，有时甚至需要好几分钟。所需时间的长短，完全取决于项目的规模。 而在 Git 中，任何规模的项目都能在瞬间创建新分支。 同时，由于每次提交都会记录父对象，所以寻找恰当的合并基础（译注：即共同祖先）也是同样的简单和高效。 这些高效的特性使得 Git 鼓励开发人员频繁地创建和使用分支。\n\n\n# 创建分支同时切换\n\n通常我们会在创建一个新分支后立即切换过去，可以使用如下命令：\n\ngit checkout -b <newbranchname>\n",normalizedContent:"# git分支-分支原理\n\ngit 处理分支的方式可谓是难以置信的轻量，创建新分支这一操作几乎能在瞬间完成，并且在不同分支之间的切换操作也是一样便捷。 与许多其它版本控制系统不同，git 鼓励在工作流程中频繁地使用分支与合并，哪怕一天之内进行许多次。\n\n\n# 首次提交\n\n在进行提交操作时，git 会保存一个提交对象（commit object）。\n\n假设现在有一个工作目录，里面包含了三个将要被暂存和提交的文件。 暂存操作会为每一个文件计算校验和（使用 sha-1 哈希算法），然后会把当前版本的文件快照保存到 git 仓库中 （git 使用 blob 对象来保存它们），最终将校验和加入到暂存区域等待提交：\n\n$ git add readme test.rb license\n$ git commit -m 'the initial commit of my project'\n\n\n当使用 git commit 进行提交操作时，git 会先计算每一个子目录（本例中只有项目根目录）的校验和， 然后在 git 仓库中这些校验和保存为树对象。随后，git 便会创建一个提交对象， 它除了包含上面提到的那些信息外，还包含指向这个树对象（项目根目录）的指针。 如此一来，git 就可以在需要的时候重现此次保存的快照。\n\n现在，git 仓库中有五个对象：三个 blob 对象（保存着文件快照）、一个 树对象 （记录着目录结构和 blob 对象索引）以及一个 提交对象（包含着指向前述树对象的指针和所有提交信息）。\n\n\n\n图1. 首次提交对象及其树结构 ▲\n\n# 小结：\n\n 1. git add 加入暂存操作，会为每个文件创建计算校验和，以及每个文件对应的文件快照（blob对象）。\n\n 2. git commit 提交操作，计算子目录或跟目录的校验和 保存为树对象。随后，创建一个提交对象，包含着指向树对象的指针和所有提交信息。\n\n\n# 再次提交\n\n做些修改后再次提交，那么这次产生的提交对象会包含一个指向上次提交对象（父对象）的指针。\n\n\n\n图2. 提交对象及其父对象 ▲\n\n\n# git 的分支\n\ngit 的分支，其实本质上仅仅是指向提交对象的可变指针。 git 的默认分支名字是 master。 在多次提交操作之后，你其实已经有一个指向最后那个提交对象的 master 分支。 master 分支指针会在每次提交时自动向前移动。\n\n> git 的 master 分支并不是一个特殊分支。 它就跟其它分支完全没有区别。\n\n\n\n图3. 分支及其提交历史 ▲\n\n\n# 创建分支\n\ngit 是怎么创建新分支的呢？ 很简单，它只是为你创建了一个可以移动的新的指针。 比如，创建一个 testing 分支， 你需要使用 git branch 命令：\n\n$ git branch testing\n\n\n这会在当前所在的提交对象上创建一个指针。\n\n\n\n图4. 两个指向相同提交历史的分支 ▲\n\n\n# 当前分支的指针\n\ngit 是怎么知道当前在哪一个分支上呢？ 很简单，它有一个名为 head 的特殊指针，指向当前所在的本地分支（译注：将 head 想象为当前分支的别名）。 在本例中，你仍然在 master 分支上。 因为 git branch 命令仅仅 创建 一个新分支，并不会自动切换到新分支中去。\n\n\n\n图5. head 指向当前所在的分支 ▲\n\n\n# 查看当前所在分支\n\n你可以简单地使用 git log 命令查看各个分支当前所指的对象。 提供这一功能的参数是 --decorate。\n\n$ git log --oneline --decorate\nf30ab (head -> master, testing) add feature # f30ab提交对象 (head当前所在分支 -> master分支，testing 分支)\n34ac2 fixed bug # 34ac2 提交对象\n98ca9 the initial commit of my project # 98ca9 提交对象\n\n\n正如你所见，当前 master 和 testing 分支均指向校验和以 f30ab 开头的提交对象。\n\n\n# 分支切换\n\n$ git checkout testing  # git checkout <分支名>\n\n\n这样 head 就指向 testing 分支了。\n\n\n\n图6. head 指向当前所在的分支 ▲\n\n那么，这样的实现方式会给我们带来什么好处呢？ 现在不妨再提交一次：\n\n$ vim test.rb\n$ git commit -a -m 'made a change'\n\n\n\n\n图7. head 分支随着提交操作自动向前移动 ▲\n\n如图所示，你的 testing 分支向前移动了，但是 master 分支却没有，它仍然指向运行 git checkout 时所指的对象。 这就有意思了，现在我们切换回 master 分支看看：\n\n$ git checkout master\n\n\n\n\n图8. 检出时 head 随之移动 ▲\n\n这条命令做了两件事。 一是使 head 指回 master 分支，二是将工作目录恢复成 master 分支所指向的快照内容。 也就是说，你现在做修改的话，项目将始于一个较旧的版本。 本质上来讲，这就是忽略 testing 分支所做的修改，以便于向另一个方向进行开发。\n\n我们不妨再稍微做些修改并提交：\n\n$ vim test.rb\n$ git commit -a -m 'made other changes'\n\n\n现在，这个项目的提交历史已经产生了分叉（参见 项目分叉历史）。 因为刚才你创建了一个新分支，并切换过去进行了一些工作，随后又切换回 master 分支进行了另外一些工作。 上述两次改动针对的是不同分支：你可以在不同分支间不断地来回切换和工作，并在时机成熟时将它们合并起来。 而所有这些工作，你需要的命令只有 branch、checkout 和 commit。\n\n\n\n图9. 项目分叉历史 ▲\n\n你可以简单地使用 git log 命令查看分叉历史。 运行 git log --oneline --decorate --graph --all ，它会输出你的提交历史、各个分支的指向以及项目的分支分叉情况。\n\n$ git log --oneline --decorate --graph --all\n* c2b9e (head, master) made other changes\n| * 87ab2 (testing) made a change\n|/\n* f30ab add feature\n* 34ac2 fixed bug\n* 98ca9 initial commit of my project\n\n\n由于 git 的分支实质上仅是包含所指对象校验和（长度为 40 的 sha-1 值字符串）的文件，所以它的创建和销毁都异常高效。 创建一个新分支就相当于往一个文件中写入 41 个字节（40 个字符和 1 个换行符），如此的简单能不快吗？\n\n这与过去大多数版本控制系统形成了鲜明的对比，它们在创建分支时，将所有的项目文件都复制一遍，并保存到一个特定的目录。 完成这样繁琐的过程通常需要好几秒钟，有时甚至需要好几分钟。所需时间的长短，完全取决于项目的规模。 而在 git 中，任何规模的项目都能在瞬间创建新分支。 同时，由于每次提交都会记录父对象，所以寻找恰当的合并基础（译注：即共同祖先）也是同样的简单和高效。 这些高效的特性使得 git 鼓励开发人员频繁地创建和使用分支。\n\n\n# 创建分支同时切换\n\n通常我们会在创建一个新分支后立即切换过去，可以使用如下命令：\n\ngit checkout -b <newbranchname>\n",charsets:{cjk:!0},lastUpdated:"2023/11/19, 12:55:48",lastUpdatedTimestamp:1700369748e3},{title:"Git分支管理-查看分支",frontmatter:{title:"Git分支管理-查看分支",date:"2020-11-18T17:43:57.000Z",permalink:"/pages/a399b3/",categories:["《Git》学习笔记"],tags:["Git"],author:{name:"王清欢",link:"https://github.com/wang-haihua"}},regularPath:"/05.Git%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/30.Git%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%AC%94%E8%AE%B0/40.Git%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86-%E6%9F%A5%E7%9C%8B%E5%88%86%E6%94%AF.html",relativePath:"05.Git 学习笔记/30.Git 官方文档笔记/40.Git分支管理-查看分支.md",key:"v-4a5cc4cc",path:"/pages/a399b3/",headers:[{level:3,title:"查看分支",slug:"查看分支",normalizedTitle:"查看分支",charIndex:10},{level:3,title:"查看每个分支的最后提交",slug:"查看每个分支的最后提交",normalizedTitle:"查看每个分支的最后提交",charIndex:142},{level:3,title:"查看已(未)合并的分支",slug:"查看已-未-合并的分支",normalizedTitle:"查看已(未)合并的分支",charIndex:277},{level:4,title:"查看指定分支的已(未)合并的分支",slug:"查看指定分支的已-未-合并的分支",normalizedTitle:"查看指定分支的已(未)合并的分支",charIndex:719}],headersStr:"查看分支 查看每个分支的最后提交 查看已(未)合并的分支 查看指定分支的已(未)合并的分支",content:"# Git分支管理-查看分支\n\n\n# 查看分支\n\n$ git branch\n  iss53\n* master  # 带星号*表示当前所在分支\n  testing\n\n\ngit branch 命令不只是可以创建与删除分支。 如果不加任何参数运行它，会得到当前所有分支的一个列表。\n\n\n# 查看每个分支的最后提交\n\n$ git branch -v\n  iss53   93b412c fix javascript issue\n* master  7a98805 Merge branch 'iss53'\n  testing 782fd34 test\n\n\n\n# 查看已(未)合并的分支\n\n--merged 与 --no-merged 这两个选项可以查看哪些分支已经合并或未合并到 当前 分支。\n\n$ git branch --merged # 查看已合并分支列表\n  iss53\n* master\n\n\n上面列表中分支名字前没有 * 号的分支通常可以使用 git branch -d 删除掉；\n\n$ git branch --no-merged # 查看未合并的分支列表\n  testing\n\n\n上面显示未合并的分支，尝试使用 git branch -d 命令删除它时会失败：\n\n$ git branch -d testing\nerror: The branch 'testing' is not fully merged.\nIf you are sure you want to delete it, run 'git branch -D testing'.\n\n\n强制删除未合并的分支:\n\n$ git branch -D testing\n\n\n# 查看指定分支的已(未)合并的分支\n\n上面描述的选项 --merged 和 --no-merged 会在没有给定提交或分支名作为参数时， 分别列出已合并或未合并到 当前 分支的分支。\n\n你总是可以提供一个附加的参数来查看其它分支的合并状态而不必检出它们。 例如，尚未合并到 testing 分支的有哪些？\n\n$ git branch --no-merged testing\n  topicA\n  featureB\n",normalizedContent:"# git分支管理-查看分支\n\n\n# 查看分支\n\n$ git branch\n  iss53\n* master  # 带星号*表示当前所在分支\n  testing\n\n\ngit branch 命令不只是可以创建与删除分支。 如果不加任何参数运行它，会得到当前所有分支的一个列表。\n\n\n# 查看每个分支的最后提交\n\n$ git branch -v\n  iss53   93b412c fix javascript issue\n* master  7a98805 merge branch 'iss53'\n  testing 782fd34 test\n\n\n\n# 查看已(未)合并的分支\n\n--merged 与 --no-merged 这两个选项可以查看哪些分支已经合并或未合并到 当前 分支。\n\n$ git branch --merged # 查看已合并分支列表\n  iss53\n* master\n\n\n上面列表中分支名字前没有 * 号的分支通常可以使用 git branch -d 删除掉；\n\n$ git branch --no-merged # 查看未合并的分支列表\n  testing\n\n\n上面显示未合并的分支，尝试使用 git branch -d 命令删除它时会失败：\n\n$ git branch -d testing\nerror: the branch 'testing' is not fully merged.\nif you are sure you want to delete it, run 'git branch -d testing'.\n\n\n强制删除未合并的分支:\n\n$ git branch -d testing\n\n\n# 查看指定分支的已(未)合并的分支\n\n上面描述的选项 --merged 和 --no-merged 会在没有给定提交或分支名作为参数时， 分别列出已合并或未合并到 当前 分支的分支。\n\n你总是可以提供一个附加的参数来查看其它分支的合并状态而不必检出它们。 例如，尚未合并到 testing 分支的有哪些？\n\n$ git branch --no-merged testing\n  topica\n  featureb\n",charsets:{cjk:!0},lastUpdated:"2023/11/19, 12:55:48",lastUpdatedTimestamp:1700369748e3},{title:"Git分支的新建与合并-分支操作",frontmatter:{title:"Git分支的新建与合并-分支操作",date:"2020-11-18T17:43:57.000Z",permalink:"/pages/ea5a8c/",categories:["《Git》学习笔记"],tags:["Git"],author:{name:"王清欢",link:"https://github.com/wang-haihua"}},regularPath:"/05.Git%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/30.Git%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%AC%94%E8%AE%B0/30.Git%E5%88%86%E6%94%AF%E7%9A%84%E6%96%B0%E5%BB%BA%E4%B8%8E%E5%90%88%E5%B9%B6-%E5%88%86%E6%94%AF%E6%93%8D%E4%BD%9C.html",relativePath:"05.Git 学习笔记/30.Git 官方文档笔记/30.Git分支的新建与合并-分支操作.md",key:"v-d6569084",path:"/pages/ea5a8c/",headers:[{level:3,title:"创建分支并切换",slug:"创建分支并切换",normalizedTitle:"创建分支并切换",charIndex:45},{level:3,title:"切换分支",slug:"切换分支",normalizedTitle:"切换分支",charIndex:177},{level:3,title:"合并分支",slug:"合并分支",normalizedTitle:"合并分支",charIndex:547},{level:3,title:"删除分支",slug:"删除分支",normalizedTitle:"删除分支",charIndex:632},{level:3,title:"多次提交之后合并分支",slug:"多次提交之后合并分支",normalizedTitle:"多次提交之后合并分支",charIndex:737},{level:3,title:"遇到冲突时的分支合并",slug:"遇到冲突时的分支合并",normalizedTitle:"遇到冲突时的分支合并",charIndex:1073}],headersStr:"创建分支并切换 切换分支 合并分支 删除分支 多次提交之后合并分支 遇到冲突时的分支合并",content:"# Git分支的新建与合并-分支操作\n\n文档：Git 分支 - 分支的新建与合并\n\n\n# 创建分支并切换\n\n此时有一个需求需要在新的分支iss53上工作：\n\n$ git checkout -b iss53  # b表示branch\n\n\n它是下面两条命令的简写：\n\n$ git branch iss53\n$ git checkout iss53\n\n\n\n# 切换分支\n\n突然有一个紧急问题要解决，需要在原来的master分支进行修复：\n\n$ git checkout master\n\n\n在切换到master之前，需要iss53分支保持好一个干净的状态（修改都已提交）。\n\n注意：切换分支Git 会重置你的工作目录。\n\n> checkout 中文含义 “检出”，checkout <branch> 检出分支 => 检出指定分支的代码 => 重置工作目录并切换分支。\n\n接下来，你要修复这个紧急问题。 建立一个 hotfix 分支，在该分支上工作直到问题解决：\n\n$ git checkout -b hotfix\n\n# 中间过程在hotfix上修改了代码并提交\n$ echo 'test' > ./hotfix.txt\n$ git add .\n$ git commit -m 'fixed'\n\n\n\n# 合并分支\n\n$ git checkout master # 首先切回master分支\n$ git merge hotfix # 把 hotfix 分支合并过来\n\n\n\n# 删除分支\n\n$ git branch -d hotfix # d表示delete\n\n# 然后切回iss53继续工作\n$ git checkout iss53\n\n\n注意删除分支是在 branch 命令上\n\n\n# 多次提交之后合并分支\n\n假设你已经修正了 #53 问题，打算合并到master分支：\n\n$ git checkout master\n$ git merga iss53\n\n\n这看似和之前的合并区别不大。此时你的开发历史从一个更早的地方开始分叉开来（diverged）。 因为，master 分支所在提交并不是 iss53 分支所在提交的直接祖先，Git 不得不做一些额外的工作。 出现这种情况的时候，Git 会使用两个分支的末端所指的快照以及这两个分支的公共祖先，做一个简单的三方合并。\n\n和之前将分支指针向前推进所不同的是，Git 将此次三方合并的结果做了一个新的快照并且自动创建一个新的提交指向它。 这个被称作一次合并提交，它的特别之处在于他有不止一个父提交。\n\n\n# 遇到冲突时的分支合并\n\n如果你在两个不同的分支中，对同一个文件的同一个部分进行了不同的修改，Git 就没法干净的合并它们，就产生了冲突。\n\n合并过程中出现CONFLICT提升，表示有冲突\n\n$ git merge iss53\nAuto-merging index.html\nCONFLICT (content): Merge conflict in index.html\nAutomatic merge failed; fix conflicts and then commit the result.\n\n\n使用git status查看未合并状态。\n\n任何因包含合并冲突而有待解决的文件，都会以未合并状态标识出来。 Git 会在有冲突的文件中加入标准的冲突解决标记，这样你可以打开这些包含冲突的文件然后手动解决冲突。 出现冲突的文件会包含一些特殊区段，看起来像下面这个样子：\n\n<<<<<<< HEAD:index.html\n<div id=\"footer\">contact : email.support@github.com</div>\n=======\n<div id=\"footer\">\n please contact us at support@github.com\n</div>\n>>>>>>> iss53:index.html\n\n\n你需要手动解决冲突，解决了所有文件里的冲突之后，对每个文件使用 git add 命令来将其标记为冲突已解决。 一旦暂存这些原本有冲突的文件，Git 就会将它们标记为冲突已解决。\n\n如果你对结果感到满意，并且确定之前有冲突的的文件都已经暂存了，这时你可以输入 git commit 来完成合并提交。",normalizedContent:"# git分支的新建与合并-分支操作\n\n文档：git 分支 - 分支的新建与合并\n\n\n# 创建分支并切换\n\n此时有一个需求需要在新的分支iss53上工作：\n\n$ git checkout -b iss53  # b表示branch\n\n\n它是下面两条命令的简写：\n\n$ git branch iss53\n$ git checkout iss53\n\n\n\n# 切换分支\n\n突然有一个紧急问题要解决，需要在原来的master分支进行修复：\n\n$ git checkout master\n\n\n在切换到master之前，需要iss53分支保持好一个干净的状态（修改都已提交）。\n\n注意：切换分支git 会重置你的工作目录。\n\n> checkout 中文含义 “检出”，checkout <branch> 检出分支 => 检出指定分支的代码 => 重置工作目录并切换分支。\n\n接下来，你要修复这个紧急问题。 建立一个 hotfix 分支，在该分支上工作直到问题解决：\n\n$ git checkout -b hotfix\n\n# 中间过程在hotfix上修改了代码并提交\n$ echo 'test' > ./hotfix.txt\n$ git add .\n$ git commit -m 'fixed'\n\n\n\n# 合并分支\n\n$ git checkout master # 首先切回master分支\n$ git merge hotfix # 把 hotfix 分支合并过来\n\n\n\n# 删除分支\n\n$ git branch -d hotfix # d表示delete\n\n# 然后切回iss53继续工作\n$ git checkout iss53\n\n\n注意删除分支是在 branch 命令上\n\n\n# 多次提交之后合并分支\n\n假设你已经修正了 #53 问题，打算合并到master分支：\n\n$ git checkout master\n$ git merga iss53\n\n\n这看似和之前的合并区别不大。此时你的开发历史从一个更早的地方开始分叉开来（diverged）。 因为，master 分支所在提交并不是 iss53 分支所在提交的直接祖先，git 不得不做一些额外的工作。 出现这种情况的时候，git 会使用两个分支的末端所指的快照以及这两个分支的公共祖先，做一个简单的三方合并。\n\n和之前将分支指针向前推进所不同的是，git 将此次三方合并的结果做了一个新的快照并且自动创建一个新的提交指向它。 这个被称作一次合并提交，它的特别之处在于他有不止一个父提交。\n\n\n# 遇到冲突时的分支合并\n\n如果你在两个不同的分支中，对同一个文件的同一个部分进行了不同的修改，git 就没法干净的合并它们，就产生了冲突。\n\n合并过程中出现conflict提升，表示有冲突\n\n$ git merge iss53\nauto-merging index.html\nconflict (content): merge conflict in index.html\nautomatic merge failed; fix conflicts and then commit the result.\n\n\n使用git status查看未合并状态。\n\n任何因包含合并冲突而有待解决的文件，都会以未合并状态标识出来。 git 会在有冲突的文件中加入标准的冲突解决标记，这样你可以打开这些包含冲突的文件然后手动解决冲突。 出现冲突的文件会包含一些特殊区段，看起来像下面这个样子：\n\n<<<<<<< head:index.html\n<div id=\"footer\">contact : email.support@github.com</div>\n=======\n<div id=\"footer\">\n please contact us at support@github.com\n</div>\n>>>>>>> iss53:index.html\n\n\n你需要手动解决冲突，解决了所有文件里的冲突之后，对每个文件使用 git add 命令来将其标记为冲突已解决。 一旦暂存这些原本有冲突的文件，git 就会将它们标记为冲突已解决。\n\n如果你对结果感到满意，并且确定之前有冲突的的文件都已经暂存了，这时你可以输入 git commit 来完成合并提交。",charsets:{cjk:!0},lastUpdated:"2023/11/19, 12:55:48",lastUpdatedTimestamp:1700369748e3},{title:"Git分支开发工作流",frontmatter:{title:"Git分支开发工作流",date:"2020-11-18T17:43:57.000Z",permalink:"/pages/49ee30/",categories:["《Git》学习笔记"],tags:["Git"],author:{name:"王清欢",link:"https://github.com/wang-haihua"}},regularPath:"/05.Git%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/30.Git%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%AC%94%E8%AE%B0/50.Git%E5%88%86%E6%94%AF%E5%BC%80%E5%8F%91%E5%B7%A5%E4%BD%9C%E6%B5%81.html",relativePath:"05.Git 学习笔记/30.Git 官方文档笔记/50.Git分支开发工作流.md",key:"v-d5f84b34",path:"/pages/49ee30/",headers:[{level:3,title:"长期分支",slug:"长期分支",normalizedTitle:"长期分支",charIndex:32},{level:3,title:"主题分支 (短期分支)",slug:"主题分支-短期分支",normalizedTitle:"主题分支 (短期分支)",charIndex:625}],headersStr:"长期分支 主题分支 (短期分支)",content:"# Git分支开发工作流\n\n文档：Git分支开发工作流\n\n\n# 长期分支\n\n因为 Git 使用简单的三方合并，所以就算在一段较长的时间内，反复把一个分支合并入另一个分支，也不是什么难事。 也就是说，在整个项目开发周期的不同阶段，你可以同时拥有多个开放的分支；你可以定期地把某些主题分支合并入其他分支中。\n\n许多使用 Git 的开发者都喜欢使用这种方式来工作，比如只在 master 分支上保留完全稳定的代码，开发过程在dev分支，开发完成后并入test分支进行测试，通过测试的稳定代码才并入master分支中。\n\ndev和test分支不需要保持绝对稳定，但在test通过测试达到稳定状态，就可以被合并入master分支。\n\n事实上我们刚才讨论的，是随着你的提交而不断右移的指针。 稳定分支(master)的指针总是在提交历史中落后一大截，而前沿分支(dev或test)的指针往往比较靠前。\n\n你可以用这种方法维护不同层次的稳定性。 一些大型项目还有一个 proposed（建议） 或 pu: proposed updates（建议更新）分支，它可能因包含一些不成熟的内容而不能进入master 分支。 这么做的目的是使你的分支具有不同级别的稳定性；当它们具有一定程度的稳定性后，再把它们合并入具有更高级别稳定性的分支中。 再次强调一下，使用多个长期分支的方法并非必要，但是这么做通常很有帮助，尤其是当你在一个非常庞大或者复杂的项目中工作时。\n\n\n# 主题分支 (短期分支)\n\n主题分支对任何规模的项目都适用。 主题分支是一种短期分支，它被用来实现单一特性或其相关工作。\n\n你已经在上一节中你创建的 iss53 和 hotfix 主题分支中看到过这种用法。 你在上一节用到的主题分支（iss53 和 hotfix 分支）中提交了一些更新，并且在它们合并入主干分支之后，你又删除了它们。 这项技术能使你快速并且完整地进行上下文切换（context-switch）——因为你的工作被分散到不同的流水线中，在不同的流水线中每个分支都仅与其目标特性相关，因此，在做代码审查之类的工作的时候就能更加容易地看出你做了哪些改动。 你可以把做出的改动在主题分支中保留几分钟、几天甚至几个月，等它们成熟之后再合并，而不用在乎它们建立的顺序或工作进度。\n\n考虑这样一个例子，你在 master 分支上工作到 C1，这时为了解决一个问题而新建 iss91 分支，在 iss91 分支上工作到 C4，然而对于那个问题你又有了新的想法，于是你再新建一个 iss91v2 分支试图用另一种方法解决那个问题，接着你回到 master 分支工作了一会儿，你又冒出了一个不太确定的想法，你便在 C10 的时候新建一个 dumbidea 分支，并在上面做些实验。 你的提交历史看起来像下面这个样子：\n\n\n\n图1. 拥有多个主题分支的提交历史 ▲\n\n现在，我们假设两件事情：你决定使用第二个方案来解决那个问题，即使用在 iss91v2 分支中方案。 另外，你将 dumbidea 分支拿给你的同事看过之后，结果发现这是个惊人之举。 这时你可以抛弃 iss91 分支（即丢弃 C5 和 C6 提交），然后把另外两个分支合并入主干分支。 最终你的提交历史看起来像下面这个样子：\n\n\n\n图2. 合并了 dumbidea 和 iss91v2 分支之后的提交历史 ▲\n\n我们将会在 分布式 Git 中向你揭示更多有关分支工作流的细节， 因此，请确保你阅读完那个章节之后，再来决定你的下个项目要使用什么样的分支策略（branching scheme）。\n\n请牢记，当你做这么多操作的时候，这些分支全部都存于本地。 当你新建和合并分支的时候，所有这一切都只发生在你本地的 Git 版本库中 —— 没有与服务器发生交互。",normalizedContent:"# git分支开发工作流\n\n文档：git分支开发工作流\n\n\n# 长期分支\n\n因为 git 使用简单的三方合并，所以就算在一段较长的时间内，反复把一个分支合并入另一个分支，也不是什么难事。 也就是说，在整个项目开发周期的不同阶段，你可以同时拥有多个开放的分支；你可以定期地把某些主题分支合并入其他分支中。\n\n许多使用 git 的开发者都喜欢使用这种方式来工作，比如只在 master 分支上保留完全稳定的代码，开发过程在dev分支，开发完成后并入test分支进行测试，通过测试的稳定代码才并入master分支中。\n\ndev和test分支不需要保持绝对稳定，但在test通过测试达到稳定状态，就可以被合并入master分支。\n\n事实上我们刚才讨论的，是随着你的提交而不断右移的指针。 稳定分支(master)的指针总是在提交历史中落后一大截，而前沿分支(dev或test)的指针往往比较靠前。\n\n你可以用这种方法维护不同层次的稳定性。 一些大型项目还有一个 proposed（建议） 或 pu: proposed updates（建议更新）分支，它可能因包含一些不成熟的内容而不能进入master 分支。 这么做的目的是使你的分支具有不同级别的稳定性；当它们具有一定程度的稳定性后，再把它们合并入具有更高级别稳定性的分支中。 再次强调一下，使用多个长期分支的方法并非必要，但是这么做通常很有帮助，尤其是当你在一个非常庞大或者复杂的项目中工作时。\n\n\n# 主题分支 (短期分支)\n\n主题分支对任何规模的项目都适用。 主题分支是一种短期分支，它被用来实现单一特性或其相关工作。\n\n你已经在上一节中你创建的 iss53 和 hotfix 主题分支中看到过这种用法。 你在上一节用到的主题分支（iss53 和 hotfix 分支）中提交了一些更新，并且在它们合并入主干分支之后，你又删除了它们。 这项技术能使你快速并且完整地进行上下文切换（context-switch）——因为你的工作被分散到不同的流水线中，在不同的流水线中每个分支都仅与其目标特性相关，因此，在做代码审查之类的工作的时候就能更加容易地看出你做了哪些改动。 你可以把做出的改动在主题分支中保留几分钟、几天甚至几个月，等它们成熟之后再合并，而不用在乎它们建立的顺序或工作进度。\n\n考虑这样一个例子，你在 master 分支上工作到 c1，这时为了解决一个问题而新建 iss91 分支，在 iss91 分支上工作到 c4，然而对于那个问题你又有了新的想法，于是你再新建一个 iss91v2 分支试图用另一种方法解决那个问题，接着你回到 master 分支工作了一会儿，你又冒出了一个不太确定的想法，你便在 c10 的时候新建一个 dumbidea 分支，并在上面做些实验。 你的提交历史看起来像下面这个样子：\n\n\n\n图1. 拥有多个主题分支的提交历史 ▲\n\n现在，我们假设两件事情：你决定使用第二个方案来解决那个问题，即使用在 iss91v2 分支中方案。 另外，你将 dumbidea 分支拿给你的同事看过之后，结果发现这是个惊人之举。 这时你可以抛弃 iss91 分支（即丢弃 c5 和 c6 提交），然后把另外两个分支合并入主干分支。 最终你的提交历史看起来像下面这个样子：\n\n\n\n图2. 合并了 dumbidea 和 iss91v2 分支之后的提交历史 ▲\n\n我们将会在 分布式 git 中向你揭示更多有关分支工作流的细节， 因此，请确保你阅读完那个章节之后，再来决定你的下个项目要使用什么样的分支策略（branching scheme）。\n\n请牢记，当你做这么多操作的时候，这些分支全部都存于本地。 当你新建和合并分支的时候，所有这一切都只发生在你本地的 git 版本库中 —— 没有与服务器发生交互。",charsets:{cjk:!0},lastUpdated:"2023/11/19, 12:55:48",lastUpdatedTimestamp:1700369748e3},{title:"Git分支-远程分支",frontmatter:{title:"Git分支-远程分支",date:"2020-11-18T17:43:57.000Z",permalink:"/pages/574d62/",categories:["《Git》学习笔记"],tags:["Git"],author:{name:"王清欢",link:"https://github.com/wang-haihua"}},regularPath:"/05.Git%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/30.Git%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%AC%94%E8%AE%B0/60.Git%E5%88%86%E6%94%AF-%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF.html",relativePath:"05.Git 学习笔记/30.Git 官方文档笔记/60.Git分支-远程分支.md",key:"v-7eca6e6d",path:"/pages/574d62/",headers:[{level:3,title:"查看远程引用列表与信息",slug:"查看远程引用列表与信息",normalizedTitle:"查看远程引用列表与信息",charIndex:71},{level:3,title:"远程跟踪分支",slug:"远程跟踪分支",normalizedTitle:"远程跟踪分支",charIndex:178},{level:3,title:"推送",slug:"推送",normalizedTitle:"推送",charIndex:426},{level:4,title:"重命名远程仓库上的分支名",slug:"重命名远程仓库上的分支名",normalizedTitle:"重命名远程仓库上的分支名",charIndex:2699},{level:3,title:"跟踪分支",slug:"跟踪分支",normalizedTitle:"跟踪分支",charIndex:180},{level:3,title:"查看跟踪分支",slug:"查看跟踪分支",normalizedTitle:"查看跟踪分支",charIndex:5185},{level:3,title:"拉取",slug:"拉取",normalizedTitle:"拉取",charIndex:599},{level:3,title:"删除远程分支",slug:"删除远程分支",normalizedTitle:"删除远程分支",charIndex:6267}],headersStr:"查看远程引用列表与信息 远程跟踪分支 推送 重命名远程仓库上的分支名 跟踪分支 查看跟踪分支 拉取 删除远程分支",content:"# Git分支-远程分支\n\n远程引用是对远程仓库的引用（指针），包括分支、标签等等。\n\n> 远程分支本质上也是一个指针，指向远程地址\n\n\n# 查看远程引用列表与信息\n\ngit ls-remote <remote> # 远程引用的完整列表\ngit remote show <remote> # 远程分支的更多信息\n\n\n上面两行命令比较少用，更常见的做法是利用远程跟踪分支。\n\n\n# 远程跟踪分支\n\n远程跟踪分支是远程分支状态的引用。它们是你无法移动的本地引用。一旦你进行了网络通信， Git 就会为你移动它们以精确反映远程仓库的状态。请将它们看做书签， 这样可以提醒你该分支在远程仓库中的位置就是你最后一次连接到它们的位置。\n\n它们以 <remote>/<branch> 的形式命名。 例如，如果你想要查看最后一次与远程仓库 origin 通信时 master 分支的状态，你可以查看 origin/master 分支。 你与同事合作解决一个问题并且他们推送了一个 iss53 分支，你可能有自己的本地 iss53 分支， 然而在服务器上的分支会以 origin/iss53 来表示。\n\n这可能有一点儿难以理解，让我们来看一个例子。 假设你的网络里有一个在 git.ourcompany.com 的 Git 服务器。 如果你从这里克隆，Git 的 clone 命令会为你自动将其命名为 origin，拉取它的所有数据， 创建一个指向它的 master 分支的指针，并且在本地将其命名为 origin/master。 Git 也会给你一个与 origin 的 master 分支在指向同一个地方的本地 master 分支，这样你就有工作的基础。\n\n笔记：从远程克隆下来的仓库有一个叫origin/master的远程跟踪分支 和 一个本地的master分支\n\n> 笔记：“origin” 并无特殊含义远程仓库名字 “origin” 与分支名字 “master” 一样，在 Git 中并没有任何特别的含义一样。 同时 “master” 是当你运行 git init 时默认的起始分支名字，原因仅仅是它的广泛使用， “origin” 是当你运行 git clone 时默认的远程仓库名字。 如果你运行 git clone -o booyah，那么你默认的远程分支名字将会是 booyah/master。\n\n\n\n图1. 克隆之后的服务器与本地仓库 ▲\n\n如果你在本地的 master 分支做了一些工作，在同一段时间内有其他人推送提交到 git.ourcompany.com 并且更新了它的 master 分支，这就是说你们的提交历史已走向不同的方向。 即便这样，只要你保持不与 origin 服务器连接（并拉取数据），你的 origin/master 指针就不会移动。\n\n\n\n图2. 本地与远程的工作可以分叉 ▲\n\n如果要与给定的远程仓库同步数据，运行 git fetch <remote> 命令（在本例中为 git fetch origin）。 这个命令查找 “origin” 是哪一个服务器（在本例中，它是 git.ourcompany.com）， 从中抓取本地没有的数据，并且更新本地数据库，移动 origin/master 指针到更新之后的位置。\n\n\n\n图3. git fetch 更新你的远程跟踪分支 ▲\n\n笔记: 本地的 master 分支 可能 和 远程跟踪分支 origin/master 分叉\n\n为了演示有多个远程仓库与远程分支的情况，我们假定你有另一个内部 Git 服务器，仅服务于你的某个敏捷开发团队。 这个服务器位于 git.team1.ourcompany.com。 你可以运行 git remote add 命令添加一个新的远程仓库引用到当前的项目，这个命令我们会在 Git 基础 中详细说明。 将这个远程仓库命名为 teamone，将其作为完整 URL 的缩写。远程仓库名本质上是远程URL的缩写\n\n\n\n图4. 添加另一个远程仓库 ▲\n\n现在，可以运行 git fetch teamone 来抓取远程仓库 teamone 有而本地没有的数据。 因为那台服务器上现有的数据是 origin 服务器上的一个子集， 所以 Git 并不会抓取数据而是会设置远程跟踪分支 teamone/master 指向 teamone 的 master 分支。\n\n\n\n图5. 远程跟踪分支 teamone/master ▲\n\n\n# 推送\n\n当你想要公开分享一个分支时，需要将其推送到有写入权限的远程仓库上。 本地的分支并不会自动与远程仓库同步——你必须显式地推送想要分享的分支。 这样，你就可以把不愿意分享的内容放到私人分支上，而将需要和别人协作的内容推送到公开分支。\n\n如果希望和别人一起在名为 serverfix 的分支上工作，你可以像推送第一个分支那样推送它。 运行 git push <remote> <branch>:\n\n$ git push origin serverfix\nCounting objects: 24, done.\nDelta compression using up to 8 threads.\nCompressing objects: 100% (15/15), done.\nWriting objects: 100% (24/24), 1.91 KiB | 0 bytes/s, done.\nTotal 24 (delta 2), reused 0 (delta 0)\nTo https://github.com/schacon/simplegit\n * [new branch]      serverfix -> serverfix\n\n\n这里有些工作被简化了。 Git 自动将 serverfix 分支名字展开为 refs/heads/serverfix:refs/heads/serverfix， 那意味着，“推送本地的 serverfix 分支来更新远程仓库上的 serverfix 分支。” 我们将会详细学习 Git 内部原理 的 refs/heads/ 部分， 但是现在可以先把它放在儿。你也可以运行 git push origin serverfix:serverfix， 它会做同样的事——也就是说“推送本地的 serverfix 分支，将其作为远程仓库的 serverfix 分支” 可以通过这种格式来推送本地分支到一个命名不相同的远程分支。\n\n# 重命名远程仓库上的分支名\n\n如果并不想让远程仓库上的分支叫做 serverfix，可以运行 git push origin serverfix:awesomebranch 来将本地的 serverfix 分支推送到远程仓库上的 awesomebranch 分支。\n\nNOTE   如何避免每次输入密码如果你正在使用 HTTPS URL 来推送，GIT 服务器会询问用户名与密码。\n       默认情况下它会在终端中提示服务器是否允许你进行推送。如果不想在每一次推送时都输入用户名与密码，你可以设置一个\n       “CREDENTIAL CACHE”。 最简单的方式就是将其保存在内存中几分钟，可以简单地运行 GIT CONFIG\n       --GLOBAL CREDENTIAL.HELPER CACHE 来设置它。想要了解更多关于不同验证缓存的可用选项，查看\n       凭证存储。\n       \n\n下一次其他协作者从服务器上抓取数据时，他们会在本地生成一个远程分支 origin/serverfix，指向服务器的 serverfix 分支的引用：\n\n$ git fetch origin\nremote: Counting objects: 7, done.\nremote: Compressing objects: 100% (2/2), done.\nremote: Total 3 (delta 0), reused 3 (delta 0)\nUnpacking objects: 100% (3/3), done.\nFrom https://github.com/schacon/simplegit\n * [new branch]      serverfix    -> origin/serverfix\n\n\n要特别注意的一点是当抓取到新的远程跟踪分支时，本地不会自动生成一份可编辑的副本（拷贝）。 换一句话说，这种情况下，不会有一个新的 serverfix 分支——只有一个不可以修改的 origin/serverfix 指针。\n\n可以运行 git merge origin/serverfix 将这些工作合并到当前所在的分支。 如果想要在自己的 serverfix 分支上工作，可以将其建立在远程跟踪分支之上：\n\n$ git checkout -b serverfix origin/serverfix\nBranch serverfix set up to track remote branch serverfix from origin.\nSwitched to a new branch 'serverfix'\n\n\n这会给你一个用于工作的本地分支，并且起点位于 origin/serverfix。\n\n\n# 跟踪分支\n\n从一个远程跟踪分支检出一个本地分支会自动创建所谓的“跟踪分支”（它跟踪的分支叫做“上游分支”）。 跟踪分支是与远程分支有直接关系的本地分支。 如果在一个跟踪分支上输入 git pull，Git 能自动地识别去哪个服务器上抓取、合并到哪个分支。\n\n当克隆一个仓库时，它通常会自动地创建一个跟踪 origin/master 的 master 分支。 然而，如果你愿意的话可以设置其他的跟踪分支，或是一个在其他远程仓库上的跟踪分支，又或者不跟踪 master 分支。 最简单的实例就是像之前看到的那样，运行 git checkout -b <branch> <remote>/<branch>。 这是一个十分常用的操作所以 Git 提供了 --track 快捷方式：\n\n$ git checkout --track origin/serverfix\nBranch serverfix set up to track remote branch serverfix from origin.\nSwitched to a new branch 'serverfix'\n\n\n由于这个操作太常用了，该捷径本身还有一个捷径。 如果你尝试检出的分支 (a) 不存在且 (b) 刚好只有一个名字与之匹配的远程分支，那么 Git 就会为你创建一个跟踪分支：\n\n$ git checkout serverfix\nBranch serverfix set up to track remote branch serverfix from origin.\nSwitched to a new branch 'serverfix'\n\n\n如果想要将本地分支与远程分支设置为不同的名字，你可以轻松地使用上一个命令增加一个不同名字的本地分支：\n\n$ git checkout -b sf origin/serverfix\nBranch sf set up to track remote branch serverfix from origin.\nSwitched to a new branch 'sf'\n\n\n现在，本地分支 sf 会自动从 origin/serverfix 拉取。\n\n设置已有的本地分支跟踪一个刚刚拉取下来的远程分支，或者想要修改正在跟踪的上游分支， 你可以在任意时间使用 -u 或 --set-upstream-to 选项运行 git branch 来显式地设置。\n\n$ git branch -u origin/serverfix\nBranch serverfix set up to track remote branch serverfix from origin.\n\n\nNOTE   上游快捷方式当设置好跟踪分支后，可以通过简写 @{UPSTREAM} 或 @{U} 来引用它的上游分支。 所以在\n       MASTER 分支时并且它正在跟踪 ORIGIN/MASTER 时，如果愿意的话可以使用 GIT MERGE @{U}\n       来取代 GIT MERGE ORIGIN/MASTER。\n       \n\n\n# 查看跟踪分支\n\n如果想要查看设置的所有跟踪分支，可以使用 git branch 的 -vv 选项。 这会将所有的本地分支列出来并且包含更多的信息，如每一个分支正在跟踪哪个远程分支与本地分支是否是领先、落后或是都有。\n\n$ git branch -vv\n  iss53     7e424c3 [origin/iss53: ahead 2] forgot the brackets\n  master    1ae2a45 [origin/master] deploying index fix\n* serverfix f8674d9 [teamone/server-fix-good: ahead 3, behind 1] this should do it\n  testing   5ea463a trying something new\n\n\n这里可以看到 iss53 分支正在跟踪 origin/iss53 并且 “ahead” 是 2，意味着本地有两个提交还没有推送到服务器上。 也能看到 master 分支正在跟踪 origin/master 分支并且是最新的。 接下来可以看到 serverfix 分支正在跟踪 teamone 服务器上的 server-fix-good 分支并且领先 3 落后 1， 意味着服务器上有一次提交还没有合并入同时本地有三次提交还没有推送。 最后看到 testing 分支并没有跟踪任何远程分支。\n\n需要重点注意的一点是这些数字的值来自于你从每个服务器上最后一次抓取的数据。 这个命令并没有连接服务器，它只会告诉你关于本地缓存的服务器数据。 如果想要统计最新的领先与落后数字，需要在运行此命令前抓取所有的远程仓库。 可以像这样做：\n\n$ git fetch --all; git branch -vv\n\n\n\n# 拉取\n\n当 git fetch 命令从服务器上抓取本地没有的数据时，它并不会修改工作目录中的内容。 它只会获取数据然后让你自己合并。 然而，有一个命令叫作 git pull 在大多数情况下它的含义是一个 git fetch 紧接着一个 git merge 命令。 如果有一个像之前章节中演示的设置好的跟踪分支，不管它是显式地设置还是通过 clone 或 checkout 命令为你创建的，git pull 都会查找当前分支所跟踪的服务器与分支， 从服务器上抓取数据然后尝试合并入那个远程分支。\n\n由于 git pull 的魔法经常令人困惑所以通常单独显式地使用 fetch 与 merge 命令会更好一些。\n\n\n# 删除远程分支\n\n假设你已经通过远程分支做完所有的工作了——也就是说你和你的协作者已经完成了一个特性， 并且将其合并到了远程仓库的 master 分支（或任何其他稳定代码分支）。 可以运行带有 --delete 选项的 git push 命令来删除一个远程分支。 如果想要从服务器上删除 serverfix 分支，运行下面的命令：\n\n$ git push origin --delete serverfix\nTo https://github.com/schacon/simplegit\n - [deleted]         serverfix\n\n\n基本上这个命令做的只是从服务器上移除这个指针。 Git 服务器通常会保留数据一段时间直到垃圾回收运行，所以如果不小心删除掉了，通常是很容易恢复的。",normalizedContent:"# git分支-远程分支\n\n远程引用是对远程仓库的引用（指针），包括分支、标签等等。\n\n> 远程分支本质上也是一个指针，指向远程地址\n\n\n# 查看远程引用列表与信息\n\ngit ls-remote <remote> # 远程引用的完整列表\ngit remote show <remote> # 远程分支的更多信息\n\n\n上面两行命令比较少用，更常见的做法是利用远程跟踪分支。\n\n\n# 远程跟踪分支\n\n远程跟踪分支是远程分支状态的引用。它们是你无法移动的本地引用。一旦你进行了网络通信， git 就会为你移动它们以精确反映远程仓库的状态。请将它们看做书签， 这样可以提醒你该分支在远程仓库中的位置就是你最后一次连接到它们的位置。\n\n它们以 <remote>/<branch> 的形式命名。 例如，如果你想要查看最后一次与远程仓库 origin 通信时 master 分支的状态，你可以查看 origin/master 分支。 你与同事合作解决一个问题并且他们推送了一个 iss53 分支，你可能有自己的本地 iss53 分支， 然而在服务器上的分支会以 origin/iss53 来表示。\n\n这可能有一点儿难以理解，让我们来看一个例子。 假设你的网络里有一个在 git.ourcompany.com 的 git 服务器。 如果你从这里克隆，git 的 clone 命令会为你自动将其命名为 origin，拉取它的所有数据， 创建一个指向它的 master 分支的指针，并且在本地将其命名为 origin/master。 git 也会给你一个与 origin 的 master 分支在指向同一个地方的本地 master 分支，这样你就有工作的基础。\n\n笔记：从远程克隆下来的仓库有一个叫origin/master的远程跟踪分支 和 一个本地的master分支\n\n> 笔记：“origin” 并无特殊含义远程仓库名字 “origin” 与分支名字 “master” 一样，在 git 中并没有任何特别的含义一样。 同时 “master” 是当你运行 git init 时默认的起始分支名字，原因仅仅是它的广泛使用， “origin” 是当你运行 git clone 时默认的远程仓库名字。 如果你运行 git clone -o booyah，那么你默认的远程分支名字将会是 booyah/master。\n\n\n\n图1. 克隆之后的服务器与本地仓库 ▲\n\n如果你在本地的 master 分支做了一些工作，在同一段时间内有其他人推送提交到 git.ourcompany.com 并且更新了它的 master 分支，这就是说你们的提交历史已走向不同的方向。 即便这样，只要你保持不与 origin 服务器连接（并拉取数据），你的 origin/master 指针就不会移动。\n\n\n\n图2. 本地与远程的工作可以分叉 ▲\n\n如果要与给定的远程仓库同步数据，运行 git fetch <remote> 命令（在本例中为 git fetch origin）。 这个命令查找 “origin” 是哪一个服务器（在本例中，它是 git.ourcompany.com）， 从中抓取本地没有的数据，并且更新本地数据库，移动 origin/master 指针到更新之后的位置。\n\n\n\n图3. git fetch 更新你的远程跟踪分支 ▲\n\n笔记: 本地的 master 分支 可能 和 远程跟踪分支 origin/master 分叉\n\n为了演示有多个远程仓库与远程分支的情况，我们假定你有另一个内部 git 服务器，仅服务于你的某个敏捷开发团队。 这个服务器位于 git.team1.ourcompany.com。 你可以运行 git remote add 命令添加一个新的远程仓库引用到当前的项目，这个命令我们会在 git 基础 中详细说明。 将这个远程仓库命名为 teamone，将其作为完整 url 的缩写。远程仓库名本质上是远程url的缩写\n\n\n\n图4. 添加另一个远程仓库 ▲\n\n现在，可以运行 git fetch teamone 来抓取远程仓库 teamone 有而本地没有的数据。 因为那台服务器上现有的数据是 origin 服务器上的一个子集， 所以 git 并不会抓取数据而是会设置远程跟踪分支 teamone/master 指向 teamone 的 master 分支。\n\n\n\n图5. 远程跟踪分支 teamone/master ▲\n\n\n# 推送\n\n当你想要公开分享一个分支时，需要将其推送到有写入权限的远程仓库上。 本地的分支并不会自动与远程仓库同步——你必须显式地推送想要分享的分支。 这样，你就可以把不愿意分享的内容放到私人分支上，而将需要和别人协作的内容推送到公开分支。\n\n如果希望和别人一起在名为 serverfix 的分支上工作，你可以像推送第一个分支那样推送它。 运行 git push <remote> <branch>:\n\n$ git push origin serverfix\ncounting objects: 24, done.\ndelta compression using up to 8 threads.\ncompressing objects: 100% (15/15), done.\nwriting objects: 100% (24/24), 1.91 kib | 0 bytes/s, done.\ntotal 24 (delta 2), reused 0 (delta 0)\nto https://github.com/schacon/simplegit\n * [new branch]      serverfix -> serverfix\n\n\n这里有些工作被简化了。 git 自动将 serverfix 分支名字展开为 refs/heads/serverfix:refs/heads/serverfix， 那意味着，“推送本地的 serverfix 分支来更新远程仓库上的 serverfix 分支。” 我们将会详细学习 git 内部原理 的 refs/heads/ 部分， 但是现在可以先把它放在儿。你也可以运行 git push origin serverfix:serverfix， 它会做同样的事——也就是说“推送本地的 serverfix 分支，将其作为远程仓库的 serverfix 分支” 可以通过这种格式来推送本地分支到一个命名不相同的远程分支。\n\n# 重命名远程仓库上的分支名\n\n如果并不想让远程仓库上的分支叫做 serverfix，可以运行 git push origin serverfix:awesomebranch 来将本地的 serverfix 分支推送到远程仓库上的 awesomebranch 分支。\n\nnote   如何避免每次输入密码如果你正在使用 https url 来推送，git 服务器会询问用户名与密码。\n       默认情况下它会在终端中提示服务器是否允许你进行推送。如果不想在每一次推送时都输入用户名与密码，你可以设置一个\n       “credential cache”。 最简单的方式就是将其保存在内存中几分钟，可以简单地运行 git config\n       --global credential.helper cache 来设置它。想要了解更多关于不同验证缓存的可用选项，查看\n       凭证存储。\n       \n\n下一次其他协作者从服务器上抓取数据时，他们会在本地生成一个远程分支 origin/serverfix，指向服务器的 serverfix 分支的引用：\n\n$ git fetch origin\nremote: counting objects: 7, done.\nremote: compressing objects: 100% (2/2), done.\nremote: total 3 (delta 0), reused 3 (delta 0)\nunpacking objects: 100% (3/3), done.\nfrom https://github.com/schacon/simplegit\n * [new branch]      serverfix    -> origin/serverfix\n\n\n要特别注意的一点是当抓取到新的远程跟踪分支时，本地不会自动生成一份可编辑的副本（拷贝）。 换一句话说，这种情况下，不会有一个新的 serverfix 分支——只有一个不可以修改的 origin/serverfix 指针。\n\n可以运行 git merge origin/serverfix 将这些工作合并到当前所在的分支。 如果想要在自己的 serverfix 分支上工作，可以将其建立在远程跟踪分支之上：\n\n$ git checkout -b serverfix origin/serverfix\nbranch serverfix set up to track remote branch serverfix from origin.\nswitched to a new branch 'serverfix'\n\n\n这会给你一个用于工作的本地分支，并且起点位于 origin/serverfix。\n\n\n# 跟踪分支\n\n从一个远程跟踪分支检出一个本地分支会自动创建所谓的“跟踪分支”（它跟踪的分支叫做“上游分支”）。 跟踪分支是与远程分支有直接关系的本地分支。 如果在一个跟踪分支上输入 git pull，git 能自动地识别去哪个服务器上抓取、合并到哪个分支。\n\n当克隆一个仓库时，它通常会自动地创建一个跟踪 origin/master 的 master 分支。 然而，如果你愿意的话可以设置其他的跟踪分支，或是一个在其他远程仓库上的跟踪分支，又或者不跟踪 master 分支。 最简单的实例就是像之前看到的那样，运行 git checkout -b <branch> <remote>/<branch>。 这是一个十分常用的操作所以 git 提供了 --track 快捷方式：\n\n$ git checkout --track origin/serverfix\nbranch serverfix set up to track remote branch serverfix from origin.\nswitched to a new branch 'serverfix'\n\n\n由于这个操作太常用了，该捷径本身还有一个捷径。 如果你尝试检出的分支 (a) 不存在且 (b) 刚好只有一个名字与之匹配的远程分支，那么 git 就会为你创建一个跟踪分支：\n\n$ git checkout serverfix\nbranch serverfix set up to track remote branch serverfix from origin.\nswitched to a new branch 'serverfix'\n\n\n如果想要将本地分支与远程分支设置为不同的名字，你可以轻松地使用上一个命令增加一个不同名字的本地分支：\n\n$ git checkout -b sf origin/serverfix\nbranch sf set up to track remote branch serverfix from origin.\nswitched to a new branch 'sf'\n\n\n现在，本地分支 sf 会自动从 origin/serverfix 拉取。\n\n设置已有的本地分支跟踪一个刚刚拉取下来的远程分支，或者想要修改正在跟踪的上游分支， 你可以在任意时间使用 -u 或 --set-upstream-to 选项运行 git branch 来显式地设置。\n\n$ git branch -u origin/serverfix\nbranch serverfix set up to track remote branch serverfix from origin.\n\n\nnote   上游快捷方式当设置好跟踪分支后，可以通过简写 @{upstream} 或 @{u} 来引用它的上游分支。 所以在\n       master 分支时并且它正在跟踪 origin/master 时，如果愿意的话可以使用 git merge @{u}\n       来取代 git merge origin/master。\n       \n\n\n# 查看跟踪分支\n\n如果想要查看设置的所有跟踪分支，可以使用 git branch 的 -vv 选项。 这会将所有的本地分支列出来并且包含更多的信息，如每一个分支正在跟踪哪个远程分支与本地分支是否是领先、落后或是都有。\n\n$ git branch -vv\n  iss53     7e424c3 [origin/iss53: ahead 2] forgot the brackets\n  master    1ae2a45 [origin/master] deploying index fix\n* serverfix f8674d9 [teamone/server-fix-good: ahead 3, behind 1] this should do it\n  testing   5ea463a trying something new\n\n\n这里可以看到 iss53 分支正在跟踪 origin/iss53 并且 “ahead” 是 2，意味着本地有两个提交还没有推送到服务器上。 也能看到 master 分支正在跟踪 origin/master 分支并且是最新的。 接下来可以看到 serverfix 分支正在跟踪 teamone 服务器上的 server-fix-good 分支并且领先 3 落后 1， 意味着服务器上有一次提交还没有合并入同时本地有三次提交还没有推送。 最后看到 testing 分支并没有跟踪任何远程分支。\n\n需要重点注意的一点是这些数字的值来自于你从每个服务器上最后一次抓取的数据。 这个命令并没有连接服务器，它只会告诉你关于本地缓存的服务器数据。 如果想要统计最新的领先与落后数字，需要在运行此命令前抓取所有的远程仓库。 可以像这样做：\n\n$ git fetch --all; git branch -vv\n\n\n\n# 拉取\n\n当 git fetch 命令从服务器上抓取本地没有的数据时，它并不会修改工作目录中的内容。 它只会获取数据然后让你自己合并。 然而，有一个命令叫作 git pull 在大多数情况下它的含义是一个 git fetch 紧接着一个 git merge 命令。 如果有一个像之前章节中演示的设置好的跟踪分支，不管它是显式地设置还是通过 clone 或 checkout 命令为你创建的，git pull 都会查找当前分支所跟踪的服务器与分支， 从服务器上抓取数据然后尝试合并入那个远程分支。\n\n由于 git pull 的魔法经常令人困惑所以通常单独显式地使用 fetch 与 merge 命令会更好一些。\n\n\n# 删除远程分支\n\n假设你已经通过远程分支做完所有的工作了——也就是说你和你的协作者已经完成了一个特性， 并且将其合并到了远程仓库的 master 分支（或任何其他稳定代码分支）。 可以运行带有 --delete 选项的 git push 命令来删除一个远程分支。 如果想要从服务器上删除 serverfix 分支，运行下面的命令：\n\n$ git push origin --delete serverfix\nto https://github.com/schacon/simplegit\n - [deleted]         serverfix\n\n\n基本上这个命令做的只是从服务器上移除这个指针。 git 服务器通常会保留数据一段时间直到垃圾回收运行，所以如果不小心删除掉了，通常是很容易恢复的。",charsets:{cjk:!0},lastUpdated:"2023/11/19, 12:55:48",lastUpdatedTimestamp:1700369748e3},{title:"Git分支-变基",frontmatter:{title:"Git分支-变基",date:"2020-11-18T17:43:57.000Z",permalink:"/pages/3a3247/",categories:["《Git》学习笔记"],tags:["Git"],author:{name:"王清欢",link:"https://github.com/wang-haihua"}},regularPath:"/05.Git%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/30.Git%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%AC%94%E8%AE%B0/70.Git%E5%88%86%E6%94%AF-%E5%8F%98%E5%9F%BA.html",relativePath:"05.Git 学习笔记/30.Git 官方文档笔记/70.Git分支-变基.md",key:"v-10fa8822",path:"/pages/3a3247/",headers:[{level:2,title:"变基的基本操作",slug:"变基的基本操作",normalizedTitle:"变基的基本操作",charIndex:117},{level:3,title:"概念",slug:"概念",normalizedTitle:"概念",charIndex:312},{level:3,title:"原理",slug:"原理",normalizedTitle:"原理",charIndex:718},{level:3,title:"步骤",slug:"步骤",normalizedTitle:"步骤",charIndex:1122},{level:3,title:"优点",slug:"优点",normalizedTitle:"优点",charIndex:1673},{level:2,title:"更有趣的变基例子",slug:"更有趣的变基例子",normalizedTitle:"更有趣的变基例子",charIndex:1699},{level:3,title:"更有趣的变基例子",slug:"更有趣的变基例子-2",normalizedTitle:"更有趣的变基例子",charIndex:1699},{level:3,title:"--onto选项",slug:"onto选项",normalizedTitle:"--onto选项",charIndex:2498},{level:3,title:"省去先切换到源分支的步骤",slug:"省去先切换到源分支的步骤",normalizedTitle:"省去先切换到源分支的步骤",charIndex:2724},{level:2,title:"变基的风险",slug:"变基的风险",normalizedTitle:"变基的风险",charIndex:3353},{level:3,title:"金科玉律",slug:"金科玉律",normalizedTitle:"金科玉律",charIndex:3363},{level:3,title:"变基的实质",slug:"变基的实质",normalizedTitle:"变基的实质",charIndex:3553},{level:2,title:"用变基解决变基",slug:"用变基解决变基",normalizedTitle:"用变基解决变基",charIndex:4350},{level:2,title:"变基 vs. 合并",slug:"变基-vs-合并",normalizedTitle:"变基 vs. 合并",charIndex:5488}],headersStr:"变基的基本操作 概念 原理 步骤 优点 更有趣的变基例子 更有趣的变基例子 --onto选项 省去先切换到源分支的步骤 变基的风险 金科玉律 变基的实质 用变基解决变基 变基 vs. 合并",content:"# Git分支-变基\n\n在 Git 中整合来自不同分支的修改主要有两种方法：merge 以及 rebase。 在本节中我们将学习什么是“变基”，怎样使用“变基”，并将展示该操作的惊艳之处，以及指出在何种情况下你应避免使用它。\n\n\n# 变基的基本操作\n\n请回顾之前在 分支的合并 中的一个例子，你会看到开发任务分叉到两个不同分支，又各自提交了更新。\n\n\n\n图0. 分叉的提交历史 ▲\n\n之前介绍过，整合分支最容易的方法是 merge 命令。 它会把两个分支的最新快照（C3 和 C4）以及二者最近的共同祖先（C2）进行三方合并，合并的结果是生成一个新的快照（并提交）。\n\n\n\n图1. 通过合并操作来整合分叉的历史 ▲\n\n\n# 概念\n\n变基就是：将某一分支上的所有修改复制到另一分支上\n\n除了merge，还有一种方法：你可以提取在 C4 中引入的补丁和修改，然后在 C3 的基础上应用一次。 在 Git 中，这种操作就叫做 变基（rebase）。 你可以使用 rebase 命令将提交到某一分支上的所有修改都移到另一分支上，就好像“重新播放”一样。\n\n在这个例子中，你可以检出 experiment 分支，然后将它变基到 master 分支上：\n\n$ git checkout experiment\n$ git rebase master # 将experiment上的修改变基到master分支上（将experiment的提交移动到master上。）\nFirst, rewinding head to replay your work on top of it...\nApplying: added staged command\n\n\n它的原理是首先找到这两个分支（即当前分支 experiment、变基操作的目标基底分支 master） 的最近共同祖先 C2，然后对比当前分支相对于该祖先的历次提交，提取相应的修改并存为临时文件， 然后将当前分支指向目标基底 C3, 最后以此将之前另存为临时文件的修改依序应用。 （译注：写明了 commit id，以便理解，下同）\n\n\n# 原理\n\n 1. 找到当前分支和目标分支的最近共同祖先\n\n 2. 对比当前分支相对于该共同祖先的历次提交\n\n 3. 提取相应的修改并存为临时文件\n\n 4. 将当前分支指向目标分支\n\n 5. 将之前临时文件的修改依序应用\n\n\n\n图2.将 C4 中的修改变基到 C3 上 ▲\n\n现在回到 master 分支，进行一次快进合并。\n\n$ git checkout master\n$ git merge experiment\n\n\n\n\n图3.master 分支的快进合并 ▲\n\n\n# 步骤\n\n先检出源分支，将源分支的修改变基到目标分支。切回目标分支，进行一次快进合并\n\n# 示意：\ngit checkout <源分支>\ngit (源分支的修改)rebase(到) <目标分支>\ngit checkout <目标分支>\ngit merge <源分支>\n\n\n此时，C4' 指向的快照就和 the merge example 中 C5 指向的快照一模一样了。 这两种整合方法的最终结果没有任何区别，但是 变基使得提交历史更加整洁。 你在查看一个经过变基的分支的历史记录时会发现，尽管实际的开发工作是并行的， 但它们看上去就像是串行的一样，提交历史是一条直线没有分叉。\n\n一般我们这样做的目的是为了确保在向远程分支推送时能保持提交历史的整洁——例如向某个其他人维护的项目贡献代码时。 在这种情况下，你首先在自己的分支里进行开发，当开发完成时你需要先将你的代码变基到 origin/master 上，然后再向主项目提交修改。 这样的话，该项目的维护者就不再需要进行整合工作，只需要快进合并便可。\n\n请注意，无论是通过变基，还是通过三方合并，整合的最终结果所指向的快照始终是一样的，只不过提交历史不同罢了。 变基是将一系列提交按照原有次序依次应用到另一分支上，而合并是把最终结果合在一起。\n\n\n# 优点\n\n变基的优点： 使提交记录更加整洁。\n\n\n# 更有趣的变基例子\n\n在对两个分支进行变基时，所生成的“重放”并不一定要在目标分支上应用，你也可以指定另外的一个分支进行应用。 就像 从一个主题分支里再分出一个主题分支的提交历史 中的例子那样。 你创建了一个主题分支 server，为服务端添加了一些功能，提交了 C3 和 C4。 然后从 C3 上创建了主题分支 client，为客户端添加了一些功能，提交了 C8 和 C9。 最后，你回到 server 分支，又提交了 C10。\n\n\n# 更有趣的变基例子\n\n在对两个分支进行变基时，所生成的“重放”并不一定要在目标分支上应用，你也可以指定另外的一个分支进行应用。 就像 从一个主题分支里再分出一个主题分支的提交历史 中的例子那样。 你创建了一个主题分支 server，为服务端添加了一些功能，提交了 C3 和 C4。 然后从 C3 上创建了主题分支 client，为客户端添加了一些功能，提交了 C8 和 C9。 最后，你回到 server 分支，又提交了 C10。\n\n\n\n图4.从一个主题分支里再分出一个主题分支的提交历史 ▲\n\n假设你希望将 client 中的修改合并到主分支并发布，但暂时并不想合并 server 中的修改， 因为它们还需要经过更全面的测试。这时，你就可以使用 git rebase 命令的 --onto 选项， 选中在 client 分支里但不在 server 分支里的修改（即 C8 和 C9），将它们在 master 分支上重放：\n\n$ git rebase --onto master server client\n\n\n以上命令的意思是：“取出 client 分支，找出它从 server 分支分歧之后的补丁， 然后把这些补丁在 master 分支上重放一遍，让 client 看起来像直接基于 master 修改一样”。这理解起来有一点复杂，不过效果非常酷。\n\n\n# --onto选项\n\n选中C分支中的但不在B分支里的修改，应用到A分支。\n\n\n\n图5.截取主题分支上的另一个主题分支，然后变基到其他分支 ▲\n\n现在可以快进合并 master 分支了。（如图 快进合并 master 分支，使之包含来自 client 分支的修改）：\n\n$ git checkout master\n$ git merge client\n\n\n\n\n图6.快进合并 `master` 分支，使之包含来自 `client` 分支的修改 ▲\n\n\n# 省去先切换到源分支的步骤\n\ngit rebase <目标(当前)分支> <源分支> # 将源分支变基到目标分支。执行此命令后会自动切换到源分支\ngit checkout <目标分支>\ngit merge <源分支>\n\n\n注意：使用这个方法要确保源分支上的代码是最新的。\n\n接下来你决定将 server 分支中的修改也整合进来。 使用 git rebase <basebranch> <topicbranch> 命令可以直接将主题分支 （即本例中的 server）变基到目标分支（即 master）上。 这样做能省去你先切换到 server 分支，再对其执行变基命令的多个步骤。\n\n$ git rebase master server\n\n\n如图 将 server 中的修改变基到 master 上 所示，server 中的代码被“续”到了 master 后面。\n\n\n\n图7.将 `server` 中的修改变基到 `master` 上 ▲\n\n然后就可以快进合并主分支 master 了：\n\n$ git checkout master\n$ git merge server\n\n\n至此，client 和 server 分支中的修改都已经整合到主分支里了， 你可以删除这两个分支，最终提交历史会变成图 最终的提交历史 中的样子：\n\n$ git branch -d client\n$ git branch -d server\n\n\n\n\n图8. 最终的提交历史 ▲\n\n\n# 变基的风险\n\n\n# 金科玉律\n\n呃，奇妙的变基也并非完美无缺，要用它得遵守一条准则：\n\n如果提交存在于你的仓库之外，而别人可能基于这些提交进行开发，那么不要执行变基。\n\n如果你遵循这条金科玉律，就不会出差错。 否则，人民群众会仇恨你，你的朋友和家人也会嘲笑你，唾弃你。\n\n提示\n\n例如：几个人同时在一个主题分支上进行开发和提交时，你不要中途执行变基，只有在大家都完成工作之后才可以执行变基。\n\n\n# 变基的实质\n\n变基操作的实质是丢弃一些现有的提交，然后相应地新建一些内容一样但实际上不同的提交。 如果你已经将提交推送至某个仓库，而其他人也已经从该仓库拉取提交并进行了后续工作，此时，如果你用 git rebase 命令重新整理了提交并再次推送，你的同伴因此将不得不再次将他们手头的工作与你的提交进行整合，如果接下来你还要拉取并整合他们修改过的提交，事情就会变得一团糟。\n\n让我们来看一个在公开的仓库上执行变基操作所带来的问题。 假设你从一个中央服务器克隆然后在它的基础上进行了一些开发。 你的提交历史如图所示：\n\n\n\n图9. 克隆一个仓库，然后在它的基础上进行了一些开发 ▲\n\n然后，某人又向中央服务器提交了一些修改，其中还包括一次合并。 你抓取了这些在远程分支上的修改，并将其合并到你本地的开发分支，然后你的提交历史就会变成这样：\n\n\n\n图10. 抓取别人的提交，合并到自己的开发分支 ▲\n\n接下来，这个人又决定把合并操作回滚，改用变基；继而又用 git push --force 命令覆盖了服务器上的提交历史。 之后你从服务器抓取更新，会发现多出来一些新的提交。\n\n\n\n图11. 有人推送了经过变基的提交，并丢弃了你的本地开发所基于的一些提交 ▲\n\n结果就是你们两人的处境都十分尴尬。 如果你执行 git pull 命令，你将合并来自两条提交历史的内容，生成一个新的合并提交，最终仓库会如图所示：\n\n\n\n图12. 你将相同的内容又合并了一次，生成了一个新的提交 ▲\n\n此时如果你执行 git log 命令，你会发现有两个提交的作者、日期、日志居然是一样的，这会令人感到混乱。 此外，如果你将这一堆又推送到服务器上，你实际上是将那些已经被变基抛弃的提交又找了回来，这会令人感到更加混乱。 很明显对方并不想在提交历史中看到 C4 和 C6，因为之前就是他把这两个提交通过变基丢弃的。\n\n\n# 用变基解决变基\n\n如果你 真的 遭遇了类似的处境，Git 还有一些高级魔法可以帮到你。 如果团队中的某人强制推送并覆盖了一些你所基于的提交，你需要做的就是检查你做了哪些修改，以及他们覆盖了哪些修改。\n\n实际上，Git 除了对整个提交计算 SHA-1 校验和以外，也对本次提交所引入的修改计算了校验和——即 “patch-id”。\n\n如果你拉取被覆盖过的更新并将你手头的工作基于此进行变基的话，一般情况下 Git 都能成功分辨出哪些是你的修改，并把它们应用到新分支上。\n\n举个例子，如果遇到前面提到的 有人推送了经过变基的提交，并丢弃了你的本地开发所基于的一些提交 那种情境，如果我们不是执行合并，而是执行 git rebase teamone/master, Git 将会：\n\n * 检查哪些提交是我们的分支上独有的（C2，C3，C4，C6，C7）\n * 检查其中哪些提交不是合并操作的结果（C2，C3，C4）\n * 检查哪些提交在对方覆盖更新时并没有被纳入目标分支（只有 C2 和 C3，因为 C4 其实就是 C4'）\n * 把查到的这些提交应用在 teamone/master 上面\n\n从而我们将得到与 你将相同的内容又合并了一次，生成了一个新的提交 中不同的结果，如图 在一个被变基然后强制推送的分支上再次执行变基 所示。\n\n\n\n图13. 在一个被变基然后强制推送的分支上再次执行变基 ▲\n\n要想上述方案有效，还需要对方在变基时确保 C4' 和 C4 是几乎一样的。 否则变基操作将无法识别，并新建另一个类似 C4 的补丁（而这个补丁很可能无法整洁的整合入历史，因为补丁中的修改已经存在于某个地方了）。\n\n在本例中另一种简单的方法是使用 git pull --rebase 命令而不是直接 git pull。 又或者你可以自己手动完成这个过程，先 git fetch，再 git rebase teamone/master。\n\n如果你习惯使用 git pull ，同时又希望默认使用选项 --rebase，你可以执行这条语句 git config --global pull.rebase true 来更改 pull.rebase 的默认配置。\n\n如果你只对不会离开你电脑的提交执行变基，那就不会有事。 如果你对已经推送过的提交执行变基，但别人没有基于它的提交，那么也不会有事。 如果你对已经推送至共用仓库的提交上执行变基命令，并因此丢失了一些别人的开发所基于的提交， 那你就有大麻烦了，你的同事也会因此鄙视你。\n\n如果你或你的同事在某些情形下决意要这么做，请一定要通知每个人执行 git pull --rebase 命令，这样尽管不能避免伤痛，但能有所缓解。\n\n\n# 变基 vs. 合并\n\n至此，你已在实战中学习了变基和合并的用法，你一定会想问，到底哪种方式更好。 在回答这个问题之前，让我们退后一步，想讨论一下提交历史到底意味着什么。\n\n有一种观点认为，仓库的提交历史即是 记录实际发生过什么。 它是针对历史的文档，本身就有价值，不能乱改。 从这个角度看来，改变提交历史是一种亵渎，你使用 谎言 掩盖了实际发生过的事情。 如果由合并产生的提交历史是一团糟怎么办？ 既然事实就是如此，那么这些痕迹就应该被保留下来，让后人能够查阅。\n\n另一种观点则正好相反，他们认为提交历史是 项目过程中发生的事。 没人会出版一本书的第一版草稿，软件维护手册也是需要反复修订才能方便使用。 持这一观点的人会使用 rebase 及 filter-branch 等工具来编写故事，怎么方便后来的读者就怎么写。\n\n现在，让我们回到之前的问题上来，到底合并还是变基好？希望你能明白，这并没有一个简单的答案。 Git 是一个非常强大的工具，它允许你对提交历史做许多事情，但每个团队、每个项目对此的需求并不相同。 既然你已经分别学习了两者的用法，相信你能够根据实际情况作出明智的选择。\n\n总的原则是，只对尚未推送或分享给别人的本地修改执行变基操作清理历史， 从不对已推送至别处的提交执行变基操作，这样，你才能享受到两种方式带来的便利。",normalizedContent:"# git分支-变基\n\n在 git 中整合来自不同分支的修改主要有两种方法：merge 以及 rebase。 在本节中我们将学习什么是“变基”，怎样使用“变基”，并将展示该操作的惊艳之处，以及指出在何种情况下你应避免使用它。\n\n\n# 变基的基本操作\n\n请回顾之前在 分支的合并 中的一个例子，你会看到开发任务分叉到两个不同分支，又各自提交了更新。\n\n\n\n图0. 分叉的提交历史 ▲\n\n之前介绍过，整合分支最容易的方法是 merge 命令。 它会把两个分支的最新快照（c3 和 c4）以及二者最近的共同祖先（c2）进行三方合并，合并的结果是生成一个新的快照（并提交）。\n\n\n\n图1. 通过合并操作来整合分叉的历史 ▲\n\n\n# 概念\n\n变基就是：将某一分支上的所有修改复制到另一分支上\n\n除了merge，还有一种方法：你可以提取在 c4 中引入的补丁和修改，然后在 c3 的基础上应用一次。 在 git 中，这种操作就叫做 变基（rebase）。 你可以使用 rebase 命令将提交到某一分支上的所有修改都移到另一分支上，就好像“重新播放”一样。\n\n在这个例子中，你可以检出 experiment 分支，然后将它变基到 master 分支上：\n\n$ git checkout experiment\n$ git rebase master # 将experiment上的修改变基到master分支上（将experiment的提交移动到master上。）\nfirst, rewinding head to replay your work on top of it...\napplying: added staged command\n\n\n它的原理是首先找到这两个分支（即当前分支 experiment、变基操作的目标基底分支 master） 的最近共同祖先 c2，然后对比当前分支相对于该祖先的历次提交，提取相应的修改并存为临时文件， 然后将当前分支指向目标基底 c3, 最后以此将之前另存为临时文件的修改依序应用。 （译注：写明了 commit id，以便理解，下同）\n\n\n# 原理\n\n 1. 找到当前分支和目标分支的最近共同祖先\n\n 2. 对比当前分支相对于该共同祖先的历次提交\n\n 3. 提取相应的修改并存为临时文件\n\n 4. 将当前分支指向目标分支\n\n 5. 将之前临时文件的修改依序应用\n\n\n\n图2.将 c4 中的修改变基到 c3 上 ▲\n\n现在回到 master 分支，进行一次快进合并。\n\n$ git checkout master\n$ git merge experiment\n\n\n\n\n图3.master 分支的快进合并 ▲\n\n\n# 步骤\n\n先检出源分支，将源分支的修改变基到目标分支。切回目标分支，进行一次快进合并\n\n# 示意：\ngit checkout <源分支>\ngit (源分支的修改)rebase(到) <目标分支>\ngit checkout <目标分支>\ngit merge <源分支>\n\n\n此时，c4' 指向的快照就和 the merge example 中 c5 指向的快照一模一样了。 这两种整合方法的最终结果没有任何区别，但是 变基使得提交历史更加整洁。 你在查看一个经过变基的分支的历史记录时会发现，尽管实际的开发工作是并行的， 但它们看上去就像是串行的一样，提交历史是一条直线没有分叉。\n\n一般我们这样做的目的是为了确保在向远程分支推送时能保持提交历史的整洁——例如向某个其他人维护的项目贡献代码时。 在这种情况下，你首先在自己的分支里进行开发，当开发完成时你需要先将你的代码变基到 origin/master 上，然后再向主项目提交修改。 这样的话，该项目的维护者就不再需要进行整合工作，只需要快进合并便可。\n\n请注意，无论是通过变基，还是通过三方合并，整合的最终结果所指向的快照始终是一样的，只不过提交历史不同罢了。 变基是将一系列提交按照原有次序依次应用到另一分支上，而合并是把最终结果合在一起。\n\n\n# 优点\n\n变基的优点： 使提交记录更加整洁。\n\n\n# 更有趣的变基例子\n\n在对两个分支进行变基时，所生成的“重放”并不一定要在目标分支上应用，你也可以指定另外的一个分支进行应用。 就像 从一个主题分支里再分出一个主题分支的提交历史 中的例子那样。 你创建了一个主题分支 server，为服务端添加了一些功能，提交了 c3 和 c4。 然后从 c3 上创建了主题分支 client，为客户端添加了一些功能，提交了 c8 和 c9。 最后，你回到 server 分支，又提交了 c10。\n\n\n# 更有趣的变基例子\n\n在对两个分支进行变基时，所生成的“重放”并不一定要在目标分支上应用，你也可以指定另外的一个分支进行应用。 就像 从一个主题分支里再分出一个主题分支的提交历史 中的例子那样。 你创建了一个主题分支 server，为服务端添加了一些功能，提交了 c3 和 c4。 然后从 c3 上创建了主题分支 client，为客户端添加了一些功能，提交了 c8 和 c9。 最后，你回到 server 分支，又提交了 c10。\n\n\n\n图4.从一个主题分支里再分出一个主题分支的提交历史 ▲\n\n假设你希望将 client 中的修改合并到主分支并发布，但暂时并不想合并 server 中的修改， 因为它们还需要经过更全面的测试。这时，你就可以使用 git rebase 命令的 --onto 选项， 选中在 client 分支里但不在 server 分支里的修改（即 c8 和 c9），将它们在 master 分支上重放：\n\n$ git rebase --onto master server client\n\n\n以上命令的意思是：“取出 client 分支，找出它从 server 分支分歧之后的补丁， 然后把这些补丁在 master 分支上重放一遍，让 client 看起来像直接基于 master 修改一样”。这理解起来有一点复杂，不过效果非常酷。\n\n\n# --onto选项\n\n选中c分支中的但不在b分支里的修改，应用到a分支。\n\n\n\n图5.截取主题分支上的另一个主题分支，然后变基到其他分支 ▲\n\n现在可以快进合并 master 分支了。（如图 快进合并 master 分支，使之包含来自 client 分支的修改）：\n\n$ git checkout master\n$ git merge client\n\n\n\n\n图6.快进合并 `master` 分支，使之包含来自 `client` 分支的修改 ▲\n\n\n# 省去先切换到源分支的步骤\n\ngit rebase <目标(当前)分支> <源分支> # 将源分支变基到目标分支。执行此命令后会自动切换到源分支\ngit checkout <目标分支>\ngit merge <源分支>\n\n\n注意：使用这个方法要确保源分支上的代码是最新的。\n\n接下来你决定将 server 分支中的修改也整合进来。 使用 git rebase <basebranch> <topicbranch> 命令可以直接将主题分支 （即本例中的 server）变基到目标分支（即 master）上。 这样做能省去你先切换到 server 分支，再对其执行变基命令的多个步骤。\n\n$ git rebase master server\n\n\n如图 将 server 中的修改变基到 master 上 所示，server 中的代码被“续”到了 master 后面。\n\n\n\n图7.将 `server` 中的修改变基到 `master` 上 ▲\n\n然后就可以快进合并主分支 master 了：\n\n$ git checkout master\n$ git merge server\n\n\n至此，client 和 server 分支中的修改都已经整合到主分支里了， 你可以删除这两个分支，最终提交历史会变成图 最终的提交历史 中的样子：\n\n$ git branch -d client\n$ git branch -d server\n\n\n\n\n图8. 最终的提交历史 ▲\n\n\n# 变基的风险\n\n\n# 金科玉律\n\n呃，奇妙的变基也并非完美无缺，要用它得遵守一条准则：\n\n如果提交存在于你的仓库之外，而别人可能基于这些提交进行开发，那么不要执行变基。\n\n如果你遵循这条金科玉律，就不会出差错。 否则，人民群众会仇恨你，你的朋友和家人也会嘲笑你，唾弃你。\n\n提示\n\n例如：几个人同时在一个主题分支上进行开发和提交时，你不要中途执行变基，只有在大家都完成工作之后才可以执行变基。\n\n\n# 变基的实质\n\n变基操作的实质是丢弃一些现有的提交，然后相应地新建一些内容一样但实际上不同的提交。 如果你已经将提交推送至某个仓库，而其他人也已经从该仓库拉取提交并进行了后续工作，此时，如果你用 git rebase 命令重新整理了提交并再次推送，你的同伴因此将不得不再次将他们手头的工作与你的提交进行整合，如果接下来你还要拉取并整合他们修改过的提交，事情就会变得一团糟。\n\n让我们来看一个在公开的仓库上执行变基操作所带来的问题。 假设你从一个中央服务器克隆然后在它的基础上进行了一些开发。 你的提交历史如图所示：\n\n\n\n图9. 克隆一个仓库，然后在它的基础上进行了一些开发 ▲\n\n然后，某人又向中央服务器提交了一些修改，其中还包括一次合并。 你抓取了这些在远程分支上的修改，并将其合并到你本地的开发分支，然后你的提交历史就会变成这样：\n\n\n\n图10. 抓取别人的提交，合并到自己的开发分支 ▲\n\n接下来，这个人又决定把合并操作回滚，改用变基；继而又用 git push --force 命令覆盖了服务器上的提交历史。 之后你从服务器抓取更新，会发现多出来一些新的提交。\n\n\n\n图11. 有人推送了经过变基的提交，并丢弃了你的本地开发所基于的一些提交 ▲\n\n结果就是你们两人的处境都十分尴尬。 如果你执行 git pull 命令，你将合并来自两条提交历史的内容，生成一个新的合并提交，最终仓库会如图所示：\n\n\n\n图12. 你将相同的内容又合并了一次，生成了一个新的提交 ▲\n\n此时如果你执行 git log 命令，你会发现有两个提交的作者、日期、日志居然是一样的，这会令人感到混乱。 此外，如果你将这一堆又推送到服务器上，你实际上是将那些已经被变基抛弃的提交又找了回来，这会令人感到更加混乱。 很明显对方并不想在提交历史中看到 c4 和 c6，因为之前就是他把这两个提交通过变基丢弃的。\n\n\n# 用变基解决变基\n\n如果你 真的 遭遇了类似的处境，git 还有一些高级魔法可以帮到你。 如果团队中的某人强制推送并覆盖了一些你所基于的提交，你需要做的就是检查你做了哪些修改，以及他们覆盖了哪些修改。\n\n实际上，git 除了对整个提交计算 sha-1 校验和以外，也对本次提交所引入的修改计算了校验和——即 “patch-id”。\n\n如果你拉取被覆盖过的更新并将你手头的工作基于此进行变基的话，一般情况下 git 都能成功分辨出哪些是你的修改，并把它们应用到新分支上。\n\n举个例子，如果遇到前面提到的 有人推送了经过变基的提交，并丢弃了你的本地开发所基于的一些提交 那种情境，如果我们不是执行合并，而是执行 git rebase teamone/master, git 将会：\n\n * 检查哪些提交是我们的分支上独有的（c2，c3，c4，c6，c7）\n * 检查其中哪些提交不是合并操作的结果（c2，c3，c4）\n * 检查哪些提交在对方覆盖更新时并没有被纳入目标分支（只有 c2 和 c3，因为 c4 其实就是 c4'）\n * 把查到的这些提交应用在 teamone/master 上面\n\n从而我们将得到与 你将相同的内容又合并了一次，生成了一个新的提交 中不同的结果，如图 在一个被变基然后强制推送的分支上再次执行变基 所示。\n\n\n\n图13. 在一个被变基然后强制推送的分支上再次执行变基 ▲\n\n要想上述方案有效，还需要对方在变基时确保 c4' 和 c4 是几乎一样的。 否则变基操作将无法识别，并新建另一个类似 c4 的补丁（而这个补丁很可能无法整洁的整合入历史，因为补丁中的修改已经存在于某个地方了）。\n\n在本例中另一种简单的方法是使用 git pull --rebase 命令而不是直接 git pull。 又或者你可以自己手动完成这个过程，先 git fetch，再 git rebase teamone/master。\n\n如果你习惯使用 git pull ，同时又希望默认使用选项 --rebase，你可以执行这条语句 git config --global pull.rebase true 来更改 pull.rebase 的默认配置。\n\n如果你只对不会离开你电脑的提交执行变基，那就不会有事。 如果你对已经推送过的提交执行变基，但别人没有基于它的提交，那么也不会有事。 如果你对已经推送至共用仓库的提交上执行变基命令，并因此丢失了一些别人的开发所基于的提交， 那你就有大麻烦了，你的同事也会因此鄙视你。\n\n如果你或你的同事在某些情形下决意要这么做，请一定要通知每个人执行 git pull --rebase 命令，这样尽管不能避免伤痛，但能有所缓解。\n\n\n# 变基 vs. 合并\n\n至此，你已在实战中学习了变基和合并的用法，你一定会想问，到底哪种方式更好。 在回答这个问题之前，让我们退后一步，想讨论一下提交历史到底意味着什么。\n\n有一种观点认为，仓库的提交历史即是 记录实际发生过什么。 它是针对历史的文档，本身就有价值，不能乱改。 从这个角度看来，改变提交历史是一种亵渎，你使用 谎言 掩盖了实际发生过的事情。 如果由合并产生的提交历史是一团糟怎么办？ 既然事实就是如此，那么这些痕迹就应该被保留下来，让后人能够查阅。\n\n另一种观点则正好相反，他们认为提交历史是 项目过程中发生的事。 没人会出版一本书的第一版草稿，软件维护手册也是需要反复修订才能方便使用。 持这一观点的人会使用 rebase 及 filter-branch 等工具来编写故事，怎么方便后来的读者就怎么写。\n\n现在，让我们回到之前的问题上来，到底合并还是变基好？希望你能明白，这并没有一个简单的答案。 git 是一个非常强大的工具，它允许你对提交历史做许多事情，但每个团队、每个项目对此的需求并不相同。 既然你已经分别学习了两者的用法，相信你能够根据实际情况作出明智的选择。\n\n总的原则是，只对尚未推送或分享给别人的本地修改执行变基操作清理历史， 从不对已推送至别处的提交执行变基操作，这样，你才能享受到两种方式带来的便利。",charsets:{cjk:!0},lastUpdated:"2023/11/19, 12:55:48",lastUpdatedTimestamp:1700369748e3},{title:"Git工具-查看修订版本",frontmatter:{title:"Git工具-查看修订版本",date:"2020-11-18T17:43:57.000Z",permalink:"/pages/c984d1/",categories:["《Git》学习笔记"],tags:["Git"],author:{name:"王清欢",link:"https://github.com/wang-haihua"}},regularPath:"/05.Git%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/30.Git%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%AC%94%E8%AE%B0/80.Git%E5%B7%A5%E5%85%B7-%E6%9F%A5%E7%9C%8B%E4%BF%AE%E8%AE%A2%E7%89%88%E6%9C%AC.html",relativePath:"05.Git 学习笔记/30.Git 官方文档笔记/80.Git工具-查看修订版本.md",key:"v-24cfacec",path:"/pages/c984d1/",headers:[{level:2,title:"单个修订版本",slug:"单个修订版本",normalizedTitle:"单个修订版本",charIndex:91},{level:2,title:"简短的 SHA-1",slug:"简短的-sha-1",normalizedTitle:"简短的 sha-1",charIndex:181},{level:3,title:"查看给定SHA-1值的提交",slug:"查看给定sha-1值的提交",normalizedTitle:"查看给定sha-1值的提交",charIndex:906},{level:2,title:"分支引用",slug:"分支引用",normalizedTitle:"分支引用",charIndex:2109},{level:3,title:"查看最后一次提交",slug:"查看最后一次提交",normalizedTitle:"查看最后一次提交",charIndex:2184},{level:2,title:"引用日志",slug:"引用日志",normalizedTitle:"引用日志",charIndex:2616},{level:3,title:"HEAD的指向历史",slug:"head的指向历史",normalizedTitle:"head的指向历史",charIndex:2625},{level:2,title:"祖先引用",slug:"祖先引用",normalizedTitle:"祖先引用",charIndex:4466},{level:2,title:"提交区间",slug:"提交区间",normalizedTitle:"提交区间",charIndex:6391},{level:3,title:"双点",slug:"双点",normalizedTitle:"双点",charIndex:6492},{level:4,title:"查看即将推送到远端的内容",slug:"查看即将推送到远端的内容",normalizedTitle:"查看即将推送到远端的内容",charIndex:7003},{level:3,title:"多点",slug:"多点",normalizedTitle:"多点",charIndex:7343},{level:3,title:"三点",slug:"三点",normalizedTitle:"三点",charIndex:7755}],headersStr:"单个修订版本 简短的 SHA-1 查看给定SHA-1值的提交 分支引用 查看最后一次提交 引用日志 HEAD的指向历史 祖先引用 提交区间 双点 查看即将推送到远端的内容 多点 三点",content:"# Git工具-查看修订版本\n\nGit 能够以多种方式来指定单个提交、一组提交、或者一定范围内的提交。 了解它们并不是必需的，但是了解一下总没坏处。\n\n修订版本指的是：提交\n\n\n# 单个修订版本\n\n你可以通过任意一个提交的 40 个字符的完整 SHA-1 散列值来指定它， 不过还有很多更人性化的方式来做同样的事情。本节将会介绍获取单个提交的多种方法。\n\n\n# 简短的 SHA-1\n\nGit 十分智能，你只需要提供 SHA-1 的前几个字符就可以获得对应的那次提交， 当然你提供的 SHA-1 字符数量不得少于 4 个，并且没有歧义——也就是说， 当前对象数据库中没有其它对象以这段 SHA-1 开头。\n\n例如，要查看你知道其中添加了某个功能的提交，首先运行 git log 命令来定位该提交：\n\n$ git log\ncommit 734713bc047d87bf7eac9674765ae793478c50d3\nAuthor: Scott Chacon <schacon@gmail.com>\nDate:   Fri Jan 2 18:32:33 2009 -0800\n\n    fixed refs handling, added gc auto, updated tests\n\ncommit d921970aadf03b3cf0e71becdaab3147ba71cdef\nMerge: 1c002dd... 35cfb2b...\nAuthor: Scott Chacon <schacon@gmail.com>\nDate:   Thu Dec 11 15:08:43 2008 -0800\n\n    Merge commit 'phedders/rdocs'\n\ncommit 1c002dd4b536e7479fe34593e72e6c6c1819e53b\nAuthor: Scott Chacon <schacon@gmail.com>\nDate:   Thu Dec 11 14:58:32 2008 -0800\n\n    added some blame and merge stuff\n\n\n\n# 查看给定SHA-1值的提交\n\n在本例中，假设你想要的提交其 SHA-1 以 1c002dd.... 开头， 那么你可以用如下几种 git show 的变体来检视该提交（假设简短的版本没有歧义）：\n\n$ git show 1c002dd4b536e7479fe34593e72e6c6c1819e53b\n$ git show 1c002dd4b536e7479f\n$ git show 1c002d\n\n\nGit 可以为 SHA-1 值生成出简短且唯一的缩写。 如果你在 git log 后加上 --abbrev-commit 参数，输出结果里就会显示简短且唯一的值； 默认使用七个字符，不过有时为了避免 SHA-1 的歧义，会增加字符数：\n\n$ git log --abbrev-commit --pretty=oneline\nca82a6d changed the version number\n085bb3b removed unnecessary test code\na11bef0 first commit\n\n\n通常 8 到 10 个字符就已经足够在一个项目中避免 SHA-1 的歧义。 例如，到 2019 年 2 月为止，Linux 内核这个相当大的 Git 项目， 其对象数据库中有超过 875,000 个提交，包含七百万个对象，也只需要前 12 个字符就能保证唯一性。\n\nNOTE   关于 SHA-1 的简短说明许多人觉得他们的仓库里有可能出现两个不同的对象其 SHA-1 值相同。\n       然后呢？如果你真的向仓库里提交了一个对象，它跟之前的某个 不同 对象的 SHA-1 值相同， GIT\n       会发现该对象的散列值已经存在于仓库里了，于是就会认为该对象被写入，然后直接使用它。\n       如果之后你想检出那个对象时，你将得到先前那个对象的数据。但是这种情况发生的概率十分渺小。 SHA-1 摘要长度是 20\n       字节，也就是 160 位。 2^80 个随机哈希对象才有 50% 的概率出现一次冲突 （计算冲突机率的公式是 P =\n       (N(N-1)/2) * (1/2^160)) ）。 2^80 是 1.2 X\n       10^24，也就是一亿亿亿，这是地球上沙粒总数的 1200 倍。举例说一下怎样才能产生一次 SHA-1 冲突。\n       如果地球上 65 亿个人类都在编程，每人每秒都在产生等价于整个 LINUX 内核历史（650 万个 GIT\n       对象）的代码， 并将之提交到一个巨大的 GIT 仓库里面，这样持续两年的时间才会产生足够的对象， 使其拥有 50%\n       的概率产生一次 SHA-1 对象冲突， 这比你编程团队的成员同一个晚上在互不相干的意外中被狼袭击并杀死的机率还要小。\n       \n\n\n# 分支引用\n\n引用特定提交的一种直接方法是，若它是一个分支的顶端的提交， 那么可以在任何需要引用该提交的 Git 命令中直接使用该分支的名称。\n\n\n# 查看最后一次提交\n\n例如，你想要查看一个分支的最后一次提交的对象，假设 topic1 分支指向提交 ca82a6d... ， 那么以下的命令是等价的：\n\n$ git show ca82a6dff817ec66f44342007202690a93763949\n$ git show topic1  # topic1是分支名\n\n\n如果你想知道某个分支指向哪个特定的 SHA-1，或者想看任何一个例子中被简写的 SHA-1， 你可以使用一个叫做 rev-parse 的 Git 探测工具。 你可以在 Git 内部原理 中查看更多关于探测工具的信息。 简单来说，rev-parse 是为了底层操作而不是日常操作设计的。 不过，有时你想看 Git 现在到底处于什么状态时，它可能会很有用。 你可以在你的分支上执行 rev-parse\n\n$ git rev-parse topic1\nca82a6dff817ec66f44342007202690a93763949\n\n\n\n# 引用日志\n\n\n# HEAD的指向历史\n\n当你在工作时， Git 会在后台保存一个引用日志（reflog）， 引用日志记录了最近几个月你的 HEAD 和分支引用所指向的历史。\n\n你可以使用 git reflog 来查看引用日志\n\n$ git reflog\n734713b HEAD@{0}: commit: fixed refs handling, added gc auto, updated\nd921970 HEAD@{1}: merge phedders/rdocs: Merge made by the 'recursive' strategy.\n1c002dd HEAD@{2}: commit: added some blame and merge stuff\n1c36188 HEAD@{3}: rebase -i (squash): updating HEAD\n95df984 HEAD@{4}: commit: # This is a combination of two commits.\n1c36188 HEAD@{5}: rebase -i (squash): updating HEAD\n7e05da5 HEAD@{6}: rebase -i (pick): updating HEAD\n\n\n每当你的 HEAD 所指向的位置发生了变化，Git 就会将这个信息存储到引用日志这个历史记录里。 你也可以通过 reflog 数据来获取之前的提交历史。 如果你想查看仓库中 HEAD 在五次前的所指向的提交，你可以使用 @{n} 来引用 reflog 中输出的提交记录。\n\n$ git show HEAD@{5}\n\n\n你同样可以使用这个语法来查看某个分支在一定时间前的位置。 例如，查看你的 master 分支在昨天的时候指向了哪个提交，你可以输入\n\n$ git show master@{yesterday}\n\n\n就会显示昨天 master 分支的顶端指向了哪个提交。 这个方法只对还在你引用日志里的数据有用，所以不能用来查好几个月之前的提交。\n\n可以运行 git log -g 来查看类似于 git log 输出格式的引用日志信息：\n\n$ git log -g master\ncommit 734713bc047d87bf7eac9674765ae793478c50d3\nReflog: master@{0} (Scott Chacon <schacon@gmail.com>)\nReflog message: commit: fixed refs handling, added gc auto, updated\nAuthor: Scott Chacon <schacon@gmail.com>\nDate:   Fri Jan 2 18:32:33 2009 -0800\n\n    fixed refs handling, added gc auto, updated tests\n\ncommit d921970aadf03b3cf0e71becdaab3147ba71cdef\nReflog: master@{1} (Scott Chacon <schacon@gmail.com>)\nReflog message: merge phedders/rdocs: Merge made by recursive.\nAuthor: Scott Chacon <schacon@gmail.com>\nDate:   Thu Dec 11 15:08:43 2008 -0800\n\n    Merge commit 'phedders/rdocs'\n\n\n值得注意的是，引用日志只存在于本地仓库，它只是一个记录你在 自己 的仓库里做过什么的日志。 其他人拷贝的仓库里的引用日志不会和你的相同，而你新克隆一个仓库的时候，引用日志是空的，因为你在仓库里还没有操作。 git show HEAD@{2.months.ago} 这条命令只有在你克隆了一个项目至少两个月时才会显示匹配的提交—— 如果你刚刚克隆了仓库，那么它将不会有任何结果返回。\n\nTIP   将引用日志想作 GIT 版的 SHELL 历史记录如果你有 UNIX 或者 LINUX 的背景，不妨将引用日志想作\n      GIT 版的 SHELL 历史记录， 重点在于仅与你和你的会话相关，而与他人无关。\n      \n\n\n# 祖先引用\n\n祖先引用是另一种指明一个提交的方式。 如果你在引用的尾部加上一个 ^（脱字符）， Git 会将其解析为该引用的上一个提交。 假设你的提交历史是：\n\n$ git log --pretty=format:'%h %s' --graph\n* 734713b fixed refs handling, added gc auto, updated tests\n*   d921970 Merge commit 'phedders/rdocs'\n|\\\n| * 35cfb2b Some rdoc changes\n* | 1c002dd added some blame and merge stuff\n|/\n* 1c36188 ignore *.gem\n* 9b29157 add open3_detach to gemspec file list\n\n\n你可以使用 HEAD^ 来查看上一个提交，也就是 “HEAD 的父提交”：\n\n$ git show HEAD^\ncommit d921970aadf03b3cf0e71becdaab3147ba71cdef\nMerge: 1c002dd... 35cfb2b...\nAuthor: Scott Chacon <schacon@gmail.com>\nDate:   Thu Dec 11 15:08:43 2008 -0800\n\n    Merge commit 'phedders/rdocs'\n\n\nNOTE   在 WINDOWS 上转义脱字符在 WINDOWS 的 CMD.EXE 中，^ 是一个特殊字符，因此需要区别对待。\n       你可以双写它或者将提交引用放在引号中：$ GIT SHOW HEAD^ # 在 WINDOWS 上无法工作 $ GIT\n       SHOW HEAD^^ # 可以 $ GIT SHOW \"HEAD^\" # 可以\n       \n\n你也可以在 ^ 后面添加一个数字来指明想要 哪一个 父提交——例如 d921970^2 代表 “d921970 的第二父提交” 这个语法只适用于合并的提交，因为合并提交会有多个父提交。 合并提交的第一父提交是你合并时所在分支（通常为 master），而第二父提交是你所合并的分支（例如 topic）：\n\n$ git show d921970^\ncommit 1c002dd4b536e7479fe34593e72e6c6c1819e53b\nAuthor: Scott Chacon <schacon@gmail.com>\nDate:   Thu Dec 11 14:58:32 2008 -0800\n\n    added some blame and merge stuff\n\n$ git show d921970^2\ncommit 35cfb2b795a55793d7cc56a6cc2060b4bb732548\nAuthor: Paul Hedderly <paul+git@mjr.org>\nDate:   Wed Dec 10 22:22:03 2008 +0000\n\n    Some rdoc changes\n\n\n另一种指明祖先提交的方法是 ~（波浪号）。 同样是指向第一父提交，因此 HEAD~ 和 HEAD^ 是等价的。 而区别在于你在后面加数字的时候。 HEAD~2 代表“第一父提交的第一父提交”，也就是“祖父提交”——Git 会根据你指定的次数获取对应的第一父提交。 例如，在之前的列出的提交历史中，HEAD~3 就是\n\n$ git show HEAD~3\ncommit 1c3618887afb5fbcbea25b7c013f4e2114448b8d\nAuthor: Tom Preston-Werner <tom@mojombo.com>\nDate:   Fri Nov 7 13:47:59 2008 -0500\n\n    ignore *.gem\n\n\n也可以写成 HEAD~~~，也是第一父提交的第一父提交的第一父提交：\n\n$ git show HEAD~~~\ncommit 1c3618887afb5fbcbea25b7c013f4e2114448b8d\nAuthor: Tom Preston-Werner <tom@mojombo.com>\nDate:   Fri Nov 7 13:47:59 2008 -0500\n\n    ignore *.gem\n\n\n你也可以组合使用这两个语法——你可以通过 HEAD~3^2 来取得之前引用的第二父提交（假设它是一个合并提交）。\n\n\n# 提交区间\n\n你已经学会如何单次的提交，现在来看看如何指明一定区间的提交。 当你有很多分支时，这对管理你的分支时十分有用， 你可以用提交区间来解决“这个分支还有哪些提交尚未合并到主分支？”的问题\n\n\n# 双点\n\n最常用的指明提交区间语法是双点。 这种语法可以让 Git 选出在一个分支中而不在另一个分支中的提交。 例如，你有如下的提交历史 Example history for range selection.\n\n\n\nFigure 137. Example history for range selection.\n\n你想要查看 experiment 分支中还有哪些提交尚未被合并入 master 分支。 你可以使用 master..experiment 来让 Git 显示这些提交。也就是“在 experiment 分支中而不在 master 分支中的提交”。 为了使例子简单明了，我使用了示意图中提交对象的字母来代替真实日志的输出，所以会显示：\n\n$ git log master..experiment\nD\nC\n\n\n反过来，如果你想查看在 master 分支中而不在 experiment 分支中的提交，你只要交换分支名即可。 experiment..master 会显示在 master 分支中而不在 experiment 分支中的提交：\n\n$ git log experiment..master\nF\nE\n\n\n# 查看即将推送到远端的内容\n\n这可以让你保持 experiment 分支跟随最新的进度以及查看你即将合并的内容。 另一个常用的场景是查看你即将推送到远端的内容：\n\n$ git log origin/master..HEAD\n\n\n这个命令会输出在你当前分支中而不在远程 origin 中的提交。 如果你执行 git push 并且你的当前分支正在跟踪 origin/master，由 git log origin/master..HEAD 所输出的提交就是会被传输到远端服务器的提交。如果你留空了其中的一边， Git 会默认为 HEAD。 例如， git log origin/master.. 将会输出与之前例子相同的结果 —— Git 使用 HEAD 来代替留空的一边。\n\n\n# 多点\n\n双点语法很好用，但有时候你可能需要两个以上的分支才能确定你所需要的修订， 比如查看哪些提交是被包含在某些分支中的一个，但是不在你当前的分支上。 Git 允许你在任意引用前加上 ^ 字符或者 --not 来指明你不希望提交被包含其中的分支。 因此下列三个命令是等价的：\n\n$ git log refA..refB\n$ git log ^refA refB\n$ git log refB --not refA\n\n\n这个语法很好用，因为你可以在查询中指定超过两个的引用，这是双点语法无法实现的。 比如，你想查看所有被 refA 或 refB 包含的但是不被 refC 包含的提交，你可以使用以下任意一个命令：\n\n$ git log refA refB ^refC\n$ git log refA refB --not refC\n\n\n这就构成了一个十分强大的修订查询系统，你可以通过它来查看你的分支里包含了哪些东西。\n\n\n# 三点\n\n最后一种主要的区间选择语法是三点，这个语法可以选择出被两个引用 之一 包含但又不被两者同时包含的提交。 再看看之前双点例子中的提交历史。 如果你想看 master 或者 experiment 中包含的但不是两者共有的提交，你可以执行：\n\n$ git log master...experiment\nF\nE\nD\nC\n\n\n这和通常 log 按日期排序的输出一样，仅仅给出了4个提交的信息。\n\n这种情形下，log 命令的一个常用参数是 --left-right，它会显示每个提交到底处于哪一侧的分支。 这会让输出数据更加清晰。\n\n$ git log --left-right master...experiment\n< F\n< E\n> D\n> C\n\n\n有了这些工具，你就可以十分方便地查看你 Git 仓库中的提交。",normalizedContent:"# git工具-查看修订版本\n\ngit 能够以多种方式来指定单个提交、一组提交、或者一定范围内的提交。 了解它们并不是必需的，但是了解一下总没坏处。\n\n修订版本指的是：提交\n\n\n# 单个修订版本\n\n你可以通过任意一个提交的 40 个字符的完整 sha-1 散列值来指定它， 不过还有很多更人性化的方式来做同样的事情。本节将会介绍获取单个提交的多种方法。\n\n\n# 简短的 sha-1\n\ngit 十分智能，你只需要提供 sha-1 的前几个字符就可以获得对应的那次提交， 当然你提供的 sha-1 字符数量不得少于 4 个，并且没有歧义——也就是说， 当前对象数据库中没有其它对象以这段 sha-1 开头。\n\n例如，要查看你知道其中添加了某个功能的提交，首先运行 git log 命令来定位该提交：\n\n$ git log\ncommit 734713bc047d87bf7eac9674765ae793478c50d3\nauthor: scott chacon <schacon@gmail.com>\ndate:   fri jan 2 18:32:33 2009 -0800\n\n    fixed refs handling, added gc auto, updated tests\n\ncommit d921970aadf03b3cf0e71becdaab3147ba71cdef\nmerge: 1c002dd... 35cfb2b...\nauthor: scott chacon <schacon@gmail.com>\ndate:   thu dec 11 15:08:43 2008 -0800\n\n    merge commit 'phedders/rdocs'\n\ncommit 1c002dd4b536e7479fe34593e72e6c6c1819e53b\nauthor: scott chacon <schacon@gmail.com>\ndate:   thu dec 11 14:58:32 2008 -0800\n\n    added some blame and merge stuff\n\n\n\n# 查看给定sha-1值的提交\n\n在本例中，假设你想要的提交其 sha-1 以 1c002dd.... 开头， 那么你可以用如下几种 git show 的变体来检视该提交（假设简短的版本没有歧义）：\n\n$ git show 1c002dd4b536e7479fe34593e72e6c6c1819e53b\n$ git show 1c002dd4b536e7479f\n$ git show 1c002d\n\n\ngit 可以为 sha-1 值生成出简短且唯一的缩写。 如果你在 git log 后加上 --abbrev-commit 参数，输出结果里就会显示简短且唯一的值； 默认使用七个字符，不过有时为了避免 sha-1 的歧义，会增加字符数：\n\n$ git log --abbrev-commit --pretty=oneline\nca82a6d changed the version number\n085bb3b removed unnecessary test code\na11bef0 first commit\n\n\n通常 8 到 10 个字符就已经足够在一个项目中避免 sha-1 的歧义。 例如，到 2019 年 2 月为止，linux 内核这个相当大的 git 项目， 其对象数据库中有超过 875,000 个提交，包含七百万个对象，也只需要前 12 个字符就能保证唯一性。\n\nnote   关于 sha-1 的简短说明许多人觉得他们的仓库里有可能出现两个不同的对象其 sha-1 值相同。\n       然后呢？如果你真的向仓库里提交了一个对象，它跟之前的某个 不同 对象的 sha-1 值相同， git\n       会发现该对象的散列值已经存在于仓库里了，于是就会认为该对象被写入，然后直接使用它。\n       如果之后你想检出那个对象时，你将得到先前那个对象的数据。但是这种情况发生的概率十分渺小。 sha-1 摘要长度是 20\n       字节，也就是 160 位。 2^80 个随机哈希对象才有 50% 的概率出现一次冲突 （计算冲突机率的公式是 p =\n       (n(n-1)/2) * (1/2^160)) ）。 2^80 是 1.2 x\n       10^24，也就是一亿亿亿，这是地球上沙粒总数的 1200 倍。举例说一下怎样才能产生一次 sha-1 冲突。\n       如果地球上 65 亿个人类都在编程，每人每秒都在产生等价于整个 linux 内核历史（650 万个 git\n       对象）的代码， 并将之提交到一个巨大的 git 仓库里面，这样持续两年的时间才会产生足够的对象， 使其拥有 50%\n       的概率产生一次 sha-1 对象冲突， 这比你编程团队的成员同一个晚上在互不相干的意外中被狼袭击并杀死的机率还要小。\n       \n\n\n# 分支引用\n\n引用特定提交的一种直接方法是，若它是一个分支的顶端的提交， 那么可以在任何需要引用该提交的 git 命令中直接使用该分支的名称。\n\n\n# 查看最后一次提交\n\n例如，你想要查看一个分支的最后一次提交的对象，假设 topic1 分支指向提交 ca82a6d... ， 那么以下的命令是等价的：\n\n$ git show ca82a6dff817ec66f44342007202690a93763949\n$ git show topic1  # topic1是分支名\n\n\n如果你想知道某个分支指向哪个特定的 sha-1，或者想看任何一个例子中被简写的 sha-1， 你可以使用一个叫做 rev-parse 的 git 探测工具。 你可以在 git 内部原理 中查看更多关于探测工具的信息。 简单来说，rev-parse 是为了底层操作而不是日常操作设计的。 不过，有时你想看 git 现在到底处于什么状态时，它可能会很有用。 你可以在你的分支上执行 rev-parse\n\n$ git rev-parse topic1\nca82a6dff817ec66f44342007202690a93763949\n\n\n\n# 引用日志\n\n\n# head的指向历史\n\n当你在工作时， git 会在后台保存一个引用日志（reflog）， 引用日志记录了最近几个月你的 head 和分支引用所指向的历史。\n\n你可以使用 git reflog 来查看引用日志\n\n$ git reflog\n734713b head@{0}: commit: fixed refs handling, added gc auto, updated\nd921970 head@{1}: merge phedders/rdocs: merge made by the 'recursive' strategy.\n1c002dd head@{2}: commit: added some blame and merge stuff\n1c36188 head@{3}: rebase -i (squash): updating head\n95df984 head@{4}: commit: # this is a combination of two commits.\n1c36188 head@{5}: rebase -i (squash): updating head\n7e05da5 head@{6}: rebase -i (pick): updating head\n\n\n每当你的 head 所指向的位置发生了变化，git 就会将这个信息存储到引用日志这个历史记录里。 你也可以通过 reflog 数据来获取之前的提交历史。 如果你想查看仓库中 head 在五次前的所指向的提交，你可以使用 @{n} 来引用 reflog 中输出的提交记录。\n\n$ git show head@{5}\n\n\n你同样可以使用这个语法来查看某个分支在一定时间前的位置。 例如，查看你的 master 分支在昨天的时候指向了哪个提交，你可以输入\n\n$ git show master@{yesterday}\n\n\n就会显示昨天 master 分支的顶端指向了哪个提交。 这个方法只对还在你引用日志里的数据有用，所以不能用来查好几个月之前的提交。\n\n可以运行 git log -g 来查看类似于 git log 输出格式的引用日志信息：\n\n$ git log -g master\ncommit 734713bc047d87bf7eac9674765ae793478c50d3\nreflog: master@{0} (scott chacon <schacon@gmail.com>)\nreflog message: commit: fixed refs handling, added gc auto, updated\nauthor: scott chacon <schacon@gmail.com>\ndate:   fri jan 2 18:32:33 2009 -0800\n\n    fixed refs handling, added gc auto, updated tests\n\ncommit d921970aadf03b3cf0e71becdaab3147ba71cdef\nreflog: master@{1} (scott chacon <schacon@gmail.com>)\nreflog message: merge phedders/rdocs: merge made by recursive.\nauthor: scott chacon <schacon@gmail.com>\ndate:   thu dec 11 15:08:43 2008 -0800\n\n    merge commit 'phedders/rdocs'\n\n\n值得注意的是，引用日志只存在于本地仓库，它只是一个记录你在 自己 的仓库里做过什么的日志。 其他人拷贝的仓库里的引用日志不会和你的相同，而你新克隆一个仓库的时候，引用日志是空的，因为你在仓库里还没有操作。 git show head@{2.months.ago} 这条命令只有在你克隆了一个项目至少两个月时才会显示匹配的提交—— 如果你刚刚克隆了仓库，那么它将不会有任何结果返回。\n\ntip   将引用日志想作 git 版的 shell 历史记录如果你有 unix 或者 linux 的背景，不妨将引用日志想作\n      git 版的 shell 历史记录， 重点在于仅与你和你的会话相关，而与他人无关。\n      \n\n\n# 祖先引用\n\n祖先引用是另一种指明一个提交的方式。 如果你在引用的尾部加上一个 ^（脱字符）， git 会将其解析为该引用的上一个提交。 假设你的提交历史是：\n\n$ git log --pretty=format:'%h %s' --graph\n* 734713b fixed refs handling, added gc auto, updated tests\n*   d921970 merge commit 'phedders/rdocs'\n|\\\n| * 35cfb2b some rdoc changes\n* | 1c002dd added some blame and merge stuff\n|/\n* 1c36188 ignore *.gem\n* 9b29157 add open3_detach to gemspec file list\n\n\n你可以使用 head^ 来查看上一个提交，也就是 “head 的父提交”：\n\n$ git show head^\ncommit d921970aadf03b3cf0e71becdaab3147ba71cdef\nmerge: 1c002dd... 35cfb2b...\nauthor: scott chacon <schacon@gmail.com>\ndate:   thu dec 11 15:08:43 2008 -0800\n\n    merge commit 'phedders/rdocs'\n\n\nnote   在 windows 上转义脱字符在 windows 的 cmd.exe 中，^ 是一个特殊字符，因此需要区别对待。\n       你可以双写它或者将提交引用放在引号中：$ git show head^ # 在 windows 上无法工作 $ git\n       show head^^ # 可以 $ git show \"head^\" # 可以\n       \n\n你也可以在 ^ 后面添加一个数字来指明想要 哪一个 父提交——例如 d921970^2 代表 “d921970 的第二父提交” 这个语法只适用于合并的提交，因为合并提交会有多个父提交。 合并提交的第一父提交是你合并时所在分支（通常为 master），而第二父提交是你所合并的分支（例如 topic）：\n\n$ git show d921970^\ncommit 1c002dd4b536e7479fe34593e72e6c6c1819e53b\nauthor: scott chacon <schacon@gmail.com>\ndate:   thu dec 11 14:58:32 2008 -0800\n\n    added some blame and merge stuff\n\n$ git show d921970^2\ncommit 35cfb2b795a55793d7cc56a6cc2060b4bb732548\nauthor: paul hedderly <paul+git@mjr.org>\ndate:   wed dec 10 22:22:03 2008 +0000\n\n    some rdoc changes\n\n\n另一种指明祖先提交的方法是 ~（波浪号）。 同样是指向第一父提交，因此 head~ 和 head^ 是等价的。 而区别在于你在后面加数字的时候。 head~2 代表“第一父提交的第一父提交”，也就是“祖父提交”——git 会根据你指定的次数获取对应的第一父提交。 例如，在之前的列出的提交历史中，head~3 就是\n\n$ git show head~3\ncommit 1c3618887afb5fbcbea25b7c013f4e2114448b8d\nauthor: tom preston-werner <tom@mojombo.com>\ndate:   fri nov 7 13:47:59 2008 -0500\n\n    ignore *.gem\n\n\n也可以写成 head~~~，也是第一父提交的第一父提交的第一父提交：\n\n$ git show head~~~\ncommit 1c3618887afb5fbcbea25b7c013f4e2114448b8d\nauthor: tom preston-werner <tom@mojombo.com>\ndate:   fri nov 7 13:47:59 2008 -0500\n\n    ignore *.gem\n\n\n你也可以组合使用这两个语法——你可以通过 head~3^2 来取得之前引用的第二父提交（假设它是一个合并提交）。\n\n\n# 提交区间\n\n你已经学会如何单次的提交，现在来看看如何指明一定区间的提交。 当你有很多分支时，这对管理你的分支时十分有用， 你可以用提交区间来解决“这个分支还有哪些提交尚未合并到主分支？”的问题\n\n\n# 双点\n\n最常用的指明提交区间语法是双点。 这种语法可以让 git 选出在一个分支中而不在另一个分支中的提交。 例如，你有如下的提交历史 example history for range selection.\n\n\n\nfigure 137. example history for range selection.\n\n你想要查看 experiment 分支中还有哪些提交尚未被合并入 master 分支。 你可以使用 master..experiment 来让 git 显示这些提交。也就是“在 experiment 分支中而不在 master 分支中的提交”。 为了使例子简单明了，我使用了示意图中提交对象的字母来代替真实日志的输出，所以会显示：\n\n$ git log master..experiment\nd\nc\n\n\n反过来，如果你想查看在 master 分支中而不在 experiment 分支中的提交，你只要交换分支名即可。 experiment..master 会显示在 master 分支中而不在 experiment 分支中的提交：\n\n$ git log experiment..master\nf\ne\n\n\n# 查看即将推送到远端的内容\n\n这可以让你保持 experiment 分支跟随最新的进度以及查看你即将合并的内容。 另一个常用的场景是查看你即将推送到远端的内容：\n\n$ git log origin/master..head\n\n\n这个命令会输出在你当前分支中而不在远程 origin 中的提交。 如果你执行 git push 并且你的当前分支正在跟踪 origin/master，由 git log origin/master..head 所输出的提交就是会被传输到远端服务器的提交。如果你留空了其中的一边， git 会默认为 head。 例如， git log origin/master.. 将会输出与之前例子相同的结果 —— git 使用 head 来代替留空的一边。\n\n\n# 多点\n\n双点语法很好用，但有时候你可能需要两个以上的分支才能确定你所需要的修订， 比如查看哪些提交是被包含在某些分支中的一个，但是不在你当前的分支上。 git 允许你在任意引用前加上 ^ 字符或者 --not 来指明你不希望提交被包含其中的分支。 因此下列三个命令是等价的：\n\n$ git log refa..refb\n$ git log ^refa refb\n$ git log refb --not refa\n\n\n这个语法很好用，因为你可以在查询中指定超过两个的引用，这是双点语法无法实现的。 比如，你想查看所有被 refa 或 refb 包含的但是不被 refc 包含的提交，你可以使用以下任意一个命令：\n\n$ git log refa refb ^refc\n$ git log refa refb --not refc\n\n\n这就构成了一个十分强大的修订查询系统，你可以通过它来查看你的分支里包含了哪些东西。\n\n\n# 三点\n\n最后一种主要的区间选择语法是三点，这个语法可以选择出被两个引用 之一 包含但又不被两者同时包含的提交。 再看看之前双点例子中的提交历史。 如果你想看 master 或者 experiment 中包含的但不是两者共有的提交，你可以执行：\n\n$ git log master...experiment\nf\ne\nd\nc\n\n\n这和通常 log 按日期排序的输出一样，仅仅给出了4个提交的信息。\n\n这种情形下，log 命令的一个常用参数是 --left-right，它会显示每个提交到底处于哪一侧的分支。 这会让输出数据更加清晰。\n\n$ git log --left-right master...experiment\n< f\n< e\n> d\n> c\n\n\n有了这些工具，你就可以十分方便地查看你 git 仓库中的提交。",charsets:{cjk:!0},lastUpdated:"2023/11/19, 12:55:48",lastUpdatedTimestamp:1700369748e3},{title:"02质数问题",frontmatter:{title:"02质数问题",date:"2023-03-24T18:39:49.000Z",permalink:"/pages/8d884e/"},regularPath:"/03.LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/05.%E5%85%B6%E4%BB%96%E5%86%85%E5%AE%B9/01.%E6%95%B0%E5%AD%A6%E9%97%AE%E9%A2%98/02.%E8%B4%A8%E6%95%B0%E9%97%AE%E9%A2%98.html",relativePath:"03.LeetCode刷题笔记/05.其他内容/01.数学问题/02.质数问题.md",key:"v-300c680b",path:"/pages/8d884e/",headers:[{level:2,title:"02 质数问题",slug:"_02-质数问题",normalizedTitle:"02 质数问题",charIndex:2},{level:4,title:"204 计数质数",slug:"_204-计数质数",normalizedTitle:"204 计数质数",charIndex:84},{level:4,title:"172 阶乘后的零",slug:"_172-阶乘后的零",normalizedTitle:"172 阶乘后的零",charIndex:962}],headersStr:"02 质数问题 204 计数质数 172 阶乘后的零",content:"# 02 质数问题\n\n质数又称素数，指的是指在大于 1 的自然数中，除了 1 和它本身以外不再有其他因数的自然数。值得注意的是，每一个数都可以分解成质数的乘积。\n\n# 204 计数质数\n\n给定一个数字 n，求小于 n 的质数的个数。\n\n输入一个整数，输出也是一个整数，表示小于输入数的质数的个数。\n\n> 输入：n = 10\n> 输出：4\n> 解释：小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。\n\n解析：\n\n埃拉托斯特尼筛法（Sieve of Eratosthenes，简称埃氏筛法）是非常常用的，判断一个整数是否是质数的方法。并且它可以在判断一个整数 n 时，同时判断所小于 n 的整数，因此非常适合这道题。其原理也十分易懂：从 1 到 n 遍历，假设当前遍历到 m，则把所有小于 n 的、且是 m 的倍数的整数标为和数；遍历完成后，没有被标为和数的数字即为质数。\n\n一般情况下标记和数时从 2m 开始标记，此处可以进一步优化，对于一个质数 m，如果从 2m 开始标记其实是冗余的，应该直接从 m^2 开始标记，因为 2m, 3m, … 这些数一定在 m^2 之前就被其他数的倍数标记过了，例如 2 的所有倍数，3 的所有倍数等。\n\nclass Solution {\npublic:\n    int countPrimes(int n) {\n        vector<bool> prime(n,true);\n        int ans = 0;\n        for(int i=2;i<n;++i){\n            if(prime[i]){\n                ++ans;\n                if((long long)i*i < n){ // i^2 可能越界 用长整型表示\n                    for(int j=i*i;j<n;j+=i){\n                        prime[j] = false;\n                    }\n                }\n            }\n        }\n        return ans;\n    }\n};\n\n\n# 172 阶乘后的零\n\n给定一个非负整数，判断它的阶乘结果的结尾有几个 0。\n\n输入一个非负整数，输出一个非负整数，表示输入的阶乘结果的结尾有几个 0。\n\n> 输入：n = 5\n> 输出：1\n> 解释：5! = 120 ，有一个尾随 0\n\n解析：\n\n唯一分解定理：任何一个大于1的自然数 N，如果 N 不为质数，那么 N 可以唯一分解成有限个质数的乘积。例如：42 = 2×3×7, 75 = 3×5×5。\n\n每个尾部的 0 由 2 × 5 = 10 而来，因此可以把阶乘的每一个元素拆成质数相乘，统计有多少个 2 和 5 数对。明显的，质因子 2 的数量远多于质因子 5 的数量，因为每 4 个数字算作额外的因子 2，但是只有每 25 个数字算作额外的因子 5，因此可以进一步优化只统计阶乘结果里有多少个质因子 5。\n\n对于一个数的阶乘，就如之前分析的，5 的因子一定是每隔 5 个数出现一次，也就是下边的样子。n! = 1 * 2 * 3 * 4 * (1 * 5) * ... * (2 * 5) * ... * (3 * 5) *... * n。因为每隔 5 个数出现一个 5，所以计算出现了多少个 5，我们只需要用 n/5 就可以算出来。\n\n但还没有结束，继续分析。... * (1 * 5) * ... * (1 * 5 * 5) * ... * (2 * 5 * 5) * ... * (3 * 5 * 5) * ... * n。每隔 25 个数字，出现的是两个 5，所以除了每隔 5 个数算作一个 5，每隔 25 个数，还需要多算一个 5。也就是我们需要再加上 n / 25 个 5。\n\n同理还会有每隔 5 * 5 * 5 = 125 个数字，会出现 3 个 5，所以还需要再加上 n / 125 。\n\n综上，规律就是每隔 5 个数，出现一个 5，每隔 25 个数，出现 2 个 5，每隔 125 个数，出现 3 个 5... 以此类推。最终 5 的个数就是 n / 5 + n / 25 + n / 125 ...\n\nclass Solution {\npublic:\n    int trailingZeroes(int n) {\n        if(n==0){\n            return 0;\n        }\n        int a = n / 5;\n        return a + trailingZeroes(a);\n    }\n};\n",normalizedContent:"# 02 质数问题\n\n质数又称素数，指的是指在大于 1 的自然数中，除了 1 和它本身以外不再有其他因数的自然数。值得注意的是，每一个数都可以分解成质数的乘积。\n\n# 204 计数质数\n\n给定一个数字 n，求小于 n 的质数的个数。\n\n输入一个整数，输出也是一个整数，表示小于输入数的质数的个数。\n\n> 输入：n = 10\n> 输出：4\n> 解释：小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。\n\n解析：\n\n埃拉托斯特尼筛法（sieve of eratosthenes，简称埃氏筛法）是非常常用的，判断一个整数是否是质数的方法。并且它可以在判断一个整数 n 时，同时判断所小于 n 的整数，因此非常适合这道题。其原理也十分易懂：从 1 到 n 遍历，假设当前遍历到 m，则把所有小于 n 的、且是 m 的倍数的整数标为和数；遍历完成后，没有被标为和数的数字即为质数。\n\n一般情况下标记和数时从 2m 开始标记，此处可以进一步优化，对于一个质数 m，如果从 2m 开始标记其实是冗余的，应该直接从 m^2 开始标记，因为 2m, 3m, … 这些数一定在 m^2 之前就被其他数的倍数标记过了，例如 2 的所有倍数，3 的所有倍数等。\n\nclass solution {\npublic:\n    int countprimes(int n) {\n        vector<bool> prime(n,true);\n        int ans = 0;\n        for(int i=2;i<n;++i){\n            if(prime[i]){\n                ++ans;\n                if((long long)i*i < n){ // i^2 可能越界 用长整型表示\n                    for(int j=i*i;j<n;j+=i){\n                        prime[j] = false;\n                    }\n                }\n            }\n        }\n        return ans;\n    }\n};\n\n\n# 172 阶乘后的零\n\n给定一个非负整数，判断它的阶乘结果的结尾有几个 0。\n\n输入一个非负整数，输出一个非负整数，表示输入的阶乘结果的结尾有几个 0。\n\n> 输入：n = 5\n> 输出：1\n> 解释：5! = 120 ，有一个尾随 0\n\n解析：\n\n唯一分解定理：任何一个大于1的自然数 n，如果 n 不为质数，那么 n 可以唯一分解成有限个质数的乘积。例如：42 = 2×3×7, 75 = 3×5×5。\n\n每个尾部的 0 由 2 × 5 = 10 而来，因此可以把阶乘的每一个元素拆成质数相乘，统计有多少个 2 和 5 数对。明显的，质因子 2 的数量远多于质因子 5 的数量，因为每 4 个数字算作额外的因子 2，但是只有每 25 个数字算作额外的因子 5，因此可以进一步优化只统计阶乘结果里有多少个质因子 5。\n\n对于一个数的阶乘，就如之前分析的，5 的因子一定是每隔 5 个数出现一次，也就是下边的样子。n! = 1 * 2 * 3 * 4 * (1 * 5) * ... * (2 * 5) * ... * (3 * 5) *... * n。因为每隔 5 个数出现一个 5，所以计算出现了多少个 5，我们只需要用 n/5 就可以算出来。\n\n但还没有结束，继续分析。... * (1 * 5) * ... * (1 * 5 * 5) * ... * (2 * 5 * 5) * ... * (3 * 5 * 5) * ... * n。每隔 25 个数字，出现的是两个 5，所以除了每隔 5 个数算作一个 5，每隔 25 个数，还需要多算一个 5。也就是我们需要再加上 n / 25 个 5。\n\n同理还会有每隔 5 * 5 * 5 = 125 个数字，会出现 3 个 5，所以还需要再加上 n / 125 。\n\n综上，规律就是每隔 5 个数，出现一个 5，每隔 25 个数，出现 2 个 5，每隔 125 个数，出现 3 个 5... 以此类推。最终 5 的个数就是 n / 5 + n / 25 + n / 125 ...\n\nclass solution {\npublic:\n    int trailingzeroes(int n) {\n        if(n==0){\n            return 0;\n        }\n        int a = n / 5;\n        return a + trailingzeroes(a);\n    }\n};\n",charsets:{cjk:!0},lastUpdated:"2023/11/19, 12:55:48",lastUpdatedTimestamp:1700369748e3},{title:"问答",frontmatter:{title:"问答",date:"2020-05-25T12:01:52.000Z",permalink:"/pages/9cc27d",article:!1},regularPath:"/06.FixBug/01.%E9%97%AE%E7%AD%94.html",relativePath:"06.FixBug/01.问答.md",key:"v-c6e0a240",path:"/pages/9cc27d/",headers:[{level:2,title:"我是一个小白，想使用这个主题搭建博客（知识库）需要做哪些工作？",slug:"我是一个小白-想使用这个主题搭建博客-知识库-需要做哪些工作",normalizedTitle:"我是一个小白，想使用这个主题搭建博客（知识库）需要做哪些工作？",charIndex:2},{level:2,title:"clone 项目后需要修改哪些地方？",slug:"clone-项目后需要修改哪些地方",normalizedTitle:"clone 项目后需要修改哪些地方？",charIndex:220},{level:2,title:"可减少项目冗余的地方有哪些？",slug:"可减少项目冗余的地方有哪些",normalizedTitle:"可减少项目冗余的地方有哪些？",charIndex:371},{level:2,title:"我可以不使用永久链接吗？",slug:"我可以不使用永久链接吗",normalizedTitle:"我可以不使用永久链接吗？",charIndex:533},{level:2,title:"是否支持国际化？",slug:"是否支持国际化",normalizedTitle:"是否支持国际化？",charIndex:756},{level:2,title:"打包后在本地预览怎么没有样式？",slug:"打包后在本地预览怎么没有样式",normalizedTitle:"打包后在本地预览怎么没有样式？",charIndex:834},{level:2,title:"在build时出现错误，但是在dev时是正常的",slug:"在build时出现错误-但是在dev时是正常的",normalizedTitle:"在build时出现错误，但是在dev时是正常的",charIndex:974}],headersStr:"我是一个小白，想使用这个主题搭建博客（知识库）需要做哪些工作？ clone 项目后需要修改哪些地方？ 可减少项目冗余的地方有哪些？ 我可以不使用永久链接吗？ 是否支持国际化？ 打包后在本地预览怎么没有样式？ 在build时出现错误，但是在dev时是正常的",content:"# 我是一个小白，想使用这个主题搭建博客（知识库）需要做哪些工作？\n\n答：使用这个主题前需要你掌握下面这些知识：\n\n * 掌握 markdown、yaml 语法\n * 会使用终端（命令行），会使用 git\n * 会阅读文档、搜索文档\n * 会VuePress的基本使用和默认主题的基本配置\n\n以上知识都掌握之后，再查看本文档。你也可以运行我的主题项目，一边看代码，一边查看文档。主题项目内写了比较多的注释代码，方便你的学习和使用。\n\n\n# clone 项目后需要修改哪些地方？\n\n答：大致的修改流程是这样的：\n\n 1. 首先让项目正常的跑起来\n 2. 根据需求构建和替换 docs/<结构化目录> 的目录及内容\n 3. 根据需求修改 config.js 配置\n 4. 修改 首页配置\n 5. 修改 主题颜色和样式（如果你想修改的话）\n\n\n# 可减少项目冗余的地方有哪些？\n\n答：在完成项目的搭建之后，对于没有使用到的一些文件和代码，可以看情况删减，可删减的地方有:\n\n * 卸载config.js中未使用的插件依赖包\n * 参照 目录结构，删除未使用到的 可选 文件\n * 删除.vusepress目录内未使用到的 可选 文件\n * 删除各文件内的注释代码\n\n\n# 我可以不使用永久链接吗？\n\n答：不可以。当你没有在front matter指定永久链接时，主题会自动生成永久链接到front matter，你可以修改永久链接的值。 使用永久链接是出于以下几点考虑:\n\n 1. 在config.js配置nav时使用永久链接，就不会因为文件的路径或名称的改变而改变。\n 2. 对于博客而言，当别人收藏了你的文章，在未来的时间里都可以通过永久链接来访问到。\n 3. 主题中的目录页需要通过永久链接来访问文章。\n\n\n# 是否支持国际化？\n\n答：暂不支持。目前的国际化方案，只能是使用不同项目来处理，比如：一个项目是中文，一个项目是英文，在导航中添加中英文站点的链接。\n\n\n# 打包后在本地预览怎么没有样式？\n\n答：因vuepress打包后的CSS、JS等资源链接采用绝对路径引入，在本地预览时的引入链接是不正确的，部署到服务器即可正常引入和预览。如果你确实需要本地预览，可以使用vuepress-plugin-serve插件，使用方法看相应文档。\n\n\n# 在build时出现错误，但是在dev时是正常的\n\n答：这种情况多半是因为你在created或beforeCreate生命周期调用了浏览器API的原因导致，详情查看：浏览器的 API 访问限制",normalizedContent:"# 我是一个小白，想使用这个主题搭建博客（知识库）需要做哪些工作？\n\n答：使用这个主题前需要你掌握下面这些知识：\n\n * 掌握 markdown、yaml 语法\n * 会使用终端（命令行），会使用 git\n * 会阅读文档、搜索文档\n * 会vuepress的基本使用和默认主题的基本配置\n\n以上知识都掌握之后，再查看本文档。你也可以运行我的主题项目，一边看代码，一边查看文档。主题项目内写了比较多的注释代码，方便你的学习和使用。\n\n\n# clone 项目后需要修改哪些地方？\n\n答：大致的修改流程是这样的：\n\n 1. 首先让项目正常的跑起来\n 2. 根据需求构建和替换 docs/<结构化目录> 的目录及内容\n 3. 根据需求修改 config.js 配置\n 4. 修改 首页配置\n 5. 修改 主题颜色和样式（如果你想修改的话）\n\n\n# 可减少项目冗余的地方有哪些？\n\n答：在完成项目的搭建之后，对于没有使用到的一些文件和代码，可以看情况删减，可删减的地方有:\n\n * 卸载config.js中未使用的插件依赖包\n * 参照 目录结构，删除未使用到的 可选 文件\n * 删除.vusepress目录内未使用到的 可选 文件\n * 删除各文件内的注释代码\n\n\n# 我可以不使用永久链接吗？\n\n答：不可以。当你没有在front matter指定永久链接时，主题会自动生成永久链接到front matter，你可以修改永久链接的值。 使用永久链接是出于以下几点考虑:\n\n 1. 在config.js配置nav时使用永久链接，就不会因为文件的路径或名称的改变而改变。\n 2. 对于博客而言，当别人收藏了你的文章，在未来的时间里都可以通过永久链接来访问到。\n 3. 主题中的目录页需要通过永久链接来访问文章。\n\n\n# 是否支持国际化？\n\n答：暂不支持。目前的国际化方案，只能是使用不同项目来处理，比如：一个项目是中文，一个项目是英文，在导航中添加中英文站点的链接。\n\n\n# 打包后在本地预览怎么没有样式？\n\n答：因vuepress打包后的css、js等资源链接采用绝对路径引入，在本地预览时的引入链接是不正确的，部署到服务器即可正常引入和预览。如果你确实需要本地预览，可以使用vuepress-plugin-serve插件，使用方法看相应文档。\n\n\n# 在build时出现错误，但是在dev时是正常的\n\n答：这种情况多半是因为你在created或beforecreate生命周期调用了浏览器api的原因导致，详情查看：浏览器的 api 访问限制",charsets:{cjk:!0},lastUpdated:"2023/11/19, 12:55:48",lastUpdatedTimestamp:1700369748e3},{title:"一行代码“黑”掉任意网站",frontmatter:{title:"一行代码“黑”掉任意网站",date:"2021-11-25T14:33:51.000Z",permalink:"/pages/dcebaf/",titleTag:"原创",sticky:1,categories:["更多","实用技巧"],tags:["JavaScript","css","实用技巧"],author:{name:"王清欢",link:"https://github.com/wang-haihua"}},regularPath:"/07.%E8%83%A1%E6%80%9D%E4%B9%B1%E6%83%B3/01.%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/02.%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%E2%80%9C%E9%BB%91%E2%80%9D%E6%8E%89%E4%BB%BB%E6%84%8F%E7%BD%91%E7%AB%99.html",relativePath:"07.胡思乱想/01.实用技巧/02.一行代码“黑”掉任意网站.md",key:"v-e9633f54",path:"/pages/dcebaf/",excerpt:'<h1 id="一行代码-黑-掉任意网站"><a class="header-anchor" href="#一行代码-黑-掉任意网站">#</a> 一行代码“黑”掉任意网站</h1>\n<p>实用技巧：只需一行代码，轻轻一点就可以把任意网站变成暗黑模式。\n<p align="center"><img src="https://cdn.staticaly.com/gh/xugaoyi/image_store@master/blog/QQ20211125-163111.2tmjlvz28n80.png" width="500" style="cursor: zoom-in;"></p></p>\n',headersStr:null,content:"# 一行代码“黑”掉任意网站\n\n实用技巧：只需一行代码，轻轻一点就可以把任意网站变成暗黑模式。\n\n\n\n\n\n首先我们先做一个实验，在任意网站中，打开浏览器开发者工具(F12)，在Console控制台输入如下代码并回车：\n\ndocument.documentElement.style.filter='invert(85%) hue-rotate(180deg)'\n\n\n神奇的事情发生了，当前打开的网站变成了暗黑模式。\n\n原理解释\n 1. document.documentElement 获取文档对象的根元素，即<html>元素\n 2. 给html元素的.style样式添加filter滤镜样式为invert(85%) hue-rotate(180deg)\n 3. invert() 反转图像。\n 4. hue-rotate()色相旋转。\n\n更多滤镜知识：filter。\n\n为了更方便实用，达到轻轻一点就可以对网页施加魔法🎉，\n\n我们对代码做了一点点🤏🏻改动。（修正了滤镜对图片等元素的影响）\n\njavascript: (function () {  const docStyle = document.documentElement.style;  if (!window.modeIndex) {    window.modeIndex = 0;  }  const styleList = [    '',    'invert(85%) hue-rotate(180deg)',   'invert(100%) hue-rotate(180deg)',  ];  modeIndex = modeIndex >= styleList.length - 1 ? 0 : modeIndex + 1;  docStyle.filter = styleList[modeIndex];  document.body.querySelectorAll('img, picture, video').forEach(el => el.style.filter = modeIndex ? 'invert(1) hue-rotate(180deg)' : '');})();\n\n\n然后打开浏览器书签管理器，添加新书签，在网址栏粘贴这段代码并保存：\n\n\n\n\n\n以后在任意网站，只需要轻轻一点切换模式书签就可以让它变成85%的暗黑，再点一次就是100%的暗黑，再点一次变回正常模式。\n\n",normalizedContent:"# 一行代码“黑”掉任意网站\n\n实用技巧：只需一行代码，轻轻一点就可以把任意网站变成暗黑模式。\n\n\n\n\n\n首先我们先做一个实验，在任意网站中，打开浏览器开发者工具(f12)，在console控制台输入如下代码并回车：\n\ndocument.documentelement.style.filter='invert(85%) hue-rotate(180deg)'\n\n\n神奇的事情发生了，当前打开的网站变成了暗黑模式。\n\n原理解释\n 1. document.documentelement 获取文档对象的根元素，即<html>元素\n 2. 给html元素的.style样式添加filter滤镜样式为invert(85%) hue-rotate(180deg)\n 3. invert() 反转图像。\n 4. hue-rotate()色相旋转。\n\n更多滤镜知识：filter。\n\n为了更方便实用，达到轻轻一点就可以对网页施加魔法🎉，\n\n我们对代码做了一点点🤏🏻改动。（修正了滤镜对图片等元素的影响）\n\njavascript: (function () {  const docstyle = document.documentelement.style;  if (!window.modeindex) {    window.modeindex = 0;  }  const stylelist = [    '',    'invert(85%) hue-rotate(180deg)',   'invert(100%) hue-rotate(180deg)',  ];  modeindex = modeindex >= stylelist.length - 1 ? 0 : modeindex + 1;  docstyle.filter = stylelist[modeindex];  document.body.queryselectorall('img, picture, video').foreach(el => el.style.filter = modeindex ? 'invert(1) hue-rotate(180deg)' : '');})();\n\n\n然后打开浏览器书签管理器，添加新书签，在网址栏粘贴这段代码并保存：\n\n\n\n\n\n以后在任意网站，只需要轻轻一点切换模式书签就可以让它变成85%的暗黑，再点一次就是100%的暗黑，再点一次变回正常模式。\n\n",charsets:{cjk:!0},lastUpdated:"2023/11/19, 12:55:48",lastUpdatedTimestamp:1700369748e3},{title:"费曼学习法",frontmatter:{title:"费曼学习法",date:"2020-07-16T10:04:14.000Z",permalink:"/pages/f2a556/",categories:["更多","学习"],tags:["学习方法"],author:{name:"王清欢",link:"https://github.com/wang-haihua"}},regularPath:"/07.%E8%83%A1%E6%80%9D%E4%B9%B1%E6%83%B3/02.%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/00.%E8%B4%B9%E6%9B%BC%E5%AD%A6%E4%B9%A0%E6%B3%95.html",relativePath:"07.胡思乱想/02.学习方法/00.费曼学习法.md",key:"v-4d0b7bc2",path:"/pages/f2a556/",headers:[{level:3,title:"步骤",slug:"步骤",normalizedTitle:"步骤",charIndex:102}],headersStr:"步骤",content:"费曼学习法，我很喜欢的一个学习方法，简单来说，就是：通过向别人清楚的解说某一件事或是写一篇浅显易懂的教程文章，来确认自己是否真正弄懂了这件事。 可以说是在通过向别讲解过程中来对自身的 查缺补漏。\n\n\n# 步骤\n\n费曼学习法分为4个步骤:\n\n 1. 确定学习目标\n\n你想学习的概念、内容、主题是什么。\n\n 2. 模拟教学学习法\n\n你要模拟自己是一位老师，面对完全不懂这个领域的人，用自己的话，尽可能具体形象地讲诉。这样的讲诉有助于你活学活用，触类旁通，联系生活具体情境。\n\n 3. 回顾\n\n反思第2步遇到的问题，哪些地方卡壳了，哪些地方对方没有真正听懂。找出问题的要害，把握关键环节。\n\n 4. 简化\n\n把这些遇到问题的地方，重新梳理理解，尽可能了解更多背景和相关知识，再用尽可能简化的方式重新表达，设法看穿本质。然后，返回第2步。\n\n> 参考：\n> \n> 《费曼学习法：为何被称为史上最牛的学习法，它的本质究竟是什么？》\n> \n> 《费曼学习法》",normalizedContent:"费曼学习法，我很喜欢的一个学习方法，简单来说，就是：通过向别人清楚的解说某一件事或是写一篇浅显易懂的教程文章，来确认自己是否真正弄懂了这件事。 可以说是在通过向别讲解过程中来对自身的 查缺补漏。\n\n\n# 步骤\n\n费曼学习法分为4个步骤:\n\n 1. 确定学习目标\n\n你想学习的概念、内容、主题是什么。\n\n 2. 模拟教学学习法\n\n你要模拟自己是一位老师，面对完全不懂这个领域的人，用自己的话，尽可能具体形象地讲诉。这样的讲诉有助于你活学活用，触类旁通，联系生活具体情境。\n\n 3. 回顾\n\n反思第2步遇到的问题，哪些地方卡壳了，哪些地方对方没有真正听懂。找出问题的要害，把握关键环节。\n\n 4. 简化\n\n把这些遇到问题的地方，重新梳理理解，尽可能了解更多背景和相关知识，再用尽可能简化的方式重新表达，设法看穿本质。然后，返回第2步。\n\n> 参考：\n> \n> 《费曼学习法：为何被称为史上最牛的学习法，它的本质究竟是什么？》\n> \n> 《费曼学习法》",charsets:{cjk:!0},lastUpdated:"2023/11/19, 12:55:48",lastUpdatedTimestamp:1700369748e3},{title:"Git工具-交互式暂存",frontmatter:{title:"Git工具-交互式暂存",date:"2020-11-18T17:43:57.000Z",permalink:"/pages/76d859/",categories:["《Git》学习笔记"],tags:["Git"],author:{name:"王清欢",link:"https://github.com/wang-haihua"}},regularPath:"/05.Git%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/30.Git%20%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%AC%94%E8%AE%B0/90.Git%E5%B7%A5%E5%85%B7-%E4%BA%A4%E4%BA%92%E5%BC%8F%E6%9A%82%E5%AD%98.html",relativePath:"05.Git 学习笔记/30.Git 官方文档笔记/90.Git工具-交互式暂存.md",key:"v-010c2c3e",path:"/pages/76d859/",headers:[{level:2,title:"暂存与取消暂存文件",slug:"暂存与取消暂存文件",normalizedTitle:"暂存与取消暂存文件",charIndex:728},{level:2,title:"暂存补丁",slug:"暂存补丁",normalizedTitle:"暂存补丁",charIndex:3285}],headersStr:"暂存与取消暂存文件 暂存补丁",content:'# Git工具-交互式暂存\n\n本节中的几个交互式 Git 命令可以帮助你将文件的特定部分组合成提交。 当你在修改了大量文件后，希望这些改动能拆分为若干提交而不是混杂在一起成为一个提交时，这几个工具会非常有用。 通过这种方式，可以确保提交是逻辑上独立的变更集，同时也会使其他开发者在与你工作时很容易地审核。 如果运行 git add 时使用 -i 或者 --interactive 选项，Git 将会进入一个交互式终端模式，显示类似下面的东西：\n\n$ git add -i\n           staged     unstaged path\n  1:    unchanged        +0/-1 TODO\n  2:    unchanged        +1/-1 index.html\n  3:    unchanged        +5/-1 lib/simplegit.rb\n\n*** Commands ***\n  1: [s]tatus     2: [u]pdate      3: [r]evert     4: [a]dd untracked\n  5: [p]atch      6: [d]iff        7: [q]uit       8: [h]elp\nWhat now>\n\n\n可以看到这个命令以和平时非常不同的视图显示了暂存区——基本上与 git status 是相同的信息，但是更简明扼要一些。 它将暂存的修改列在左侧，未暂存的修改列在右侧。\n\n在这块区域后是“Commands”命令区域。 在这里你可以做一些工作，包括暂存文件、取消暂存文件、暂存文件的一部分、添加未被追踪的文件、显示暂存内容的区别。\n\n\n# 暂存与取消暂存文件\n\n如果在 What now> 提示符后键入 u 或 2（更新），它会问你想要暂存哪个文件：\n\nWhat now> u\n           staged     unstaged path\n  1:    unchanged        +0/-1 TODO\n  2:    unchanged        +1/-1 index.html\n  3:    unchanged        +5/-1 lib/simplegit.rb\nUpdate>>\n\n\n要暂存 TODO 和 index.html 文件，可以输入数字：\n\nUpdate>> 1,2\n           staged     unstaged path\n* 1:    unchanged        +0/-1 TODO\n* 2:    unchanged        +1/-1 index.html\n  3:    unchanged        +5/-1 lib/simplegit.rb\nUpdate>>\n\n\n每个文件前面的 * 意味着选中的文件将会被暂存。 如果在 Update>> 提示符后不输入任何东西并直接按回车，Git 将会暂存之前选择的文件：\n\nUpdate>>\nupdated 2 paths\n\n*** Commands ***\n  1: [s]tatus     2: [u]pdate      3: [r]evert     4: [a]dd untracked\n  5: [p]atch      6: [d]iff        7: [q]uit       8: [h]elp\nWhat now> s\n           staged     unstaged path\n  1:        +0/-1      nothing TODO\n  2:        +1/-1      nothing index.html\n  3:    unchanged        +5/-1 lib/simplegit.rb\n\n\n现在可以看到 TODO 与 index.html 文件已经被暂存而 simplegit.rb 文件还未被暂存。 如果这时想要取消暂存 TODO 文件，使用 r 或 3（撤消）选项：\n\n*** Commands ***\n  1: [s]tatus     2: [u]pdate      3: [r]evert     4: [a]dd untracked\n  5: [p]atch      6: [d]iff        7: [q]uit       8: [h]elp\nWhat now> r\n           staged     unstaged path\n  1:        +0/-1      nothing TODO\n  2:        +1/-1      nothing index.html\n  3:    unchanged        +5/-1 lib/simplegit.rb\nRevert>> 1\n           staged     unstaged path\n* 1:        +0/-1      nothing TODO\n  2:        +1/-1      nothing index.html\n  3:    unchanged        +5/-1 lib/simplegit.rb\nRevert>> [enter]\nreverted one path\n\n\n再次查看 Git 状态，可以看到已经取消暂存 TODO 文件：\n\n*** Commands ***\n  1: [s]tatus     2: [u]pdate      3: [r]evert     4: [a]dd untracked\n  5: [p]atch      6: [d]iff        7: [q]uit       8: [h]elp\nWhat now> s\n           staged     unstaged path\n  1:    unchanged        +0/-1 TODO\n  2:        +1/-1      nothing index.html\n  3:    unchanged        +5/-1 lib/simplegit.rb\n\n\n如果想要查看已暂存内容的区别，可以使用 d 或 6（区别）命令。 它会显示暂存文件的一个列表，可以从中选择想要查看的暂存区别。 这跟你在命令行指定 git diff --cached 非常相似：\n\n*** Commands ***\n  1: [s]tatus     2: [u]pdate      3: [r]evert     4: [a]dd untracked\n  5: [p]atch      6: [d]iff        7: [q]uit       8: [h]elp\nWhat now> d\n           staged     unstaged path\n  1:        +1/-1      nothing index.html\nReview diff>> 1\ndiff --git a/index.html b/index.html\nindex 4d07108..4335f49 100644\n--- a/index.html\n+++ b/index.html\n@@ -16,7 +16,7 @@ Date Finder\n\n <p id="out">...</p>\n\n-<div id="footer">contact : support@github.com</div>\n+<div id="footer">contact : email.support@github.com</div>\n\n <script type="text/javascript">\n\n\n通过这些基本命令，可以使用交互式添加模式来轻松地处理暂存区。\n\n\n# 暂存补丁\n\nGit 也可以暂存文件的特定部分。 例如，如果在 simplegit.rb 文件中做了两处修改，但只想要暂存其中的一个而不是另一个，Git 会帮你轻松地完成。 在和上一节一样的交互式提示符中，输入 p 或 5（补丁）。 Git 会询问你想要部分暂存哪些文件；然后，对已选择文件的每一个部分，它都会一个个地显示文件区别并询问你是否想要暂存它们：\n\ndiff --git a/lib/simplegit.rb b/lib/simplegit.rb\nindex dd5ecc4..57399e0 100644\n--- a/lib/simplegit.rb\n+++ b/lib/simplegit.rb\n@@ -22,7 +22,7 @@ class SimpleGit\n   end\n\n   def log(treeish = \'master\')\n-    command("git log -n 25 #{treeish}")\n+    command("git log -n 30 #{treeish}")\n   end\n\n   def blame(path)\nStage this hunk [y,n,a,d,/,j,J,g,e,?]?\n\n\n这时有很多选项。 输入 ? 显示所有可以使用的命令列表：\n\nStage this hunk [y,n,a,d,/,j,J,g,e,?]? ?\ny - stage this hunk\nn - do not stage this hunk\na - stage this and all the remaining hunks in the file\nd - do not stage this hunk nor any of the remaining hunks in the file\ng - select a hunk to go to\n/ - search for a hunk matching the given regex\nj - leave this hunk undecided, see next undecided hunk\nJ - leave this hunk undecided, see next hunk\nk - leave this hunk undecided, see previous undecided hunk\nK - leave this hunk undecided, see previous hunk\ns - split the current hunk into smaller hunks\ne - manually edit the current hunk\n? - print help\n\n\n通常情况下可以输入 y 或 n 来选择是否要暂存每一个区块， 当然，暂存特定文件中的所有部分或为之后的选择跳过一个区块也是非常有用的。 如果你只暂存文件的一部分，状态输出可能会像下面这样：\n\nWhat now> 1\n           staged     unstaged path\n  1:    unchanged        +0/-1 TODO\n  2:        +1/-1      nothing index.html\n  3:        +1/-1        +4/-0 lib/simplegit.rb\n\n\nsimplegit.rb 文件的状态很有趣。 它显示出若干行被暂存与若干行未被暂存。 已经部分地暂存了这个文件。 在这时，可以退出交互式添加脚本并且运行 git commit 来提交部分暂存的文件。\n\n也可以不必在交互式添加模式中做部分文件暂存——可以在命令行中使用 git add -p 或 git add --patch 来启动同样的脚本。\n\n更进一步地，可以使用 git reset --patch 命令的补丁模式来部分重置文件， 通过 git checkout --patch 命令来部分检出文件与 git stash save --patch 命令来部分暂存文件。 我们将会在接触这些命令的高级使用方法时了解更多详细信息。',normalizedContent:'# git工具-交互式暂存\n\n本节中的几个交互式 git 命令可以帮助你将文件的特定部分组合成提交。 当你在修改了大量文件后，希望这些改动能拆分为若干提交而不是混杂在一起成为一个提交时，这几个工具会非常有用。 通过这种方式，可以确保提交是逻辑上独立的变更集，同时也会使其他开发者在与你工作时很容易地审核。 如果运行 git add 时使用 -i 或者 --interactive 选项，git 将会进入一个交互式终端模式，显示类似下面的东西：\n\n$ git add -i\n           staged     unstaged path\n  1:    unchanged        +0/-1 todo\n  2:    unchanged        +1/-1 index.html\n  3:    unchanged        +5/-1 lib/simplegit.rb\n\n*** commands ***\n  1: [s]tatus     2: [u]pdate      3: [r]evert     4: [a]dd untracked\n  5: [p]atch      6: [d]iff        7: [q]uit       8: [h]elp\nwhat now>\n\n\n可以看到这个命令以和平时非常不同的视图显示了暂存区——基本上与 git status 是相同的信息，但是更简明扼要一些。 它将暂存的修改列在左侧，未暂存的修改列在右侧。\n\n在这块区域后是“commands”命令区域。 在这里你可以做一些工作，包括暂存文件、取消暂存文件、暂存文件的一部分、添加未被追踪的文件、显示暂存内容的区别。\n\n\n# 暂存与取消暂存文件\n\n如果在 what now> 提示符后键入 u 或 2（更新），它会问你想要暂存哪个文件：\n\nwhat now> u\n           staged     unstaged path\n  1:    unchanged        +0/-1 todo\n  2:    unchanged        +1/-1 index.html\n  3:    unchanged        +5/-1 lib/simplegit.rb\nupdate>>\n\n\n要暂存 todo 和 index.html 文件，可以输入数字：\n\nupdate>> 1,2\n           staged     unstaged path\n* 1:    unchanged        +0/-1 todo\n* 2:    unchanged        +1/-1 index.html\n  3:    unchanged        +5/-1 lib/simplegit.rb\nupdate>>\n\n\n每个文件前面的 * 意味着选中的文件将会被暂存。 如果在 update>> 提示符后不输入任何东西并直接按回车，git 将会暂存之前选择的文件：\n\nupdate>>\nupdated 2 paths\n\n*** commands ***\n  1: [s]tatus     2: [u]pdate      3: [r]evert     4: [a]dd untracked\n  5: [p]atch      6: [d]iff        7: [q]uit       8: [h]elp\nwhat now> s\n           staged     unstaged path\n  1:        +0/-1      nothing todo\n  2:        +1/-1      nothing index.html\n  3:    unchanged        +5/-1 lib/simplegit.rb\n\n\n现在可以看到 todo 与 index.html 文件已经被暂存而 simplegit.rb 文件还未被暂存。 如果这时想要取消暂存 todo 文件，使用 r 或 3（撤消）选项：\n\n*** commands ***\n  1: [s]tatus     2: [u]pdate      3: [r]evert     4: [a]dd untracked\n  5: [p]atch      6: [d]iff        7: [q]uit       8: [h]elp\nwhat now> r\n           staged     unstaged path\n  1:        +0/-1      nothing todo\n  2:        +1/-1      nothing index.html\n  3:    unchanged        +5/-1 lib/simplegit.rb\nrevert>> 1\n           staged     unstaged path\n* 1:        +0/-1      nothing todo\n  2:        +1/-1      nothing index.html\n  3:    unchanged        +5/-1 lib/simplegit.rb\nrevert>> [enter]\nreverted one path\n\n\n再次查看 git 状态，可以看到已经取消暂存 todo 文件：\n\n*** commands ***\n  1: [s]tatus     2: [u]pdate      3: [r]evert     4: [a]dd untracked\n  5: [p]atch      6: [d]iff        7: [q]uit       8: [h]elp\nwhat now> s\n           staged     unstaged path\n  1:    unchanged        +0/-1 todo\n  2:        +1/-1      nothing index.html\n  3:    unchanged        +5/-1 lib/simplegit.rb\n\n\n如果想要查看已暂存内容的区别，可以使用 d 或 6（区别）命令。 它会显示暂存文件的一个列表，可以从中选择想要查看的暂存区别。 这跟你在命令行指定 git diff --cached 非常相似：\n\n*** commands ***\n  1: [s]tatus     2: [u]pdate      3: [r]evert     4: [a]dd untracked\n  5: [p]atch      6: [d]iff        7: [q]uit       8: [h]elp\nwhat now> d\n           staged     unstaged path\n  1:        +1/-1      nothing index.html\nreview diff>> 1\ndiff --git a/index.html b/index.html\nindex 4d07108..4335f49 100644\n--- a/index.html\n+++ b/index.html\n@@ -16,7 +16,7 @@ date finder\n\n <p id="out">...</p>\n\n-<div id="footer">contact : support@github.com</div>\n+<div id="footer">contact : email.support@github.com</div>\n\n <script type="text/javascript">\n\n\n通过这些基本命令，可以使用交互式添加模式来轻松地处理暂存区。\n\n\n# 暂存补丁\n\ngit 也可以暂存文件的特定部分。 例如，如果在 simplegit.rb 文件中做了两处修改，但只想要暂存其中的一个而不是另一个，git 会帮你轻松地完成。 在和上一节一样的交互式提示符中，输入 p 或 5（补丁）。 git 会询问你想要部分暂存哪些文件；然后，对已选择文件的每一个部分，它都会一个个地显示文件区别并询问你是否想要暂存它们：\n\ndiff --git a/lib/simplegit.rb b/lib/simplegit.rb\nindex dd5ecc4..57399e0 100644\n--- a/lib/simplegit.rb\n+++ b/lib/simplegit.rb\n@@ -22,7 +22,7 @@ class simplegit\n   end\n\n   def log(treeish = \'master\')\n-    command("git log -n 25 #{treeish}")\n+    command("git log -n 30 #{treeish}")\n   end\n\n   def blame(path)\nstage this hunk [y,n,a,d,/,j,j,g,e,?]?\n\n\n这时有很多选项。 输入 ? 显示所有可以使用的命令列表：\n\nstage this hunk [y,n,a,d,/,j,j,g,e,?]? ?\ny - stage this hunk\nn - do not stage this hunk\na - stage this and all the remaining hunks in the file\nd - do not stage this hunk nor any of the remaining hunks in the file\ng - select a hunk to go to\n/ - search for a hunk matching the given regex\nj - leave this hunk undecided, see next undecided hunk\nj - leave this hunk undecided, see next hunk\nk - leave this hunk undecided, see previous undecided hunk\nk - leave this hunk undecided, see previous hunk\ns - split the current hunk into smaller hunks\ne - manually edit the current hunk\n? - print help\n\n\n通常情况下可以输入 y 或 n 来选择是否要暂存每一个区块， 当然，暂存特定文件中的所有部分或为之后的选择跳过一个区块也是非常有用的。 如果你只暂存文件的一部分，状态输出可能会像下面这样：\n\nwhat now> 1\n           staged     unstaged path\n  1:    unchanged        +0/-1 todo\n  2:        +1/-1      nothing index.html\n  3:        +1/-1        +4/-0 lib/simplegit.rb\n\n\nsimplegit.rb 文件的状态很有趣。 它显示出若干行被暂存与若干行未被暂存。 已经部分地暂存了这个文件。 在这时，可以退出交互式添加脚本并且运行 git commit 来提交部分暂存的文件。\n\n也可以不必在交互式添加模式中做部分文件暂存——可以在命令行中使用 git add -p 或 git add --patch 来启动同样的脚本。\n\n更进一步地，可以使用 git reset --patch 命令的补丁模式来部分重置文件， 通过 git checkout --patch 命令来部分检出文件与 git stash save --patch 命令来部分暂存文件。 我们将会在接触这些命令的高级使用方法时了解更多详细信息。',charsets:{cjk:!0},lastUpdated:"2023/11/19, 12:55:48",lastUpdatedTimestamp:1700369748e3},{title:"搜索引擎使用技巧",frontmatter:{title:"搜索引擎使用技巧",date:"2020-05-24T11:44:19.000Z",permalink:"/pages/ce818a",categories:["更多","学习"],tags:["搜索技巧"],author:{name:"王清欢",link:"https://github.com/wang-haihua"}},regularPath:"/07.%E8%83%A1%E6%80%9D%E4%B9%B1%E6%83%B3/01.%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/03.%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7.html",relativePath:"07.胡思乱想/01.实用技巧/03.搜索引擎使用技巧.md",key:"v-0aaf80f1",path:"/pages/ce818a/",headers:[{level:3,title:"技巧1：排除干扰项",slug:"技巧1-排除干扰项",normalizedTitle:"技巧1：排除干扰项",charIndex:117},{level:3,title:"技巧2：精确搜索",slug:"技巧2-精确搜索",normalizedTitle:"技巧2：精确搜索",charIndex:259},{level:3,title:"技巧3：指定网站内搜索",slug:"技巧3-指定网站内搜索",normalizedTitle:"技巧3：指定网站内搜索",charIndex:346},{level:3,title:"技巧4：指定文件格式",slug:"技巧4-指定文件格式",normalizedTitle:"技巧4：指定文件格式",charIndex:446},{level:3,title:"技巧5：指定在标题搜索",slug:"技巧5-指定在标题搜索",normalizedTitle:"技巧5：指定在标题搜索",charIndex:528},{level:3,title:"技巧6：指定在内容中搜索",slug:"技巧6-指定在内容中搜索",normalizedTitle:"技巧6：指定在内容中搜索",charIndex:579},{level:3,title:"技巧7：多种搜索技巧叠加使用",slug:"技巧7-多种搜索技巧叠加使用",normalizedTitle:"技巧7：多种搜索技巧叠加使用",charIndex:642},{level:3,title:"注意事项",slug:"注意事项",normalizedTitle:"注意事项",charIndex:719}],headersStr:"技巧1：排除干扰项 技巧2：精确搜索 技巧3：指定网站内搜索 技巧4：指定文件格式 技巧5：指定在标题搜索 技巧6：指定在内容中搜索 技巧7：多种搜索技巧叠加使用 注意事项",content:'搜索引擎相信大家经常在使用，但是有时候想搜某个信息时却搜出来一大堆不相关的（百度：你们都在看我干什么？）。下面我们来介绍几种搜索技巧，可以提升搜索效率，助你快速查资料，妈妈再也不担心我的学习了（\'妈~我真的是在找学习资料\'）\n\n\n# 技巧1：排除干扰项\n\n方式：关键词1+空格+减号+关键词2，即 关键词1 -关键词2\n\n功能：排除一些不想要的关键词\n\n示例：\n\n锤子 -锤子手机\n\n\n示例中将在搜索结果排除与锤子手机相关的，只显示锤子本来的样子。\n\n> 经过百度搜索的测试，有的关键词能排除掉，有的并不好使\n\n\n# 技巧2：精确搜索\n\n方式：给关键词加双引号，"关键词"\n\n功能：只搜索引号里的字，少一个字或者把字拆开都不行\n\n示例：\n\n"达拉不崩吧"\n\n\n> 注意是英文的双引号\n\n\n# 技巧3：指定网站内搜索\n\n方式：site:域名 关键词\n\n功能：只搜索指定域名的内容\n\n示例：\n\nsite:zhihu.com 前端\n\n\n有一些站内自带的搜索并不好用，可以尝试这个搜索技巧。\n\n\n# 技巧4：指定文件格式\n\n方式：filetype:文件格式 关键词\n\n示例：\n\nfiletype:avi 你懂的\n\n\n常见文件格式有doc、pdf、ppt等\n\n\n# 技巧5：指定在标题搜索\n\n方式：intitle:关键词\n\n功能：搜索的关键词要出现在标题当中\n\n\n# 技巧6：指定在内容中搜索\n\n方式：intext:关键词、allintext:关键词1 关键词2、inurl:关键词2\n\n\n# 技巧7：多种搜索技巧叠加使用\n\n示例：\n\nsite:zhihu.com 前端 intitle:js\n\n\n多种技巧和关键词叠加使用，中间空格隔开。\n\n\n# 注意事项\n\n以上搜索技巧使用的符号均是英文符号。',normalizedContent:'搜索引擎相信大家经常在使用，但是有时候想搜某个信息时却搜出来一大堆不相关的（百度：你们都在看我干什么？）。下面我们来介绍几种搜索技巧，可以提升搜索效率，助你快速查资料，妈妈再也不担心我的学习了（\'妈~我真的是在找学习资料\'）\n\n\n# 技巧1：排除干扰项\n\n方式：关键词1+空格+减号+关键词2，即 关键词1 -关键词2\n\n功能：排除一些不想要的关键词\n\n示例：\n\n锤子 -锤子手机\n\n\n示例中将在搜索结果排除与锤子手机相关的，只显示锤子本来的样子。\n\n> 经过百度搜索的测试，有的关键词能排除掉，有的并不好使\n\n\n# 技巧2：精确搜索\n\n方式：给关键词加双引号，"关键词"\n\n功能：只搜索引号里的字，少一个字或者把字拆开都不行\n\n示例：\n\n"达拉不崩吧"\n\n\n> 注意是英文的双引号\n\n\n# 技巧3：指定网站内搜索\n\n方式：site:域名 关键词\n\n功能：只搜索指定域名的内容\n\n示例：\n\nsite:zhihu.com 前端\n\n\n有一些站内自带的搜索并不好用，可以尝试这个搜索技巧。\n\n\n# 技巧4：指定文件格式\n\n方式：filetype:文件格式 关键词\n\n示例：\n\nfiletype:avi 你懂的\n\n\n常见文件格式有doc、pdf、ppt等\n\n\n# 技巧5：指定在标题搜索\n\n方式：intitle:关键词\n\n功能：搜索的关键词要出现在标题当中\n\n\n# 技巧6：指定在内容中搜索\n\n方式：intext:关键词、allintext:关键词1 关键词2、inurl:关键词2\n\n\n# 技巧7：多种搜索技巧叠加使用\n\n示例：\n\nsite:zhihu.com 前端 intitle:js\n\n\n多种技巧和关键词叠加使用，中间空格隔开。\n\n\n# 注意事项\n\n以上搜索技巧使用的符号均是英文符号。',charsets:{cjk:!0},lastUpdated:"2023/11/19, 12:55:48",lastUpdatedTimestamp:1700369748e3},{title:"提高学习效率的策略",frontmatter:{title:"提高学习效率的策略",date:"2020-01-04T11:54:14.000Z",permalink:"/pages/a8692ab3bdcb4588",categories:["更多","学习"],tags:[null],author:{name:"王清欢",link:"https://github.com/wang-haihua"}},regularPath:"/07.%E8%83%A1%E6%80%9D%E4%B9%B1%E6%83%B3/02.%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/02.%E6%8F%90%E9%AB%98%E5%AD%A6%E4%B9%A0%E6%95%88%E7%8E%87%E7%9A%84%E7%AD%96%E7%95%A5.html",relativePath:"07.胡思乱想/02.学习方法/02.提高学习效率的策略.md",key:"v-e53dc4e2",path:"/pages/a8692ab3bdcb4588/",headers:[{level:3,title:"检索式学习",slug:"检索式学习",normalizedTitle:"检索式学习",charIndex:222},{level:3,title:"频繁的集中练习只会产生短期记忆",slug:"频繁的集中练习只会产生短期记忆",normalizedTitle:"频繁的集中练习只会产生短期记忆",charIndex:634},{level:3,title:"间隔练习使知识存储更牢固",slug:"间隔练习使知识存储更牢固",normalizedTitle:"间隔练习使知识存储更牢固",charIndex:958},{level:3,title:"穿插练习有助于长期记忆",slug:"穿插练习有助于长期记忆",normalizedTitle:"穿插练习有助于长期记忆",charIndex:1346},{level:3,title:"多样化练习促进知识的活学活用",slug:"多样化练习促进知识的活学活用",normalizedTitle:"多样化练习促进知识的活学活用",charIndex:1728},{level:3,title:"小总结",slug:"小总结",normalizedTitle:"小总结",charIndex:1918},{level:3,title:"知识的“滚雪球”效应",slug:"知识的-滚雪球-效应",normalizedTitle:"知识的“滚雪球”效应",charIndex:2183}],excerpt:'<h1 id="提高学习效率的策略"><a class="header-anchor" href="#提高学习效率的策略">#</a> 提高学习效率的策略</h1>\n<p>推荐一本关于学习方法的书《认知天性》，里面有讲到有一些简单实用的学习策略，能让大家学的更好、记得更牢，而且这些策略人人可用，时时可用。这些方法包括各种形式的<strong>检索练习</strong>——例如小的测试和自测，<strong>间隔练习</strong>、<strong>穿插</strong>不同但相关科目或技能的练习（<strong>多样化练习</strong>），在别人教给你解决方案前自己先试着解决问题，从不同类型问题中提取基本原理和规则。由于学习是反复的过程，需要复习早先学过的东西，持续更新已知，并把它们和新知识联系起来。</p>\n',headersStr:"检索式学习 频繁的集中练习只会产生短期记忆 间隔练习使知识存储更牢固 穿插练习有助于长期记忆 多样化练习促进知识的活学活用 小总结 知识的“滚雪球”效应",content:"# 提高学习效率的策略\n\n推荐一本关于学习方法的书《认知天性》，里面有讲到有一些简单实用的学习策略，能让大家学的更好、记得更牢，而且这些策略人人可用，时时可用。这些方法包括各种形式的检索练习——例如小的测试和自测，间隔练习、穿插不同但相关科目或技能的练习（多样化练习），在别人教给你解决方案前自己先试着解决问题，从不同类型问题中提取基本原理和规则。由于学习是反复的过程，需要复习早先学过的东西，持续更新已知，并把它们和新知识联系起来。\n\n\n# 检索式学习\n\n练习从记忆中检索新知识或新技能是有效的学习工具，也是保持长久记忆的有力武器。但凡需要大脑记忆、需要在将来回忆的东西，都可以用到它——对于事实、复杂的概念、解决问题的技巧、运动技能来说都适用。\n\n那么到底什么是检索式学习呢？说说我理解的检索式学习：在脑中检索知识，比如课后的一个小测试、对某个知识点用笔默写出来，甚至去参加面试，等等，都可以理解为检索式学习。\n\n努力检索有助于人们获得更好的学习效果，产生更持久的记忆。我们很容易相信，学东西时越轻松，学习效果越好，但研究表明，事实恰恰相反。只有当头脑被迫工作时，才会将所学的东西记得更牢靠。在检索时所付出的努力越大——只要真正做到这一点检索就会更好地强化你的所学。在第一次检测后，推迟后续检索练习要比立即练习更能强化记忆，因为延迟后再检索需要会费更大力气。\n\n反复检索不仅能让记忆更持久，还能让知识在更多变的环境中更容易被检索，而且可以解决更多的问题。\n\n\n# 频繁的集中练习只会产生短期记忆\n\n人们顽固地相信，自己把心思放在一件事上，拼命重复就能学得更好，认为这些观点经受住了时间的考验，而且“练习，练习，再练习”的明显收效再次证明了这种方法的好处。但是，科学家们把习得技能阶段的这种成绩称为“暂时的优势”，并把它同“潜在的习惯优势”区分开来。形成习惯优势有种种技巧，例如有间隔的练习、有穿插内容的练习，以及多样化练习，这些技巧恰恰会放缓有明显成果的学习进程，它们不会在练习中提高我们的表现。我们从表面上看不到成绩提高，也就没有付出努力的动力（大多数人的学习心理就是这样，在看不到成果的时候容易失去动力）。填鸭式练习是集中练习的一种形式，它一直被比作贪食症——吃得不少，但没过多久基本上都吐出来了。\n\n\n# 间隔练习使知识存储更牢固\n\n把学习与练习间隔开来分期进行，让两者之间隔上一定时间，这样做就能让学习成果更加显著、记忆更加牢固，能有效地形成习惯优势。间隔多长时间才够？答案很简单：从最低限度上说，间隔的时间足够出现一点儿遗忘就对了。练习环节中间出现一点儿遗忘是好事，只要它能让人更加努力地练习就行。话说回来，你肯定不愿意忘掉太多东西，以至于检索最终变成了对资料的重新学习。间隔一段时间再练习能巩固记忆。睡眠似乎在巩固记忆的工作中扮演了重要角色，所以在两次练习间至少间隔一天应该是不错的做法。 要当心熟悉这个陷阱：你感觉自己明白了某样东西，觉得不再需要练习了。如果想走捷径，这种熟悉会让你在自测时受伤。道格拉斯·拉尔森说：“你必须自觉地说，好吧，我要强迫自己把这些全想起来，要是我想不起来，那我是忘掉了什么，我怎，么会不知道那个呢?’如果是教师出题测验，那就一下子变成你\n\n\n# 穿插练习有助于长期记忆\n\n穿插练习两样或更多的内容同样也提供了一种间隔。穿插内容练习有助于发展人们辨识不同问题的能力，也是在培养人们从不断增加的解决方案中寻找合适工具的能力。进行穿插内容练习，不能是完成一个科目的全部练习再跳到下一个科目。你需要在每个科目的练习完成前就跳到下一个科目。我们的一个朋友这样描述自己的经历，“我去上了一堂冰球课，学习滑冰、控球、射门。滑冰练习还没进行多长时间，自己刚刚有点儿上手的感觉，教练就转到控球练习上了，这让我感到非常沮丧。灰心地到家后，我说，‘为什么教练不让我们一次把技能练好呢？”其实他是遇上了少有的好教练。这位教练懂得分散精力练习不同技能要比下力气一次掌握一件事更有效果。球员感到沮丧是因为并没有在短时间内看到成果，但到下一周，无论是滑冰、控球，还是其他内容，他都会获得全面进步，效果会好于每次只专心练习一项技能。\n\n\n# 多样化练习促进知识的活学活用\n\n与穿插内容练习一样，多样化练习有助于学习者树立更开阔的心理模式。这是一种能力，掌握它的人可以评估不断变化的条件，并调整应对方式进行适应。可以说，穿插内容练习与多样化练习有助于学习者超越暂时性记忆，步入更高层次的概念性学习，并把它们应用到实际情景中，从而获得更全面、更深刻、更持久的学习效果。这些学习成果在运动技能中就表现为潜在的习惯优势。\n\n\n# 小总结\n\n有间隔、有内容穿插出现，以及内容多样化，其实就是我们生活的本来面貌。程序员每开发一个项目，都是一次测验，也是一次检索练习的锻炼。每次常规的拦车检查对于警察来说都是一次测验，而且每次检查都不一样，这会加强警察的外显记忆与内隐记忆。只要他上心，今后的工作就会更有效率。人们常说的一句话是“从经验中学习”。有些人似乎从来不学习，学与不学的一个区别可能就在于，人们是否培养了反思（总结）的习惯。反思（总结）是检索练习的一种形式（发生了什么？我是怎么做的？怎样才能有用？），而且辅以细化加强（下次我要采取别的什么方法？）\n\n\n# 知识的“滚雪球”效应\n\n学习的过程至少可以分成三步：最开始是对短期工作记忆中信息的编码。这时信息还没有被巩固成长期记忆中坚实的知识表征。巩固会辨识并稳定记忆线索，赋予其含义，把它们与过去的经验以及长期记忆中已经存储下来的其他知识联系起来。检索会更新所学的东西，并让你做到学以致用。\n\n学习总是建立在已知基础之上。我们是通过与已知建立联系这种方式来解读事件和记忆事件的。\n\n长期记忆的容量基本上是无限的。你知道得越多，就越有可能为新知识建立联系。\n\n由于长期记忆的容量颇大，所以关键是要有一种能力，让你在需要的时候锁定并回忆已知。回忆所学知识的难易程度取决于对信息的重复使用（保持检索路径不会被忘却），也取决于你是否建立起了强大的检索线索，因为它能重新激活你的记忆。\n\n阶段性地检索所学，有助于强化记忆间的联系，也能强化回忆知识的线索，同时还能弱化连通冲突记忆的路径。检索练习若是没什么难度，那就不能强化所学的知识；练习难度越大，收效才越大。\n\n当你从短期记忆中回忆所学时，例如快速频繁地进行练习，是不需要花什么心思的，也不会有长期性的收效。但当你过一段时间再回忆时，当你对所学的东西有些遗忘时，你就不得不努力重建这一切。这种耗费心力的检索既能强化记忆，又能让所学再次具有可塑性，引发对所学知识的再巩固。再巩固可以用新信息更新你的记忆，同时可以将它们与最近学到的东西联系起来。\n\n重复进行费力的回忆或是练习，有助于把所学的知识整合成心智模型。在心智模型中，一套彼此相关的概念或一系列运动技能被融会贯通，形成一个有意义的整体。它能适应随后的各种环境，并发挥作用。开车时的感知和操控就是一个例子。在面对弧线球时知道如何打出全垒打也是同一个道理。\n\n练习的条件如果发生了变化，或是在检索中穿插安排了对其他资料的练习，我们就能强化自己的辨析与归纳能力，凭借全面发展，我们还能把所学的知识用在以后的新环境中。穿插与多样化建立了新的联系，拓展并进一步深化了记忆中的知识，同时增加了检索线索的数量。、\n\n试着自己想出答案，而不是坐等别人给你答案，或是在拿到解决方案前自行尝试解决一个问题，会产生更好的学习效果，也能让你把正确的答案或解决方案记得更持久。即便有时你会犯错，只要有纠正性反馈就没问题。\n\n——以上内容摘自《认知天性》，结合本人的个人理解，更多内容请查看该书籍。\n\n",normalizedContent:"# 提高学习效率的策略\n\n推荐一本关于学习方法的书《认知天性》，里面有讲到有一些简单实用的学习策略，能让大家学的更好、记得更牢，而且这些策略人人可用，时时可用。这些方法包括各种形式的检索练习——例如小的测试和自测，间隔练习、穿插不同但相关科目或技能的练习（多样化练习），在别人教给你解决方案前自己先试着解决问题，从不同类型问题中提取基本原理和规则。由于学习是反复的过程，需要复习早先学过的东西，持续更新已知，并把它们和新知识联系起来。\n\n\n# 检索式学习\n\n练习从记忆中检索新知识或新技能是有效的学习工具，也是保持长久记忆的有力武器。但凡需要大脑记忆、需要在将来回忆的东西，都可以用到它——对于事实、复杂的概念、解决问题的技巧、运动技能来说都适用。\n\n那么到底什么是检索式学习呢？说说我理解的检索式学习：在脑中检索知识，比如课后的一个小测试、对某个知识点用笔默写出来，甚至去参加面试，等等，都可以理解为检索式学习。\n\n努力检索有助于人们获得更好的学习效果，产生更持久的记忆。我们很容易相信，学东西时越轻松，学习效果越好，但研究表明，事实恰恰相反。只有当头脑被迫工作时，才会将所学的东西记得更牢靠。在检索时所付出的努力越大——只要真正做到这一点检索就会更好地强化你的所学。在第一次检测后，推迟后续检索练习要比立即练习更能强化记忆，因为延迟后再检索需要会费更大力气。\n\n反复检索不仅能让记忆更持久，还能让知识在更多变的环境中更容易被检索，而且可以解决更多的问题。\n\n\n# 频繁的集中练习只会产生短期记忆\n\n人们顽固地相信，自己把心思放在一件事上，拼命重复就能学得更好，认为这些观点经受住了时间的考验，而且“练习，练习，再练习”的明显收效再次证明了这种方法的好处。但是，科学家们把习得技能阶段的这种成绩称为“暂时的优势”，并把它同“潜在的习惯优势”区分开来。形成习惯优势有种种技巧，例如有间隔的练习、有穿插内容的练习，以及多样化练习，这些技巧恰恰会放缓有明显成果的学习进程，它们不会在练习中提高我们的表现。我们从表面上看不到成绩提高，也就没有付出努力的动力（大多数人的学习心理就是这样，在看不到成果的时候容易失去动力）。填鸭式练习是集中练习的一种形式，它一直被比作贪食症——吃得不少，但没过多久基本上都吐出来了。\n\n\n# 间隔练习使知识存储更牢固\n\n把学习与练习间隔开来分期进行，让两者之间隔上一定时间，这样做就能让学习成果更加显著、记忆更加牢固，能有效地形成习惯优势。间隔多长时间才够？答案很简单：从最低限度上说，间隔的时间足够出现一点儿遗忘就对了。练习环节中间出现一点儿遗忘是好事，只要它能让人更加努力地练习就行。话说回来，你肯定不愿意忘掉太多东西，以至于检索最终变成了对资料的重新学习。间隔一段时间再练习能巩固记忆。睡眠似乎在巩固记忆的工作中扮演了重要角色，所以在两次练习间至少间隔一天应该是不错的做法。 要当心熟悉这个陷阱：你感觉自己明白了某样东西，觉得不再需要练习了。如果想走捷径，这种熟悉会让你在自测时受伤。道格拉斯·拉尔森说：“你必须自觉地说，好吧，我要强迫自己把这些全想起来，要是我想不起来，那我是忘掉了什么，我怎，么会不知道那个呢?’如果是教师出题测验，那就一下子变成你\n\n\n# 穿插练习有助于长期记忆\n\n穿插练习两样或更多的内容同样也提供了一种间隔。穿插内容练习有助于发展人们辨识不同问题的能力，也是在培养人们从不断增加的解决方案中寻找合适工具的能力。进行穿插内容练习，不能是完成一个科目的全部练习再跳到下一个科目。你需要在每个科目的练习完成前就跳到下一个科目。我们的一个朋友这样描述自己的经历，“我去上了一堂冰球课，学习滑冰、控球、射门。滑冰练习还没进行多长时间，自己刚刚有点儿上手的感觉，教练就转到控球练习上了，这让我感到非常沮丧。灰心地到家后，我说，‘为什么教练不让我们一次把技能练好呢？”其实他是遇上了少有的好教练。这位教练懂得分散精力练习不同技能要比下力气一次掌握一件事更有效果。球员感到沮丧是因为并没有在短时间内看到成果，但到下一周，无论是滑冰、控球，还是其他内容，他都会获得全面进步，效果会好于每次只专心练习一项技能。\n\n\n# 多样化练习促进知识的活学活用\n\n与穿插内容练习一样，多样化练习有助于学习者树立更开阔的心理模式。这是一种能力，掌握它的人可以评估不断变化的条件，并调整应对方式进行适应。可以说，穿插内容练习与多样化练习有助于学习者超越暂时性记忆，步入更高层次的概念性学习，并把它们应用到实际情景中，从而获得更全面、更深刻、更持久的学习效果。这些学习成果在运动技能中就表现为潜在的习惯优势。\n\n\n# 小总结\n\n有间隔、有内容穿插出现，以及内容多样化，其实就是我们生活的本来面貌。程序员每开发一个项目，都是一次测验，也是一次检索练习的锻炼。每次常规的拦车检查对于警察来说都是一次测验，而且每次检查都不一样，这会加强警察的外显记忆与内隐记忆。只要他上心，今后的工作就会更有效率。人们常说的一句话是“从经验中学习”。有些人似乎从来不学习，学与不学的一个区别可能就在于，人们是否培养了反思（总结）的习惯。反思（总结）是检索练习的一种形式（发生了什么？我是怎么做的？怎样才能有用？），而且辅以细化加强（下次我要采取别的什么方法？）\n\n\n# 知识的“滚雪球”效应\n\n学习的过程至少可以分成三步：最开始是对短期工作记忆中信息的编码。这时信息还没有被巩固成长期记忆中坚实的知识表征。巩固会辨识并稳定记忆线索，赋予其含义，把它们与过去的经验以及长期记忆中已经存储下来的其他知识联系起来。检索会更新所学的东西，并让你做到学以致用。\n\n学习总是建立在已知基础之上。我们是通过与已知建立联系这种方式来解读事件和记忆事件的。\n\n长期记忆的容量基本上是无限的。你知道得越多，就越有可能为新知识建立联系。\n\n由于长期记忆的容量颇大，所以关键是要有一种能力，让你在需要的时候锁定并回忆已知。回忆所学知识的难易程度取决于对信息的重复使用（保持检索路径不会被忘却），也取决于你是否建立起了强大的检索线索，因为它能重新激活你的记忆。\n\n阶段性地检索所学，有助于强化记忆间的联系，也能强化回忆知识的线索，同时还能弱化连通冲突记忆的路径。检索练习若是没什么难度，那就不能强化所学的知识；练习难度越大，收效才越大。\n\n当你从短期记忆中回忆所学时，例如快速频繁地进行练习，是不需要花什么心思的，也不会有长期性的收效。但当你过一段时间再回忆时，当你对所学的东西有些遗忘时，你就不得不努力重建这一切。这种耗费心力的检索既能强化记忆，又能让所学再次具有可塑性，引发对所学知识的再巩固。再巩固可以用新信息更新你的记忆，同时可以将它们与最近学到的东西联系起来。\n\n重复进行费力的回忆或是练习，有助于把所学的知识整合成心智模型。在心智模型中，一套彼此相关的概念或一系列运动技能被融会贯通，形成一个有意义的整体。它能适应随后的各种环境，并发挥作用。开车时的感知和操控就是一个例子。在面对弧线球时知道如何打出全垒打也是同一个道理。\n\n练习的条件如果发生了变化，或是在检索中穿插安排了对其他资料的练习，我们就能强化自己的辨析与归纳能力，凭借全面发展，我们还能把所学的知识用在以后的新环境中。穿插与多样化建立了新的联系，拓展并进一步深化了记忆中的知识，同时增加了检索线索的数量。、\n\n试着自己想出答案，而不是坐等别人给你答案，或是在拿到解决方案前自行尝试解决一个问题，会产生更好的学习效果，也能让你把正确的答案或解决方案记得更持久。即便有时你会犯错，只要有纠正性反馈就没问题。\n\n——以上内容摘自《认知天性》，结合本人的个人理解，更多内容请查看该书籍。\n\n",charsets:{cjk:!0},lastUpdated:"2023/11/19, 12:55:48",lastUpdatedTimestamp:1700369748e3},{title:"2分钟规则",frontmatter:{title:"2分钟规则",date:"2020-11-09T11:05:29.000Z",permalink:"/pages/baaa02/",categories:["更多","实用技巧"],tags:["实用技巧","文摘"],author:{name:"王清欢",link:"https://github.com/wang-haihua"}},regularPath:"/07.%E8%83%A1%E6%80%9D%E4%B9%B1%E6%83%B3/01.%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/01.2%E5%88%86%E9%92%9F%E8%A7%84%E5%88%99.html",relativePath:"07.胡思乱想/01.实用技巧/01.2分钟规则.md",key:"v-618f02ea",path:"/pages/baaa02/",excerpt:"<p>每当你发现很难开始执行某项任务时，可以试试将其缩减成2分钟的版本。</p>\n<ul>\n<li>看一本书 → 看一页书</li>\n<li>写一篇文章 → 写一句话</li>\n<li>跑10公里 → 穿上跑鞋</li>\n<li>做100次俯卧撑 → 做1次俯卧撑</li>\n<li>多吃蔬菜水果 → 吃一个水果</li>\n<li>编写一个程序 → 编写一个函数 → 编写一行代码</li>\n</ul>\n",headersStr:null,content:"每当你发现很难开始执行某项任务时，可以试试将其缩减成2分钟的版本。\n\n * 看一本书 → 看一页书\n * 写一篇文章 → 写一句话\n * 跑10公里 → 穿上跑鞋\n * 做100次俯卧撑 → 做1次俯卧撑\n * 多吃蔬菜水果 → 吃一个水果\n * 编写一个程序 → 编写一个函数 → 编写一行代码\n\n这样做的目的是使上手变得超级容易，让你先上手再说。一旦开始做了（这可能是最艰难的一步），你就会开始有动力，可能会继续做下去。\n\n * 阅读一页 → 阅读10页 → 读完第一章\n * 写一个句子 → 写文章的开头 → 写出正文\n * 穿上跑鞋 → 步行5分钟 → 跑步5分钟\n\n一旦开始，继续做下去就会容易得多。有时，你甚至会发现，自己在不知不觉间已经完成了任务。\n\n> 本文摘录自 https://hoanhan.co/2-minute-rule",normalizedContent:"每当你发现很难开始执行某项任务时，可以试试将其缩减成2分钟的版本。\n\n * 看一本书 → 看一页书\n * 写一篇文章 → 写一句话\n * 跑10公里 → 穿上跑鞋\n * 做100次俯卧撑 → 做1次俯卧撑\n * 多吃蔬菜水果 → 吃一个水果\n * 编写一个程序 → 编写一个函数 → 编写一行代码\n\n这样做的目的是使上手变得超级容易，让你先上手再说。一旦开始做了（这可能是最艰难的一步），你就会开始有动力，可能会继续做下去。\n\n * 阅读一页 → 阅读10页 → 读完第一章\n * 写一个句子 → 写文章的开头 → 写出正文\n * 穿上跑鞋 → 步行5分钟 → 跑步5分钟\n\n一旦开始，继续做下去就会容易得多。有时，你甚至会发现，自己在不知不觉间已经完成了任务。\n\n> 本文摘录自 https://hoanhan.co/2-minute-rule",charsets:{cjk:!0},lastUpdated:"2023/11/19, 12:55:48",lastUpdatedTimestamp:1700369748e3},{title:"笔记方法",frontmatter:{title:"笔记方法",date:"2020-07-16T11:00:55.000Z",permalink:"/pages/e60c81/",categories:["更多","学习"],tags:["笔记方法"],author:{name:"王清欢",link:"https://github.com/wang-haihua"}},regularPath:"/07.%E8%83%A1%E6%80%9D%E4%B9%B1%E6%83%B3/02.%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/01.%E7%AC%94%E8%AE%B0%E6%96%B9%E6%B3%95.html",relativePath:"07.胡思乱想/02.学习方法/01.笔记方法.md",key:"v-33e54f21",path:"/pages/e60c81/",headers:[{level:2,title:"康奈尔笔记法",slug:"康奈尔笔记法",normalizedTitle:"康奈尔笔记法",charIndex:2},{level:2,title:"思维导图法",slug:"思维导图法",normalizedTitle:"思维导图法",charIndex:15},{level:2,title:"金三角笔记法",slug:"金三角笔记法",normalizedTitle:"金三角笔记法",charIndex:27},{level:2,title:"曼陀罗九宫格笔记法",slug:"曼陀罗九宫格笔记法",normalizedTitle:"曼陀罗九宫格笔记法",charIndex:40},{level:2,title:"记号记录法",slug:"记号记录法",normalizedTitle:"记号记录法",charIndex:56},{level:2,title:"六色笔记法",slug:"六色笔记法",normalizedTitle:"六色笔记法",charIndex:68},{level:2,title:"加工笔记法",slug:"加工笔记法",normalizedTitle:"加工笔记法",charIndex:80},{level:2,title:"整理笔记要点1-科学标记重点",slug:"整理笔记要点1-科学标记重点",normalizedTitle:"整理笔记要点1-科学标记重点",charIndex:92},{level:2,title:"整理笔记要点2-修改不涂改",slug:"整理笔记要点2-修改不涂改",normalizedTitle:"整理笔记要点2-修改不涂改",charIndex:113}],headersStr:"康奈尔笔记法 思维导图法 金三角笔记法 曼陀罗九宫格笔记法 记号记录法 六色笔记法 加工笔记法 整理笔记要点1-科学标记重点 整理笔记要点2-修改不涂改",content:"# 康奈尔笔记法\n\n\n\n\n# 思维导图法\n\n\n\n\n# 金三角笔记法\n\n\n\n\n# 曼陀罗九宫格笔记法\n\n\n\n\n# 记号记录法\n\n\n\n\n# 六色笔记法\n\n\n\n\n# 加工笔记法\n\n\n\n\n# 整理笔记要点1-科学标记重点\n\n\n\n\n# 整理笔记要点2-修改不涂改\n\n",normalizedContent:"# 康奈尔笔记法\n\n\n\n\n# 思维导图法\n\n\n\n\n# 金三角笔记法\n\n\n\n\n# 曼陀罗九宫格笔记法\n\n\n\n\n# 记号记录法\n\n\n\n\n# 六色笔记法\n\n\n\n\n# 加工笔记法\n\n\n\n\n# 整理笔记要点1-科学标记重点\n\n\n\n\n# 整理笔记要点2-修改不涂改\n\n",charsets:{cjk:!0},lastUpdated:"2023/11/19, 12:55:48",lastUpdatedTimestamp:1700369748e3},{title:"提高记忆的技巧",frontmatter:{title:"提高记忆的技巧",date:"2020-01-03T14:34:48.000Z",permalink:"/pages/996822b2a2ca6e3b",categories:["更多","学习"],tags:[null],author:{name:"王清欢",link:"https://github.com/wang-haihua"}},regularPath:"/07.%E8%83%A1%E6%80%9D%E4%B9%B1%E6%83%B3/02.%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/03.%E6%8F%90%E9%AB%98%E8%AE%B0%E5%BF%86%E7%9A%84%E6%8A%80%E5%B7%A7.html",relativePath:"07.胡思乱想/02.学习方法/03.提高记忆的技巧.md",key:"v-51acde98",path:"/pages/996822b2a2ca6e3b/",excerpt:'<h1 id="提高记忆的技巧"><a class="header-anchor" href="#提高记忆的技巧">#</a> 提高记忆的技巧</h1>\n<ol>\n<li><strong>多个感官并用</strong>\n记忆时调用一切感官。没人的话可以大声阅读，有人的话可以默念，轻微摇晃手指等，有助于保持专注。</li>\n</ol>\n',headersStr:null,content:"# 提高记忆的技巧\n\n 1. 多个感官并用 记忆时调用一切感官。没人的话可以大声阅读，有人的话可以默念，轻微摇晃手指等，有助于保持专注。\n\n 2. 重复记忆 每天留出半个到一个小时，梳理总结今天所学的内容。每一章复习完成后做系统的知识整理。\n\n 3. 建立关联 把你所学的新知识与已有的认知建立联系，对于记忆事半功倍。\n\n 4. 场景记忆 把知识具象化为一个场景，想象自己在何时何地能用这些知识，与自身发生联系。\n\n 5. 提出问题 每学习一个知识点，试着提问，然后给出答案。用了就记住了。",normalizedContent:"# 提高记忆的技巧\n\n 1. 多个感官并用 记忆时调用一切感官。没人的话可以大声阅读，有人的话可以默念，轻微摇晃手指等，有助于保持专注。\n\n 2. 重复记忆 每天留出半个到一个小时，梳理总结今天所学的内容。每一章复习完成后做系统的知识整理。\n\n 3. 建立关联 把你所学的新知识与已有的认知建立联系，对于记忆事半功倍。\n\n 4. 场景记忆 把知识具象化为一个场景，想象自己在何时何地能用这些知识，与自身发生联系。\n\n 5. 提出问题 每学习一个知识点，试着提问，然后给出答案。用了就记住了。",charsets:{cjk:!0},lastUpdated:"2023/11/19, 12:55:48",lastUpdatedTimestamp:1700369748e3},{title:"自律小建议",frontmatter:{title:"自律小建议",date:"2020-01-03T14:35:18.000Z",permalink:"/pages/c3f302a03c8daf79",categories:["更多","学习"],tags:[null],author:{name:"王清欢",link:"https://github.com/wang-haihua"}},regularPath:"/07.%E8%83%A1%E6%80%9D%E4%B9%B1%E6%83%B3/02.%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/04.%E8%87%AA%E5%BE%8B%E5%B0%8F%E5%BB%BA%E8%AE%AE.html",relativePath:"07.胡思乱想/02.学习方法/04.自律小建议.md",key:"v-590f3efc",path:"/pages/c3f302a03c8daf79/",excerpt:'<h1 id="自律小建议"><a class="header-anchor" href="#自律小建议">#</a> 自律小建议</h1>\n<ul>\n<li><strong>培养专注</strong>\n<ul>\n<li>练习冥想、瑜伽等</li>\n</ul>\n</li>\n<li><strong>排除外界干扰</strong>\n<ul>\n<li>手机调到勿扰，在图书馆学习等</li>\n</ul>\n</li>\n</ul>\n',headersStr:null,content:"# 自律小建议\n\n * 培养专注\n   * 练习冥想、瑜伽等\n * 排除外界干扰\n   * 手机调到勿扰，在图书馆学习等\n\n * 规定学习时间\n   \n   * 番茄时间管理——使用番茄时间管理法，选择一个待完成的任务，将番茄时间设为25分钟，专注工作，中途不允许做任何与该任务无关的事，直到番茄时钟响起，然后短暂休息一下（5分钟就行），每4个番茄时段多休息一会儿。\n     \n     > 人的大脑在记忆一个东西的时候，有短期记忆和长期记忆之分。大脑编码内容进行长期记忆，需要一个过程的，可能是几个小时或几天，集中练习就给不了这个过程，所以集中练习带来的效果是短期记忆，而进行间隔练习，大脑则有时间进行充分的编码，学习到的知识就会储存为长期记忆。\n     > \n     > 推荐几种间歇锻炼方法：体能训练、课间操、眼保操、拉伸训练...\n     > \n     > 有好的身体可以使大脑更清醒哟~\n\n * 限制娱乐时间\n   \n   * 减少使用娱乐app的时间（苹果手机可设定屏幕使用时间）\n   \n   * 推荐观看>B站某位UP主的视频《每天只看半小时手机，坚持一周后我有哪些变化？》\n\n * 戒网瘾（特别是游戏）\n   \n   * 除了手机、游戏以外，周围有很多美好的事物值得我们去关注。\n\n * 设定目标\n   \n   * 想要更好的薪水和职位？多花点时间在学习上吧~\n   * 潜意识暗示自己，建立信心，让自己变得更优秀，然后去挑战更高的目标\n\n * 优秀的人仍在不断努力\n   \n   * 且看大神 阮一峰github 提交记录",normalizedContent:"# 自律小建议\n\n * 培养专注\n   * 练习冥想、瑜伽等\n * 排除外界干扰\n   * 手机调到勿扰，在图书馆学习等\n\n * 规定学习时间\n   \n   * 番茄时间管理——使用番茄时间管理法，选择一个待完成的任务，将番茄时间设为25分钟，专注工作，中途不允许做任何与该任务无关的事，直到番茄时钟响起，然后短暂休息一下（5分钟就行），每4个番茄时段多休息一会儿。\n     \n     > 人的大脑在记忆一个东西的时候，有短期记忆和长期记忆之分。大脑编码内容进行长期记忆，需要一个过程的，可能是几个小时或几天，集中练习就给不了这个过程，所以集中练习带来的效果是短期记忆，而进行间隔练习，大脑则有时间进行充分的编码，学习到的知识就会储存为长期记忆。\n     > \n     > 推荐几种间歇锻炼方法：体能训练、课间操、眼保操、拉伸训练...\n     > \n     > 有好的身体可以使大脑更清醒哟~\n\n * 限制娱乐时间\n   \n   * 减少使用娱乐app的时间（苹果手机可设定屏幕使用时间）\n   \n   * 推荐观看>b站某位up主的视频《每天只看半小时手机，坚持一周后我有哪些变化？》\n\n * 戒网瘾（特别是游戏）\n   \n   * 除了手机、游戏以外，周围有很多美好的事物值得我们去关注。\n\n * 设定目标\n   \n   * 想要更好的薪水和职位？多花点时间在学习上吧~\n   * 潜意识暗示自己，建立信心，让自己变得更优秀，然后去挑战更高的目标\n\n * 优秀的人仍在不断努力\n   \n   * 且看大神 阮一峰github 提交记录",charsets:{cjk:!0},lastUpdated:"2023/11/19, 12:55:48",lastUpdatedTimestamp:1700369748e3},{title:"处理问题的思路",frontmatter:{title:"处理问题的思路",date:"2020-01-03T14:36:02.000Z",permalink:"/pages/9ba2b8fb13de1957",categories:["更多","学习"],tags:[null],author:{name:"王清欢",link:"https://github.com/wang-haihua"}},regularPath:"/07.%E8%83%A1%E6%80%9D%E4%B9%B1%E6%83%B3/02.%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/05.%E5%A4%84%E7%90%86%E9%97%AE%E9%A2%98%E7%9A%84%E6%80%9D%E8%B7%AF.html",relativePath:"07.胡思乱想/02.学习方法/05.处理问题的思路.md",key:"v-c7d5fea8",path:"/pages/9ba2b8fb13de1957/",headers:[{level:2,title:"工作中遇到问题？",slug:"工作中遇到问题",normalizedTitle:"工作中遇到问题？",charIndex:14},{level:2,title:"这个问题我该怎么解决呢？",slug:"这个问题我该怎么解决呢",normalizedTitle:"这个问题我该怎么解决呢？",charIndex:86}],headersStr:"工作中遇到问题？ 这个问题我该怎么解决呢？",content:"# 处理问题的思路\n\n\n# 工作中遇到问题？\n\n遇到问题卡住了，可以先休息一会儿，调整一下状态，喝杯水走走放松放松，然后想想有没有遗漏的地方，或者其他的解决方案呢\n\n\n# 这个问题我该怎么解决呢？\n\n 1. 学会搜索\n    \n    * 关键词\n    \n    * 多关键词\n    \n    * 加入时间\n    \n    * 加入特定的社区\n    \n    * site用法\n\n 2. 高阶搜索方法\n    \n    * 英文搜索（必应搜索、google搜索，很多英文文档或文章相对来说层数结构很清晰）\n    * 视频站搜索（http://www.youtube.com/、http://egghead.io）\n    * 百度盘搜索\n    * 指定文件后缀\n\n 3. 寻求帮助\n    \n    * 找同学\n    \n    * 找同事\n    \n    * 找朋友\n    \n    * 找社区\n\n 4. 开拓思路——发散性解决问题\n    \n    * 去问问原作者？\n    * 去发个邮件/twitter/facebook?\n    * 去找Boss要资源？\n    * 加入公共社区参与讨论?\n    * ...",normalizedContent:"# 处理问题的思路\n\n\n# 工作中遇到问题？\n\n遇到问题卡住了，可以先休息一会儿，调整一下状态，喝杯水走走放松放松，然后想想有没有遗漏的地方，或者其他的解决方案呢\n\n\n# 这个问题我该怎么解决呢？\n\n 1. 学会搜索\n    \n    * 关键词\n    \n    * 多关键词\n    \n    * 加入时间\n    \n    * 加入特定的社区\n    \n    * site用法\n\n 2. 高阶搜索方法\n    \n    * 英文搜索（必应搜索、google搜索，很多英文文档或文章相对来说层数结构很清晰）\n    * 视频站搜索（http://www.youtube.com/、http://egghead.io）\n    * 百度盘搜索\n    * 指定文件后缀\n\n 3. 寻求帮助\n    \n    * 找同学\n    \n    * 找同事\n    \n    * 找朋友\n    \n    * 找社区\n\n 4. 开拓思路——发散性解决问题\n    \n    * 去问问原作者？\n    * 去发个邮件/twitter/facebook?\n    * 去找boss要资源？\n    * 加入公共社区参与讨论?\n    * ...",charsets:{cjk:!0},lastUpdated:"2023/11/19, 12:55:48",lastUpdatedTimestamp:1700369748e3},{title:"站点扩展",frontmatter:{title:"站点扩展",date:"2023-06-24T17:12:37.000Z",permalink:"/pages/35750f/"},regularPath:"/07.%E8%83%A1%E6%80%9D%E4%B9%B1%E6%83%B3/03.%E8%B5%84%E6%BA%90%E5%88%86%E4%BA%AB/01.%E7%AB%99%E7%82%B9%E6%89%A9%E5%B1%95.html",relativePath:"07.胡思乱想/03.资源分享/01.站点扩展.md",key:"v-68c52d46",path:"/pages/35750f/",headers:[{level:2,title:"插件推荐",slug:"插件推荐",normalizedTitle:"插件推荐",charIndex:2},{level:2,title:"社区优秀解决方案",slug:"社区优秀解决方案",normalizedTitle:"社区优秀解决方案",charIndex:524},{level:3,title:"1. 站点信息模块",slug:"_1-站点信息模块",normalizedTitle:"1. 站点信息模块",charIndex:537},{level:3,title:"2. 私密文章功能",slug:"_2-私密文章功能",normalizedTitle:"2. 私密文章功能",charIndex:597},{level:3,title:"3. 首页大图模块",slug:"_3-首页大图模块",normalizedTitle:"3. 首页大图模块",charIndex:648},{level:3,title:"4. 优雅的全文搜索方案",slug:"_4-优雅的全文搜索方案",normalizedTitle:"4. 优雅的全文搜索方案",charIndex:683},{level:2,title:"文章管理和发布",slug:"文章管理和发布",normalizedTitle:"文章管理和发布",charIndex:700},{level:2,title:"图标&配图",slug:"图标-配图",normalizedTitle:"图标&amp;配图",charIndex:null},{level:3,title:"静态图标",slug:"静态图标",normalizedTitle:"静态图标",charIndex:822},{level:3,title:"萌系图标",slug:"萌系图标",normalizedTitle:"萌系图标",charIndex:877},{level:3,title:"动态图标",slug:"动态图标",normalizedTitle:"动态图标",charIndex:915},{level:3,title:"插画",slug:"插画",normalizedTitle:"插画",charIndex:943},{level:3,title:"配图",slug:"配图",normalizedTitle:"配图",charIndex:768},{level:3,title:"Logo",slug:"logo",normalizedTitle:"logo",charIndex:990},{level:3,title:"Emoji表情",slug:"emoji表情",normalizedTitle:"emoji表情",charIndex:1016}],headersStr:"插件推荐 社区优秀解决方案 1. 站点信息模块 2. 私密文章功能 3. 首页大图模块 4. 优雅的全文搜索方案 文章管理和发布 图标&配图 静态图标 萌系图标 动态图标 插画 配图 Logo Emoji表情",content:'# 插件推荐\n\n * vuepress-plugin-fulltext-search 全文搜索\n\n * vuepress-plugin-thirdparty-search 可以添加第三方搜索链接的搜索框\n\n * vuepress-plugin-one-click-copy 代码块一键复制\n\n * vuepress-plugin-comment 评论区\n\n * vuepress-plugin-vssue 评论区（单页）\n\n * vuepress-plugin-vssue-global 评论区（全局）\n\n * vuepress-plugin-smplayer 播放器\n\n * vuepress-plugin-flowchart 流程图\n\n * vuepress-plugin-mathjax 数学公式\n\n * vuepress-plugin-tabs 选项卡\n\n * vuepress-plugin-element-ui Element UI\n\n * 花里胡哨的插件 鼠标点击特效、背景彩带、音乐播放器等花里胡哨的插件\n\n更多插件...\n\n * Awesome VuePress\n\n * 在npm中搜索"vuepress–plugin"\n\n\n# 社区优秀解决方案\n\n\n# 1. 站点信息模块\n\n在首页添加站点信息模块，效果：\n\n\n\n在文章页添加文章字数、阅读时间、浏览量，效果：\n\n\n\n\n# 2. 私密文章功能\n\n当大家想要「云端备份」文章到博客时，又不希望别人看到，该功能能满足你。\n\n\n# 3. 首页大图模块\n\n喜欢首页大图模式的朋友可以参考此教程。\n\n\n# 4. 优雅的全文搜索方案\n\n\n# 文章管理和发布\n\n使用 此插件 src-sy-post-publisher 发布思源笔记的文章到Vuepress等平台。\n\n\n# 图标&配图\n\n说明：以下图标非主题内置，你可以选择喜欢的图标右键保存或到图标库下载。更多图标：阿里图标库\n\n\n# 静态图标\n\n编程   服务器   机器学习   计算机网络   面向对象   软件开发   数据结构\n\n\n# 萌系图标\n\n * 猫咪系列\n   \n * 数码宝贝\n * 水果系列\n\n\n# 动态图标\n\n猫1   猫2   猫3   猫4\n\n\n# 插画\n\n免费插画\n2D/3D/手绘插画\n阿里插画库\n\n\n\n# 配图\n\n可画-文章配图\n\n\n# Logo\n\nlogo生成1\nlogo生成2\n\n\n# Emoji表情\n\nEmoji百科\n\n小技巧\n\n在任意输入框快速打开emoji表情方法：\nWindows系统下按Win + .\nMac系统下按Control + Command + 空格\n\n',normalizedContent:'# 插件推荐\n\n * vuepress-plugin-fulltext-search 全文搜索\n\n * vuepress-plugin-thirdparty-search 可以添加第三方搜索链接的搜索框\n\n * vuepress-plugin-one-click-copy 代码块一键复制\n\n * vuepress-plugin-comment 评论区\n\n * vuepress-plugin-vssue 评论区（单页）\n\n * vuepress-plugin-vssue-global 评论区（全局）\n\n * vuepress-plugin-smplayer 播放器\n\n * vuepress-plugin-flowchart 流程图\n\n * vuepress-plugin-mathjax 数学公式\n\n * vuepress-plugin-tabs 选项卡\n\n * vuepress-plugin-element-ui element ui\n\n * 花里胡哨的插件 鼠标点击特效、背景彩带、音乐播放器等花里胡哨的插件\n\n更多插件...\n\n * awesome vuepress\n\n * 在npm中搜索"vuepress–plugin"\n\n\n# 社区优秀解决方案\n\n\n# 1. 站点信息模块\n\n在首页添加站点信息模块，效果：\n\n\n\n在文章页添加文章字数、阅读时间、浏览量，效果：\n\n\n\n\n# 2. 私密文章功能\n\n当大家想要「云端备份」文章到博客时，又不希望别人看到，该功能能满足你。\n\n\n# 3. 首页大图模块\n\n喜欢首页大图模式的朋友可以参考此教程。\n\n\n# 4. 优雅的全文搜索方案\n\n\n# 文章管理和发布\n\n使用 此插件 src-sy-post-publisher 发布思源笔记的文章到vuepress等平台。\n\n\n# 图标&配图\n\n说明：以下图标非主题内置，你可以选择喜欢的图标右键保存或到图标库下载。更多图标：阿里图标库\n\n\n# 静态图标\n\n编程   服务器   机器学习   计算机网络   面向对象   软件开发   数据结构\n\n\n# 萌系图标\n\n * 猫咪系列\n   \n * 数码宝贝\n * 水果系列\n\n\n# 动态图标\n\n猫1   猫2   猫3   猫4\n\n\n# 插画\n\n免费插画\n2d/3d/手绘插画\n阿里插画库\n\n\n\n# 配图\n\n可画-文章配图\n\n\n# logo\n\nlogo生成1\nlogo生成2\n\n\n# emoji表情\n\nemoji百科\n\n小技巧\n\n在任意输入框快速打开emoji表情方法：\nwindows系统下按win + .\nmac系统下按control + command + 空格\n\n',charsets:{cjk:!0},lastUpdated:"2024/12/21, 13:59:01",lastUpdatedTimestamp:1734760741e3},{title:"素材资源",frontmatter:{title:"素材资源",date:"2024-03-01T20:52:27.000Z",permalink:"/pages/023f1a/"},regularPath:"/07.%E8%83%A1%E6%80%9D%E4%B9%B1%E6%83%B3/03.%E8%B5%84%E6%BA%90%E5%88%86%E4%BA%AB/02.%E7%B4%A0%E6%9D%90%E8%B5%84%E6%BA%90.html",relativePath:"07.胡思乱想/03.资源分享/02.素材资源.md",key:"v-0dd9388e",path:"/pages/023f1a/",headers:[{level:2,title:"插件推荐",slug:"插件推荐",normalizedTitle:"插件推荐",charIndex:2},{level:3,title:"插画",slug:"插画",normalizedTitle:"插画",charIndex:11},{level:3,title:"配图",slug:"配图",normalizedTitle:"配图",charIndex:42},{level:3,title:"Logo",slug:"logo",normalizedTitle:"logo",charIndex:58},{level:3,title:"Emoji表情",slug:"emoji表情",normalizedTitle:"emoji表情",charIndex:84}],headersStr:"插件推荐 插画 配图 Logo Emoji表情",content:"# 插件推荐\n\n\n# 插画\n\n免费插画\n2D/3D/手绘插画\n阿里插画库\n\n\n\n# 配图\n\n可画-文章配图\n\n\n# Logo\n\nlogo生成1\nlogo生成2\n\n\n# Emoji表情\n\nEmoji百科\n\n小技巧\n\n在任意输入框快速打开emoji表情方法：\nWindows系统下按Win + .\nMac系统下按Control + Command + 空格",normalizedContent:"# 插件推荐\n\n\n# 插画\n\n免费插画\n2d/3d/手绘插画\n阿里插画库\n\n\n\n# 配图\n\n可画-文章配图\n\n\n# logo\n\nlogo生成1\nlogo生成2\n\n\n# emoji表情\n\nemoji百科\n\n小技巧\n\n在任意输入框快速打开emoji表情方法：\nwindows系统下按win + .\nmac系统下按control + command + 空格",charsets:{cjk:!0},lastUpdated:"2024/12/21, 13:59:01",lastUpdatedTimestamp:1734760741e3},{title:"Home",frontmatter:{home:!0,heroImage:"/img/logo.png",heroText:"王清欢的知识库",tagline:"🚀 解决问题，承担责任，优雅生活。",actionText:"开始探索 →",actionLink:"/pages/9b85e0/",bannerBg:"none",features:[{title:"1️⃣ 编程基础",details:"语言的原理，类库的实现，编程技术（并发、异步等），编程范式，设计模式... 🕌",link:"/pages/fa0f35/"},{title:"2️⃣ 理论知识",details:"掌握技术基础可以找到答案和知识，基础是抽象和归纳，可以形成进一步的推论... 🎢",link:"/pages/240fd4/"},{title:"3️⃣ 开源实践",details:"“只要是我不能创造的，我就还不理解” 💬 -- 费曼",link:"/pages/93824d/"}],postList:"none"},regularPath:"/",relativePath:"index.md",key:"v-35460c03",path:"/",headers:[{level:2,title:"💯 Google 评分卡",slug:"💯-google-评分卡",normalizedTitle:"💯 google 评分卡",charIndex:2},{level:2,title:"🤖 我的开源项目",slug:"🤖-我的开源项目",normalizedTitle:"🤖 我的开源项目",charIndex:1627},{level:2,title:"🎉 上新推荐",slug:"🎉-上新推荐",normalizedTitle:"🎉 上新推荐",charIndex:2292},{level:2,title:"💭 反馈与交流",slug:"💭-反馈与交流",normalizedTitle:"💭 反馈与交流",charIndex:2380}],headersStr:"💯 Google 评分卡 🤖 我的开源项目 🎉 上新推荐 💭 反馈与交流",content:"# 💯 Google 评分卡\n\nLevel-1\n\n0 – 对于相关的技术领域还不熟悉\n1 – 可以读懂这个领域的基础知识\n2 – 可以实现一些小的改动，清楚基本的原理，并能够在简单的指导下自己找到更多的细节\n\nLevel-2\n\n3 – 基本精通这个技术领域，完全不需要别人的帮助\n4 – 对这个技术领域非常的熟悉和舒适，可以应对和完成所有的日常工作\n5 – 对于该技术领域有非常底层的了解和深入的技能\n\nLevel-3\n\n6 – 能够从零开发大规模的程序和系统，掌握底层和内在原理，能够设计和部署大规模的分布式系统架构\n7 – 理解并能利用高级技术，以及相关的内在原理，并可以从根本上自动化大量的系统管理和运维工作\n8 – 对于一些边角和晦涩的技术、协议和系统工作原理有很深入的理解和经验。能够设计，部署并负责非常关键以及规模很大的基础设施，并能够构建相应的自动化设施\n\nLevel-4\n\n9 – 能够在该技术领域出一本经典的书。并和标准委员会的人一起工作制定相关的技术标准和方法\n10 – 在该领域写过一本书，被业内尊为专家，并是该技术的发明人\n\n# - name: OpenHarmony\n#   desc: 开放原子开源基金会\n#   link: https://docs.openharmony.cn/pages/000000/\n#   bgColor: '#f1f1f1'\n#   textColor: '#2A3344'\n- name: Level-1\n  desc: 0 – 对于相关的技术领域还不熟悉 <br/>\n        1 – 可以读懂这个领域的基础知识 <br/>\n        <strong>2 – 可以实现一些小的改动，清楚基本的原理，并能够在简单的指导下自己找到更多的细节 </strong>\n  link: https://github.com/wang-haihua/hidb\n  bgColor: '#f1f1f1'\n  textColor: '#2A3344'\n- name: Level-2\n  desc: 3 – 基本精通这个技术领域，完全不需要别人的帮助 <br/>\n        4 – 对这个技术领域非常的熟悉和舒适，可以应对和完成所有的日常工作 <br/>\n        5 – 对于该技术领域有非常底层的了解和深入的技能\n  link: https://wang-haihua.github.io/pages/4b9df2/\n  bgColor: '#f1f1f1'\n  textColor: '#2A3344'\n- name: Level-3\n  desc: 6 – 能够从零开发大规模的程序和系统，掌握底层和内在原理，能够设计和部署大规模的分布式系统架构 <br/>\n        7 – 理解并能利用高级技术，以及相关的内在原理，并可以从根本上自动化大量的系统管理和运维工作 <br/>\n        8 – 对于一些边角和晦涩的技术、协议和系统工作原理有很深入的理解和经验。能够设计，部署并负责非常关键以及规模很大的基础设施，并能够构建相应的自动化设施\n  link: https://github.com/wang-haihua/pgbaseline\n  bgColor: '#f1f1f1'\n  textColor: '#2A3344'\n- name: Level-4\n  desc: 9 – 能够在该技术领域出一本经典的书。并和标准委员会的人一起工作制定相关的技术标准和方法 <br/>\n        10 – 在该领域写过一本书，被业内尊为专家，并是该技术的发明人\n  link: https://github.com/wang-haihua/pgbaseline\n  bgColor: '#f1f1f1'\n  textColor: '#2A3344'\n\n\n\n\n# 🤖 我的开源项目\n\nhidb\n\n🚀极简数据库内核实现\n\npgproxy\n\nPostgreSQL 数据库代理中间件，提供负载均衡能力\n\npgbaseline\n\nPostgreSQL 安全配置基线检测工具\n\n# - name: OpenHarmony\n#   desc: 开放原子开源基金会\n#   link: https://docs.openharmony.cn/pages/000000/\n#   bgColor: '#f1f1f1'\n#   textColor: '#2A3344'\n- name: hidb\n  desc: 🚀极简数据库内核实现\n  link: https://github.com/wang-haihua/hidb\n  bgColor: '#f1f1f1'\n  textColor: '#2A3344'\n- name: pgproxy\n  desc: PostgreSQL 数据库代理中间件，提供负载均衡能力\n  link: https://wang-haihua.github.io/pages/4b9df2/\n  bgColor: '#f1f1f1'\n  textColor: '#2A3344'\n- name: pgbaseline\n  desc: PostgreSQL 安全配置基线检测工具\n  link: https://github.com/wang-haihua/pgbaseline\n  bgColor: '#f1f1f1'\n  textColor: '#2A3344'\n\n\n\n\n# 🎉 上新推荐\n\n * v1.1.x\n   * 新增实用技巧 费曼学习法。详情\n * v1.0.x：新增栏目 C/C++ 学习笔记。详情\n\n更多上新请查阅：更新日志\n\n\n\n# 💭 反馈与交流\n\n在使用过程中有任何问题和想法，请给我提 Issue。 你也可以在Issue查看别人提的问题和给出解决方案。\n\n或者直接联系我：\n\n我的微信(备注\"来自知识库\")   微信支付请笔者喝杯咖啡 ☕   支付宝打赏笔者品盏茶 🍵",normalizedContent:"# 💯 google 评分卡\n\nlevel-1\n\n0 – 对于相关的技术领域还不熟悉\n1 – 可以读懂这个领域的基础知识\n2 – 可以实现一些小的改动，清楚基本的原理，并能够在简单的指导下自己找到更多的细节\n\nlevel-2\n\n3 – 基本精通这个技术领域，完全不需要别人的帮助\n4 – 对这个技术领域非常的熟悉和舒适，可以应对和完成所有的日常工作\n5 – 对于该技术领域有非常底层的了解和深入的技能\n\nlevel-3\n\n6 – 能够从零开发大规模的程序和系统，掌握底层和内在原理，能够设计和部署大规模的分布式系统架构\n7 – 理解并能利用高级技术，以及相关的内在原理，并可以从根本上自动化大量的系统管理和运维工作\n8 – 对于一些边角和晦涩的技术、协议和系统工作原理有很深入的理解和经验。能够设计，部署并负责非常关键以及规模很大的基础设施，并能够构建相应的自动化设施\n\nlevel-4\n\n9 – 能够在该技术领域出一本经典的书。并和标准委员会的人一起工作制定相关的技术标准和方法\n10 – 在该领域写过一本书，被业内尊为专家，并是该技术的发明人\n\n# - name: openharmony\n#   desc: 开放原子开源基金会\n#   link: https://docs.openharmony.cn/pages/000000/\n#   bgcolor: '#f1f1f1'\n#   textcolor: '#2a3344'\n- name: level-1\n  desc: 0 – 对于相关的技术领域还不熟悉 <br/>\n        1 – 可以读懂这个领域的基础知识 <br/>\n        <strong>2 – 可以实现一些小的改动，清楚基本的原理，并能够在简单的指导下自己找到更多的细节 </strong>\n  link: https://github.com/wang-haihua/hidb\n  bgcolor: '#f1f1f1'\n  textcolor: '#2a3344'\n- name: level-2\n  desc: 3 – 基本精通这个技术领域，完全不需要别人的帮助 <br/>\n        4 – 对这个技术领域非常的熟悉和舒适，可以应对和完成所有的日常工作 <br/>\n        5 – 对于该技术领域有非常底层的了解和深入的技能\n  link: https://wang-haihua.github.io/pages/4b9df2/\n  bgcolor: '#f1f1f1'\n  textcolor: '#2a3344'\n- name: level-3\n  desc: 6 – 能够从零开发大规模的程序和系统，掌握底层和内在原理，能够设计和部署大规模的分布式系统架构 <br/>\n        7 – 理解并能利用高级技术，以及相关的内在原理，并可以从根本上自动化大量的系统管理和运维工作 <br/>\n        8 – 对于一些边角和晦涩的技术、协议和系统工作原理有很深入的理解和经验。能够设计，部署并负责非常关键以及规模很大的基础设施，并能够构建相应的自动化设施\n  link: https://github.com/wang-haihua/pgbaseline\n  bgcolor: '#f1f1f1'\n  textcolor: '#2a3344'\n- name: level-4\n  desc: 9 – 能够在该技术领域出一本经典的书。并和标准委员会的人一起工作制定相关的技术标准和方法 <br/>\n        10 – 在该领域写过一本书，被业内尊为专家，并是该技术的发明人\n  link: https://github.com/wang-haihua/pgbaseline\n  bgcolor: '#f1f1f1'\n  textcolor: '#2a3344'\n\n\n\n\n# 🤖 我的开源项目\n\nhidb\n\n🚀极简数据库内核实现\n\npgproxy\n\npostgresql 数据库代理中间件，提供负载均衡能力\n\npgbaseline\n\npostgresql 安全配置基线检测工具\n\n# - name: openharmony\n#   desc: 开放原子开源基金会\n#   link: https://docs.openharmony.cn/pages/000000/\n#   bgcolor: '#f1f1f1'\n#   textcolor: '#2a3344'\n- name: hidb\n  desc: 🚀极简数据库内核实现\n  link: https://github.com/wang-haihua/hidb\n  bgcolor: '#f1f1f1'\n  textcolor: '#2a3344'\n- name: pgproxy\n  desc: postgresql 数据库代理中间件，提供负载均衡能力\n  link: https://wang-haihua.github.io/pages/4b9df2/\n  bgcolor: '#f1f1f1'\n  textcolor: '#2a3344'\n- name: pgbaseline\n  desc: postgresql 安全配置基线检测工具\n  link: https://github.com/wang-haihua/pgbaseline\n  bgcolor: '#f1f1f1'\n  textcolor: '#2a3344'\n\n\n\n\n# 🎉 上新推荐\n\n * v1.1.x\n   * 新增实用技巧 费曼学习法。详情\n * v1.0.x：新增栏目 c/c++ 学习笔记。详情\n\n更多上新请查阅：更新日志\n\n\n\n# 💭 反馈与交流\n\n在使用过程中有任何问题和想法，请给我提 issue。 你也可以在issue查看别人提的问题和给出解决方案。\n\n或者直接联系我：\n\n我的微信(备注\"来自知识库\")   微信支付请笔者喝杯咖啡 ☕   支付宝打赏笔者品盏茶 🍵",charsets:{cjk:!0},lastUpdated:"2024/12/21, 13:59:01",lastUpdatedTimestamp:1734760741e3},{title:"博客文章",frontmatter:{archivesPage:!0,title:"博客文章",permalink:"/blog/",article:!1},regularPath:"/@pages/archivesPage.html",relativePath:"@pages/archivesPage.md",key:"v-6a78bbac",path:"/blog/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/03/24, 20:06:17",lastUpdatedTimestamp:1679659577e3}],themeConfig:{nav:[{text:"首页",link:"/"},{text:"编程基础",link:"/pages/fa0f35/",items:[{text:"编程语言",items:[{text:"C/C++ 学习笔记",link:"/pages/bb810c/"},{text:"Golang 学习笔记",link:"/pages/4b9df2/"}]},{text:"算法分析",items:[{text:"LeetCode 刷题笔记",link:"/pages/0f3851/"}]},{text:"操作系统",items:[{text:"Linux 基础",link:"/pages/bcf4de/"},{text:"Vim 实用技巧",link:"/pages/875f14/"},{text:"Shell 脚本编程",link:"/pages/028d7e/"},{text:"GDB 学习笔记",link:"/pages/f4281d/"}]},{text:"开发工具",items:[{text:"Git 学习笔记",link:"/pages/8292d8/"}]}]},{text:"理论知识",link:"/pages/240fd4/",items:[{text:"分布式理论",items:[{text:"共识算法",link:""},{text:"分布式事务",link:""}]}]},{text:"开源实践",link:"/pages/93824d/",items:[{text:"数据库内核",items:[{text:"PostgreSQL",link:""},{text:"Postgres-XL",link:""}]},{text:"hidb",link:""},{text:"pgproxy",link:""}]},{text:"胡思乱想",link:"/pages/0232db/",items:[{text:"实用技巧",link:"/pages/baaa02/"},{text:"学习方法",link:"/pages/f2a556/"},{text:"资源分享",link:"/pages/35750f/"}]}],sidebarDepth:2,logo:"/img/logo.png",repo:"wang-haihua/TechStack",searchMaxSuggestions:10,lastUpdated:"上次更新",sidebar:{"/00.目录导航/":[["00.全站导航.md","全站导航","/pages/9b85e0/"],["01.计算机基础.md","计算机基础","/pages/fa0f35/"],["02.分布式系统.md","分布式系统","/pages/240fd4/"],["03.我的开源项目.md","我的开源项目","/pages/93824d/"],["04.胡思乱想.md","胡思乱想","/pages/0232db/"]],catalogue:{},"/01.C&Cpp学习笔记/":[{title:"C语言基础",collapsable:!1,children:[["01.C语言基础/01.数据类型.md","数据类型","/pages/bb810c/"],["01.C语言基础/02.指针与字符串.md","指针与字符串","/pages/28b16e/"],["01.C语言基础/03.结构类型.md","结构类型","/pages/d1c8a2/"],["01.C语言基础/04.链表.md","链表","/pages/8a62ea/"],["01.C语言基础/05.程序结构.md","程序结构","/pages/4c654b/"],["01.C语言基础/06.文件.md","文件","/pages/31eb8a/"]]},{title:"C++面向对象编程",collapsable:!1,children:[{title:"C++面向对象",collapsable:!1,children:[["02.C++面向对象编程/01.C++面向对象/01.从 C 到 C++.md","从 C 到 C++","/pages/1718db/"],["02.C++面向对象编程/01.C++面向对象/02.C++ 类和对象基础.md","C++ 类和对象基础","/pages/f80b37/"],["02.C++面向对象编程/01.C++面向对象/03.C++ 构造函数与析构函数.md","C++ 构造函数与析构函数","/pages/c03a08/"],["02.C++面向对象编程/01.C++面向对象/04.C++ 类和对象提高.md","C++ 类和对象提高","/pages/bbcad6/"],["02.C++面向对象编程/01.C++面向对象/05.运算符重载.md","运算符重载","/pages/8176d2/"],["02.C++面向对象编程/01.C++面向对象/06.C++ 继承.md","C++ 继承","/pages/7e1638/"],["02.C++面向对象编程/01.C++面向对象/07.C++ 多态.md","C++ 多态","/pages/7df88b/"]]},{title:"C++ STL",collapsable:!1,children:[["02.C++面向对象编程/02.C++ STL/01.C++ 输入输出流.md","C++ 输入输出流","/pages/f0b4b2/"],["02.C++面向对象编程/02.C++ STL/02.C++ 泛型编程.md","C++ 泛型编程","/pages/b3a5d5/"],["02.C++面向对象编程/02.C++ STL/03.C++ string类.md","C++ string类","/pages/9b802c/"],["02.C++面向对象编程/02.C++ STL/04.C++ 标准模板库 STL 概述.md","C++ 标准模板库 STL 概述","/pages/79b686/"],["02.C++面向对象编程/02.C++ STL/05.C++ 标准模板库 STL 顺序容器.md","C++ 标准模板库 STL 顺序容器","/pages/6cbf31/"],["02.C++面向对象编程/02.C++ STL/06.C++ 标准模板库 STL 函数对象.md","C++ 标准模板库 STL 函数对象","/pages/2fa612/"],["02.C++面向对象编程/02.C++ STL/07.C++ 标准模板库 STL 关联容器.md","C++ 标准模板库 STL 关联容器","/pages/56c2ea/"],["02.C++面向对象编程/02.C++ STL/08.C++ 标准模板库 STL 容器适配器.md","C++ 标准模板库 STL 容器适配器","/pages/c24021/"]]},{title:"C++ 新特性",collapsable:!1,children:[["02.C++面向对象编程/03.C++ 新特性/01.C++11 新特性.md","C++11 新特性","/pages/dc0db4/"]]}]}],"/02.Golang学习笔记/":[{title:"Golang基础",collapsable:!1,children:[{title:"数据类型",collapsable:!1,children:[["01.Golang基础/01.数据类型/01.变量与常量.md","变量与常量","/pages/4b9df2/"],["01.Golang基础/01.数据类型/02.基础数据类型之值类型.md","基础数据类型之值类型","/pages/97e5f5/"],["01.Golang基础/01.数据类型/03.基础数据类型之引用类型.md","基础数据类型之引用类型","/pages/410fb6/"]]},{title:"流程控制",collapsable:!1,children:[["01.Golang基础/02.流程控制/01.条件判断.md","条件判断","/pages/d8dd95/"],["01.Golang基础/02.流程控制/02.循环控制.md","循环控制","/pages/3a35c4/"]]},{title:"函数",collapsable:!1,children:[["01.Golang基础/03.函数/01.函数基础.md","函数基础","/pages/06199f/"],["01.Golang基础/03.函数/02.匿名函数与闭包.md","匿名函数与闭包","/pages/95ec3d/"],["01.Golang基础/03.函数/03.延迟调用.md","延迟调用","/pages/f5e003/"]]}]}],"/03.LeetCode刷题笔记/":[{title:"基础算法",collapsable:!1,children:[{title:"双指针",collapsable:!1,children:[["01.基础算法/01.双指针/01.双指针基础.md","双指针基础","/pages/0f3851/"],["01.基础算法/01.双指针/02.碰撞指针.md","碰撞指针","/pages/700e2e/"],["01.基础算法/01.双指针/03.快慢指针.md","快慢指针","/pages/85ec9f/"],["01.基础算法/01.双指针/04.滑动窗口.md","滑动窗口","/pages/90a84d/"]]},{title:"二分查找",collapsable:!1,children:[["01.基础算法/02.二分查找/01.基础应用.md","基础应用","/pages/3b46c0/"],["01.基础算法/02.二分查找/02.边界收缩.md","边界收缩","/pages/0a4983/"],["01.基础算法/02.二分查找/03.局部有序.md","局部有序","/pages/d09927/"]]},{title:"排序算法",collapsable:!1,children:[["01.基础算法/03.排序算法/01.八大排序.md","01八大排序","/pages/3aa832/"],["01.基础算法/03.排序算法/02.快速排序.md","02快速排序","/pages/8c54f6/"],["01.基础算法/03.排序算法/03.归并排序.md","03归并排序","/pages/832c90/"],["01.基础算法/03.排序算法/04.桶排序.md","04桶排序","/pages/a40ad8/"],["01.基础算法/03.排序算法/05.堆排序.md","05堆排序","/pages/c2b2d7/"]]},{title:"优先搜索",collapsable:!1,children:[["01.基础算法/04.优先搜索/01.递归.md","01递归","/pages/9c6520/"],["01.基础算法/04.优先搜索/02.网格结构深度优先搜索.md","02网格结构深度优先搜索","/pages/88ecc3/"],["01.基础算法/04.优先搜索/03.树结构深度优先搜索.md","03树结构深度优先搜索","/pages/35b7a7/"],["01.基础算法/04.优先搜索/04.图结构深度优先搜索.md","04图结构深度优先搜索","/pages/13d287/"],["01.基础算法/04.优先搜索/05.网格结构广度优先搜索.md","05网格结构广度优先搜索","/pages/3cb71c/"],["01.基础算法/04.优先搜索/06.树结构广度优先搜索.md","06树结构广度优先搜索","/pages/5134a9/"],["01.基础算法/04.优先搜索/07.图结构广度优先搜索.md","07图结构广度优先搜索","/pages/4da67f/"]]},{title:"回溯算法",collapsable:!1,children:[["01.基础算法/05.回溯算法/01.递归.md","01递归","/pages/9c7a53/"],["01.基础算法/05.回溯算法/02.子集问题.md","02 子集问题","/pages/cbe7a5/"],["01.基础算法/05.回溯算法/03.全排列问题.md","03 全排列问题","/pages/71f066/"],["01.基础算法/05.回溯算法/04.组合问题.md","04 组合问题","/pages/21e47b/"],["01.基础算法/05.回溯算法/05.回溯搜索问题.md","05 回溯搜索问题","/pages/e9a845/"]]}]},{title:"基础数据结构",collapsable:!1,children:[{title:"线性表与哈希表",collapsable:!1,children:[["02.基础数据结构/01.线性表与哈希表/01.数组.md","01数组","/pages/e3b123/"],["02.基础数据结构/01.线性表与哈希表/02.栈和队列.md","02栈和队列","/pages/c3fc14/"],["02.基础数据结构/01.线性表与哈希表/03.单调栈.md","03单调栈","/pages/45a757/"],["02.基础数据结构/01.线性表与哈希表/04.优先队列.md","04优先队列","/pages/366d13/"],["02.基础数据结构/01.线性表与哈希表/05.双端队列.md","05双端队列","/pages/dfe85c/"],["02.基础数据结构/01.线性表与哈希表/06.哈希表.md","06哈希表","/pages/d9969b/"],["02.基础数据结构/01.线性表与哈希表/07.多重集合.md","07多重集合","/pages/52cdea/"],["02.基础数据结构/01.线性表与哈希表/08.前缀和.md","08前缀和","/pages/45a8d1/"],["02.基础数据结构/01.线性表与哈希表/09.数据结构设计.md","09数据结构设计","/pages/7a84c5/"]]},{title:"字符串",collapsable:!1,children:[["02.基础数据结构/02.字符串/01.字符串比较.md","01字符串比较","/pages/5f258c/"],["02.基础数据结构/02.字符串/02.回文字符串.md","02回文字符串","/pages/8a4607/"],["02.基础数据结构/02.字符串/03.字符串匹配.md","03字符串匹配","/pages/d0219a/"],["02.基础数据结构/02.字符串/04.字符串算术表达式.md","04字符串算术表达式","/pages/9ad0e3/"]]},{title:"单链表",collapsable:!1,children:[["02.基础数据结构/03.单链表/01.链表基础操作.md","01链表基础操作","/pages/1b79f3/"],["02.基础数据结构/03.单链表/02.链表遍历.md","02链表遍历","/pages/3871a6/"]]},{title:"二叉树",collapsable:!1,children:[["02.基础数据结构/04.二叉树/01.二叉树的属性.md","01二叉树的属性","/pages/334633/"],["02.基础数据结构/04.二叉树/02.二叉树的操作.md","02二叉树的操作","/pages/f97107/"],["02.基础数据结构/04.二叉树/03.层次遍历.md","03层次遍历","/pages/22355f/"],["02.基础数据结构/04.二叉树/04.前中后序遍历.md","04前中后序遍历","/pages/0480d5/"],["02.基础数据结构/04.二叉树/05.二叉搜索树的属性.md","05二叉搜索树的属性","/pages/b9029c/"],["02.基础数据结构/04.二叉树/06.二叉搜索树的操作.md","06二叉搜索树的操作","/pages/8995b9/"],["02.基础数据结构/04.二叉树/07.字典树.md","07字典树","/pages/5c0017/"],["02.基础数据结构/04.二叉树/08.二叉搜索树BST.md","08二叉搜索树BST","/pages/01f1e6/"]]},{title:"图",collapsable:!1,children:[["02.基础数据结构/05.图/01.二分图.md","01二分图","/pages/208d53/"],["02.基础数据结构/05.图/02.拓扑排序.md","02拓扑排序","/pages/f51192/"],["02.基础数据结构/05.图/03.并查集.md","03并查集","/pages/e70bde/"],["02.基础数据结构/05.图/04.最小生成树.md","04最小生成树","/pages/599b16/"],["02.基础数据结构/05.图/05.最短路径.md","05最短路径","/pages/cc367b/"]]}]},{title:"进阶算法",collapsable:!1,children:[{title:"贪心算法",collapsable:!1,children:[["03.进阶算法/01.贪心算法/01.跳跃游戏.md","01跳跃游戏","/pages/fbf15c/"],["03.进阶算法/01.贪心算法/02.分配问题.md","02分配问题","/pages/82a324/"],["03.进阶算法/01.贪心算法/03.区间问题.md","03区间问题","/pages/df21f6/"]]},{title:"分治策略",collapsable:!1,children:[]},{title:"动态规划",collapsable:!1,children:[["03.进阶算法/03.动态规划/01.一维动态规划.md","01一维动态规划","/pages/be1ad8/"],["03.进阶算法/03.动态规划/02.二维动态规划.md","02二维动态规划","/pages/5b4acb/"],["03.进阶算法/03.动态规划/03.分割型动态规划.md","03分割型动态规划","/pages/4015bd/"],["03.进阶算法/03.动态规划/04.子序列问题.md","04子序列问题","/pages/221930/"],["03.进阶算法/03.动态规划/05.背包问题.md","05背包问题","/pages/6417f0/"],["03.进阶算法/03.动态规划/06.字符串编辑问题.md","06字符串编辑问题","/pages/ef03e8/"],["03.进阶算法/03.动态规划/07.股票交易问题.md","07股票交易问题","/pages/c50903/"]]}]},{title:"其他内容",collapsable:!1,children:[{title:"数学问题",collapsable:!1,children:[["05.其他内容/01.数学问题/01.公倍数与公因数.md","01公倍数与公因数","/pages/1a23eb/"],["05.其他内容/01.数学问题/02.质数问题.md","02质数问题","/pages/8d884e/"],["05.其他内容/01.数学问题/03.进制转换问题.md","03进制转换问题","/pages/aef702/"],["05.其他内容/01.数学问题/04.数字字符串求和问题.md","04数字字符串求和问题","/pages/65cf94/"],["05.其他内容/01.数学问题/05.众数问题.md","05众数问题","/pages/be2fa2/"],["05.其他内容/01.数学问题/06.中位数问题.md","06中位数问题","/pages/a8b0f0/"],["05.其他内容/01.数学问题/07.数字处理问题.md","07数字处理问题","/pages/261fe5/"],["05.其他内容/01.数学问题/08.随机数问题.md","08随机数问题","/pages/708f52/"]]},{title:"位运算",collapsable:!1,children:[["05.其他内容/02.位运算/01.位运算基础.md","01位运算基础","/pages/296a65/"],["05.其他内容/02.位运算/02.妙用异或运算.md","02妙用异或运算","/pages/bec6ef/"],["05.其他内容/02.位运算/03.二进制特性.md","03二进制特性","/pages/d88bb5/"]]}]}],"/04.Linux操作系统编程/":[{title:"Linux 基础",collapsable:!1,children:[["01.Linux 基础/01.基本 Linux 命令.md","基本Linux命令","/pages/bcf4de/"],["01.Linux 基础/02.文件与目录操作.md","文件与目录操作","/pages/f56384/"],["01.Linux 基础/03.进程与线程.md","进程与线程","/pages/0b3143/"],["01.Linux 基础/04.线程同步与进程通信.md","线程同步与进程通信","/pages/ff5e65/"],["01.Linux 基础/05.Linux 文件权限.md","Linux 文件权限","/pages/5d33e8/"],["01.Linux 基础/06.Linux 命令行快捷键.md","Linux 命令行快捷键","/pages/154d65/"]]},{title:"Vim 实用技巧",collapsable:!1,children:[["02.Vim 实用技巧/00.Vim常用技巧.md","Vim常用技巧","/pages/875f14/"],["02.Vim 实用技巧/01.Vim解决问题的方式.md","Vim解决问题的方式","/pages/dfff1a/"],["02.Vim 实用技巧/02.Vim普通模式.md","Vim普通模式","/pages/7fbd14/"],["02.Vim 实用技巧/03.Vim插入模式.md","Vim插入模式","/pages/aab584/"],["02.Vim 实用技巧/04.Vim可视模式.md","Vim可视模式","/pages/2a0740/"],["02.Vim 实用技巧/05.Vim命令行模式.md","Vim命令行模式","/pages/d598a0/"]]},{title:"Shell 脚本编程",collapsable:!1,children:[["03.Shell 脚本编程/00.目录.md","目录","/pages/028d7e/"]]},{title:"GDB学习笔记",collapsable:!1,children:[["04.GDB学习笔记/01.GDB基础调试.md","GDB基础调试","/pages/f4281d/"],["04.GDB学习笔记/02.GDB调试Coredump.md","GDB调试Coredump","/pages/2f33c0/"]]}],"/05.Git 学习笔记/":[{title:"Git 常用技巧",collapsable:!1,children:[["10.Git 常用技巧/01.常用Git命令清单.md","常用Git命令清单","/pages/8292d8/"],["10.Git 常用技巧/02.Git使用手册.md","Git使用手册","/pages/9a7ee40fc232253e"],["10.Git 常用技巧/03.Git变基合并.md","Git变基合并","/pages/c10281/"],["10.Git 常用技巧/04.Git命令思维导图.md","Git命令思维导图","/pages/4cbc21/"],["10.Git 常用技巧/05.Git修改分支名.md","Git修改分支名","/pages/922650/"],["10.Git 常用技巧/06.Markdown使用教程.md","Markdown使用教程","/pages/ad247c4332211551"],["10.Git 常用技巧/07.Git提交规范.md","Git提交规范","/pages/172ab2/"],["10.Git 常用技巧/08.Git合并多个提交.md","Git合并多个提交","/pages/1d2468/"]]},{title:"GitHub 高级技巧",collapsable:!1,children:[["20.GitHub 高级技巧/11.GitHub高级搜索技巧.md","GitHub高级搜索技巧","/pages/4c778760be26d8b3"],["20.GitHub 高级技巧/12.GitHub Actions 实现自动部署静态博客.md","GitHub Actions 实现自动部署静态博客","/pages/6b9d359ec5aa5019"],["20.GitHub 高级技巧/13.GitHub Actions 定时运行代码：每天定时百度链接推送.md","GitHub Actions 定时运行代码：每天定时百度链接推送","/pages/f44d2f9ad04ab8d3"],["20.GitHub 高级技巧/14.GitHub加速下载项目的方法.md","GitHub加速下载项目的方法","/pages/95331c6a9613faf8"],["20.GitHub 高级技巧/15.GitHub提交MR分支合并请求.md","GitHub提交MR分支合并请求","/pages/fcb482/"]]},{title:"Git 官方文档笔记",collapsable:!1,children:[["30.Git 官方文档笔记/10.Git基础与命令.md","Git基础与命令","/pages/635088/"],["30.Git 官方文档笔记/20.Git分支-分支原理.md","Git分支-分支原理","/pages/4bef1a/"],["30.Git 官方文档笔记/30.Git分支的新建与合并-分支操作.md","Git分支的新建与合并-分支操作","/pages/ea5a8c/"],["30.Git 官方文档笔记/40.Git分支管理-查看分支.md","Git分支管理-查看分支","/pages/a399b3/"],["30.Git 官方文档笔记/50.Git分支开发工作流.md","Git分支开发工作流","/pages/49ee30/"],["30.Git 官方文档笔记/60.Git分支-远程分支.md","Git分支-远程分支","/pages/574d62/"],["30.Git 官方文档笔记/70.Git分支-变基.md","Git分支-变基","/pages/3a3247/"],["30.Git 官方文档笔记/80.Git工具-查看修订版本.md","Git工具-查看修订版本","/pages/c984d1/"],["30.Git 官方文档笔记/90.Git工具-交互式暂存.md","Git工具-交互式暂存","/pages/76d859/"],["30.Git 官方文档笔记/100.Git工具-重写历史.md","Git工具-重写历史","/pages/1832fe/"],["30.Git 官方文档笔记/110.Git工具-重置揭密.md","Git工具-重置揭密","/pages/d9e9c6/"]]}],"/06.FixBug/":[["01.问答.md","问答","/pages/9cc27d"]],"/07.胡思乱想/":[{title:"实用技巧",collapsable:!1,children:[["01.实用技巧/01.2分钟规则.md","2分钟规则","/pages/baaa02/"],["01.实用技巧/02.一行代码“黑”掉任意网站.md","一行代码“黑”掉任意网站","/pages/dcebaf/","原创"],["01.实用技巧/03.搜索引擎使用技巧.md","搜索引擎使用技巧","/pages/ce818a"]]},{title:"学习方法",collapsable:!1,children:[["02.学习方法/00.费曼学习法.md","费曼学习法","/pages/f2a556/"],["02.学习方法/01.笔记方法.md","笔记方法","/pages/e60c81/"],["02.学习方法/02.提高学习效率的策略.md","提高学习效率的策略","/pages/a8692ab3bdcb4588"],["02.学习方法/03.提高记忆的技巧.md","提高记忆的技巧","/pages/996822b2a2ca6e3b"],["02.学习方法/04.自律小建议.md","自律小建议","/pages/c3f302a03c8daf79"],["02.学习方法/05.处理问题的思路.md","处理问题的思路","/pages/9ba2b8fb13de1957"]]},{title:"资源分享",collapsable:!1,children:[["03.资源分享/01.站点扩展.md","站点扩展","/pages/35750f/"],["03.资源分享/02.素材资源.md","素材资源","/pages/023f1a/"]]}]},updateBar:{showToArticle:!1},pageStyle:"line",category:!1,tag:!1,author:{name:"王清欢",href:"https://github.com/wang-haihua"},social:{icons:[{iconClass:"icon-youjian",title:"发邮件",link:"mailto:wanghaihua@hust.edu.cn"},{iconClass:"icon-github",title:"GitHub",link:"https://github.com/wang-haihua"},{iconClass:"icon-csdn",title:"CSDN",link:"https://randy.blog.csdn.net/"}]},footer:{createYear:2023,copyrightInfo:"Wang Qinghuan | MIT License"}}};var El=t(88),_l=t.n(El),kl=t(95),wl=t(96),jl=t(11);var Al={computed:{$filterPosts(){return this.$site.pages.filter(n=>{const{frontmatter:{pageComponent:e,article:t,home:i}}=n;return!(e||!1===t||!0===i)})},$sortPosts(){return(n=this.$filterPosts).sort((n,e)=>{const t=n.frontmatter.sticky,i=e.frontmatter.sticky;return t&&i?t==i?Object(jl.a)(n,e):t-i:t&&!i?-1:!t&&i?1:Object(jl.a)(n,e)}),n;var n},$sortPostsByDate(){return(n=this.$filterPosts).sort((n,e)=>Object(jl.a)(n,e)),n;var n},$groupPosts(){return function(n){const e={},t={};for(let i=0,r=n.length;i<r;i++){const{frontmatter:{categories:r,tags:a}}=n[i];"array"===Object(jl.n)(r)&&r.forEach(t=>{t&&(e[t]||(e[t]=[]),e[t].push(n[i]))}),"array"===Object(jl.n)(a)&&a.forEach(e=>{e&&(t[e]||(t[e]=[]),t[e].push(n[i]))})}return{categories:e,tags:t}}(this.$sortPosts)},$categoriesAndTags(){return function(n){const e=[],t=[];for(let t in n.categories)e.push({key:t,length:n.categories[t].length});for(let e in n.tags)t.push({key:e,length:n.tags[e].length});return{categories:e,tags:t}}(this.$groupPosts)}}};Vt.component(kl.default),Vt.component(wl.default);function Tl(n){return n.toString().padStart(2,"0")}t(244);Vt.component("Badge",()=>Promise.all([t.e(0),t.e(3)]).then(t.bind(null,506))),Vt.component("CodeBlock",()=>Promise.resolve().then(t.bind(null,95))),Vt.component("CodeGroup",()=>Promise.resolve().then(t.bind(null,96)));t(245);var Cl=[_l.a,({Vue:n,options:e,router:t,siteData:i})=>{i.pages.map(n=>{const{frontmatter:{date:e,author:t}}=n;"string"==typeof e&&"Z"===e.charAt(e.length-1)&&(n.frontmatter.date=function(n){n instanceof Date||(n=new Date(n));return`${n.getUTCFullYear()}-${Tl(n.getUTCMonth()+1)}-${Tl(n.getUTCDate())} ${Tl(n.getUTCHours())}:${Tl(n.getUTCMinutes())}:${Tl(n.getUTCSeconds())}`}(e)),t?n.author=t:i.themeConfig.author&&(n.author=i.themeConfig.author)}),n.mixin(Al)},{},({Vue:n})=>{n.mixin({computed:{$dataBlock(){return this.$options.__data__block__}}})},{},{},({router:n})=>{"undefined"!=typeof window&&(window._hmt=window._hmt||[],function(){var n=document.createElement("script");n.src="https://hm.baidu.com/hm.js?01293bffa6c3962016c08ba685c79d78";var e=document.getElementsByTagName("script")[0];e.parentNode.insertBefore(n,e)}(),n.afterEach((function(n){_hmt.push(["_trackPageview",n.fullPath])})))}],zl=[];class Bl extends class{constructor(){this.store=new Vt({data:{state:{}}})}$get(n){return this.store.state[n]}$set(n,e){Vt.set(this.store.state,n,e)}$emit(...n){this.store.$emit(...n)}$on(...n){this.store.$on(...n)}}{}Object.assign(Bl.prototype,{getPageAsyncComponent:ao,getLayoutAsyncComponent:so,getAsyncComponent:oo,getVueComponent:lo});var Il={install(n){const e=new Bl;n.$vuepress=e,n.prototype.$vuepress=e}};function Sl(n,e){const t=e.toLowerCase();return n.options.routes.some(n=>n.path.toLowerCase()===t)}var Ll={props:{pageKey:String,slotKey:{type:String,default:"default"}},render(n){const e=this.pageKey||this.$parent.$page.key;return uo("pageKey",e),Vt.component(e)||Vt.component(e,ao(e)),Vt.component(e)?n(e):n("")}},Pl={functional:!0,props:{slotKey:String,required:!0},render:(n,{props:e,slots:t})=>n("div",{class:["content__"+e.slotKey]},t()[e.slotKey])},ql={computed:{openInNewWindowTitle(){return this.$themeLocaleConfig.openNewWindowText||"(opens new window)"}}},Nl=(t(246),t(247),Object(bl.a)(ql,(function(){var n=this._self._c;return n("span",[n("svg",{staticClass:"icon outbound",attrs:{xmlns:"http://www.w3.org/2000/svg","aria-hidden":"true",focusable:"false",x:"0px",y:"0px",viewBox:"0 0 100 100",width:"15",height:"15"}},[n("path",{attrs:{fill:"currentColor",d:"M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"}}),this._v(" "),n("polygon",{attrs:{fill:"currentColor",points:"45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"}})]),this._v(" "),n("span",{staticClass:"sr-only"},[this._v(this._s(this.openInNewWindowTitle))])])}),[],!1,null,null,null).exports),$l={functional:!0,render(n,{parent:e,children:t}){if(e._isMounted)return t;e.$once("hook:mounted",()=>{e.$forceUpdate()})}};Vt.config.productionTip=!1,Vt.use(Rs),Vt.use(Il),Vt.mixin(function(n,e,t=Vt){!function(n){n.locales&&Object.keys(n.locales).forEach(e=>{n.locales[e].path=e});Object.freeze(n)}(e),t.$vuepress.$set("siteData",e);const i=new(n(t.$vuepress.$get("siteData"))),r=Object.getOwnPropertyDescriptors(Object.getPrototypeOf(i)),a={};return Object.keys(r).reduce((n,e)=>(e.startsWith("$")&&(n[e]=r[e].get),n),a),{computed:a}}(n=>class{setPage(n){this.__page=n}get $site(){return n}get $themeConfig(){return this.$site.themeConfig}get $frontmatter(){return this.$page.frontmatter}get $localeConfig(){const{locales:n={}}=this.$site;let e,t;for(const i in n)"/"===i?t=n[i]:0===this.$page.path.indexOf(i)&&(e=n[i]);return e||t||{}}get $siteTitle(){return this.$localeConfig.title||this.$site.title||""}get $canonicalUrl(){const{canonicalUrl:n}=this.$page.frontmatter;return"string"==typeof n&&n}get $title(){const n=this.$page,{metaTitle:e}=this.$page.frontmatter;if("string"==typeof e)return e;const t=this.$siteTitle,i=n.frontmatter.home?null:n.frontmatter.title||n.title;return t?i?i+" | "+t:t:i||"VuePress"}get $description(){const n=function(n){if(n){const e=n.filter(n=>"description"===n.name)[0];if(e)return e.content}}(this.$page.frontmatter.meta);return n||(this.$page.frontmatter.description||this.$localeConfig.description||this.$site.description||"")}get $lang(){return this.$page.frontmatter.lang||this.$localeConfig.lang||"en-US"}get $localePath(){return this.$localeConfig.path||"/"}get $themeLocaleConfig(){return(this.$site.themeConfig.locales||{})[this.$localePath]||{}}get $page(){return this.__page?this.__page:function(n,e){for(let t=0;t<n.length;t++){const i=n[t];if(i.path.toLowerCase()===e.toLowerCase())return i}return{path:"",frontmatter:{}}}(this.$site.pages,this.$route.path)}},yl)),Vt.component("Content",Ll),Vt.component("ContentSlotsDistributor",Pl),Vt.component("OutboundLink",Nl),Vt.component("ClientOnly",$l),Vt.component("Layout",so("Layout")),Vt.component("NotFound",so("NotFound")),Vt.prototype.$withBase=function(n){const e=this.$site.base;return"/"===n.charAt(0)?e+n.slice(1):n},window.__VUEPRESS__={version:"1.9.2",hash:"b5b9b74"},async function(n){const e="undefined"!=typeof window&&window.__VUEPRESS_ROUTER_BASE__?window.__VUEPRESS_ROUTER_BASE__:yl.routerBase||yl.base,t=new Rs({base:e,mode:"history",fallback:!1,routes:xl,scrollBehavior:(n,e,t)=>t||(n.hash?!Vt.$vuepress.$get("disableScrollBehavior")&&{selector:decodeURIComponent(n.hash)}:{x:0,y:0})});!function(n){n.beforeEach((e,t,i)=>{if(Sl(n,e.path))i();else if(/(\/|\.html)$/.test(e.path))if(/\/$/.test(e.path)){const t=e.path.replace(/\/$/,"")+".html";Sl(n,t)?i(t):i()}else i();else{const t=e.path+"/",r=e.path+".html";Sl(n,r)?i(r):Sl(n,t)?i(t):i()}})}(t);const i={};try{await Promise.all(Cl.filter(n=>"function"==typeof n).map(e=>e({Vue:Vt,options:i,router:t,siteData:yl,isServer:n})))}catch(n){console.error(n)}return{app:new Vt(Object.assign(i,{router:t,render:n=>n("div",{attrs:{id:"app"}},[n("RouterView",{ref:"layout"}),n("div",{class:"global-ui"},zl.map(e=>n(e)))])})),router:t}}(!1).then(({app:n,router:e})=>{e.onReady(()=>{n.$mount("#app")})})}]);