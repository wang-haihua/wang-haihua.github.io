(window.webpackJsonp=window.webpackJsonp||[]).push([[58],{386:function(t,r,e){"use strict";e.r(r);var _=e(7),a=Object(_.a)({},(function(){var t=this,r=t._self._c;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h2",{attrs:{id:"_05-网格结构广度优先搜索"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_05-网格结构广度优先搜索"}},[t._v("#")]),t._v(" 05 网格结构广度优先搜索")]),t._v(" "),r("h3",{attrs:{id:"广度优先搜索简介"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#广度优先搜索简介"}},[t._v("#")]),t._v(" 广度优先搜索简介")]),t._v(" "),r("p",[t._v("深度优先搜索"),r("code",[t._v("（depth-first seach，DFS）")]),t._v("在搜索到一个新的节点时，立即对该新节点进行遍历；因此遍历需要用先入后出的栈来实现，也可以通过与栈等价的递归来实现。")]),t._v(" "),r("p",[r("strong",[t._v("二维数组深度优先搜索的一般写法")]),t._v("：")]),t._v(" "),r("p",[t._v("​\t一般来说，深度优先搜索类型的题可以分为"),r("strong",[t._v("主函数")]),t._v("和"),r("strong",[t._v("辅函数")]),t._v("，主函数用于遍历所有的搜索位置，判断是否满足开始搜索的条件，如果可以即在辅函数中进行搜索。")]),t._v(" "),r("p",[t._v("​\t辅函数负责实现深度优先搜索过程。这一过程可以使用递归调用调用实现；当然，我们也可以使用栈（stack）实现深度优先搜索，与使用队列 （queue）实现广度优先搜索类比。但因为栈与递归的调用原理相同，而递归相对便于实现，因此刷题时推荐使用递归式写法，可以将深度优先搜索与回溯算法进行类比。不过在实际工程上，直接使用栈可能才是最好的选择，一是因为便于理解，二是更不易出现递归栈满的情况。")]),t._v(" "),r("p",[t._v("​\t在辅函数里，一个一定要注意的点是辅函数内递归搜索时，对矩阵边界条件的判定。边界判定一般有两种写法："),r("strong",[t._v("一种")]),t._v("是先判定是否越界，只有在合法的情况下才进行下一步搜索（即判断放在调用递归函数前）；"),r("strong",[t._v("另一种")]),t._v("是不管三七二十一先进行下一步搜索，待下一步搜索开始时再判断是否合法（即判断放在辅函数第一行）。两种方法任选一种符合自身代码习惯的写法即可。")]),t._v(" "),r("p",[t._v("​\t"),r("strong",[t._v("二维数组四向遍历小技巧")]),t._v("：对于四个方向的遍历，可以创造一个数组 "),r("code",[t._v("direction = [-1, 0, 1, 0, -1]")]),t._v("，每相邻两位即为上下左右四个方向之一，即：")]),t._v(" "),r("ul",[r("li",[t._v("左移 "),r("code",[t._v("x+=direction[0]; y+=direction[1]")]),t._v("；")]),t._v(" "),r("li",[t._v("上移  "),r("code",[t._v("x+=direction[1]; y+=direction[2]")]),t._v("；")]),t._v(" "),r("li",[t._v("右移  "),r("code",[t._v("x+=direction[2]; y+=direction[3]")]),t._v("；")]),t._v(" "),r("li",[t._v("下移 "),r("code",[t._v("x+=direction[3]; y+=direction[4]")]),t._v("；")])]),t._v(" "),r("h4",{attrs:{id:"_542-0-1-矩阵"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_542-0-1-矩阵"}},[t._v("#")]),t._v(" "),r("a",{attrs:{href:"https://leetcode-cn.com/problems/01-matrix/",target:"_blank",rel:"noopener noreferrer"}},[t._v("542 0-1 矩阵"),r("OutboundLink")],1)]),t._v(" "),r("h4",{attrs:{id:"_130-被围绕的区域"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_130-被围绕的区域"}},[t._v("#")]),t._v(" "),r("a",{attrs:{href:"https://leetcode-cn.com/problems/surrounded-regions/",target:"_blank",rel:"noopener noreferrer"}},[t._v("130 被围绕的区域"),r("OutboundLink")],1)]),t._v(" "),r("h4",{attrs:{id:"_934-最短的桥"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_934-最短的桥"}},[t._v("#")]),t._v(" "),r("a",{attrs:{href:"https://leetcode-cn.com/problems/shortest-bridge/",target:"_blank",rel:"noopener noreferrer"}},[t._v("934 最短的桥"),r("OutboundLink")],1)]),t._v(" "),r("h4",{attrs:{id:"_126-单词接龙-ii"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_126-单词接龙-ii"}},[t._v("#")]),t._v(" "),r("a",{attrs:{href:"https://leetcode-cn.com/problems/word-ladder-ii/",target:"_blank",rel:"noopener noreferrer"}},[t._v("126 单词接龙 II"),r("OutboundLink")],1)]),t._v(" "),r("h4",{attrs:{id:"_994-腐烂的橘子"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_994-腐烂的橘子"}},[t._v("#")]),t._v(" "),r("a",{attrs:{href:"https://leetcode-cn.com/problems/rotting-oranges/",target:"_blank",rel:"noopener noreferrer"}},[t._v("994 腐烂的橘子"),r("OutboundLink")],1)])])}),[],!1,null,null,null);r.default=a.exports}}]);