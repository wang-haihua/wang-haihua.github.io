(window.webpackJsonp=window.webpackJsonp||[]).push([[97],{421:function(e,t,a){"use strict";a.r(t);var r=a(7),n=Object(r.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h2",{attrs:{id:"_03-并查集"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_03-并查集"}},[e._v("#")]),e._v(" 03 并查集")]),e._v(" "),t("p",[e._v("​\t并查集（union-find, 或 disjoint set）可以动态地连通两个点，并且可以非常快速地判断两个\n点是否连通。假设存在 n 个节点，我们先将所有节点的父亲标为自己；每次要连接节点 i 和 j 时，\n我们可以将 i 的父亲标为 j；每次要查询两个节点是否相连时，我们可以查找 i 和 j 的祖先是否最\n终为同一个人。")]),e._v(" "),t("p",[t("img",{attrs:{src:"/home/wang/Desktop/TechStack/ALGLearning/LeetCode_Cpp/LeetCodeNote/Graph/img/union_find.jpg",alt:"union_find"}})]),e._v(" "),t("h4",{attrs:{id:"_684-冗余连接"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_684-冗余连接"}},[e._v("#")]),e._v(" "),t("a",{attrs:{href:"https://leetcode-cn.com/problems/redundant-connection/",target:"_blank",rel:"noopener noreferrer"}},[e._v("684 冗余连接"),t("OutboundLink")],1)]),e._v(" "),t("p",[e._v("​\t在无向图找出一条边，移除它之后该图能够成为一棵树（即无向无环图）。如果有多个解，返\n回在原数组中位置最靠后的那条边。")]),e._v(" "),t("p",[e._v("​\t输入是一个二维数组，表示所有的边（对应的两个节点）；输出是一个一维数组，表示需要移除的边（对应的两个节点）。")]),e._v(" "),t("img",{staticStyle:{zoom:"67%"},attrs:{src:"/home/wang/Desktop/TechStack/ALGLearning/LeetCode_Cpp/LeetCodeNote/Graph/img/684.png",alt:"684"}}),e._v(" "),t("blockquote",[t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("输入: edges = [[1,2], [2,3], [3,4], [1,4], [1,5]]\n输出: [1,4]\n")])])])]),e._v(" "),t("p",[t("strong",[e._v("解析：")])]),e._v(" "),t("h4",{attrs:{id:"_685-冗余连接-ii"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_685-冗余连接-ii"}},[e._v("#")]),e._v(" "),t("a",{attrs:{href:"https://leetcode-cn.com/problems/redundant-connection-ii/",target:"_blank",rel:"noopener noreferrer"}},[e._v("685 冗余连接 II"),t("OutboundLink")],1)]),e._v(" "),t("p",[e._v("在本问题中，有根树指满足以下条件的 有向 图。该树只有一个根节点，所有其他节点都是该根节点的后继。该树除了根节点之外的每一个节点都有且只有一个父节点，而根节点没有父节点。")]),e._v(" "),t("p",[e._v("输入一个有向图，该图由一个有着 n 个节点（节点值不重复，从 1 到 n）的树及一条附加的有向边构成。附加的边包含在 1 到 n 中的两个不同顶点间，这条附加的边不属于树中已存在的边。")]),e._v(" "),t("p",[e._v("结果图是一个以边组成的二维数组 edges 。 每个元素是一对 [ui, vi]，用以表示 有向 图中连接顶点 ui 和顶点 vi 的边，其中 ui 是 vi 的一个父节点。")]),e._v(" "),t("p",[e._v("返回一条能删除的边，使得剩下的图是有 n 个节点的有根树。若有多个答案，返回最后出现在给定二维数组的答案。")]),e._v(" "),t("p",[t("img",{attrs:{src:"/home/wang/Desktop/TechStack/ALGLearning/LeetCode_Cpp/LeetCodeNote/Graph/img/685.jpg",alt:"685"}})]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("输入：edges = [[1,2],[2,3],[3,4],[4,1],[1,5]]\n输出：[4,1]\n")])])]),t("p",[t("strong",[e._v("解析：")])]),e._v(" "),t("h4",{attrs:{id:"_399-除法求值"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_399-除法求值"}},[e._v("#")]),e._v(" "),t("a",{attrs:{href:"https://leetcode-cn.com/problems/evaluate-division/",target:"_blank",rel:"noopener noreferrer"}},[e._v("399 除法求值"),t("OutboundLink")],1)]),e._v(" "),t("p",[e._v("​\t给定一个变量对数组 equations 和一个实数值数组 values 作为已知条件，其中 "),t("code",[e._v("equations[i] = [Ai, Bi]")]),e._v(" 和 "),t("code",[e._v("values[i]")]),e._v(" 共同表示等式 "),t("code",[e._v("Ai / Bi = values[i]")]),e._v(" 。每个 Ai 或 Bi 是一个表示单个变量的字符串。")]),e._v(" "),t("p",[e._v("​\t另有一些以数组 queries 表示的问题，其中 "),t("code",[e._v("queries[j] = [Cj, Dj]")]),e._v(" 表示第 j 个问题，请根据已知条件找出 "),t("code",[e._v("Cj / Dj = ?")]),e._v(" 的结果作为答案。")]),e._v(" "),t("p",[e._v("​\t返回所有问题的答案 。如果存在某个无法确定的答案，则用 "),t("code",[e._v("-1.0")]),e._v(" 替代这个答案。如果问题中出现了给定的已知条件中没有出现的字符串，也需要用 "),t("code",[e._v("-1.0")]),e._v(" 替代这个答案。")]),e._v(" "),t("blockquote",[t("p",[e._v('输入：equations = [["a","b"],["b","c"]], values = [2.0,3.0], queries = [["a","c"],["b","a"],["a","e"],["a","a"],["x","x"]]')]),e._v(" "),t("p",[e._v("输出：[6.00000,0.50000,-1.00000,1.00000,-1.00000]")]),e._v(" "),t("p",[e._v("解释：\n条件：a / b = 2.0, b / c = 3.0\n问题：a / c = ?, b / a = ?, a / e = ?, a / a = ?, x / x = ?\n结果：[6.0, 0.5, -1.0, 1.0, -1.0 ]")])]),e._v(" "),t("p",[t("strong",[e._v("解析：")])]),e._v(" "),t("h4",{attrs:{id:"_1631-最小体力消耗路径"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1631-最小体力消耗路径"}},[e._v("#")]),e._v(" "),t("a",{attrs:{href:"https://leetcode-cn.com/problems/path-with-minimum-effort/",target:"_blank",rel:"noopener noreferrer"}},[e._v("1631 最小体力消耗路径"),t("OutboundLink")],1)]),e._v(" "),t("p",[e._v("给定一个二维 rows x columns 的地图 heights ，其中 heights[row][col] 表示格子 (row, col) 的高度。")]),e._v(" "),t("p",[e._v("一开始在最左上角的格子 (0, 0) ，且希望去最右下角的格子 (rows-1, columns-1) （注意下标从 0 开始编号）。")]),e._v(" "),t("p",[e._v("每次可以往 上，下，左，右 四个方向之一移动，想要找到耗费体力最小的一条路径。")]),e._v(" "),t("p",[e._v("一条路径耗费的体力值是路径上相邻格子之间"),t("strong",[e._v("高度差绝对值的最大值")]),e._v("决定的。")]),e._v(" "),t("p",[e._v("请返回从左上角走到右下角的最小体力消耗值 。")]),e._v(" "),t("p",[t("img",{attrs:{src:"/home/wang/Desktop/TechStack/ALGLearning/LeetCode_Cpp/LeetCodeNote/Graph/img/1631.png",alt:"1631"}})]),e._v(" "),t("blockquote",[t("p",[e._v("输入：heights = [[1,2,2],[3,8,2],[5,3,5]]\n输出：2\n解释：路径 [1,3,5,3,5] 连续格子的差值绝对值最大为 2 。这条路径比路径 [1,2,2,2,5] 更优，因为另一条路径差值最大值为 3 。")])]),e._v(" "),t("p",[t("strong",[e._v("解析：")])]),e._v(" "),t("h4",{attrs:{id:"_547-省份数量"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_547-省份数量"}},[e._v("#")]),e._v(" "),t("a",{attrs:{href:"https://leetcode-cn.com/problems/number-of-provinces/",target:"_blank",rel:"noopener noreferrer"}},[e._v("547 省份数量"),t("OutboundLink")],1)])])}),[],!1,null,null,null);t.default=n.exports}}]);